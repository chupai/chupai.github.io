[{"content":" JavaScript筆記 目錄\n 非同步是 JavaScript 最重要的觀念之一。\n 非同步 回呼函式 Promise Async/Await  \r什麼是 Async/Await ES8 新增 的 Async/Await 為 Promise 的語法糖，底層運作還是 Promise。\n1. Async functions 在一個函式前面加上async 關鍵字放：\n1  async function fn() {}   這個函式只會回傳一個 Promise 物件，如果 return 值非 Promise ，會將 return 值作為 resolve() 的參數值。\n1 2 3 4 5 6 7  async function fn() { return 1; } fn().then(console.log); // 1   也就是說 async 確保了函式的回傳值是一個 Promise 物件，也會包裝非 Promise 的值。\n2. Await await 只能用在 Async functions 中。\nawait 可以讓非同步程式在 Async functions 中用起來像是使寫同步程式一樣，依序執行。\n這是一個隨機延遲時間的函式：\n1 2 3 4 5 6 7  function delay(value) { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(value); }, Math.random() * 2000); }); }   如果依序呼叫三個函式，會根據延遲時間回傳，所以順序會不一定：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function delay(value) { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(value); }, Math.random() * 2000); }); } function test() { delay(1).then(console.log); delay(2).then(console.log); delay(3).then(console.log); } test();   使用 Async/Await 就不需要使用 then 方法了，能直接獲得結果值：\n1 2 3 4 5 6 7 8 9 10  async function test() { console.log(await delay(1)); console.log(await delay(2)); console.log(await delay(3)); } test(); // 1 // 2 // 3   每個函式都會依序執行，會等到處理完畢，再執行下一行，就像寫同步的程式一樣。\n錯誤處理 如果要錯誤處理，要使用 try...catch 述句：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  async function fun() { const p = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { const ran = Math.floor(Math.random() * 2); // 模擬可能失敗 0 or 1  if (ran) { resolve(\u0026#39;done!\u0026#39;); } else { reject(new Error(\u0026#39;error!\u0026#39;)); } }, 1000); }); try { const r = await p; console.log(r); } catch (err) { console.log(err); } } fun();   ","description":"Async/Await 為 Promise 的語法糖。","id":0,"section":"posts","tags":["JavaScript","非同步","Promise","Async/Await"],"title":"Async/Await","uri":"https://chupai.github.io/posts/2008/js_async_await/"},{"content":" JavaScript筆記 目錄\n 非同步是 JavaScript 最重要的觀念之一。\n 非同步 回呼函式 Promise Async/Await  \r什麼是 Promise？ Promise 在其他不同語言有很多不同的名稱，例如 Delay、Future。其實 Promise API 已經存在多年，但是直到 ES6 才被標準化和引入。\nPromise 字面意思為「承諾」或「約定」，白話一點的解釋就是「我承諾幫你做某件事，但會不會做到不一定，但最後一定會跟你說有做到或沒做到」。\n當你拿到一個 Promise 的時候，代表在未來中這個 Promise 可能會有三種狀態：\n 未定（pending） 達成（fulfilled） 拒絕（rejected）  狀態只會由 pending 變成 fulfilled 或 rejected。\n接下來可以根據上面這兩種結果，決定下一步要做啥：\n 履行承諾，繼續做預定好的下一件事 毀約後，根據原因去做對應的處理  創建 Promise 物件 要建立一個 Promise 物件實體需要使用 Promise() 建構式：\n1 2 3  new Promise(function(resolve, reject) { // ... });   建構式中接受一個函式作為參數，該函式稱為 executor（執行函式），當 Promise 實體被創建，就會立刻執行 executor 函式。\n這函式又接收兩個參數，分別為 resolve 與 reject，這兩個參數也是函式，皆接收一個參數。\n如果在 executor 函式中：\n 呼叫 resolve(value)  Promise 會從 pending 狀態進入 fulfilled 狀態 如有值傳入，它將成為完成結果   呼叫 reject(reason)  Promise 會從 pending 狀態進入 rejected 狀態 如有值傳入，它將被設為拒絕理由，值通常會是 Error 物件實體，表示拋出訊息   如果都沒呼叫，那 Promise 會一直保持 pending 狀態。  一但進入 fulfilled 或 rejected 狀態，Promise 就不會再接受任何狀態改變，所以重複呼叫 resolve 或 reject 是沒有意義的行為。\nresolve() 通常會用在非同步程式中，可以將非同步程式處理的結果傳出去：\n1 2 3  const p = new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; resolve(\u0026#39;done!\u0026#39;), 1000); });   經過一秒，呼叫 resolve() 將字串 done! 當作完成結果，也就是 Promise 狀態經過一秒才由 pending 狀態進入 fulfilled 狀態。\n假如非同步程式執行失敗時，就可以利用 reject() 獲取錯誤訊息，讓我們模擬一下：\n1 2 3 4 5 6 7 8 9 10  const p = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { const ran = Math.floor(Math.random() * 2); // 模擬可能失敗 0 或 1  if (ran) { resolve(\u0026#39;done!\u0026#39;); } else { reject(new Error(\u0026#39;error!\u0026#39;)); } }, 1000); });   另外，呼叫 resolve 或 reject 並不會終止 executor 函式的執行，後續的程式碼還使會執行：\n1 2 3 4  const p = new Promise((resolve) =\u0026gt; { resolve(\u0026#39;done!\u0026#39;); console.log(123); });   但一般來說，呼叫 resolve 或 reject 以後，Promise 的使命就完成了，後繼操作應該放到 then 方法中，而不應該直接寫在呼叫完 resolve 或 reject 的後方。\n接下來 1. then 方法 接下來，我們來看如何從 Promise 中取出結果值。\nthen 方法是 Promise 中最重要的方法，標準有八成在定義它。\nthen 字面意思為「然後」或「接下來」，也就是 Promise 實體被創建後，可以使用 then 方法分別指定 fulfilled 和 rejected 狀態的回呼函式，來處理回傳值：\n1  p.then(fulfilledCallback[, rejectedCallback]);    fulfilledCallback：當 Promise 為 fulfilled 狀態時被呼叫，接收的參數為 resolve() 回傳的結果。 rejectedCallback（可選）：當 Promise 為 rejected 狀態時被呼叫，接收的參數為 reject() 回傳的失敗訊息。  如果 fulfilledCallback 或 fulfilled 不是函式時，忽略跳過。\nthen 方法雖然是立即執行的，但它裡面的回呼函式會進入到事件佇列中，等待 Promise 改變狀態。如果 Promise 一直是 pending 狀態，也就是一直沒有回應，then 方法中的回呼函式就會一直等待。\n一個簡單的範例，建立一個 delay 函式，回傳 Promise 物件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function delay(time) { return new Promise((resolve) =\u0026gt; { const t = time * 1000; setTimeout(() =\u0026gt; { resolve(`延遲了 ${time}秒`); }, t); }); } delay(2).then((result) =\u0026gt; { console.log(result); }); // (經過2秒 // \u0026#34;延遲了 2 秒\u0026#34;   經過了 2 秒，Promise 由 pending 狀態進入 fulfilled 狀態，就會觸發 then 方法綁定的回呼函式，印出結果。\n如果 Promise 為 rejected 狀態，沒有處理會有 Uncaught 提示，因此如果有呼叫 reject() 要加上 rejected 狀態的回呼函式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const p = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { const ran = Math.floor(Math.random() * 2); // 模擬可能失敗  if (ran) { resolve(\u0026#39;done!\u0026#39;); } else { reject(\u0026#39;錯誤\u0026#39;); } }, 1000); }); p.then( (result) =\u0026gt; { console.log(result); }, (error) =\u0026gt; { console.log(error); } );   2. 呼叫順序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const p = new Promise((resolve) =\u0026gt; { console.log(1); resolve(4); console.log(2); }); p.then((v) =\u0026gt; { console.log(3); console.log(v); console.log(5); }); console.log(6); // 1 // 2 // 6 // 3 // 4 // 5    當 Promise 實體被創建，就會立刻執行 executor 函式，所以先印出 1； 就算 resolve() 已呼叫，executor 函式並不會終止，所以印出 2； then 方法中的回呼函式一開始就會進入到事件佇列中，當 Promise 狀態改變，並等到同步程式執行完畢，才會開始執行，因此會跳過，所以會先印出 6； Promise 狀態改變了，同步程式執行也完了，因此執行 then 方法中的回呼函式，所以印出 3 4 5。  3. 串連 then 方法，會回傳一個新的 Promise 實體。因此可以用 then() 串連多個 Promise，形成一個 Promise 鏈。\nthen 方法回傳的新 Promise 會有以下幾種情況：\n 回呼函式中，return 非 Promise 的值； 回呼函式中，return Promise； 回呼函式中，因為 throw 述句拋出錯誤； 沒有對應狀態的回呼函式。  我們使用這個函式建立 Promise 來說明：\n1 2 3 4 5 6 7 8 9  function p(n, b) { return new Promise((resolve, reject) =\u0026gt; { if (b) { resolve(n); } else { reject(\u0026#39;erro\u0026#39;); } }); }   參數 n 為結果值、b 用來控制狀態。\n情況一：如果回呼函式中 return 一個非 Promise 的值，則會回傳一個 fulfilled 狀態的新 Promise，並且將 return 值作為 resolve() 的參數值。\n1 2 3 4 5 6 7 8 9 10 11 12  // 情況一 p(1, true) .then((result) =\u0026gt; { console.log(result); return 2; }) .then((result) =\u0026gt; { console.log(result); }); // 1 // 2   情況二：如果回呼函式 return 一個 Promise，會回傳與該 Promise 相同狀態、帶相同值的新 Promise。\n1 2 3 4 5 6 7 8 9 10 11  p(1, true) .then((result) =\u0026gt; { console.log(result); return p(2, true); }) .then((result) =\u0026gt; { console.log(result); }); // 1 // 2   情況三：then 方法中回呼函式因為 throw 述句拋出一個錯誤，則會回傳一個 rejected 狀態的 Promise，並且將錯誤訊息作為 reject() 的參數值。\n1 2 3 4 5 6 7 8 9  p(1, true) .then((result) =\u0026gt; { throw new Error(\u0026#39;Something failed\u0026#39;); }) .then(null, (error) =\u0026gt; { console.log(error); }); // \u0026#34;Error: Something failed\u0026#34;   情況四：如果 then 方法沒有可以處 Promise 狀態的回呼函式，會回傳與原本相同狀態、帶相同值的新 Promise。\n1 2 3 4 5 6 7 8 9  p(1, false) .then((v) =\u0026gt; { console.log(v); }) .then(null, (error) =\u0026gt; { console.log(error); }); // \u0026#34;erro\u0026#34;   4. catch 方法 catch 方法，其實就是 then(null, rejectedCallback) 或 then(undefined, rejectedCallback) 的簡寫。\n原本是使用 then 方法的兩個回呼函式，分別處理兩個狀態：\n1 2 3 4 5 6 7 8  p.then( (result) =\u0026gt; { console.log(result); }, (error) =\u0026gt; { console.log(error); } );   但建議改用以下方式：\n1 2 3 4 5  p.then((result) =\u0026gt; { console.log(result); }).catch((error) =\u0026gt; { console.log(error); });   這樣不但將兩種狀態處理分開寫，增加可讀性。如果 then() 的回呼函式因為 throw 述句拋出錯誤，catch() 也能捕捉錯誤訊息。\n5. throw 與 reject 在 Promise 建構函式的 executor 函式中，直接使用 throw 述句相當於呼叫 reject 的作用。\n1 2 3 4 5 6 7 8 9 10  const p = new Promise((resolve, reject) =\u0026gt; { throw new Error(\u0026#39;error!\u0026#39;); // 等同  // reject(new Error(\u0026#39;error!\u0026#39;)) }); p.catch((e) =\u0026gt; { console.log(e.message); }); // \u0026#34;error!\u0026#34;   6. finally 方法 在 ES7 新增了 finally 方法，不論 Promise 狀態是 fulfilled 或 rejected 都會執行。\nfinally 方法中的回呼函式不接受任何參數，也就是不會得到任何的回傳值，通常用於最後，用來處理與狀態無關的操作，例如重置、清除、終止。\n原本需要使用 then 方法，將兩個回呼函式設置相同來處理，使用 finally 方法就只需要寫一次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  p.finally(() =\u0026gt; { console.log(\u0026#39;End!\u0026#39;); }); // 等同 p.then( () =\u0026gt; { console.log(\u0026#39;End!\u0026#39;); }, (reason) =\u0026gt; { console.log(\u0026#39;End!\u0026#39;); throw reason; } );   Promise 的靜態方法 1. all 方法 Promise.all 方法用於將多個 Promise，包裝成一個新的 Promise。\n假設有一個延遲計算的函式：\n1 2 3 4 5 6 7 8  function delayAdd(x, y) { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { const r = x + y; resolve(r); }, Math.random() * 2000); }); }   要如何將這三個的結果值相加呢？\n1 2 3  const p1 = delayAdd(1, 2); const p2 = delayAdd(3, 4); const p3 = delayAdd(5, 6);   使用 Promise.all 方法：\n1 2 3 4 5  Promise.all([p1, p2, p3]).then((result) =\u0026gt; { const sum = result.reduce((total, value) =\u0026gt; total + value); console.log(sum); }); // 21   語法說明：\n1  Promise.all(iterable);   iterable：通常會是一個陣列，陣列中的值只會是一般的值或是 Promise 物件。\nPromise.all 方法會將陣列中的值並行運算執行，全部完成後後會回傳一個 finally 狀態的 Promise。\n有幾點要注意：\n 陣列中的索引值與執行順序無關； 陣列中的值如果不是 Promise 物件會自動使用Promise.resolve 方法來轉換； 陣列中只要其中一個 Promise 狀態為 rejected，就會回傳 rejected 狀態的 Promise。  Promise.all 方法最後獲得的 Promise 的結果值會是一個陣列，陣列中的內容為所有 Promise 的結果。\n1 2 3 4 5 6 7 8  const p1 = delayAdd(1, 2); const p2 = delayAdd(3, 4); const p3 = delayAdd(5, 6); Promise.all([p1, p2, p3]).then((result) =\u0026gt; { console.log(result); }); // [3, 7, 11]   2. race 方法 Promise.race 方法的規則與 Promise.all 方法相同，差異在於 Promise.race 回傳的 Promise 的結果只有最快變成 finally 狀態的那個。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function delay(name, time) { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(name); }, time); }); } const p1 = delay(\u0026#39;A\u0026#39;, 2000); const p2 = delay(\u0026#39;B\u0026#39;, 100); const p3 = delay(\u0026#39;C\u0026#39;, 500); Promise.race([p1, p2, p3]).then((result) =\u0026gt; { console.log(result); }); // \u0026#34;B\u0026#34;   如果同時變為 finally 狀態，就會以陣列順序優先者作為回傳值。\n3. resolve 方法 Promise.resolve() 能建立一個 finally 狀態的 Promise 物件，其參數為結果值。\n1  const p = Promise.resolve(1);   等同：\n1 2 3  const p = new Promise((resolve) =\u0026gt; { resolve(1); });   4. reject 方法 Promise.reject() 能建立一個 rejected 狀態的 Promise 物件，其參數為錯誤訊息。\n1  const p = Promise.reject(new Error(\u0026#39;error!\u0026#39;));   等同：\n1 2 3  const p = new Promise((resolve, reject) =\u0026gt; { reject(new Error(\u0026#39;error!\u0026#39;)); });   ","description":"Promise 代表著「承諾」在未來提供任務執行結果。","id":1,"section":"posts","tags":["JavaScript","非同步","Promise"],"title":"Promise","uri":"https://chupai.github.io/posts/2008/js_promise/"},{"content":" JavaScript筆記 目錄\n 非同步是 JavaScript 最重要的觀念之一。\n 非同步 回呼函式 Promise Async/Await  \r什麼是回呼函式 回呼函式（callback function）是指能藉由參數（argument）通往另一個函式的函式。\n簡單來說，就是這個函式做為另一個函式的引數傳入，就稱為「回呼函式」，例如常見的陣列處理方法都有回呼函式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function foo(name) { console.log(name); } function boo(name, callback) { callback(name); } boo(\u0026#39;Peter\u0026#39;, foo); // \u0026#34;Peter\u0026#34;  // 陣列批次處理方法 const arr = [1, 2, 3]; const newArr = arr.map((item) =\u0026gt; item * 2); console.log(newArr); // [2, 4, 6]   這些屬於同步回呼，因為它是立即執行的。\n非同步 而回呼常用來延續非同步行動完成後的程式執行，例如計時器等等。\n1 2 3 4  // 計時器 setTimeout(() =\u0026gt; { console.log(\u0026#39;1\u0026#39;); }, 3000);   1. 回呼中回呼 舉例來說，如果要設定計時器，在它執行完後，在一次呼叫一個計時器。\n錯誤寫法：\n1 2 3 4 5 6 7 8 9 10 11  setTimeout(() =\u0026gt; { console.log(\u0026#39;1\u0026#39;); }, 2000); setTimeout(() =\u0026gt; { console.log(\u0026#39;2\u0026#39;); }, 2000); // 兩秒後 同時印出 // 1 // 2   必須將第二個計時器寫在第一個回呼函式中：\n1 2 3 4 5 6  setTimeout(() =\u0026gt; { console.log(\u0026#39;1\u0026#39;); setTimeout(() =\u0026gt; { console.log(\u0026#39;2\u0026#39;); }, 2000); }, 2000);   2. 回呼地域 非同步程式的回呼對於一個或兩個的簡單巢狀，這樣的呼叫看起來還好。\n但對於一個接一個非同步動作來說，程式碼會變得非常難以維護。舉例來說，這是一個延遲呼叫的函式：\n1 2 3 4 5 6 7 8 9  function delay(n, callback) { setTimeout(() =\u0026gt; { callback(n); }, 2000); } delay(1, (n) =\u0026gt; { console.log(n); });   上面有說過，如果要重複呼叫，就必須要等到上次的呼叫成功時，才能進行下次呼叫：\n1 2 3 4 5 6  delay(1, (n) =\u0026gt; { console.log(n); delay(2, (n) =\u0026gt; { console.log(n); }); });   如果呼叫次非常多，程式碼就會變成這樣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  delay(1, (n) =\u0026gt; { console.log(n); delay(2, (n) =\u0026gt; { console.log(n); delay(3, (n) =\u0026gt; { console.log(n); delay(4, (n) =\u0026gt; { console.log(n); delay(5, (n) =\u0026gt; { console.log(n); delay(6, (n) =\u0026gt; { console.log(n); }); }); }); }); }); });   由上述可知，沒有進一步的非同步需求，回呼函式是直覺而簡單的，但如果需要執行多次非同步程式，就會不利於程式碼的閱讀和維護。\n從 ES6 開始，JavaScript 引入了一些新功能，可以幫助我們不用回呼就能處理非同步程式：\n Promise 物件（ES6） Async/Await 語法（Promise 語法糖 ES8） ","description":"回呼函式（callback function）是指能藉由參數（argument）通往另一個函式的函式。","id":2,"section":"posts","tags":["JavaScript","非同步","回呼函式"],"title":"回呼函式","uri":"https://chupai.github.io/posts/2008/js_callback/"},{"content":" JavaScript筆記 目錄\n 非同步是 JavaScript 最重要的觀念之一。\n 非同步 回呼函式 Promise Async/Await  \r什麼是非同步  Synchronous 同步 Asynchronous 非同步（異步）  同步就是程式碼由上到下依序執行；而非同步則是，不用等待該程式碼執行完畢，就可以往下繼續執行。\n常見的非同步程式：\n 瀏覽器所提供的計時器 setTimeout()、setInterval() DOM 的事件監聽 addEventListener() 網路請求資料 Ajax 呼叫  JavaScript 的非同步處理 首先，JavaScript 是 單線程（single threaded） 的程式語言，也就是一個單執行緒、同步的程式，它逐行執行程式碼，並不會非同步的執行程式。\n那它是如何做到非同步執行呢？\n簡單來說，JS 引擎在運行時，除了一個正在處理事情的主線程外，還有一個用來存放非同步需求的 事件佇列（Event Queue）。當偵測到非同步的需求，就會將它丟進去，等到主線程所有事情處理完畢，就會去 事件佇列 找事做。\nJS 引擎是透過不斷的檢查事件佇列，來確認非同步的程式符合進入主線程的條件，這種檢查機制叫做 事件迴圈（Event Loop）。\n換句話說，當某件事情卡住了，後續的事情都將無法繼續執行。\n非同步的流程控制 如果有多個非同步操作，就存在一個流程控制的問題。\n要如何解決非同步操作的執行順序，有以下幾種方式：\n 回呼函式 Callback（最早期） Promise 物件（ES6） Async/Await 語法（Promise 語法糖 ES8）  首先我們來看一個範例問題：\n1 2 3 4 5 6 7  function square(n) { return n * n; } const result = square(2); console.log(result); // 4    這是個很普通的同步程式，square() 回傳平方結果，然後用 console.log() 印出。\n接下來我們使用 setTimeout() 來模擬，需要經過冗長計算過程或從伺服器取得，而無法立即做運算。\n會遇到的問題：\n1 2 3 4 5 6 7 8 9 10  function delaySquare(n) { let result; setTimeout(() =\u0026gt; { result = n * n; }, 2000); return result; } const result = delaySquare(2); console.log(result); // undefined   很明顯的，我們無法直接回傳非同步程式的運算結果。\n那麼我們要如何解決？\n1. 回呼函式 傳統作法就是新增一個 回呼函式 callback 參數，將結果當作引數傳入：\n1 2 3 4 5 6 7 8 9  function delaySquare(n, callback) { setTimeout(() =\u0026gt; { callback(n * n); }, 2000); } delaySquare(2, (result) =\u0026gt; { console.log(result); });   但是，如果今天我要重複呼叫，就必須要等到上次的呼叫成功時，才能進行下次呼叫，就會產生 Callback Hell（回呼地獄）：\n1 2 3 4 5 6 7 8 9 10 11 12  delaySquare(2, (result) =\u0026gt; { console.log(result); delaySquare(3, (result) =\u0026gt; { console.log(result); delaySquare(4, (result) =\u0026gt; { console.log(result); delaySquare(5, (result) =\u0026gt; { console.log(result); }); }); }); });   由上述可知，沒有進一步的非同步需求，回呼函式是直覺而簡單的，但如果需要執行多次非同步程式，就會不利於程式碼的閱讀和維護。\n從 ES6 開始，JavaScript 引入了一些新功能，可以幫助我們不用回呼就能處理非同步程式：\n Promise 物件（ES6） Async/Await 語法（Promise 語法糖 ES8）  2. Promise 物件 其實 Promise 已經存在多年，但是直到 ES6 才被標準化和引入。\n1 2 3 4 5 6 7 8 9 10 11  function delaySquare(n) { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(n * n); }, 2000); }); } delaySquare(2).then((result) =\u0026gt; { console.log(result); });   Promise 可以讓非同步操作寫起來，就像在寫同步操作的流程：\n1 2 3 4 5 6 7 8 9 10 11 12 13  delaySquare(2) .then((result) =\u0026gt; { console.log(result); return delaySquare(3); }) .then((result) =\u0026gt; { console.log(result); return delaySquare(4); }) .then((result) =\u0026gt; { console.log(result); return delaySquare(5); });   3. Async/Await 語法 Async/Await 其實就是 Promise 的語法糖將其簡化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function delaySquare(n) { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(n * n); }, 2000); }); } async function answer() { const result = await delaySquare(2); console.log(result); const result2 = await delaySquare(3); console.log(result2); const result3 = await delaySquare(4); console.log(result3); const result4 = await delaySquare(5); console.log(result4); } answer();   必須使用 async function 宣告函式，才可以使用 await，而 await 呼叫的函式必須回傳 Promise 物件。\n","description":"非同步是 JavaScript 最重要的觀念之一。","id":3,"section":"posts","tags":["JavaScript","非同步"],"title":"非同步","uri":"https://chupai.github.io/posts/2008/js_asynchronous/"},{"content":" 竹白的 JS 學徒特訓班筆記 - 目錄\n 記錄六角學院所開的 JS 學徒特訓班，為期 60天的特訓。\n\r第四十一關 - new Date() 時間處理  題目連結\n 41. 問題 請觀看以下文章，以了解如何透過 JS 去取得年月日的資料，並用 Slack 回傳你的學習心得，42 關將會出題目來練習。\n JavaScript Date（日期） 对象 JavaScript Date 時間和日期 日期與時間 從零開始的學習 JS 生活-第二十一日  41. 參考解答 竹白記事本 - 日期時間\n教學、延伸知識連結  Date 对象 Natively Format JavaScript Dates and Times moment.js - 關於時間的一切  第四十二關 new Date() 與字串處理  題目連結\n 42. 問題 請用你學會的語法，取出今日時間，並依序組出以下字串。\n假設今天時間為 8/5，則需透過 new Date() 處理後，印出以下資料：\n// 目前時間是 2020/8/5 14:20 // 2020/08/05 // 2020-08-05 // 今天是禮拜五 // 今天是八月五日，時間為 14:20 42. 參考解答 See the Pen 第四十二關 new Date() 與字串處理 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  四十三關 你熟悉 GitHub Pages 嗎？  題目連結\n 43. 問題 請依照技術主管的指示，將網頁放在 GitHub Pages 上的服務\n 在本地端新增一個 index.html，裡面多加上一個 h1 的標籤，裡面寫自己 Slack 的暱稱 觀看此文件，讓自己的網頁上傳到 GitHub Pages 上 在下方列表，張貼自己的 GitHub Pages 網址 接下來我們將會持續用 GitHub Pages 更新網頁  43. 參考解答 略\n四十四關 window.location  題目連結\n 44. 問題 請觀看以下文件，了解 window.location 類別的功能，例如轉址、取得網址參數等等\n Javascript 頁面跳轉、刷新、重定向的幾種方式 用 JavaScript 取得目前網址與其它網址參數簡單語法 JavaScript location Object window 物件的屬性 location JavaScript：回上一頁、各種跳轉頁面方法與 window.location 物件 javascript筆記 - window.location類別 Javascript 刷新頁面的幾種方法  44. 參考解答 竹白記事本 - window.location\n教學、延伸知識連結  Location 對象，URL 對象，URLSearchParams 對象  四十五關、四十六關 window.location  題目連結\n 45. 問題 以下有兩顆按鈕，請使用 JavaScript 語法，操控點擊後，能夠轉址到對應網站去\n1 2  \u0026lt;button class=\u0026#34;google\u0026#34;\u0026gt;連到 Google\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;yahoo\u0026#34;\u0026gt;連到 Yahoo\u0026lt;/button\u0026gt;   45. 參考解答 1 2 3 4 5 6 7  document.querySelector(\u0026#39;.google\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, function () { window.location.href = \u0026#39;https://www.google.com\u0026#39;; }); document.querySelector(\u0026#39;.yahoo\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, function () { window.location.href = \u0026#39;https://tw.yahoo.com\u0026#39;; });   CodePen\n46. 問題 問題一：\n以下有兩顆按鈕，是部落格推薦連結，請抓取 data-id 的值後進行轉址：\n 點擊 Tom 時，網址為 https://www.hexschool.com/?recommend=tom 點擊 John 時，網址為 https://www.hexschool.com/?recommend=John  1 2  \u0026lt;button class=\u0026#34;google\u0026#34; data-id=\u0026#34;tom\u0026#34;\u0026gt;Tom 推薦六角學院\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;yahoo\u0026#34; data-id=\u0026#34;John\u0026#34;\u0026gt;John 推薦六角學院\u0026lt;/button\u0026gt;   問題二：\n如果網址規則是https://www.hexschool.com/?recommend=\u0026quot;值\u0026quot;，該如何取出 recommend 的值？\n例如 https://www.hexschool.com/?recommend=tom，可以透過 JS，精準取出 tom 的值？請提供 JS 寫法。\nPS：Codepen 做法是抓不到值的，需自行開 web server，或到六角官網開啟 console 面板測試\n46. 參考解答 問題一：\n1 2 3 4 5 6 7 8  document.querySelector(\u0026#39;.google\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, buttonHandler); document.querySelector(\u0026#39;.yahoo\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, buttonHandler); function buttonHandler() { const id = this.dataset.id; const url = \u0026#39;https://www.hexschool.com\u0026#39;; window.location.assign(`${url}/?recommend=${id}`); }   CodePen\n問題二：\n1  window.location.search.replace(\u0026#39;?recommend=\u0026#39;, \u0026#39;\u0026#39;);   ","description":"JS 函式 41 ~ 46 關","id":4,"section":"posts","tags":["JavaScript","JS 學徒特訓班"],"title":"JS 學徒特訓班 - Date、Location 41 ~ 46 關","uri":"https://chupai.github.io/posts/2008/js60_5/"},{"content":" JavaScript筆記 目錄\n \rLocation 物件 Location 物件是瀏覽器提供的原生物件，提供 URL 相關的資訊和操作方法。\n可以透過 window.location 或 document.location 取得。\n1. 屬性  Location.href：網址（URL） Location.protocol：網址中的通訊協定，包括冒號 : Location.host：主機名稱 Location.hostname：網域名稱 Location.port：\t網址中的埠號 Location.pathname：網址路徑，從根路徑 / 開始 Location.search：網址參數，從問號 ? 開始 Location.hash：網址 hash 值，從 # 開始 Location.username：域名前面的使用者名稱 Location.password：域名前面的密碼 Location.origin：URL 的協議  只有 origin 屬性是唯讀。\n2. 方法  Location.assign()：接受一個 URL 字串作為參數，瀏覽器會立刻跳轉至新網址。 Location.replace()：與 assign() 相同，差異在於 replace() 會刪除瀏覽器歷史 History 的當前網址，這表示回到上一頁的按鈕無法回到原先的網址。  常應用在行動裝置版的網頁跳轉   Location.reload()：重新載入當前網址，等同按下瀏覽器刷新按鈕。 Location.toString()：回傳 URL 字串，等同讀取 Location.href 屬性。  網頁跳轉 如果對 Location.href 寫入完整的 URL，瀏覽器會立刻跳轉到新網頁上：\n1 2 3 4  window.location.href = \u0026#39;https://www.google.com\u0026#39;; // 等同 window.location.assign(\u0026#39;https://www.google.com\u0026#39;);   直接改寫 location，也相當於寫入 href 屬性：\n1  window.location = \u0026#39;https://www.google.com\u0026#39;;   如果不是完整網址，可用於切換路徑、滾動到新的錨點等等：\n1 2 3 4 5 6 7  window.location.href = \u0026#39;/posts\u0026#39;; // 等同 window.location.pathname = \u0026#39;/post\u0026#39; window.location.href = \u0026#39;#top\u0026#39;; // 等同 window.location.hash = \u0026#39;#top\u0026#39;;   ","description":"Location 物件是瀏覽器提供的原生物件，提供 URL 相關的資訊和操作方法。","id":5,"section":"posts","tags":["JavaScript","window.location"],"title":"window.location","uri":"https://chupai.github.io/posts/2008/js_window_location/"},{"content":" JavaScript筆記 目錄\n 產生 0 ~ 99 的數字陣列。\n\r迴圈 最簡單的方法就是使用迴圈。\nfor 迴圈：\n1 2 3 4 5  const numbers = []; for (let i = 0; i \u0026lt; 100; i += 1) { numbers[i] = i; }   或者使用 push()：\n1 2 3 4 5  const numbers = []; for (let i = 0; i \u0026lt; 100; i += 1) { numbers.push(i); }   while 迴圈：\n1 2 3 4 5 6 7  const numbers = []; let i = 0; while (i \u0026lt; 100) { numbers.push(i); i += 1; }   一行程式碼 使用 Array.from 內建的 map() 函式：\n1 2 3 4  const numbers = Array.from({ length: 100 }, (v, k) =\u0026gt; k); // or const numbers = Array.from(Array(100), (v, k) =\u0026gt; k);   先使用 Object.keys 取得鍵名（陣列鍵名就是索引），再轉成陣列：\n1 2 3 4  const numbers = Array.from(Array(100).keys()); // or const numbers = [...Array(100).keys()];   ","description":"產生 0 ~ 99 的數字陣列。","id":6,"section":"posts","tags":["JavaScript","ES6","陣列"],"title":"連續的數字陣列","uri":"https://chupai.github.io/posts/2008/js_array_numbers/"},{"content":"這週是六角鼠年鐵人賽第二十九週。\n\r什麼是洗牌 洗牌（shuffle） 其實就是亂數排序，將一組陣列中的元素順序打亂，是一種很常用到的演算法，在生活中最常見的例子就是洗撲克牌。\n洗牌演算法的條件：\n 結果要能夠覆蓋所有的情況； 所有出現的結果機率相等。  假設有一個長度為 $n$ 的陣列，會有 $n!$ 種不同的組合情況。\n演算法必須可以產生出 $n!$ 中的每一種結果，不可以多或少，否則每種結果出現的機率不相等。\nFisher-Yates shuffle Fisher-Yates shuffle 是最標準的洗牌演算法。\n其實它就是隨機交換：\n1 2 3 4 5 6 7  function shuffle(arr) { const n = arr.length; for (let i = n - 1; i \u0026gt; 0; i -= 1) { const rand = Math.floor(Math.random() * (i + 1)); [arr[i], arr[rand]] = [arr[rand], arr[i]]; } }   從後面迭代陣列，產生隨機索引與未排序的最後一個元素交換位置（隨機索引包含自己）。\n讓我們來分析一下，假設陣列元素有 5 個：\n 第 1 次迭代：i = 4，rand 的範圍是 0 ~ 4 第 2 次迭代：i = 3，rand 的範圍是 0 ~ 3 第 3 次迭代：i = 2，rand 的範圍是 0 ~ 2 第 4 次迭代：i = 1，rand 的範圍是 0 ~ 1 第 5 次迭代：i = 0，rand 的範圍是 0  整個過程產生的所有可能結果為：\n $n! = 5! = 5 \\times 4 \\times 3 \\times 2 \\times 1$ 時間複雜度為 $O(n)$  i \u0026gt;= 0 這樣寫也可以，因為最後一次迭代可有可無：\n1 2 3 4 5 6 7  function shuffle(arr) { const n = arr.length; for (let i = n - 1; i \u0026gt;= 0; i -= 1) { const rand = Math.floor(Math.random() * (i + 1)); [arr[i], arr[rand]] = [arr[rand], arr[i]]; } }   或者將交換位置改成前面：\n1 2 3 4 5 6 7  function shuffle(arr) { const n = arr.length; for (let i = 0; i \u0026lt; n; i += 1) { const rand = Math.floor(Math.random() * (n - i)) + i; [arr[i], arr[rand]] = [arr[rand], arr[i]]; } }   假設陣列元素有 5 個：\n 第 1 次迭代：i = 0，rand 的範圍是 0 ~ 4 第 2 次迭代：i = 1，rand 的範圍是 1 ~ 4 第 3 次迭代：i = 3，rand 的範圍是 2 ~ 4 第 4 次迭代：i = 4，rand 的範圍是 3 ~ 4 第 5 次迭代：i = 5，rand 的範圍是 4  最終結果為 $5! = n!$，一樣符合洗牌演算法條件。\n錯誤的演算法 網路上有很多洗牌演算法實作其實是錯誤的，因為它看似隨機打亂順序，但分布率並不均勻，以下舉幾個常見的錯誤。\n第一種常見的錯誤，順序隨機洗牌：\n1 2 3 4 5 6 7  function shuffle(arr) { const n = arr.length; for (let i = 0; i \u0026lt; n; i += 1) { const rand = Math.floor(Math.random() * n); [arr[i], arr[rand]] = [arr[rand], arr[i]]; } }   隨機範圍不變，因此每次迭代都會有 $n$ 種結果，最終結果為 $n^n$。\n假設陣列元素有 5 個，最終產生的結果可能有 $5^5 = 3125$ 種，但最大的組合結果只有 $5! = 120$，這表示某些組合出現的機率會比較大，因此不符合條件。\n另一種常見的錯誤，使用 sort()：\n1  array.sort(() =\u0026gt; Math.random() - 0.5);   利用 -0.5 ~ 0.5 的數字，讓 sort() 的比較器函式 a 和 b 之間的大小關係是隨機的，所以排序結果也是隨機的。\n這種作法雖然簡潔優雅，但是它有很大的問題：\n 雖然每次比較的結果是隨機且均勻的，但各家瀏覽器實作 sort() 的方式不同，因此無法保證比較的次數。 假設比較次數為 $m$，每次每次比較的發生機率為 $1 / 2$，因此最終產生的結果為 $2^m$。 ","description":"洗牌（shuffle） 其實就是亂數排序。","id":7,"section":"posts","tags":["洗牌演算法","w3HexSchool"],"title":"JavaScript 學演算法（二十一）- 洗牌演算法","uri":"https://chupai.github.io/posts/2008/shuffle_algorithm/"},{"content":"這週是六角鼠年鐵人賽第二十八週。\n搜尋的操作是非常經典的演算法，身為資訊工程師，能否在最短時間內搜尋到所需要的資料，一直以來都是最關心的議題。\n\r什麼是搜尋（Search） 搜尋（Search），簡單來說就是在一堆資料中找出特定的資料輸出，核心的操作為「比較」，只有透過比較才能判斷是否符合輸出條件。\n根據資料量的大小，搜尋可分為：\n 內部搜尋：資料量小，可從主記憶儲存資料檔中進行尋找所要的資料之操作； 外部搜尋：資料量非常大，必須從外部記憶中尋找想要的資訊。因外部記憶體的操作較費時間，故需考慮如何減少存取時間與次數。  根據不同的資料結構，會有不同合適的搜尋演算法。搜尋演算法也非常的多，因為會根據需求的不同，而有很多不同的變化。\n以下會說明幾個基礎的搜尋演算法：\n 線性搜尋（Linear Search） 二分搜尋（Binary Search） 指數搜尋（Exponential Search） 內插搜尋（Interpolation Search）  線性搜尋（Linear Search） 線性搜尋（Linear Search） 或稱 循序搜尋法（Sequential Search），是一種最基本、最簡單、最低效的搜尋演算法。\n線性搜尋 是透過迭代集合中的每個元素，一筆一筆資料比較，直到找到所要尋找的特定值為止或搜尋完整個範圍仍找不到為止。簡單來說就是從頭到尾找一遍，最大的特性為不需要事先排序集合。\n舉例來說，迭代陣列尋找特定值：\n1 2 3 4 5 6 7 8 9  function linearSearch(arr, target) { const n = arr.length; for (let index = 0; index \u0026lt; n; index++) { if (target === arr[index]) { return index; } } return -1; }   回傳第一個符合條件的元素索引位置，若沒有回傳 -1。\n在 JavaScript 要在陣列中尋找特定元素，有以下方法使用：\n indexof() 類似上面的函式，但執行速度比自己寫的快。 findIndex() 迭代陣列，回傳第一個滿足指定條件的元素索引，與 indexof() 的差異在於，indexof() 使用 === 比較，findIndex() 能使用 callback 函式定義條件，適用於複雜的元素（例，物件），而且就算找到符合的條件元素，也會迭代完整個陣列。 其他陣列搜尋的方法還有 some() 、every()、find() 等等。  1. 分析 線性搜尋因為是從頭開始迭代至結尾，因此如果要找的資料在最後面或目標不存在，比較次數就會根據資料大小拉長。\n 特性：不需要事先排序 時間複雜度  最佳：$O(1)$ 最差：$O(n)$ 平均：$O(n)$   空間複雜度為： $O(1)$  二分搜尋（Binary Search） 二分搜尋（Linear Search） 或稱 折半搜尋演（Half-Interval Search）、對數搜尋（Logarithmic Search），是一種在 「已排序陣列」 中搜尋某一特定元素的搜尋演算法。\n二分搜尋會將陣列中間位置的值與目標進行比較，再判斷目標在左還是右。每次判斷都會縮小一半的搜尋範圍，直到找到目標或目標不存在。\n簡單來就說，就類似「終極密碼遊戲」，猜一個數字，會有三種回應：\n 比目標小 比目標大 猜中了  1. 演算法實作 二分搜尋輸入的陣列必須是已排序狀態。\n1 2 3 4 5 6 7 8 9 10 11 12 13  function binarySearch(sortedArray, target) { let [start, end] = [0, sortedArray.length - 1]; while (start \u0026lt;= end) { const mid = Math.floor((start + end) / 2); if (target === sortedArray[mid]) { return mid; } if (target \u0026lt; sortedArray[mid]) { end = mid - 1; } else { start = mid + 1; } } return -1; }   雖然不建議，但可以使用遞迴結構來改寫：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function binarySearch10(sortedArray, target) { return _binarySearch(0, sortedArray.length - 1); function _binarySearch(start, end) { if (start \u0026gt; end) { return -1; } const mid = Math.floor((start + end) / 2); if (target === sortedArray[mid]) { return mid; } if (target \u0026lt; sortedArray[mid]) { return _binarySearch(start, mid - 1); } else { return _binarySearch(mid + 1, end); } } }   不過空間複雜度會從 $O(1)$ 變成 $O(\\log n)$。\n2. 分析 每次判斷都會縮小一半的搜尋範圍，因此整體執行時間約為 $\\log_2$。\n 特性：需要事先排序陣列 時間複雜度  最佳：$O(1)$ 最差：$O(\\log n)$ 平均：$O(\\log n)$   空間複雜度為： $O(1)$  二分搜尋與線性搜尋相比，速度是線性搜尋的指數倍，但使用二分搜尋的前提下，陣列必須先排序過。\n指數搜尋（Exponential Search） 指數搜尋（Exponential Search） 或稱 Galloping Search，是一種特殊的二元搜尋，主要用在搜尋無限、無邊界的已排序序列。\n指數搜尋不是從中間位置來判斷，而會從索引位置 $2^{0}$ 開始，不斷遞增 $2^{1}$、$2^{2}$ 直到 $2^{i}$ 位置，若比目標大，會停止指數成長，改用二用搜尋，也就是取中位置來回頭尋找目標。\n1. 演算法實作 首先，我們先改寫二元搜尋，多傳入起始和終點的參數，也就是搜尋範圍：\n1 2 3 4 5 6 7 8 9 10 11 12 13  function binarySearch10(sortedArray, target, _start = 0, _end = sortedArray.length - 1) { let [start, end] = [_start, _end]; while (start \u0026lt;= end) { const mid = Math.floor((start + end) / 2); if (target === sortedArray[mid]) { return mid; } if (target \u0026lt; sortedArray[mid]) { end = mid - 1; } else { start = mid + 1; } } return -1; }   接下來是指數搜尋本體：\n1 2 3 4 5 6 7 8 9 10  function exponentialSearch(sortedArray, target) { const n = sortedArray.length; if (target === sortedArray[0]) { return 0; } let i = 1; while (i \u0026lt; n \u0026amp;\u0026amp; sortedArray[i] \u0026lt; target) { i = i * 2; } if(sortedArray[i] === target) { return i; } return binarySearch(sortedArray, target, i / 2, Math.min(i, n - 1)); }   2. 分析 使用指數搜尋，若目標很靠近序列前端，那麼會提升執行效率。因為縮小搜尋範圍，效率會比二分搜尋高。\n 特性：需要事先排序陣列 時間複雜度  最佳：$O(1)$ 最差：$O(\\log n)$ 平均：$O(\\log n)$   空間複雜度為： $O(1)$  內插搜尋（Interpolation Search） 內插搜尋（Interpolation Search） 又稱 插補搜尋、插值搜尋，也是一種特殊的二元搜尋，它是依照資料位置的分佈，利用內插公式預測目標的所在位置，搜尋方式與二分搜尋相同。\n二分搜尋是預測中間位置，而內插搜尋則是用直線斜率預測目標位置，一般而言，資料量愈大，數值分佈會愈平均，內插搜尋的效率會比二分搜尋法好。\n1. 內插公式 資料的值為 $y$、索引值為 $x$：\n 斜率 = $\\dfrac{y_2 - y_1}{x_2 - x_1}$  目標值為 $k$、預測目標索引位置為 $m$：\n $\\dfrac{y_2 - y_1}{x_2 - x_1}$ = $\\dfrac{k - y_1}{m - x_1}$ $m$ = $\\dfrac{(k - y_1)(x_2 - x_1)}{y_2 - y_1} + x_1$  2. 演算法實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function interpolationSearch(sortedArray, target) { let [start, end] = [0, sortedArray.length - 1]; while (start \u0026lt;= end) { const [x1, x2, y1, y2, k] = [start, end, sortedArray[start], sortedArray[end], target]; const m = Math.floor(((k - y1) * (x2 - x1)) / (y2 - y1) + x1); if (m \u0026gt; end || m \u0026lt; start) { break; } if (target === sortedArray[m]) { return m; } if (target \u0026gt; sortedArray[m]) { start = m + 1; } else { end = m - 1; } } return -1; }   3. 分析 如果資料分佈不均，近似線差異太大，最差時間複雜度高達 $O(n)$，如果資料分佈平均，執行效率會優於二元搜尋。\n 特性：需要事先排序陣列 時間複雜度  最佳：$O(1)$ 最差：$O(n)$ 平均：$O(\\log(\\log n))$   空間複雜度為： $O(1)$ ","description":"搜尋的操作是非常經典的演算法，身為資訊工程師，能否在最短時間內搜尋到所需要的資料，一直以來都是最關心的議題。","id":8,"section":"posts","tags":["搜尋演算法","w3HexSchool"],"title":"JavaScript 學演算法（二十）- 搜尋演算法","uri":"https://chupai.github.io/posts/2008/search_algorithm/"},{"content":" 竹白的 JS 學徒特訓班筆記 - 目錄\n 記錄六角學院所開的 JS 學徒特訓班，為期 60天的特訓。\n\r第三十六關：ES6 起步走 - Template String 樣板字串  題目連結\n 36. 問題 第 20 關 用 Template String 樣板字串來改寫。\n如果你已經早就會 ES6 字串處理，請觀看以下文章，挑選一個你不會的技術觀念，並分享你學到了什麼\n 邁向 JavaScript 勇者之路 [重新認識 JavaScript ES6 入門手冊  36. 參考解答 略。\n第三十七關：let、const  題目連結\n 37. 問題 還請挑戰者們分享你找到的 JS ES6 let 與 const 文章，補充在下方列表，並嘗試自己寫一些範例，並回報於 Slack 上\n37. 參考解答 變數\n第三十八關：let 與 const 觀念複習  題目連結\n 38. 問題 請在 Slack 回覆以下的解答，以及解釋為什麼？\n同時附上你找到的文章，條列在最下方\n問題一：\n請問下面會出現的 console 是？\n1 2  console.log(a); //ReferenceError let a = 10;   問題二：\n以下是否會正常執行？若不會，會顯示什麼紅字錯誤？\n1 2  let a = 1; a = 3;   1 2  let b = 1; let b = 2;   1 2  const c = 3; c = 4   問題三：此為熱門面試題目（選答）\n請問 var、let、const 的區別是？\n38. 參考答案 問題一：\n1 2 3  console.log(a); // Uncaught ReferenceError: Cannot access \u0026#39;a\u0026#39; before initialization let a = 10;   let 在正式值行前，變數不會賦值，因在沒值的狀況下被存取就會拋出錯誤。\n問題二：\n第一個正常執行。\n重複宣告：\n1 2 3 4  let b = 1; let b = 2; // Uncaught SyntaxError: Identifier \u0026#39;b\u0026#39; has already been declared   const 重新賦值：\n1 2 3 4  const c = 3; c = 4 // Uncaught TypeError: Assignment to constant variable.   問題三：\n var：函式作用域、可重複宣告、會汙染全域物件。 var、let：區塊作用域、無法重複宣告、不會汙染全域物件。  const：無法再次賦值    第三十九關：箭頭函式(arrow function)  題目連結\n 39. 問題  如果你是初學者，請回傳第 18 關的 forEach ，改用箭頭函式的寫法來撰寫 假使你已經會箭頭函式，請分享 arrow function 會如何影響到 this  39. 參考答案 略。\n第四十關：ES6 團戰關卡  題目連結\n 40. 問題  請挑選 20、35 關的其中一關，改為 ES6 寫法 程式碼必須使用到 ES6 的 36~39 關的技術，例如字串符、let、const、箭頭函式 如果你的 Code 早就已經改寫為 ES6 寫法，以下面試題目請挑選一題來解釋，並下方附上你的 HackMD 文章  請解釋什麼是 this？請寫範例解釋？ 你對 promise、promise all 有多熟悉？請寫範例解釋？ 什麼是原型繼承（prototype）？ Fetch 與 XMLHttpRequest    40. 參考答案  竹白記事本 - 函式呼叫與 this 竹白記事本 - Promise ","description":"JS 函式 36 ~ 40 關","id":9,"section":"posts","tags":["JavaScript","JS 學徒特訓班"],"title":"JS 學徒特訓班 - JS 函式 36 ~ 40 關","uri":"https://chupai.github.io/posts/2008/js60_4/"},{"content":" JavaScript筆記 目錄\n 一直沒時間將之前的筆記丟到這來，剛好最近參加 JS 學徒訓練班，就趁這次機會重新整理筆記。\n\r總結 直接來看總結。\n呼叫函式的方式會影響 this 的值：\n 直接作為函式來呼叫，通常 this 的值為全域物件，嚴格模式下為 undefined； 函式作為方法來呼叫，this 的值為被呼叫函式的所屬物件； 函式作為建構式來呼叫，this 的值為新建立的物件； 藉由 apply() 或 call() 呼叫，this 的值由第一個參數決定。  箭頭函式：\n 箭頭函式沒有自己的 this 的值，由建立時的環境來決定。  bind：\n 所有函式都具備 bind() 來建立一個新函式，此函式會綁定傳入的引數，除此之外，綁定的函式運作如原始的函式。  嚴格模式：\n 當 this 值為 undefined 或 null 會被強制轉成全域物件，而嚴格模式下，將不會強制轉值。  this 的誤解 this 有兩個因為過度解讀字面本身的意義，而造成的誤解。\n 第一個常見的誤解是 this 參考到函式本身； 另一個常見的誤解是 this 以某種方式參考了函式自身作用域。  請問會印出啥？\n1 2 3 4 5  function foo() { console.log(this); } foo(); // 預期結果為 function foo() { ... }   結果為全域物件（瀏覽器下是 Window 物件、node.js 底下是 Global 物件）。\n請問會印出啥？\n1 2 3 4 5 6 7 8 9 10  function foo() { var a = 2; this.bar(); } function bar() { console.log( this.a ); } foo(); // 預期結果為 2   結果為 undefined，因為全域物件下沒有 a。\nthis 的指向 1. 一般的函式呼叫 this 的值與物件導向有關，一但脫離了物件，this 的值並不重要。\n一般的函式呼叫，this 會指向預設的綁定（default binding），也就是全域物件（瀏覽器下是 Window 物件、node.js 底下是 Global 物件）。\n1 2 3 4 5 6 7 8  var name = \u0026#39;GlobalName\u0026#39;; function foo() { var name = \u0026#39;Chupai\u0026#39;; console.log(this.name); } foo(); // \u0026#34;GlobalName\u0026#34;   放到立即函式 IIFE ，直接在函式內直接在呼叫另一個函式：\n1 2 3 4 5 6 7 8 9  var name = \u0026#39;GlobalName\u0026#39;; (function() { function foo() { var name = \u0026#39;Chupai\u0026#39;; console.log(this.name); } foo(); // \u0026#34;GlobalName\u0026#34; })();   結果是一樣的。\n閉包 Closure：\n1 2 3 4 5 6 7 8 9 10  var name = \u0026#39;GlobalName\u0026#39;; function foo() { var name = \u0026#39;Chupai\u0026#39;; return function() { console.log(this.name); }; } foo()(); // \u0026#34;GlobalName\u0026#34;   這樣結果依然相同。\n回呼函式 Callback function：\n1 2 3 4 5 6 7 8 9 10 11 12 13  var name = \u0026#39;GlobalName\u0026#39;; function foo() { var name = \u0026#39;Chupai\u0026#39;; function boo() { console.log(this.name); } boo(); } foo(); // \u0026#34;GlobalName\u0026#34;   無論在哪一層， 一般的函式呼叫 this 都會指向全域物件。\n為什麼 this 會指向全域物件，關於這部分會在下方 嚴格模式 說明。\n2. 物件的方法呼叫 將函式綁定到一個物件屬性上，稱作方法（method）。\n如果呼叫物件的方法，this 的值為被呼叫函式的所屬物件。\n一個簡單的範例：\n1 2 3 4 5 6 7 8 9 10  var name = \u0026#39;GlobalName\u0026#39;; var obj = { name: \u0026#39;Chupai\u0026#39;, foo: function() { console.log(this.name); }, }; obj.foo(); // \u0026#34;Chupai\u0026#34;   foo 為 obj 的方法，因此 foo 內的 this 會指向 obj 物件。\n稍微改變一下程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13  var name = \u0026#39;GlobalName\u0026#39;; function foo() { console.log(this.name); } var obj = { name: \u0026#39;Chupai\u0026#39;, foo: foo }; foo(); // \u0026#34;GlobalName\u0026#34; obj.foo(); // \u0026#34;Chupai\u0026#34;   函式宣告的位置不重要，foo 內的 this 還是會指向 obj 物件。\n繼續看下個範例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  var name = \u0026#39;GlobalName\u0026#39;; function foo() { console.log(this.name); } var obj = { name: \u0026#39;Chupai\u0026#39;, boo: { name: \u0026#39;Wang\u0026#39;, foo: foo } }; obj.boo.foo(); // \u0026#34;Wang\u0026#34;   foo 為 obj.boo 物件的方法，所以它會指向 obj.boo 物件。\n3. 間接參考 接下來看一個常見的錯誤。\n如果將物件內的函式，賦予在一個變數上，並呼叫它：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var name = \u0026#39;GlobalName\u0026#39;; function foo() { console.log(this.name); } var obj = { name: \u0026#39;Chupai\u0026#39;, foo: foo, }; var callThisName = obj.foo; callThisName(); // \u0026#34;GlobalName\u0026#34;   當我們將 obj.foo 指定給變數 callThisName 時，會將 foo 函式的記憶體位置傳給 callThisName，因此當我們用 callThisName() 呼叫時，與 obj 無關，所以就只是一般的函式呼叫。\n另外，參數傳遞中的回呼函式，也屬於間接參考：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  var name = \u0026#39;GlobalName\u0026#39;; function foo() { console.log(this.name); } var obj = { name: \u0026#39;Chupai\u0026#39;, foo: foo, }; function boo(fn) { fn(); } boo(obj.foo); // \u0026#34;GlobalName\u0026#34;   4. 事件監聽 DOM 搭配事件監聽 addEventListener 時，監聽函式中的 this 會指向的則是該 DOM 物件。\n1 2 3 4 5  var dom = document.querySelector(\u0026#39;body\u0026#39;); dom.addEventListener(\u0026#39;click\u0026#39;, function() { console.log(this); // \u0026lt;body\u0026gt;...\u0026lt;/body\u0026gt; });   改變 this 的指向 會改變 this 的指向的情況：\n 使用 apply、call 函式方法； 使用 bind 函式方法； 使用建構函式 new 一個物件實體； 使用 ES6 的箭頭函式。  1. apply、call call() 與 apply() 是能呼叫函式的方法，並且能強制指定 this 值：\n1 2 3 4 5 6 7 8  var obj = {}; function foo() { console.log(this); }： foo(); // \u0026#34;Window{}\u0026#34; foo.call(obj); // Object{} foo.apply(obj); // Object{}   兩者第一個參數都是 this 值，也就是要綁定的物件。\n而兩者差異只在於後面的參數：\n1 2 3 4 5 6 7 8  var obj = {}; function foo(a, b) { console.log(this, a, b); } foo.call(obj, 1, 2); // Object{} 1 2 foo.apply(obj, [1, 2]); // Object{} 1 2   call() 第二個參數後，與平常呼叫函式一樣，apply() 則需要使用陣列將引數包起來。\n使用 call() 和 apply() 綁定 this 後，再用一次就無法改變 this 的指向：\n1 2 3 4 5 6 7 8 9 10  function foo() { console.log(this.a); } var boo = function () { foo.call({ a: 2 }); }; boo(); // 2 boo.call({ a: 10 }); // 2   此模式稱作硬綁定（hard binding），指的是綁定既明確又不會意外變回預設的綁定。\n2. bind() 因為硬綁定模式如此常用，ES5 新增了一個方法，將此模式包裝了起來，bind() 會回傳一個新的函式，當被呼叫時，將提供的值設為 this 值。\n1 2 3 4 5 6 7 8  function foo() { console.log(this.a); } var boo = foo.bind({ a: 2 }); boo(); // 2 boo.call({ a: 10 }); // 2   3. 使用建構函式 此部分只要了解建構函式的 this 是指向使用 new 建立的物件實體本身即可。\n1 2 3 4 5 6  function Foo(a) { this.a = a; } var bar = new Foo(2); console.log(bar.a); // 2   3. 箭頭函式 傳統函式的 this 是依呼叫的方法而定，因此當你的函式有好幾層時，會遇到一個問題：\n1 2 3 4 5 6 7 8 9 10 11 12  var obj = { a: 10, b: 20, print: function () { function add() { return this.a + this.b; } console.log(add()); }, }; obj.print(); // NaN   以上範例可以看到，我們在 print 方法內又建立一個函式並呼叫，因為是一般呼叫，因此 this 會會指向全域物件，所以 this.a 和 this.b 為 undefined，因此結果為 NaN。\n在 ES6 前，解決辦法是利用一個變數儲存 this 的值（常見命名 _this、that、vm、self）：\n1 2 3 4 5 6 7 8 9 10 11 12 13  var obj = { a: 10, b: 20, print: function () { var _this = this; function add() { return _this.a + _this.b; } console.log(add()); }, }; obj.print(); // 30   而 ES6 新增的箭頭函式，它本身並沒有 this，它會在定義時記住 this 值，也就在宣告它的地方的 this 是什麼，它的 this 就是什麼，會根據環境來：\n1 2 3 4 5 6 7 8 9 10 11 12  var obj = { a: 10, b: 20, print: function () { let add = () =\u0026gt; { return this.a + this.b; }; console.log(add()); }, }; obj.print(); // 30   箭頭函式注意事項：\n 箭頭函式一但綁定了 this 就不會再改變，使用 apply、call、bind 方法也無法修改； 箭頭函式也不能用在建構式上，會拋出錯誤； 用在監聽 DOM 的回呼函式上，this 會指向全域物件，因此要避免。  嚴格模式 ES5 之後，新增了嚴格模式，在嚴格模式下，一般函式呼叫的 this 值都是 undefined。\n1 2 3 4 5 6  \u0026#39;use strict\u0026#39;; function foo() { console.log(this); } foo(); // undefined   undefined 與全域物件有什麼關係？\n先來一段程式碼：\n1 2 3 4 5 6  function foo() { console.log(this); } foo.call(undefined); // Window{} foo.call(null); // Window{}   我們使用 call() 將 this 值設為 undefined，結果卻回傳全域物件。\n這是因為 JavaScript 的機制，當 this 值為 undefined 或 null 時，會將 this 值強制轉換為一個物件。\n在嚴格模式下，刻意將 undefined 或 null 設為 this 值，會回傳正確的 this 值。\n1 2 3 4 5 6 7  \u0026#39;use strict\u0026#39;; function foo() { console.log(this); } foo.call(undefined); // undefined foo.call(null); // null   這就是為什麼一般函式呼叫會回傳全域物件的原因。\n有的書會用「this 永遠指向最後呼叫它的那個物件」來解釋下面這段程式碼：\n1 2 3 4 5 6  function foo() { console.log(this); } foo(); // Window{} window.foo(); // Window{}   因為 foo() 等同 window.foo()，最後呼叫它的物件是全域物件，所以 this 指向全域物件。但這其實是不太正確的說法，this 值主要還是以函式的呼叫方式為主，foo() 的 this 值會是 undefined，會得到全域物件是因為被強制給值了。\n讓我們加上嚴格模式：\n1 2 3 4 5 6 7  \u0026#39;use strict\u0026#39;; function foo() { console.log(this); } foo(); // undefined window.foo(); // Window{}   window.foo() 的值還是指向全域物件，因為它是方法呼叫。\n1. 注意 但這裡要注意的是，呼叫地點是嚴格模式，並不會影響 this 的規則。\n1 2 3 4 5 6 7 8 9 10  function foo() { console.log( this.a ); } var a = 2; (function() { \u0026#39;use strict\u0026#39; foo(); // 2 })();   猜猜這個 this 到底是什麼？  JavaScript - 猜猜這個 \u0026ldquo;this\u0026rdquo; 到底是什麼？ 靠北 JS 之 This 到底是什麼辣  參考資料 書籍：\n 《忍者：JavaScript開發技巧探秘第二版》 《你所不知道的 JS - 範疇與 Closures、this 與物件原型》 《0 陷阱！0 誤解！8 天重新認識JavaScript！》 《JavaScript 技術手冊》  文章：\n JavaScript This 系列文：this 為什麼指向 window JavaScript This 系列文：this 與物件的關係\n ","description":"JavaScript 的大坑「this」。","id":10,"section":"posts","tags":["JavaScript","ES6","變數"],"title":"函式呼叫與 this","uri":"https://chupai.github.io/posts/2008/js_this/"},{"content":"這週是六角鼠年鐵人賽第二十七週。\n我們來看相較於 紅黑樹，可以說是非常簡單的平衡樹：樹堆（Treap）。\n\r樹堆 樹堆（Treap） 其名稱是 Tree 和 Heap 的結合。顧名思義，Treap 同時滿足二元搜尋樹和 Heap（堆積）的性質。屬於 笛卡爾樹（Cartesian Tree） 的一種，兩者在結構上是相同的，只是應用不同。\nTreap 結構相當於以隨機資料插入的二元搜尋樹，相較於其它平衡樹，實現可以說是非常簡單直觀。由於樹的結構並不等於添加元素順序，因此可有效避免一般的二元搜尋樹所出現的最糟情況。\n1. 性質 Treap 在二元搜尋樹的基礎上，每個節點都有一個隨機的 優先順序（priority）。\n Treap 為一棵二元搜尋樹； 左、右子樹也是 Treap； 每個節點都有一個隨機的 優先順序； 優先順序 保持著 Heap 性質。  Max Heap（最大堆積），所有的父節點都比子節點要大； Min Heap（最小堆積），所有的父節點都比子節點要小。    需要注意的兩點：\n Treap 相較於 Heap，不需要滿足 Complete binary tree（完全二元樹）的條件； Treap 相較於 AVL-Tree，屬於非嚴格平衡樹。  2. 新增操作 新增時，會給節點隨機分配一個優先順序，新增操作和一般二元搜尋樹相同，新增節點後，需要維護 Heap 的性質，會用到旋轉操作。\n以 Max Heap 為例：\n 新增節點到一個葉子節點上； 當前節點的優先順序比其根大，對根旋轉：  如果當前節點是根的左子節點，右旋轉； 如果當前節點是根的右子節點，左旋轉。    3. 刪除操作 因為 Treap 滿足 Heap 性質，所以只需要把要刪除的節點旋轉到葉子節點上，然後直接刪除就可以了。\n具體的方法：\n 比較被刪除節點的左、右子節點優先順序：\n- 左子樹優先順序大，執行右旋轉；\n- 右子樹優先順序大，執行左旋轉。 直到被刪除節點被旋轉到了葉子節點，然後直接刪除。  JavaScript 實作 Treap 1. 基本結構 我們簡單的寫一個隨機函式，用來模擬隨機分配的優先順：\n1 2 3  function random() { return Math.floor(Math.random() * 1000); }   節點：\n1 2 3 4 5 6 7 8  class TreapNode { constructor(data, priority = random()) { this.data = data; this.priority = priority; this.left = null; this.right = null; } }   節點比一般二元樹多一個優先順序。\n本體：\n1 2 3 4 5 6  class Treap { constructor() { this.root = null; } // methods }   2. 旋轉操作 與 AVL-Tree 相同。\n1 2 3 4 5 6 7 8 9 10 11 12 13  rightRotation(node) { const temp = node.left; node.left = temp.right; temp.right = node; return temp; } leftRotation(node) { const temp = node.right; node.right = temp.left; temp.left = node; return temp; }   3. 新增操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  insert(data) { const insertHelper = (node) =\u0026gt; { let curNode = node; if (!curNode) { return new TreapNode(data); } if (data \u0026lt; curNode.data) { curNode.left = insertHelper(curNode.left); if (curNode.left.priority \u0026gt; curNode.priority) { curNode = this.rightRotation(curNode); } } else if (data \u0026gt; curNode.data) { curNode.right = insertHelper(curNode.right); if (curNode.right.priority \u0026gt; curNode.priority) { curNode = this.leftRotation(curNode); } } return curNode; }; this.root = insertHelper(this.root); }   4. 刪除操作 因為節點是單向的，所以我們要記錄父節點和一個 key 紀錄當前節點是左、右子樹。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  remove(data) { let curNode = this.root; let parentNode = null; let key = \u0026#39;\u0026#39;; // 尋找刪除節點  while (curNode) { if (data \u0026lt; curNode.data) { parentNode = curNode; key = \u0026#39;left\u0026#39;; curNode = curNode.left; } else if (data \u0026gt; curNode.data) { parentNode = curNode; key = \u0026#39;right\u0026#39;; curNode = curNode.right; } else { break; } } // 旋轉刪除節點，直到最底下  while (curNode) { // 判斷節點狀態  const result = this.comparison(curNode); if (result === -1) { this.setNode(parentNode, null, key); return; } if (result === 1) { curNode = this.rightRotation(curNode); this.setNode(parentNode, curNode, key); key = \u0026#39;right\u0026#39;; parentNode = curNode; curNode = curNode.right; } else { curNode = this.leftRotation(curNode); this.setNode(parentNode, curNode, key); key = \u0026#39;left\u0026#39;; parentNode = curNode; curNode = curNode.left; } } }   輔助函式：\n1 2 3 4 5 6 7  setNode(parent, node, key) { if (!parent) { this.root = node; } else { parent[key] = node; } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  comparison(node) { if (!node.left \u0026amp;\u0026amp; !node.right) { return -1; } if (node.left \u0026amp;\u0026amp; !node.right) { return 1; } if (!node.left \u0026amp;\u0026amp; node.right) { return 0; } if (node.left.priority \u0026gt; node.right.priority) { return 1; } return 0; }   See the Pen Treap with Vue.js by Chupai@Design (@chupai) on CodePen. ","description":"樹堆（Treap）相較於紅黑樹，可以說是非常簡單的平衡樹。","id":11,"section":"posts","tags":["資料結構","二元搜尋樹","二元樹","Treap","平衡樹","樹堆","w3HexSchool"],"title":"JavaScript 學演算法（十九）- 樹堆","uri":"https://chupai.github.io/posts/2008/ds_treap/"},{"content":" 竹白的 JS 學徒特訓班筆記 - 目錄\n 記錄六角學院所開的 JS 學徒特訓班，為期 60天的特訓。\n\r第二十四關：資料格式處理，forEach + 陣列處理(一)  題目連結\n 劇情略。\n24. 題目 以下是預期希望出現正常的圖表，請改寫此 Codepen，並在 Slack 回傳你的解法：\nPS：HTML 與 CSS 面板壞掉了，只能變更 JS 面板\n24. 參考解答 1 2 3  newMonthMoney.forEach((item)=\u0026gt; { monthMoney.push(item); });   第二十五關：資料格式處理，forEach + 陣列處理(二)  題目連結\n 劇情略。\n25. 題目 以下是預期希望出現正常的圖表，請改寫此 Codepen，並在 Slack 回傳你的解法：\nPS：HTML 與 CSS 面板壞掉了，只能變更 JS 面板\n25. 參考解答 1 2 3 4  serverData.forEach((item)=\u0026gt; { let temp = [item.name, ...item.seasonOneData, ...item.seasonTwoData]; data.push(temp); });   教學、延伸知識連結  展開／其餘運算子\n  第二十六關：AJAX、axios 題目  題目連結\n 26. 問題 觀看 JS 新手教學 - AJAX 與資料處理，試著撈出 API 所有的姓名列表。\nhttps://raw.githubusercontent.com/hexschool/hexschoolNewbieJS/master/data.json 26. 參考解答 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const urlAPI = \u0026#39;https://raw.githubusercontent.com/hexschool/hexschoolNewbieJS/master/data.json\u0026#39;; let data = []; axios.get(urlAPI).then((res) =\u0026gt; { data = res.data; // 取得資料  rander(data); // 渲染 }); function rander(arr) { let html = \u0026#39;\u0026#39;; arr.forEach((item)=\u0026gt; { html += `\u0026lt;li\u0026gt;${item.name}\u0026lt;/li\u0026gt;` }); document.querySelector(\u0026#39;.list\u0026#39;).innerHTML = html; }   See the Pen JS 學徒特訓班 26 關 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  教學、延伸知識連結  axios中文文档 JSON-handle  第二十七關：陣列補充觀念  題目連結\n 27. 問題 請從以下連結，學習 2~3 種陣列的處理方式，聽說 sort 就蠻常見的，並在 slack 回報自己的範例程式碼與學到的東西。\n Cheatsheet for Array Methods - JavaScript 陣列方法大全 JavaScript Array 陣列操作方法大全 ( 含 ES6 ) JavaScript 陣列處理方法 [filter(), find(), forEach(), map(), every(), some(), reduce()  27. 參考解答 我以前的筆記：\n 陣列｜竹白記事本 迭代陣列｜竹白記事本 Slice、Splice、Split 的區別｜竹白記事本  第二十八關：陣列排序進度  題目連結\n 28. 問題 API：\nhttps://raw.githubusercontent.com/hexschool/hexschoolNewbieJS/master/data.json 撈出資料後，依照每個物件的 process 來進行進度排序，範例格式如下圖。\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;第 1 名是廖洧杰，他的特訓班完成度是 33%\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;第 2 名是王小明，他的特訓班完成度是 30%\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 28. 參考解答 process 資料格式為字串、數字部分為浮點數、單位為 %，因此若直接使用 parseInt() 取得數字，只能取得整數部分，小數部分就會有誤差，因此可以使用 parseFloat()。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  const urlAPI = \u0026#39;https://raw.githubusercontent.com/hexschool/hexschoolNewbieJS/master/data.json\u0026#39;; let data = []; axios.get(urlAPI).then((res) =\u0026gt; { data = res.data; // 取得資料  let sortedData = sortData(data); // 排序  rander(sortedData); // 渲染 }); function rander(arr) { let html = \u0026#39;\u0026#39;; arr.forEach((item, index)=\u0026gt; { html += `\u0026lt;li\u0026gt;第 ${index + 1}名是${item.name}，他的特訓班完成度是 ${item.process}\u0026lt;/li\u0026gt;` }); document.querySelector(\u0026#39;.list\u0026#39;).innerHTML = html; } function sortData(arr) { let temp = [...arr]; // 複製一份避免動到原始資料  temp.sort((a, b)=\u0026gt; parseFloat(b.process) - parseFloat(a.process)); return temp; }   See the Pen JS 學徒特訓班 28 關 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  教學、延伸知識連結  parseInt｜MDN parseFloat｜MDN sort()｜MDN  第二十九關：監聽切換排序功能  題目連結\n 29. 問題 承接上題，新增切換排序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;select\u0026gt; \u0026lt;option value=\u0026#34;id\u0026#34;\u0026gt;依照 id 編號排序(由1開始從上往下)\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;process\u0026#34;\u0026gt;依照完課率排序(由最高到最低)\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; // 以下為編號排序範例 \u0026lt;ul class=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;li\u0026gt;編號 ID 1 為廖洧杰，他的完成進度為 5 %\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;編號 ID 2 為王小明，他的完成進度為 33 %\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; // 以下為完課率排序範例 \u0026lt;ul class=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;li\u0026gt;編號 ID 2 為王小明，他的完成進度為 33 %\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;編號 ID 1 為廖洧杰，他的完成進度為 5 %\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;   29. 參考解答 監聽 \u0026lt;select\u0026gt; 取得 \u0026lt;option\u0026gt; 的值，用來判斷排序方式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  let selectDom = document.getElementById(\u0026#39;select\u0026#39;); selectDom.addEventListener(\u0026#39;change\u0026#39;, function() { let sortedData = sortData(data, this.value); rander(sortedData); }); function sortData(arr, mode = \u0026#39;id\u0026#39;) { let temp = [...arr]; // 複製一份避免動到原始資料  if (mode === \u0026#39;id\u0026#39;) { temp.sort((a, b)=\u0026gt; a - b); } else { temp.sort((a, b)=\u0026gt; parseFloat(b.process) - parseFloat(a.process)); } return temp; }   See the Pen JS 學徒特訓班 29 關 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  教學、延伸知識連結  現代 JavaScript 教程 - 表单，控件  第三十關：C3.js 圖表整合  題目連結\n 30. 問題  請嘗試用 codepen 附上你的解答，這次的需求是「用 c3.js 圖表顯示，看看誰的完課率最好，同時可以看出排名」 圖表不局限於上面的長條圖，也可尋找合適的圖 週六日請嘗試寫一篇 blog，分享解題流程，讓其他人也可以受益  30. 參考解答 See the Pen JS 學徒特訓班 30 關 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  第三十一關：部落格文章閱讀  題目連結\n 略。\n第三十二關：程式整合篇  題目連結\n 32. 問題 結合 29、30 關，左邊排序功能，右邊圖表顯示。\n32. 參考解答 See the Pen JS 學徒特訓班 32 關  by CHUPAIWANG (@CHUPAIWANG) on CodePen.  第三十三關：圓餅圖分析  題目連結\n 33. 問題  圓餅圖圖表\n 繪製尚未開賽跟已開賽的比例圓餅圖。\n33. 參考解答 1 2 3 4 5 6 7 8 9 10 11 12  let processCount = { non: 0, start: 0, }; data.forEach((item)=\u0026gt; { if (parseFloat(item.process) \u0026gt; 0) { processCount.start += 1; } else { processCount.non += 1; } });   See the Pen JS 學徒特訓班 33 關  by CHUPAIWANG (@CHUPAIWANG) on CodePen.  第三十四關：圓餅圖分析（中文字串判別）  題目連結\n 34. 問題 觀察每個參賽者的「姓名長度的字元數」\n34. 參考解答 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function strLen(str) { if (str == null) return 0; if (typeof str != \u0026#39;string\u0026#39;) { str += \u0026#39;\u0026#39;; } return str.replace(/[^\\x00-\\xff]/g, \u0026#39;01\u0026#39;).length; } let nameLengthCount = { lessSix: 0, moreSeven: 0, }; data.forEach((item)=\u0026gt; { if (strLen(item.name) \u0026gt; 6) { nameLengthCount.moreSeven += 1; } else { nameLengthCount.lessSix += 1; } });   See the Pen JS 學徒特訓班 34 關  by CHUPAIWANG (@CHUPAIWANG) on CodePen.  教學、延伸知識連結  JS判断字符串长度（英文占1个字符，中文汉字占2个字符）  第三十五關：圓餅圖與長條圖合併使用 35. 問題  範例連結\n 結合 API，同時顯示長條圖與圓餅圖，並顯示各區間完課率人數。\n35. 參考解答 注意，process 是浮點數，因此判斷區間時，\u0026lt;= 20 與 \u0026lt; 21 結果可能會有些微差異。\nSee the Pen JS 學徒特訓班 34 關  by CHUPAIWANG (@CHUPAIWANG) on CodePen. ","description":"JS 函式 24 ~ 35 關","id":12,"section":"posts","tags":["JavaScript","JS 學徒特訓班"],"title":"JS 學徒特訓班 - JS 函式 24 ~ 35 關","uri":"https://chupai.github.io/posts/2008/js60_3/"},{"content":" JavaScript筆記 目錄\n 一直沒時間將之前的筆記丟到這來，剛好最近參加 JS 學徒訓練班，就趁這次機會重新整理筆記。\n\r變數 Variable 程式碼會需要暫時儲存一些工作所需要的資料，它可以把這些資料儲存在變數中。\n變數必須先宣告才能使用它，有三種關鍵字可用來宣告：\n var：函式作用域 let：區塊作用域、無法重複宣告 const：區塊作用域、無法重複宣告、無法再次賦值  1. 使用 var 宣告變數 在 ES6 之前，var 是唯一可用於定義變數的關鍵字。\n宣告名稱為 a 的變數：\n1 2 3  var a; console.log(a); // undefined   若宣告時，未賦值，變數會被給予特殊值 undefined，表示值沒有被定義。\n建立變數後可以使用 = 指定運算子來賦值。\n1 2 3 4  var a; a = 10; console.log(a); // 10   var 可以重複宣告：\n1 2 3 4  var a = 1; var a = 2; console.log(a); // 2   雖然語法合法，但是不建議這麼做。\n在全域範圍宣告變數，變數會成為全域物件：\n1 2  var a = 10; console.log(this.a); // 10   2. 變數的資料型別 JavaScript 屬於動態定型語言，變數本身並沒有型別資訊，因此建立變數時，不需要宣告型別，同一個變數可以指定不同的資料型別。\n3. 同一個述句中宣告多個變數 1  var a, b;   4. 沒宣告的變數 不需告變數也能使用：\n1 2  a = 10; console.log(a); // 10   a 會變成全域變數，這是 JavaScript 的雷點之一。\n但在 ES5 之後，新增了嚴格模式，在嚴格模式之下，變數一定要宣告，否則會拋出錯誤。\n1 2 3 4 5 6  \u0026#39;use strict\u0026#39; a = 10; console.log(a); // Uncaught ReferenceError: msg is not defined   5. 還沒宣告的變數 在 var 宣告變數前呼叫，也不會報錯：\n1 2 3  console.log(a); // undefined var a = 10; console.log(a); // 10   這是因為變數的 提升（Hoisting） 行為。\n6. 作用域 Scope 5.1 函式作用域 使用 var 宣告變數將屬於當前的函式作用域，如果聲明位於任何函式外部的頂層，它就屬於全局作用域也就是全域變數。\n1 2 3 4 5  function num() { var a = 5; } console.log(a); // a is not defined   5.2 巢狀作用域 當你宣告了一個變數時，它就在這個作用域內的任何地方都是可用的，包括任何下層/內部作用域。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  function foo() { var a = 1; function bar() { var b = 2; function baz() { var c = 3; console.log(a, b, c); // 1 2 3  } baz(); console.log(a, b); // 1 2  } bar(); console.log(a); // 1 } foo();   7. 命名規則 變數命名規則，必須遵守以下條件：\n 不能以數字起始 不能使用關鍵字、或是保留字 任何 Unicode 都可以拿來當作 JavaScript 的變數  但這裡有一點要注意，undefined 在 JavaScript 並不是保留字：\n1 2 3 4 5 6  function foo() { var undefined = 10; return undefined; } console.log(foo()); // 10   在函式中，undefined 可以作為變數。\nlet、const 在 ES6 新增了兩種變數宣告方式。let 與 const 都是以區塊為作用域的宣告，而且不可以在同一個作用域下重複宣告，另外在全域範圍宣告變數，變數並不會成為全域物件。\n兩者差異在於 const 是常數為不能再次指定值。\n1. 以區塊為作用域的宣告 JavaScript 的變數作用域的基本單位永遠都是函式。如果需要建立一個區塊作用域，最常使用的方式就是使用立即函式運算式。\n1 2 3 4 5 6 7 8  var a = 2; (function(){ var a = 3; console.log( a ); // 3 })(); console.log( a ); // 2   而 let 或 const 只需要一對 {} 就能建立一個作用域。\n1 2 3 4 5 6 7  let a = 2; { let a = 3; console.log( a ); // 3 } console.log( a ); // 2   2. let let 最常使用的情境就是 if 迴圈，我們可以將變數的作用域限制於迴圈中。for 圓括號中的 let 變數仍然是在區塊作用域。\n舉例來說，如果使用 var 定義 i：\n1 2 3 4 5  for(var i = 0; i \u0026lt; 3; i++) { console.log(i); } console.log(i); // 3   你可以發現 i 汙染了全域。\n1 2 3 4 5  for(let i = 0; i \u0026lt; 3; i++) { console.log(i); } console.log(i); // Uncaught ReferenceError: i is not defined   for 迴圈中的 let 變數會作重新綁定。\n來看一個經典的範例：\n1 2 3 4 5 6 7 8 9  for(var i = 0; i \u0026lt; 3; i++) { setTimeout(function() { console.log(i); }, i * 1000); } // 3 // 3 // 3   因為 var 會直接將 i 宣告成全域變數，不斷透過 for 迴圈累加，在等到 setTimeout() 這個非同步程式實際執行時，只會拿到累加後的數值。\n1 2 3 4 5 6 7 8 9  for(let i = 0; i \u0026lt; 3; i++) { setTimeout(function() { console.log(i); }, i * 1000); } // 0 // 1 // 2   3. const 常數 constant 指是的數值不變的值。早期只有 var 時，宣告常數時，都是利用名稱全大寫來區分，但它還是能夠被更改。\n而使用 const 宣告變數，有一的特點，就是 「不能再次指定值」，宣告時一定要賦值。\n如果試著對 const 重新賦值，那將會報錯：\n1 2 3 4  const a = 1; a = 2; // Uncaught TypeError: Assignment to constant variable. console.log( 1 ); // 2   但如果一開始宣告的變數內容為物件型別，那其內容屬性還是可以被改變：\n1 2 3  const obj = {}; obj.a = \u0026#39;aa\u0026#39;;   你無法更改的只是變數本身。\n3. 重複宣告 上面提到，var 允許在同一個作用域下重複宣告，瀏覽器不會報錯，但 let 與 const 會出錯。\n1 2 3  let a; let a = 0; // Uncaught SyntaxError: Identifier \u0026#39;a\u0026#39; has already been declared   4. 還沒宣告的變數 上面提到，var 在其宣告的前後範圍都是有效的，是因為有 提升。\n但大部分的情況下，同常不應該有提升行為的出現，我們來看 let 的情況：\n1 2 3  console.log(a); // Uncaught ReferenceError: Cannot access \u0026#39;a\u0026#39; before initialization let a = 10;   let 在正式值行前，變數不會賦值，因在沒值的狀況下被存取就會拋出錯誤。\n撰寫風格 參考以下常見 ESLint 規範：\n Airbnb JavaScript Style Guide Google JavaScript Style Guide  總結幾點建議：\n let 可完全替代 var，不應該再繼續使用 var 宣告變數； 優先使用 const，除非需要再指定值才用 let； 不使用逗號 , 將變數值宣告在同一行； 不要將變數都放在區塊的最上層，而是在合理位置，在首次被使用的上面一行來宣告變數。 ","description":"JavaScript 變數 var、let、const","id":13,"section":"posts","tags":["JavaScript","ES6","變數"],"title":"變數","uri":"https://chupai.github.io/posts/2008/js_variable/"},{"content":" 竹白的 JS 學徒特訓班筆記 - 目錄\n 記錄六角學院所開的 JS 學徒特訓班，為期 60天的特訓。\n\r第十一關：函式參數再練習  題目連結\n 劇情略。\n11. 問題 題目一：老闆想要隨時扣你的薪水\n老闆：「今天是發薪日，先發給你薪資 23500 元(遞給小杰」\n老闆：「以下三步驟動作請寫成程式」\n老闆：「步驟一：昨天你上廁所太久了，我要扣你 1000 元」\n老闆：「步驟二：小黑說不喜歡你煮的狗食，我要再扣你 3500 元 (再次取走」\n老闆：「步驟三：我今天心情不太好，扣個 500 元意思一下」\n小杰：「屁啦！心情不太好關我啥事！」\n老闆：「這不是重點，快點算！將之前的寫法換成函式，並增加一個參數，讓我方便何時扣你多少都沒問題」\n老闆：「最後你寫的函式，要執行三次，每次都要回報你的總薪水剩下多少。」\n1 2 3 4 5  var salary = 23500; //請依照上面的武功秘笈 Codepen，依序實現兩步驟，算出小杰被扣了多少錢  console.log(\u0026#39;小杰目前還剩下\u0026#39; + salary + \u0026#39;元\u0026#39;);   題目二： if + 指派運算子\n老闆：「好了，現在我要告訴你贈品條件！」\n 目前小杰手上有 3 個贈品 消費滿 100 元就送對方贈品  下圖為第八關截圖，請依照以下邏輯進行改寫：\n 現在來了三個客人，並依序有消費，A顧客消費 150、B 顧客消費 99、C 顧客消費 110。 請設計一個函式，裡面代入一個參數為顧客消費金額，確認該客戶是否符合贈品條件，若符合就讓 giftNum 變數減少數量。 並依序執行三次函式，每次函式皆會 return 目前贈品數量剩下多少。  1 2 3 4 5 6 7 8 9  var giftNum = 3; // 贈品數量 var customerA = 150; // 顧客 A 消費金額 var customerB = 99; // 顧客 B 消費金額 var customerC = 99; // 顧客 C 消費金額  if (客戶A條件) {} if (客戶B條件) {} console.log(\u0026#39;目前贈品剩下\u0026#39; + giftNum + \u0026#39;個\u0026#39;);   題目三：if + 指派運算子\n老闆：「我現在補齊給你總計 200 個贈品！」\n老闆：「然後我覺得現在贈品門檻太高了，我決定大放送，只要滿 50 元就送一個！以此類推，他買 500 元就送 10 個贈品！」\n小杰：「老闆你竟然利用我的特休，我跟你沒完啦。」\n老闆：「別廢話，客人來了快點！他買完後告訴我贈品還夠不夠！」\n下圖為第八關截圖，giftNum 已改為 200 份，請依照以下邏輯進行改寫：\n 請用函式改寫，同時來了三組客人，請用你寫的函式連續執行三次，來幫助顧客是否有符合贈品條件。 另外每次執行函式時，都必須告訴老闆一次目前贈品數量。  第一組客人：Mary 買了 10 份薯條，10 份漢堡\n第二組客人：Bob 買了 1 份薯條\n第三組客人：Tim 買了 20 份薯條，15 份漢堡\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var giftNum = 200; // 贈品數量 var friesPrice = 30; // 薯條單價 var hamburgerPrice = 50; // 漢堡單價  // 以下是題目 // mary 買了 10 份薯條，10 份漢堡 // 請計算完贈品規則後，善用指派運算子去計算目前剩下的贈品有幾個 // 並用下面的 if 回報給老闆  if (條件式) { console.log(\u0026#39;老闆！贈品還夠！剩下\u0026#39; + giftNum + \u0026#39;個~\u0026#39;); } else { console.log(\u0026#39;老闆贈品賣光啦~\u0026#39;); }   11. 參考解答 題目一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function calculate(num) { salary -= num; return salary; } calculate(1000); console.log(\u0026#39;小杰目前還剩下\u0026#39; + salary + \u0026#39;元\u0026#39;); // \u0026#39;小杰目前還剩下22500元 \u0026#39;  calculate(3500); console.log(\u0026#39;小杰目前還剩下\u0026#39; + salary + \u0026#39;元\u0026#39;); // \u0026#39;小杰目前還剩下19000元\u0026#39;  calculate(500); console.log(\u0026#39;小杰目前還剩下\u0026#39; + salary + \u0026#39;元\u0026#39;); // \u0026#39;小杰目前還剩下18500元\u0026#39;   題目二：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function calculate(num) { if (num \u0026gt;= 100) { giftNum -= 1; } return giftNum; } calculate(customerA); console.log(\u0026#39;目前贈品剩下\u0026#39; + giftNum + \u0026#39;個\u0026#39;); // 目前贈品剩下2個  calculate(customerB); console.log(\u0026#39;目前贈品剩下\u0026#39; + giftNum + \u0026#39;個\u0026#39;); // 目前贈品剩下2個  calculate(customerC); console.log(\u0026#39;目前贈品剩下\u0026#39; + giftNum + \u0026#39;個\u0026#39;); // 目前贈品剩下1個   題目沒說明，因此這裡不考慮贈品不足（giftNum 變負數）的情況。\n題目三：\n1 2 3 4 5 6 7 8 9 10 11 12 13  function calculate(friesNum = 0, hamburgerNum = 0) { let total = friesPrice * friesNum + hamburgerPrice * hamburgerNum; giftNum -= Math.floor(total / 50); if (giftNum \u0026gt; 0) { console.log(\u0026#39;老闆！贈品還夠！剩下\u0026#39; + giftNum + \u0026#39;個~\u0026#39;); } else { console.log(\u0026#39;老闆贈品賣光啦~\u0026#39;); } } calculate(10, 10); // 老闆！贈品還夠！剩下184個 calculate(1); // 老闆！贈品還夠！剩下184個 calculate(20, 15); // 老闆！贈品還夠！剩下157個   第十二關：DOM 操作  題目連結\n 劇情略。\n12. 題目  請觀看此 Codepen 的線索，試圖找到密碼，並在 Slack 上回傳密碼 以下 Codepen 的 HTML 與 CSS 面板都壞掉了，你只能編輯 JS 面板，來去尋找線索  12. 參考解答 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  let url = \u0026#39;https://hexschool.github.io/JSTraining/stage12/\u0026#39;; // 區塊一，路徑放錯了，得用 setAttribute 換 src 屬性，換成 1.png document.querySelector(\u0026#39;.keyItem1 img\u0026#39;).setAttribute(\u0026#39;src\u0026#39;, `${url}1.png`); // 區塊二，唯一有放對，不需更改  // 區塊三，請用 innerHTML，指定 keyItem3，讓他插入 3.png 圖片 document.querySelector(\u0026#39;.keyItem3\u0026#39;).innerHTML = ` \u0026lt;div class=\u0026#34;keyItem keyItem3\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;${url}3.png\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt;`; // 區塊四，只能用 style 插入 background 4.png document.querySelector(\u0026#39;.keyItem4\u0026#39;).style.background = `url(\u0026#34;${url}4.png\u0026#34;)`;   解答 Codepen\n教學、延伸知識連結  JavaScript 教程 - DOM 現代 JavaScript 教程 - Document  第十三關：函式+if 判斷  題目連結\n 劇情略。\n13. 問題 以下為 BMI 計算方式：\n BMI 計算為：體重(公斤) / 身高的平方(單位為公尺)  例如 150 公分 50 kg = 50/(1.5*1.5) = 22.2 BMI 指數   BMI 數值狀態如下  體重過輕：BMI ＜ 18.5 正常：18.5 ≦ BMI ＜ 24 過重：24 ≦ BMI ＜ 27 輕度肥胖：27 ≦ BMI ＜ 30 中度肥胖：30 ≦ BMI ＜ 35 重度肥胖：BMI ≧3 5　    小杰打開 Code 才發現，裡面的 if 判斷根本都在亂寫，請依照上面的 BMI 狀態來改寫，並還小杰一個清白。\n請修改此 Codepen，並將修改結果回傳到 Slack。\n1 2 3 4 5 6 7 8 9 10  function calculationBMI(height, kg) { var bmi = kg / (height / 100 * height / 100); if (bmi \u0026gt; 20) { return \u0026#39;過胖！但能吃就是福，維持現況也沒什麼不好的~\u0026#39;; } else { return \u0026#39;你很瘦~ㄕㄡˋ~~\u0026#39;; } } console.log(calculationBMI(178, 70));   13. 參考解答 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  if (bmi \u0026lt; 18.5) { return \u0026#39;體重過輕\u0026#39;; } if (bmi \u0026lt;= 24) { return \u0026#39;正常\u0026#39;; } if (bmi \u0026lt;= 27) { return \u0026#39;過重\u0026#39;; } if (bmi \u0026lt;= 30) { return \u0026#39;輕度肥胖\u0026#39;; } if (bmi \u0026lt;= 35) { return \u0026#39;中度肥胖\u0026#39;; } return \u0026#39;重度肥胖\u0026#39;;   if 裡面已經使用 return，就不建議使用多餘的 else if 了。\n教學、延伸知識連結  禁止在 else 前有 return (no-else-return)｜ESLint 避免隨意而重複的if\u0026hellip;else JavaScript 复杂判断的更优雅写法 WEB前端if else 性能优化指南\n 理解 JavaScript 中的策略模式  第十四關：監聽與函式設計  題目連結\n 劇情略。\n14. 題目 小杰打開網頁後，發現工讀生只把 HTML 標籤寫好，JS 完全沒寫，\n因為 HTML 面板已經壞掉了，請直接修改 JS Code，\n讓 .total 的顯示數值，可以正常運作。\n並在 Slack 上回傳 carbon JS Code 與 Codepen。\nBMI 2.0版 Codepen 網址\n1 2 3 4 5 6 7  \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;height\u0026#34; placeholder=\u0026#34;請輸入您的身高(公分)\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;kg\u0026#34; placeholder=\u0026#34;請輸入您的體重(公斤)\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; class=\u0026#34;send\u0026#34; value=\u0026#34;計算\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;total\u0026#34;\u0026gt;您的 BMI 指數為 \u0026lt;span class=\u0026#34;BMI\u0026#34;\u0026gt;22\u0026lt;/span\u0026gt;， 狀態是 \u0026lt;span class=\u0026#34;status\u0026#34;\u0026gt;正常\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt;   14. 參考解答 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  document.querySelector(\u0026#39;.send\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, function () { let heightDom = document.querySelector(\u0026#39;.height\u0026#39;); let kgDom = document.querySelector(\u0026#39;.kg\u0026#39;); let height = Number(heightDom.value); let kg = Number(kgDom.value); let totalDom = document.querySelector(\u0026#39;.total\u0026#39;); // 若輸入不合法的值  if (isNaN(height) || isNaN(kg) || height \u0026lt; 1 || kg \u0026lt; 1) { totalDom.textContent = \u0026#39;請輸入大於 1 的數字\u0026#39;; return; } let bmi = Math.floor(kg / (((height / 100) * height) / 100)); let result = bmiResult(bmi); totalDom.innerHTML = ` 您的 BMI 指數為 \u0026lt;span class=\u0026#34;BMI\u0026#34;\u0026gt;${bmi}\u0026lt;/span\u0026gt;， 狀態是 \u0026lt;span class=\u0026#34;status\u0026#34;\u0026gt;${result}\u0026lt;/span\u0026gt;`; }); function bmiResult(bmi) { if (bmi \u0026lt; 18.5) { return \u0026#39;體重過輕\u0026#39;; } if (bmi \u0026lt;= 24) { return \u0026#39;正常\u0026#39;; } if (bmi \u0026lt;= 27) { return \u0026#39;過重\u0026#39;; } if (bmi \u0026lt;= 30) { return \u0026#39;輕度肥胖\u0026#39;; } if (bmi \u0026lt;= 35) { return \u0026#39;中度肥胖\u0026#39;; } return \u0026#39;重度肥胖\u0026#39;; }   教學、延伸知識連結  小tips: JS DOM innerText和textContent的区别\n  第十五關：物件運用 - 資料與渲染分離  題目連結\n 劇情略。\n15. 問題 以下是護理師改寫小杰的邏輯，程式碼連結\n護理師拿了之前工讀生的 Code 改寫，根本沒用小杰的。但可以看得出來，這個 Code 有刻意遺留了些不完整的地方，像是 bmiData 的物件沒有將條件寫完整，頗有想要再次考驗小杰的味道。\n請各位將你們的 Code 跟護理師的進行比較，看看差異在哪裡，並透過 Slack 分享自己吸收的結果，並試著依照自己的邏輯寫一遍。\n這次 HTML 面板壞掉了，你唯一可以改的面板只有 CSS 與 JS 面板。\n15. 參考解答 這裡就不優化了，直接補齊缺的部分。\n補齊所有狀態顏色：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  .blue { color: blue; } .green { color: green; } .pink { color: pink; } .orange { color: orange; } .purple { color: purple; } .red { color: red; }   建議語意化命名 class 名稱，但這裡就依照題目吧。\n補齊 BMIData 物件狀態：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  var BMIData = { overThin: { statusText: \u0026#39;體重過輕\u0026#39;, class: \u0026#39;blue\u0026#39;, }, normal: { statusText: \u0026#39;正常\u0026#39;, class: \u0026#39;green\u0026#39;, }, overweight: { statusText: \u0026#39;過重\u0026#39;, class: \u0026#39;pink\u0026#39;, }, mildObesity: { statusText: \u0026#39;輕度肥胖\u0026#39;, class: \u0026#39;orange\u0026#39;, }, moderateObesity: { statusText: \u0026#39;中度肥胖\u0026#39;, class: \u0026#39;purple\u0026#39;, }, severeObesity: { statusText: \u0026#39;重度肥胖\u0026#39;, class: \u0026#39;red\u0026#39;, }, };   補齊 calculationBMI 函式：\n1 2 3 4 5 6 7 8 9 10 11 12 13  if (bmi \u0026lt; 18.5) { render(\u0026#39;overThin\u0026#39;, bmi); } else if (bmi \u0026lt;= 24) { render(\u0026#39;normal\u0026#39;, bmi); } else if (bmi \u0026lt;= 27) { render(\u0026#39;overweight\u0026#39;, bmi); } else if (bmi \u0026lt;= 30) { render(\u0026#39;mildObesity\u0026#39;, bmi); } else if (bmi \u0026lt;= 35) { render(\u0026#39;moderateObesity\u0026#39;, bmi); } else { render(\u0026#39;severeObesity\u0026#39;, bmi); }    render 函式加入其他 class 前要先清除所有 class 樣式：\n1  statusDOM.classList.remove(...statusDOM.classList);   解答 CodePen\n教學、延伸知識連結  JavaScript 設計模式：關注點分離 Fastest way to clear classList  第十六關：forEach 與 HTML 字串累加  題目連結\n 劇情略。\n16. 問題 小杰一時間還不知道怎麼寫，所以先寫了陣列 + forEach 的方式來累加 HTML 字串，再來顯示介面出來。範例程式碼\n請你依照這邏輯，試著改寫物件格式，呈現的格式如下程式碼。\n設計好物件後，依序 push 五筆資料到陣列裡，最後整理完字串資料，再 innerHTML 到 ul 裡。\n這次 HTML 與 CSS 面板都壞了，請改寫 JS 面板。\nPS:請拿上面的 Codepen 改寫即可，不需拿前幾關的 code 來整合\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;小杰的身高為 178 公分，體重是 70 公斤，BMI 數據為 20，狀態為正常\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;小美的身高為 150 公分，體重是 200 公斤，BMI 數據為 38，狀態為超重\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 16. 參考答案： 物件格式改寫，我改一個就好，剩下雷同。\n1 2 3 4 5 6 7  { name: \u0026#39;廖洧杰\u0026#39;, height: 178, kg: 70, bmi: 22, status: \u0026#39;正常\u0026#39;, }   str 拿出來，避免每次迭代都被重置，並使用字串樣板加入變數。\n1 2 3 4 5 6 7 8 9 10  var str = \u0026#39;\u0026#39;; data.forEach(function (item) { var content = ` \u0026lt;li\u0026gt;${item.name}的身高為 ${item.height}公分， 體重是 ${item.kg}公斤， BMI 數據為 ${item.bmi}， 狀態為${item.status}\u0026lt;li\u0026gt;`; str += content; list.innerHTML = str; });   教學、延伸知識連結  樣板字面值｜MDN  第十七關：innerHTML+forEach  題目連結\n 劇情略。\n17. 問題 明明陣列裡面有五筆資料，但寫出來的程式碼，列表永遠只顯示一筆資料，究竟小杰哪裡觀念有問題呢？一起來幫助小杰吧~\n小杰程式碼網址\n請思考並在 Slack 回覆：\n str 放 forEach 外頭跟裡面的差異 innerHTML 放 forEach 外頭跟裡面的差異 innerHTML 當要寫內容進去時，會不會將裡面內容給覆蓋掉？  17. 參考解答  作用域不同，一個是全域，另一個只作用在 forEach 的 callback 函式內。放在外面才會累加結果。 innerHTML 放在外面就不會迭代，只會跑一次。 會覆蓋。  教學、延伸知識連結  append()、appendChild() 和 innerHTML 的区别\n ParentNode.append()｜MDN  第十八關：字串相加 innerHTML+ 樣式搭配  題目連結\n 劇情略。\n18. 問題 挑戰者們不要忘了，JS 始終要搭配妳寫好的 CSS 來進行渲染，護理師好像已經看膩了小杰爛到不行的陽春版本，寫了一個 .list2 版本，請依照他的 CSS 樣式邏輯，將 data 陣列裡面的資料，依序渲染到 .list2 裡面的 li 來顯示。\n護理師的 Codepen 網址\n18. 參考解答 1 2 3 4 5 6 7 8 9 10 11  var list2 = document.querySelector(\u0026#39;.list2\u0026#39;); var str = \u0026#39;\u0026#39;; data.forEach(function (item) { var content = ` \u0026lt;li class=\u0026#34;list-card\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;${item.name}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;你的身高是${item.height}\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt;`; str += content; }); list.innerHTML = str;   第十九關：驗收前夕  題目連結\n 劇情略。\n19. 問題 小杰打開師傅的程式碼，才發現這程式碼其實是來自於 Vic 這位工程師的範例程式碼。\n雖然跟設計稿有非常大的差異，但從程式邏輯中，慢慢掌握到了一些概念。\n請解讀 Vic 的（程式碼），並在 Slack 上回報他以下邏輯是做了什麼事情：\n arrayBMIrecord 的陣列用途是什麼？ 請描述 calculateBMI 函式做了什麼事情 請描述 render 函式做了什麼事情  19. 參考解答  儲存處理過的資料。 處理資料、將資料丟到 arrayBMIrecord、並執行 render 函式。 渲染 arrayBMIrecord 資料到畫面上。  第二十關：BMI 計算機團戰關卡  題目連結\n 劇情略。\n20. 題目  UI 設計稿  完成上方 UI 設計稿。\n20. 參考解答  使用樣板：HexSchool-BMI (Erica) CodePen：連結  教學、延伸知識連結  input type number｜MDN  第二十一關：BMI 追加功能  題目連結\n 劇情略。\n22. 問題 可憐的小杰又被威脅了，原來院長想要統計每次 BMI 測量的總平均值，一起做完這最後的需求，讓小杰順利離開醫院吧！\n22. 參考解答 1  \u0026lt;span class=\u0026#34;js-bmiAverage\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt;   1 2 3 4 5 6 7 8 9 10  const bmiAveragea = document.querySelector(\u0026#39;.js-bmiAverage\u0026#39;); function render() { let sum = 0; arrayBMIrecord.forEach((item) =\u0026gt; { sum += item.bmi; }); let avg = Math.floor(sum / arrayBMIrecord.length) || 0; bmiAveragea.textContent = avg; }   CodePen 解答\n第二十二關：陣列調整  題目連結\n 劇情略。\n22. 問題 最新的資料放在第一筆，讓最新資料都能排序在最前面，將資料進行反轉。\n22. 參考解答 有好幾種做法，渲染時，從後面迭代資料：\n1 2 3 4  for (let i = arrayBMIrecord.length - 1; i \u0026gt; 0; i -= 1) { const item = arrayBMIrecord[i]; // ... }   或是先淺拷貝一份資料，並使用 reverse() 反轉陣列，再迭代資料：\n1 2 3 4 5  let temp = [...arrayBMIrecord].reverse(); temp.forEach( // ... );   或是添加資料時，使用 unshift() 將最新資料加在最前面：\n1  arrayBMIrecord.unshift(userRecord);   但使用 unshift 效率不佳，因為背後的運作原理會將每個元素往後移動。\nCodePen 解答\n教學、延伸知識連結  Array的push与unshift方法性能分析  第二十三關：資料格式處理，陣列 unshift  題目連結\n 劇情略。\n23. 問題 小杰一看到題目整個傻眼，裡面用了他從來沒看過的圖表資料，好在老闆在程式碼裡面寫了些註解，讓小杰知道自己不需要懂圖表框架，好好的把資料處理好後，圖表自然就會顯示正常，一起來幫幫小杰吧！\n以下是預期希望出現正常的圖表，請改寫此 Codepen，並在 Slack 回傳你的解法：\nPS：HTML 與 CSS 面板壞掉了，只能變更 JS 面板\n23. 參考解答 1  monthMoney.unshift(title);   ","description":"JS 函式 23 ~ 20 關","id":14,"section":"posts","tags":["JavaScript","JS 學徒特訓班"],"title":"JS 學徒特訓班 - JS 函式 11 ~ 23 關","uri":"https://chupai.github.io/posts/2008/js60_2/"},{"content":" 竹白的 JS 學徒特訓班筆記 - 目錄\n 記錄六角學院所開的 JS 學徒特訓班，為期 60天的特訓。\n\r第一關：環境與變數環境  題目連結\n 1. 題目 第 1 題：\n1 2 3 4 5 6  // 1.產生 console.log 從上到下的值為？ // 2.出現幾個變數、型別、記憶體物件? var a; a = 1; a = \u0026#39;hello\u0026#39;; console.log(a);   第 2 題：\n1 2 3 4 5 6 7  // 1.產生 console.log 從上到下的值為？ // 2.出現幾個變數、型別、記憶體物件? var b = 3; var c = 4; console.log(d); var d = b + c; console.log(d);   第 3 題：\n1 2 3 4 5 6 7 8  // 1.產生 console.log 從上到下的值為？ // 2.出現幾個變數、型別、記憶體物件? console.log(e); var e; e = 5; e = \u0026#39;hello\u0026#39;; e = true; console.log(e);   1. 參考解答 第 1 題：\n \u0026quot;hello\u0026quot; 1個變數、2個型別、3個記憶體物件  1 2 3 4  var a ; // 已經有記憶體空間，但沒有值 a = 1; // 數值 a = \u0026#39;hello\u0026#39;; // 字串 console.log(a); // \u0026#34;hello\u0026#34;   第 2 題：\n undefined、7 3個變數、1個型別、6個記憶體物件  1 2 3 4 5 6 7 8  var b; // 已經有記憶體空間，但沒有值 var c; // 已經有記憶體空間，但沒有值 var d; // 已經有記憶體空間，但沒有值 console.log(d); // undefined b = 3; // 數值 c = 4; // 數值 d = b + c; // 數值 console.log(d); // 7   第 3 題：\n undefined、true 1個變數、3個型別、4個記憶體物件  1 2 3 4 5 6  var e; // 已經有記憶體空間，但沒有值 console.log(e); // undefined e = 5; // 數值 e = \u0026#39;hello\u0026#39;; // 字串 e = true; // 布林值 console.log(e); // true   教學、延伸知識連結  記憶體管理｜MDN 鐵人賽：JavaScript 變數的宣告與他的作用域 【译】JavaScript的内存管理和 4 种处理内存泄漏的方法  第二關：變數命名  題目連結\n 2. 題目 請依照以下房型資訊，去定義各個變數名稱，變數務必要命名比較語意化且好懂。\n3. 參考解答 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  const singleRoom = { peopleLimit: 1, bedSize: \u0026#39;單人床\u0026#39;, bathroomNum: 1, roomSize: 18, feetSize: \u0026#39;平方公尺\u0026#39;, description: \u0026#39;Single Room is only...\u0026#39;, checkInTimeFrom: \u0026#39;15:00\u0026#39;, checkInTimeTo: \u0026#39;21:00\u0026#39;, checkOutTimeFrom: \u0026#39;10:00\u0026#39;, checkOutTimeTo: \u0026#39;21:00\u0026#39;, facilities: { wifi: true, landlinePhone: true, breakfast: true, airConditioning: true, minibar: false, refrigerator: true, }, }   教學、延伸知識連結  無瑕的 JavaScript 程式碼（正體中文版）  第三關：變數型別轉換  題目連結\n 3. 題目 請依序告知以下 console.log 會顯示什麼值。\n第一題：\n1 2 3 4 5 6 7 8 9 10 11 12  var a = 1; console.log(typeof a); var b = \u0026#39;hello\u0026#39;; console.log(typeof b); var c = 1 + \u0026#39;hello\u0026#39;; console.log(typeof c); var d = 1 + \u0026#39;11\u0026#39;; console.log(d); console.log(typeof d);   第二題：\n1 2 3 4 5 6 7  var a; a = a + \u0026#39;hello\u0026#39;; console.log(a); console.log(typeof a); var b = 3; console.log(b * \u0026#39;hello\u0026#39;);   第三題：\n1 2 3 4 5 6 7  var a = 9; console.log(a + 9); console.log(a + \u0026#39;9\u0026#39;); var b = \u0026#39;9\u0026#39;; console.log(b * b); console.log(typeof (b * b));   3. 參考解答 第一題：\n1 2 3 4 5 6 7 8 9 10 11 12 13  var a = 1; console.log(typeof a); // \u0026#39;number\u0026#39;  var b = \u0026#39;hello\u0026#39;; console.log(typeof b); // \u0026#39;string\u0026#39;  var c = 1 + \u0026#39;hello\u0026#39;; console.log(typeof c); // \u0026#39;string\u0026#39;  var d = 1 + \u0026#39;11\u0026#39;; console.log(d); // \u0026#39;111\u0026#39; 隱含的強制轉型 console.log(typeof d); // \u0026#39;string\u0026#39;    使用 + 運算子，其中一邊為字串型別，會將另一邊強制轉型成字串。\n依據 ES5.1 語言規格的 section 11.6.1：\n 只要其中一邊為字串，就是字串相接：  非字串的型別會強制轉型成字串。   若雙方皆為非字串：  基本型別的值會轉為數值，物件型別（物件、陣列、函式）會先進行 ToPrimitive 轉換； 如果雙邊都沒有字串，就會進行數值運算。    第二題：\n1 2 3 4 5 6 7  var a; a = a + \u0026#39;hello\u0026#39;; console.log(a); // \u0026#39;undefinedhello\u0026#39; 隱含的強制轉型 console.log(typeof a); // \u0026#39;string\u0026#39;  var b = 3; console.log(b * \u0026#39;hello\u0026#39;); // NaN 隱含的強制轉型   -、*、/ 運算子與 + 運算子不同，它們只能對數值進行運算使用，因此會將非數值的值轉成數值。\n數值轉換過程是根據 ES5 的規格中 section 9.3 的 ToNumber：\n undefined：NaN null：+0 即 0 布林值：  true：1 false：+0 即 0   字串：數值或 NaN 物件型別（物件、陣列、函式）  會先進行 ToPrimitive 轉換，再執行 ToNumber    第三題：\n1 2 3 4 5 6 7  var a = 9; console.log(a + 9); // 18 console.log(a + \u0026#39;9\u0026#39;); // \u0026#39;99\u0026#39; 隱含的強制轉型  var b = \u0026#39;9\u0026#39;; console.log(b * b); // 81 隱含的強制轉型 console.log(typeof (b * b)); // \u0026#39;number\u0026#39;   教學、延伸知識連結  You Dont Know JS：型別與文法 第四章：強制轉型  第四關：比較運算子  題目連結\n 4. 題目 請依序告知以下 console.log 會顯示什麼值，若不知道答案，可將 code 貼在 chrome console 來顯示後，再回頭補知識點。\n第一題：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var a = 2; var b = 1; console.log(a \u0026gt; 0); console.log(a + b \u0026gt; 1); var c = 4; var d = 3; console.log(c == d); var e = 8; var f = 5; console.log(f \u0026gt;= e); console.log(f != e); console.log(f == e);   第二題 搭配型別自動轉型：\n1 2 3 4 5 6 7 8 9  var a = 3; var b = \u0026#39;3\u0026#39;; console.log(a == 1); console.log(a == b); var c = 2; var d = \u0026#39;5\u0026#39;; // 請解釋為什麼 console.log(c * d \u0026gt;= 5);   第三題 嚴謹模式：\n1 2 3 4 5 6  var a = 1; var b = \u0026#39;1\u0026#39;; console.log(a == 1); console.log(a == b); console.log(a === b); console.log(a !== b);   4. 參考解答 第一題：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var a = 2; var b = 1; console.log(a \u0026gt; 0); // true console.log(a + b \u0026gt; 1); // true  var c = 4; var d = 3; console.log(c == d); // false  var e = 8; var f = 5; console.log(f \u0026gt;= e); // false console.log(f != e); // true console.log(f == e); // false   第二題：\n1 2 3 4 5 6 7 8 9  var a = 3; var b = \u0026#39;3\u0026#39;; console.log(a == 1); // false console.log(a == b); // true  var c = 2; var d = \u0026#39;5\u0026#39;; // 請解釋為什麼 console.log(c * d \u0026gt;= 5); // true   第四關有說明過了，* 運算子只能對數值進行運算使用，因此會將非數值的值強制轉成數值。\n第三題：\n1 2 3 4 5 6  var a = 1; var b = \u0026#39;1\u0026#39;; console.log(a == 1); // true console.log(a == b); // true console.log(a === b); // false console.log(a !== b); // true   教學、延伸知識連結  You Dont Know JS：型別與文法 第四章：強制轉型 JavaScript 中的相等性視覺化圖表 JavaScript Equality Table   第五關：變數實作情境題  題目連結\n 劇情略。\n5. 問題 第一題：顧客 Bob 向店員詢價\n顧客 Bob：「請問我要買 4 個漢堡，30 份薯條，總共多少？」\n1 2 3 4 5 6 7 8 9 10  // 定義薯條跟漢堡的金額（金額不可以更改） var hamburgerPrice = 50; var friesPrice = 40; var bobTotal; // Code 寫在這，運算內容賦予到 bobTotal， // 並要利用到 hamburgerPrice、friesPrice // 算出 Bob 的提問。  console.log(\u0026#39;Bob 您好，您詢問的金額總計為\u0026#39; + bobTotal + \u0026#39;元\u0026#39;);   第二題：錢包剩下多少錢\nMark 錢包裡有 200 元，買了一個漢堡，三個薯條，他還剩下多少錢？\n1 2 3 4 5 6 7 8 9 10 11  // 定義薯條跟漢堡的金額（金額不可以更改） var hamburgerPrice = 50; var friesPrice = 40; var markWallet = 200; var markTotal; // Code 寫在這，運算內容賦予到 markTotal， // 並要利用到 markWallet、hamburgerPrice、friesPrice // 算出 Mark 購買後剩餘的金額。  console.log(\u0026#39;馬克買完東西後，錢包剩下\u0026#39; + markTotal + \u0026#39;元\u0026#39;);   第三題：顧客 Mary 提供折扣券\n顧客 Mary 身上有 5000 元，想要買 10 份漢堡、10 份薯條，因為他有會員卡，所以可以打九折優惠，請問他還剩下多少錢？\n1 2 3 4 5 6 7 8 9 10 11 12  // 定義薯條跟漢堡的金額（金額不可以更改） var hamburgerPrice = 50; var friesPrice = 40; var sale = 0.9; var maryWallet = 5000; var maryTotal; // Code 寫在這，運算內容賦予到 maryTotal， // 並要利用到 hamburgerPrice、friesPrice、sale、maryWallet // 算出 maryTotal 購買後剩餘的金額。  console.log(\u0026#39;Mary 買完東西後，錢包剩下\u0026#39; + maryTotal + \u0026#39;元\u0026#39;);   5. 參考解答 第一題：\n1 2 3  bobTotal = hamburgerPrice * 4 + friesPrice * 30; // Bob 您好，您詢問的金額總計為1400元   第二題：\n1 2 3  markTotal = markWallet - (hamburgerPrice * 1 + friesPrice * 3); // 馬克買完東西後，錢包剩下30元   第三題：\n1 2 3  maryTotal = maryWallet - (hamburgerPrice * 10 + friesPrice * 10) * sale; // Mary 買完東西後，錢包剩下4190元   第六關：邏輯運算子情境題  題目連結\n 劇情略。\n6. 題目 題目一：布林與比較運算子練習\n成為 VIP 會員的條件，只要購買滿 200 元，就可無條件成為會員，Bob 買了 2 個漢堡，2 個 薯條，是否有滿足條件？\n1 2 3 4 5 6 7 8 9 10  var VIPTotal = 200; var hamburgerPrice = 50; var friesPrice = 30; var isVIP; // 請透過比較運算子，將比較結果寫在 isVip 上 // 請利用 VIPTotal、hamburgerPrice、friesPrice 的變數進行比較 // isVIP 的型別必須為布林值 (true or false)  console.log(\u0026#39;Bob 的 VIP 條件為\u0026#39; + isVIP);   題目二：三心二意的老闆希望用邏輯運算子 \u0026amp;\u0026amp;\n老闆發現大家都只買薯條衝 VIP 資格，導致大家都不買漢堡，老闆好生氣，他認為他的美味蟹堡是全美最好吃的，小杰也不知道他的自信從哪裡來的。\n所以他跟小杰說，從今天起，VIP 條件必須同時符合以下兩點，才能成為 VIP 資格。\n 一次消費滿 200 元 一定要買 1 個漢堡  這時又來了兩位顧客，Mary 與 Mark，來看看他們有沒有符合條件吧！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // 此變數不可更改 var VIPTotal = 200; var hamburgerPrice = 50; var friesPrice = 30; var markHamburgerNum = 2; var markfriesNum = 4; var markIsVIP; // 如上面新增的變數，馬克買了 2 個漢堡，與 4 個薯條 // 請同時運用比較運算子與邏輯運算子，將比較結果寫在 markIsVIP 上 // markIsVIP 的型別必須為布林值 (true or false)  console.log(\u0026#39;mark 的 VIP 條件為\u0026#39; + markIsVIP); var maryHamburgerNum = 0; var maryfriesNum = 10; var maryIsVIP; // 如上面新增的變數，Mary 買了 0 個漢堡，與 10 個薯條 // 請同時運用比較運算子與邏輯運算子，將比較結果寫在 markIsVIP 上 // maryIsVIP 的型別必須為布林值 (true or false)  console.log(\u0026#39;mary 的 VIP 條件為\u0026#39; + maryIsVIP);   題目三：Mary 很生氣，他覺得現在的 VIP 資格吃人夠夠，希望用 || 邏輯運算子\nMary 說：「老闆我好歹是忠實老客戶欸，我買了你八年的薯條，而且遠遠超過 200 元，竟然還不算我是 VIP，你有沒有搞錯！」\n老闆怕了，他很擔心會上台灣的老天鵝娛樂被當作笑柄，所以他立馬將 VIP 條件改成，只要符合以下任一點消費條件，就能成為 VIP 資格。\n 一次消費滿 200 元 一定要買 1 個漢堡  我們再看看 Mary 有沒有符合條件吧！\n1 2 3 4 5 6 7 8 9 10 11 12 13  var VIPTotal = 200; var hamburgerPrice = 50; var friesPrice = 30; var maryHamburgerNum = 0; var maryfriesNum = 10; var maryIsVIP; // 如上面新增的變數，Mary 買了 0 個漢堡，與 10 個薯條 // 請同時運用比較運算子與邏輯運算子，將比較結果寫在 markIsVIP 上 // maryIsVIP 的型別必須為布林值 (true or false)  console.log(\u0026#39;mary 的 VIP 條件為\u0026#39; + maryIsVIP);   6. 參考解答 題目一：\n1 2 3  isVIP = hamburgerPrice * 2 + friesPrice * 2 \u0026gt;= VIPTotal; // Bob 的 VIP 條件為false   題目二：\n1 2 3 4 5 6 7 8 9 10 11  markIsVIP = markHamburgerNum \u0026gt; 1 \u0026amp;\u0026amp; hamburgerPrice * markHamburgerNum + friesPrice * markfriesNum \u0026gt;= VIPTotal; // mark 的 VIP 條件為true  maryIsVIP = maryHamburgerNum \u0026gt; 1 \u0026amp;\u0026amp; hamburgerPrice * maryHamburgerNum + friesPrice * maryfriesNum \u0026gt;= VIPTotal; // mary 的 VIP 條件為false   題目三：\n1 2 3 4 5  maryIsVIP = maryHamburgerNum \u0026gt; 1 || hamburgerPrice * maryHamburgerNum + friesPrice * maryfriesNum \u0026gt;= VIPTotal; // mary 的 VIP 條件為true   教學、延伸知識連結  運算式與運算子｜MDN 運算子優先序｜MDN  第七關：if - 認真的小杰竟被客訴  題目連結\n 劇情略。\n7. 題目 題目一：if 的練習\n老闆說現在要來驗收 if 成果，\n成為 VIP 會員的條件，只要購買滿 200 元，\n現在 會員 A 購買了 350 元，請用 if 判斷是否要給他 VIP 卡。\n1 2 3 4 5  var VIPTotal = 200; var memberPrice = 350; // 請透過 if 來設計回覆，如果對方滿足門檻 // 就回覆 console.log(\u0026#34;您好，您有達到 VIP 門檻。這裡給您 VIP 會員卡(遞上\u0026#34;)   題目二：if else 的練習\n又有人來申請 VIP 活動了！\n成為 VIP 會員的條件，只要購買滿 200 元，就可無條件成為會員，Mark 買了 2 個漢堡，2 個 薯條，是否有滿足條件？\n這次要記得用 if，以及注意你的語氣啊~ (小杰覺得人生好難\n1 2 3 4 5 6 7  var VIPTotal = 200; var hamburgerPrice = 50; var friesPrice = 30; // 請透過 if else 來去設計對方是否有達到條件，有或沒有都需要回覆對方 // 如果有，請顯示 console.log(\u0026#34;尊敬的客戶您好，您有達到 VIP 條件\u0026#34;) // 如果沒有達到條件，便用 else 顯示 console.log(\u0026#34;尊敬的客戶您好，您還差 xx 元，才有符合 VIP 條件哦~\u0026#34;)   題目三： if、else if、else 練習\n工作一整天，小杰累到懷疑人生，累歸累，但還是得吃東西，小杰吃東西有自己的 SOP，來幫幫小杰看看他該吃什麼食物。\n 小杰都用飢餓度 1~100 來計算，100 就是代表最飢餓，數值皆為整數，不會有小數點 小杰飢餓度 0~20 時，都吃飯糰 小杰飢餓度在 21~40 時，都吃肉燥飯+貢丸湯 小杰飢餓度在 41~60 時，都吃麥當勞 小杰飢餓度在 61~100 時，都吃 99 元火鍋吃到飽  今天小杰的飢餓度是 53，請引導小杰去指定地點用餐\n1 2 3 4 5 6 7 8 9 10  var hungryNum = 53; if (條件式) { console.log(); } else if (條件式) { console.log(); } // 請用 if、else if 去判斷主人公該吃什麼 // 各區塊回覆內容請顯示 console.log(\u0026#34;主人公因為飢餓度在\u0026#34;+hungryNum+\u0026#34;，所以他決定去吃麥當勞\u0026#34;)   7. 參考解答 題目一：\n1 2 3 4 5  if (memberPrice \u0026gt;= VIPTotal) { console.log(\u0026#39;您好，您有達到 VIP 門檻。這裡給您 VIP 會員卡(遞上\u0026#39;); } // 您好，您有達到 VIP 門檻。這裡給您 VIP 會員卡(遞上   題目二：\n1 2 3 4 5 6 7 8 9  let total = hamburgerPrice * 2 + friesPrice * 2; if (total \u0026gt;= VIPTotal) { console.log(\u0026#39;您好，您有達到 VIP 門檻。這裡給您 VIP 會員卡(遞上\u0026#39;); } else { let shortage = VIPTotal - total; console.log(\u0026#39;尊敬的客戶您好，您還差 \u0026#39; + shortage + \u0026#39; 元，才有符合 VIP 條件哦~\u0026#39;); } // 尊敬的客戶您好，您還差 40 元，才有符合 VIP 條件哦~   題目三：\n1 2 3 4 5 6 7 8 9 10 11 12 13  // 題目已經說明飢餓度 1~100 的整數，因此先不考慮此範圍外的輸入  if (hungryNum \u0026lt;= 20) { console.log(\u0026#39;主人公因為飢餓度在\u0026#39; + hungryNum + \u0026#39;，所以他決定去吃飯糰\u0026#39;); } else if (hungryNum \u0026lt;= 40) { console.log(\u0026#39;主人公因為飢餓度在\u0026#39; + hungryNum + \u0026#39;，所以他決定去吃肉燥飯+貢丸湯\u0026#39;); } else if (hungryNum \u0026lt;= 60) { console.log(\u0026#39;主人公因為飢餓度在\u0026#39; + hungryNum + \u0026#39;，所以他決定去吃麥當勞\u0026#39;); } else { console.log(\u0026#39;主人公因為飢餓度在\u0026#39; + hungryNum + \u0026#39;，所以他決定去吃 99 元火鍋吃到飽\u0026#39;); } // 主人公因為飢餓度在53，所以他決定去吃麥當勞   第八關：if 與指派運算子 - 幫幫小杰的金魚腦  題目連結\n 劇情略。\n8. 問題 題目一：老闆考考你指派運算子\n老闆：「我其實很懷疑你是不是真的會了，我考考你！」\n老闆：「剛好今天是發薪日，先發給你薪資 23500 元(遞給小杰」\n小杰：「謝謝腦闆，但你怎麼把我的薪資告訴大家了..」\n老闆：「這不是重點，以下兩步驟動作請寫成程式」\n老闆：「步驟一：因為你遲到一次，我要扣你 1000 元(取走小杰手上的 1000 元」\n老闆：「步驟二：然後你又偷吃 Pizza，我要再扣你 2500 元 (再次取走」\n小杰：「不是啊！那明明是小黑吃..」\n老闆：「這不是重點，快點算！算出你還剩下多少錢！」\n1 2 3 4 5  var salary = 23500; //請依照上面的武功秘笈 Codepen，依序實現兩步驟，算出小杰被扣了多少錢  console.log(\u0026#39;小杰目前還剩下\u0026#39; + salary + \u0026#39;元\u0026#39;);   題目二： if + 指派運算子\n老闆：「好了，現在我要告訴你贈品條件！」\n 目前小杰手上有 3 個贈品 消費滿 100 元就送對方贈品  而現在來了兩個客人，並依序有消費，請問現在他還剩下多少個贈品？\n1 2 3 4 5 6 7 8 9 10  var giftNum = 3; // 贈品數量 var customerA = 150; // 顧客 A 消費金額 var customerB = 99; // 顧客 B 消費金額  if (客戶A條件) { } if (客戶B條件) { } console.log(\u0026#39;目前贈品剩下\u0026#39; + giftNum + \u0026#39;個\u0026#39;);   題目三：if + 指派運算子\n老闆：「我現在補齊給你總計 50 個贈品！」\n老闆：「然後我覺得現在贈品門檻太高了，我決定大放送，只要滿 50 元就送一個！以此類推，他買 500 元就送 10 個贈品！」\n小杰：「老闆你今天這麼慷慨，那我的薪..」\n老闆：「別廢話，客人來了快點！他買完後告訴我贈品還夠不夠！」\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var giftNum = 50; // 贈品數量 var friesPrice = 30; // 薯條單價 var hamburgerPrice = 50; // 漢堡單價  // 以下是題目 // mary 買了 10 份薯條，10 份漢堡 // 請計算完贈品規則後，善用指派運算子去計算目前剩下的贈品有幾個 // 並用下面的 if 回報給老闆  if (條件) { console.log(\u0026#39;老闆！贈品還夠！剩下\u0026#39; + giftNum + \u0026#39;個~\u0026#39;); } else { console.log(\u0026#39;老闆贈品賣光啦~\u0026#39;); }   8. 參考解答 題目一：\n1 2 3 4  salary -= 1000; salary -= 2500 // \u0026#34;小杰目前還剩下20000元\u0026#34;   題目二：\n1 2 3 4 5 6 7 8  if (customerA \u0026gt;= 100) { giftNum -= 1; } if (customerB \u0026gt;= 100) { giftNum -= 1; } // \u0026#39;目前贈品剩下2個\u0026#39;   題目三：\n1 2 3 4 5 6 7 8 9 10 11  let maryTotal = friesPrice * 10 + hamburgerPrice * 10; let maryGiftNum = Math.floor(maryTotal / 50); giftNum -= maryGiftNum; if (giftNum \u0026gt; 0) { console.log(\u0026#39;老闆！贈品還夠！剩下\u0026#39; + giftNum + \u0026#39;個~\u0026#39;); } else { console.log(\u0026#39;老闆贈品賣光啦~\u0026#39;); } // \u0026#39;老闆！贈品還夠！剩下34個~\u0026#39;   第九關：觀念總整理 - 幫小杰學會 Function 之呼吸  題目連結\n 劇情略。\n9. 問題 請回覆以下 console.log 內容。\n第一式：變數型別之呼吸\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  var a = 1; a += 1; a += 5; var b = 5; console.log(a + b); var c = 3; var d = \u0026#39;hello\u0026#39;; console.log(c * d); var e = 8 + 2 * \u0026#39;9\u0026#39;; console.log(e); var f = 1; var g = \u0026#39;2\u0026#39;; var h = 3; console.log(typeof (f + g + h));   第二式：運算子之呼吸\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  var total = 200; var isVip = true; console.log(total \u0026gt;= 200 \u0026amp;\u0026amp; isVip); var a = true; var b = false; console.log(a \u0026amp;\u0026amp; b); console.log(a || b); var c = 10; var d = 20; var e = 30; console.log(c == 10 \u0026amp;\u0026amp; d \u0026gt;= 5 \u0026amp;\u0026amp; e !== 20); console.log(c == 10 || d \u0026gt;= 5 || e !== 20); console.log(c == 5 || d \u0026gt;= 40 || e !== 30);   第三式：運算子之呼吸\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  var maryIsVIP = true; if (maryIsVIP) { console.log(\u0026#39;哇貴婦餒！\u0026#39;); } else { console.log(\u0026#39;你一定搞錯了，叫你們店長出來！\u0026#39;); } var momSwim = false; var girlfriendSwim = true; if (momSwim \u0026amp;\u0026amp; girlfriendSwim) { console.log(\u0026#39;都不救，因為他們都會游泳\u0026#39;); } else { console.log(\u0026#39;小杰大喊：「你們誰不會游泳啊？？」\u0026#39;); if (girlfriendSwim) { console.log(\u0026#39;那你自己游上來！\u0026#39;); } else { console.log(\u0026#39;我先問我阿母會不會游泳！\u0026#39;); } if (momSwim) { console.log(\u0026#39;媽妳先自己游上來！\u0026#39;); } else { console.log(\u0026#39;媽我去救你！\u0026#39;); } }   9. 參考解答 第一式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  var a = 1; a += 1; a += 5; var b = 5; console.log(a + b); // 12  var c = 3; var d = \u0026#39;hello\u0026#39;; console.log(c * d); // NaN  var e = 8 + 2 * \u0026#39;9\u0026#39;; console.log(e); // 26  var f = 1; var g = \u0026#39;2\u0026#39;; var h = 3; console.log(typeof (f + g + h)); // \u0026#39;string\u0026#39;   第二式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  var total = 200; var isVip = true; console.log(total\u0026gt;=200 \u0026amp;\u0026amp; isVip); // true  var a = true; var b = false; console.log( a \u0026amp;\u0026amp; b); // false console.log( a || b); // true  var c = 10; var d = 20; var e = 30; console.log(c==10 \u0026amp;\u0026amp; d\u0026gt;=5 \u0026amp;\u0026amp; e !== 20); // true console.log(c==10 || d\u0026gt;=5 || e !== 20); // true console.log(c==5 || d\u0026gt;=40 || e !== 30); // false   第三式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  var maryIsVIP = true; if (maryIsVIP) { console.log(\u0026#39;哇貴婦餒！\u0026#39;); // \u0026#34;哇貴婦餒！\u0026#34; } else { console.log(\u0026#39;你一定搞錯了，叫你們店長出來！\u0026#39;); } var momSwim = false; var girlfriendSwim = true; if (momSwim \u0026amp;\u0026amp; girlfriendSwim) { console.log(\u0026#39;都不救，因為他們都會游泳\u0026#39;); } else { console.log(\u0026#39;小杰大喊：「你們誰不會游泳啊？？」\u0026#39;); // \u0026#34;小杰大喊：「你們誰不會游泳啊？？」\u0026#34;  if (girlfriendSwim) { console.log(\u0026#39;那你自己游上來！\u0026#39;); // \u0026#34;那你自己游上來！\u0026#34;  } else { console.log(\u0026#39;我先問我阿母會不會游泳！\u0026#39;); } if (momSwim) { console.log(\u0026#39;媽妳先自己游上來！\u0026#39;); } else { console.log(\u0026#39;媽我去救你！\u0026#39;); // \u0026#34;媽我去救你！\u0026#34;  } }   基本問題，就不說明了 😉。\n第十關：函式參數設計  題目連結\n 劇情略。\n10. 問題 第一題：客戶詢價函式，來更多個客人也不怕\n請改設計一個詢價用的函式，並新增三個參數，依序為客戶姓名、薯條數量，漢堡數量。\n同時來了三個客戶，請執行三次函式回報結果。\n1 2 3 4 5 6  // 定義薯條跟漢堡的金額（金額不可以更改） var hamburgerPrice = 50; var friesPrice = 40; var bobTotal; console.log(\u0026#34;Bob 您好，您詢問的金額總計為\u0026#34; + bobTotal + \u0026#34;元\u0026#34;);   第二題：好多客戶都在問小杰，他們錢包剩下多少錢，小杰表示無言\n下面截圖，請改設計一個查詢客戶錢包餘額用的函式，並新增四個參數，依序為客戶姓名、客戶錢包總額、薯條數量，漢堡數量。\n同時來了三個客戶，請執行三次函式回報結果。\n1 2 3 4 5 6 7  // 定義薯條跟漢堡的金額（金額不可以更改） var hamburgerPrice = 50; var friesPrice = 40; var markWallet = 200; var markTotal; console.log(\u0026#39;馬克買完東西後，錢包剩下\u0026#39; + markTotal + \u0026#39;元\u0026#39;);   第三題：好多人都擁有九折優惠券\n這一題，換您來設計函式與參數看看。\n突然間同時來了三個客戶，請執行三次函式回報結果。\n1 2 3 4 5 6 7 8  // 定義薯條跟漢堡的金額（金額不可以更改） var hamburgerPrice = 50; var friesPrice = 40; var sale = 0.9; var maryWallet = 5000; var maryTotal; console.log(\u0026#39;Mary 買完東西後，錢包剩下\u0026#39; + markTotal + \u0026#39;元\u0026#39;);   10. 參考解答 第一題：\n1 2 3 4 5  function customer(userName, hamburgerNum, friesPriceNum) { let total = hamburgerPrice * hamburgerNum + friesPrice * friesPriceNum; return userName + \u0026#39; 您好，您詢問的金額總計為\u0026#39; + total + \u0026#39;元\u0026#39;; }   第二題：\n1 2 3 4 5 6 7 8  function customer(userName, wallet, hamburgerNum, friesPriceNum) { let total = hamburgerPrice * hamburgerNum + friesPrice * friesPriceNum; let walletLast = wallet - total; return userName + \u0026#34;買完東西後，錢包剩下\u0026#34; + walletLast + \u0026#34;元\u0026#34;; }   題目沒說明，這裡不考慮錢不足的情況。\n第三題：\n1 2 3 4 5 6  function customer(userName, wallet, hamburgerNum, friesPriceNum) { let total = hamburgerPrice * hamburgerNum + friesPrice * friesPriceNum; let walletLast = wallet - total * sale; return userName + \u0026#39;買完東西後，錢包剩下\u0026#39; + walletLast + \u0026#39;元\u0026#39;; }   題目沒說明，這裡不考慮錢不足的情況，且客戶一定有優惠券。\n","description":"JS 變數 1 ~ 10 關","id":15,"section":"posts","tags":["JavaScript","JS 學徒特訓班"],"title":"JS 學徒特訓班 - JS 變數 1 ~ 10 關","uri":"https://chupai.github.io/posts/2008/js60_1/"},{"content":" 竹白的 JS 學徒特訓班筆記 - 目錄\n \r記錄六角學院所開的 JS 學徒特訓班，為期 60天的特訓。\n2020/08/01 中途加入，補進度：\n 2020/08/01 - JS 變數 - 1 ~ 10 關 2020/08/02 - JS 函式 - 11 ~ 23 關 2020/08/03 - JS 函式 - 24 ~ 35 關 2020/08/04 - JS 函式 - 36 ~ 40 關 2020/08/19 - Date、Location - 41 ~ 46 關 ","description":"竹白的 JS 學徒特訓班筆記","id":16,"section":"posts","tags":["JavaScript","JS 學徒特訓班"],"title":"JS 學徒特訓 - 目錄","uri":"https://chupai.github.io/posts/2008/js60_menu/"},{"content":" JavaScript筆記 目錄\n \r前言 Slice、Splice、Split 這幾個方法都是 S 開頭，因此若不熟悉很容易搞混，但它們又是處理 陣列 或 字串 常見的方法。\n Array.prototype.slice() Array.prototype.splice() String.prototype.split() String.prototype.slice()  slice 提取 陣列和字串都有 slice() 方法。\n1. Array.prototype.slice() 陣列的 slice() 會回傳一個指定索引範圍的新陣列（不改變原陣列）。\n1  arr.slice([begin[, end]])    begin：起始索引，若省略預設為 0； end：停止索引（不包含自己），若省略預設為 arr.length； 可以使用負數索引，從末項開始倒數。  1.1 範例 1 2 3 4 5 6 7 8 9 10 11 12 13  const arr = [0, 1, 2, 3, 4, 5]; // 無參數 0 ~ (arr.length - 1) console.log( arr.slice() ); // [0, 1, 2, 3, 4, 5]  // begin 2 ~ (arr.length - 1) console.log( arr.slice(2) ); // [2, 3, 4, 5]  // begin end 2 ~ (3 - 1) console.log( arr.slice(2, 4) ); // [2, 3]  // 負數 (arr.length - 2) ~ (arr.length - 1) console.log( arr.slice(-2) ); // [4, 5]   1.2 常見用法 用法一：淺拷貝陣列\n1 2  const arr = [0, 1, 2, 3, 4, 5]; const temp = arr.slice();   ES6 前沒展開運算子，都是使用 slice() 來淺拷貝陣列。\n用法二：從陣列前端、末端取 N 個元素使用\n1 2 3 4 5 6 7  const arr = [0, 1, 2, 3, 4, 5]; const first4 = arr.slice(0, 4); console.log( first4 ); // [0, 1, 2, 3]  const last4 = arr.slice(-4); console.log( last4 ); // [2, 3, 4, 5]   用法三：獲取陣列中的某段長度的子陣列\n1 2 3 4 5 6 7  const arr = [0, 1, 2, 3, 4, 5]; function pullSegment(arr, begin, len) { return arr.slice(begin, begin + len); } console.log( pullSegment(arr, 2, 3) ); // [2, 3, 4]   用法四：縮短陣列長度\n1 2 3 4  let arr = [0, 1, 2, 3, 4, 5]; arr = arr.slice(0, 3); console.log( arr ); // [0, 1, 2]   2. String.prototype.slice() 字串的 slice() 會回傳一個指定索引範圍字元的新字串（不改變原字串）。\n1  str.slice(beginIndex[, endIndex])   用法基本上與陣列的 slice() 差不多，直接看範例。\n2.1 範例 1 2 3 4 5 6  const str = \u0026#39;Hello world!\u0026#39;; console.log( str.slice() ); // \u0026#39;Hello world!\u0026#39; console.log( str.slice(2) ); // \u0026#39;llo world!\u0026#39; console.log( str.slice(2, 4) ); // \u0026#39;ll\u0026#39; console.log( str.slice(-2) ); // \u0026#39;d!\u0026#39;   2.1 類似方法 類似的方法還有 substring()、substr() 但 substr() 它不屬於 JavaScript 核心規範，所以如果是非瀏覽器的環境可能無法使用，所以盡可能避免使用。而 substring() 因為第二個參數小於第一個參數時，會自動換位，而且不支援負數，沒有 slice() 來的彈性。\nSplice 拼接 Array.prototype.splice() 藉由刪除既有元素或加入新元素來改變一個陣列的內容，並回傳一個包含被刪除的元素陣列。\n1  array.splice(start[, deleteCount[, item1[, item2[, ...]]]])    start：要插入或刪除的索引位置；  可以使用負數索引，從末項開始倒數 若大於 arr.length 則會被設為 0   deleteCount：要刪除的元素數量；  若省略或大於 arr.length，start 後的元素都會被刪除（包含 start）   item1, item2, ...：要插入的元素內容。  1. 範例 從指定索引位置開始，刪除所有元素（含指定索引）：\n1 2 3 4 5  const arr = [0, 1, 2, 3, 4, 5]; const removed = arr.splice(2); console.log(arr); // [0, 1] console.log(removed); // [2, 3, 4, 5]   從指定索引位置開始，刪除指定數量的元素：\n1 2 3 4 5  const arr = [0, 1, 2, 3, 4, 5]; const removed = arr.splice(2, 2); console.log(arr); // [0, 1, 4, 5] console.log(removed); // [2, 3]   從指定索引位置開始，刪除指定數量的元素，並插入元素：\n1 2 3 4 5  const arr = [0, 1, 2, 3, 4, 5]; const removed = arr.splice(2, 3, \u0026#39;aa\u0026#39;); console.log(arr); // [ 0, 1, \u0026#39;aa\u0026#39;, 5 ] console.log(removed); // [2, 3, 4]   2. 常見用法 移除陣列指定元素：\n1 2 3 4 5 6 7 8  function removeElement(arr, index) { arr.splice(index, 1); return arr; } const arr = [0, 1, 2, 3, 4, 5]; removeElement(arr, 2); console.log(arr); // [0, 1, 3, 4, 5]   split 分割 String.prototype.split() 方法會依照指定規則分割字串，並回傳一個陣列，內容為拆分的字串。\n1  str.split([separator[, limit]])    separator：字串或正則表達式，從符合的字元位置分割，若為空字串，則分割每個字元； limit：回傳的分割元素數量。  1. 範例 1 2 3 4 5 6 7 8 9  const monthString = \u0026#39;Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec\u0026#39;; console.log( monthString.split(\u0026#39;,\u0026#39;) ); // [ \u0026#39;Jan\u0026#39;, \u0026#39;Feb\u0026#39;, \u0026#39;Mar\u0026#39;, \u0026#39;Apr\u0026#39;, \u0026#39;May\u0026#39;, \u0026#39;Jun\u0026#39;, \u0026#39;Jul\u0026#39;, \u0026#39;Aug\u0026#39;, \u0026#39;Sep\u0026#39;, \u0026#39;Oct\u0026#39;, \u0026#39;Nov\u0026#39;, \u0026#39;Dec\u0026#39; ]  const num = \u0026#39;00000000\u0026#39;; console.log( num.split(\u0026#39;\u0026#39;, 2) ); // [ \u0026#39;0\u0026#39;, \u0026#39;0\u0026#39; ]   ","description":"處理陣列或字串常見的方法。","id":17,"section":"posts","tags":["JavaScript","陣列 Array","字串 String"],"title":"Slice、Splice、Split 的區別","uri":"https://chupai.github.io/posts/2007/js_slice_splice_split/"},{"content":"這週是六角鼠年鐵人賽第二十六週。\n最後我們來看紅黑樹刪除操作，相較於新增操作複雜。\n 紅黑樹（上）：B 樹、2-3-4 樹 紅黑樹（中）：新增操作 紅黑樹（下）：刪除操作  \r紅黑樹的刪除操作 在 紅黑樹 中，刪除一個節點，跟普通二元搜尋樹一樣有以下三種情況：\n 葉子節點（無子樹）。 節點有單邊子樹。 節點有左右兩邊子樹。  情況 3，的處理方式與普通二元搜尋樹相同，會從右子樹尋找最小值代替，將問題變成刪除替代節點（不是情況 1、就是情況 2）。\n但紅黑樹有兩種顏色的節點，因此還需要考慮節點顏色的不同，不過刪除操作後，需要平衡修正的，基本上只有刪除黑色的葉子節點。\n注意，這裡指的葉子節點是沒有子節點的節點，而不是紅黑樹定義的 NIL。\r 1. 節點有單邊子樹 因為有兩種顏色，所以節點有單邊子樹組合可能有 4 種，但實際存在的只有 1 種：\n 紅紅：不符合性質 4，不存在； 紅黑：不符合性質 4，不存在； 黑黑：不符合性質 5，不存在； 黑紅：存在。  性質 4、5：\n 性質 4：每個紅色節點必須有兩個黑色的子節點（不能有兩個連續的紅色節點）； 性質 5：從任一節點到其每個 NIL 的所有簡單路徑都包含相同數目的黑色節點。  黑紅組合，直接刪除黑色節點後，會由紅色節點遞補，不影響平衡。\ngraph TB; N --\u0026gt; A; A((D)) --- B((DL)) \u0026amp; n1; N1 --\u0026gt; AAA((DL)); class A,AA,AAA black; class B,BB red; class N,N1,n1,n2 transparent; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; graph TB; N --\u0026gt; AA; AA((D)) --- n2 \u0026amp; BB((DR)); N1 --\u0026gt; AAA((DR)); class A,AA,AAA black; class B,BB red; class N,N1,n1,n2 transparent; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 2. 刪除紅色葉子節點 刪除紅色葉子節點，也不會影響紅黑樹的特性，因此直接刪除即可，不需要修正。\ngraph TB; N --\u0026gt; A; A((P)) --- B((D)) \u0026amp; n1; N1 --\u0026gt; AAA((P)); class A,AA,AAA black; class B,BB red; class N,N1,n1,n2 transparent; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; graph TB; N --\u0026gt; AA; AA((P)) --- n2 \u0026amp; BB((D)); N1 --\u0026gt; AAA((P)); class A,AA,AAA black; class B,BB red; class N,N1,n1,n2 transparent; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; graph TB; N --\u0026gt; AA; AA((P)) --- BB((D)) \u0026amp; CC((B)); N1 --\u0026gt; A((P)); A((P)) --- n1 \u0026amp; B((B)); class AA black; class BB,CC red; class A,AA,AAA black; class B,BB red; class N,N1,n1,n2 transparent; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; graph TB; N --\u0026gt; AA; AA((P)) --- BB((B)) \u0026amp; CC((D)); N1 --\u0026gt; A((P)); A((P)) --- B((B)) \u0026amp; n1; class AA black; class BB,CC red; class A,AA,AAA black; class B,BB red; class N,N1,n1,n2 transparent; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 3. 刪除黑色葉子節點 遇到此情況最麻煩，因為可能會破壞紅黑樹性質 4，因此必須修正它。\n不需要修正的情況：\n 如果黑色葉子節點是根節點，直接刪除即可，不用修正。  修正的方法其實就是重新調整左、右子樹的黑色節點數量，讓他們保持相同，不違反性質 4，因此要判斷兄弟節點的狀態。\n需要修正的情況組合：\n 黑兄無侄紅父 紅兄（黑侄黑父） 黑兄紅侄 黑兄黑父  3.1 黑兄黑姪紅父  兄弟節點 B：黑色 姪子節點（兄弟子節點）：無 父節點 P：紅色  graph TB; N --\u0026gt; P; P((P)) --- D[D] \u0026amp; B((B)); class P red; class B black; class N transparent; class D del; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; 修正處理：P 設為黑色、B 設為紅色。\ngraph TB; N --\u0026gt; P; P((P)) --- D[D] \u0026amp; B((B)); class P white; class P black; class B red; class N,n1 transparent; class D del; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; 用 2-3-4 樹表示：\ngraph TB; A[P ? _] --- B[D] \u0026amp; C[B] \u0026amp; D[?]; AA[?] --- BB[P B] \u0026amp; CC[?]; class B del; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; 如果是鏡像情況，相同的修正處理方式。\n3.2 紅兄（黑侄黑父）  兄弟節點 B：紅色 姪子節點（兄弟子節點）Ｌ、Ｒ：一定有姪子節點，且為黑色 父節點 P：一定是黑色  graph TB; N --\u0026gt; P; P((P)) --- D[D] \u0026amp; B((B)); B((B)) --- L((L)) \u0026amp; R((R)); class P,L,R black; class B red; class N transparent; class D del; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 修正處理：對 P 進行左旋轉，並將 P 設為紅色，B 設為黑色。\ngraph TB; N --\u0026gt; B; B((B)) --- P((P)) \u0026amp; R((R)); P((P)) --- D[D] \u0026amp; L((L)); class B,L,R black; class P red; class N transparent; class D del; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 子樹 P 就變成情況一，執行相同修正處理：\ngraph TB; N --\u0026gt; B; B((B)) --- P((P)) \u0026amp; R((R)); P((P)) --- D[D] \u0026amp; L((L)); class B,P,R black; class L red; class N transparent; class D del; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 用 2-3-4 樹表示：\ngraph TB; A[_ P B] --- B[D] \u0026amp; C[L] \u0026amp; D[R]; A2[P B _] --- B2[D] \u0026amp; C2[L] \u0026amp; D2[R]; A3[B _] --- B3[P L] \u0026amp; C3[R]; class B,B2 del; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; 如果是鏡像情況，改對 P 進行右旋轉。\n3.3 黑兄紅侄  兄弟節點 B：黑色 父節點 P：黑色或紅色 姪子節點（兄弟子節點）Ｌ、Ｒ：紅色，共三種狀態：  L、R 都存在 只有 R 只有 L    基本狀態，L、R 都存在：\ngraph TB; N --\u0026gt; P; P((P)) --- D[D] \u0026amp; B((B)); B((B)) --- L((L)) \u0026amp; R((R)); class P white; class D,B black; class L,R red; class N transparent; classDef white fill:white,stroke:black; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 修正處理：對 P 執行左旋轉，並將 P 設為黑色、B 設為 P 的顏色、R 設為黑色。\ngraph TB; N --\u0026gt; B; B((B)) --- P((P)) \u0026amp; R((R)); P((P)) --- n1 \u0026amp; L((L)); class B white; class P,R black; class L red; class N,n1 transparent; classDef white fill:white,stroke:black; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 若只有 R、沒有 L，可執行相同修正處理：\ngraph TB; N --\u0026gt; P; P((P)) --- D[D] \u0026amp; B((B)); B((B)) --- n1 \u0026amp; R((R)); class P white; class D,B black; class L,R red; class N,n1 transparent; N1 --\u0026gt; B1; B1((B)) --- P1((P)) \u0026amp; R1((R)); class B1 white; class P1,R1 black; class L1 red; class N1,n11 transparent; classDef white fill:white,stroke:black; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 若只有 L，沒有 R，需先對 B 執行右旋轉，並將 L 設為黑色、B設為紅色，就會變上面的情況，再執行上面的修正處理：\ngraph TB; N --\u0026gt; P; P((P)) --- D[D] \u0026amp; B((B)); B((B)) --- L((L)) \u0026amp; n1; class P white; class D,B black; class L,R red; class N,n1 transparent; N2 --\u0026gt; P2; P2((P)) --- D2[D] \u0026amp; L2((L)); L2((L)) --- n2 \u0026amp; B2((B)); class P2 white; class D2,L2 black; class B2 red; class N2,n2 transparent; classDef white fill:white,stroke:black; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 用 2-3-4 樹表示：\ngraph TB; A[P] --- B[D] \u0026amp; C[_ B R]; A3[B] --- B3[P] \u0026amp; C3[R]; class B,B2 del; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; 如果是鏡像情況，左旋轉改右旋轉、右旋轉改左旋轉，修正邏輯相同。\n3.4 黑兄黑父  兄弟節點 B：黑色 父節點 P：紅色 姪子節點（兄弟子節點）：無或是黑色節點  graph TB; N --\u0026gt; P; P((P)) --- D[D] \u0026amp; B((B)); class P,B black; class N transparent; class D del; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; 首先，B 設為紅色：\ngraph TB; N --\u0026gt; P; P((P)) --- D[D] \u0026amp; B((B)); class P white; class P black; class B red; class N,n1 transparent; class D del; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; 樹依然是不平衡，因此將 P 設為當前節點，再次執行平衡操作。\n用 2-3-4 樹表示：\ngraph TB; N --\u0026gt; A; A[P] --- B[D] \u0026amp; C[B]; N1 --\u0026gt; A1; A1[null] --- B1[P B]; class N,N1 transparent; class B,B2 del; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; classDef transparent fill:transparent,stroke:transparent,color:transparent; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; JavaScript 實作紅黑樹刪除操作 1. 刪除操作 因為紅黑樹的節點是雙向的，我們可以直接用尋找方法取得節點，並更改父節點的指向。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  remove(data, node = this.root) { const delNode = this.search(data, node); if (!delNode) { return false; } // 葉子節點  if (!delNode.left \u0026amp;\u0026amp; !delNode.right) { // 紅色  if (this.isRed(delNode)) { this.replaceParent(delNode, null); // 黑色  } else { this.deleteFixup(delNode); this.replaceParent(delNode, null); } // 單邊子樹  } else if (!delNode.left || !delNode.right) { // 單邊左子樹  if (delNode.left) { delNode.left.color = NodeColor.BLACK; delNode.left.parent = delNode.parent; this.replaceParent(delNode, delNode.left); // 單邊右子樹  } else { delNode.right.color = NodeColor.BLACK; delNode.right.parent = delNode.parent; this.replaceParent(delNode, delNode.right); } } else { const aux = this.findMin(delNode.right); delNode.data = aux.data; this.remove(aux.data, delNode.right); } return this.root; }   我們說明時，是刪除後修正，但實作時，先刪除就沒辦法傳入節點判斷了，因此這裡改成先判斷刪除後是否會影響平衡，若會影響平衡先調整在刪除。\n1.1 輔助方法 尋找節點、尋找最小值，在一般的二元搜尋樹都有說明過：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  search(data, node = this.root) { if (!node) { return false; } if (data === node.data) { return node; } if (data \u0026lt; node.data) { return this.search(data, node.left); } return this.search(data, node.right); } findMin(node = this.root) { let currentNode = node; while (currentNode \u0026amp;\u0026amp; currentNode.left) { currentNode = currentNode.left; } return currentNode; }   替換父節點的指向，在新增節點操作說明過：\n1 2 3 4 5 6 7 8 9 10  replaceParent(curNode, newNode) { const parent = curNode.parent; if (!parent) { this.root = newNode; } else if (parent.left === curNode) { parent.left = newNode; } else { parent.right = newNode; } }   2. 刪除操作平衡修正 節點代號，方便說明：\n 當前節點：N 父親節點：P 祖父節點：G 兄弟節點：B 姪子節點：L、R  檢查是否需要修正，修正條件「非根節點且為黑色」：\n 若 N 為 P 的左子節點，B 為 P 的右子節點：  若 B 是紅色，對 P 左旋轉，重新執行修正檢查。否則： 若 L 和 R 皆為黑色（包含 NIL）：  若 P 是紅色，將 P 設為黑色、右子節點設為紅色，結束修正。否則： 將 B 設為紅色，並將 N 設為 P，重新執行修正檢查。   若 L 是紅色且 R 不存在，對 B 執行右旋轉，並重新執行執行操作。否則： 對 P 轉左旋轉，並將 P、R 設為黑色，結束修正。   若 N 為 P 的右子節點，B 為 P 的左子節點：  若 B 是紅色，對 P 左旋轉，重新執行修正檢查。否則： 若 L 和 R 皆為黑色（包含 NIL）：  若 P 是紅色，將 P 設為黑色、左子節點設為紅色，結束修正。否則： 將 B 設為紅色，並將 N 設為 P，重新執行修正檢查。   若 L 是紅色且 R 不存在，對 B 執行左旋轉，並重新執行執行操作。否則： 對 P 轉右旋轉，並將 P、L 設為黑色，結束修正。    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  deleteFixup(node) { let currNode = node; while (currNode !== this.root \u0026amp;\u0026amp; !this.isRed(currNode)) { const { parent } = currNode; let bother; if (currNode === parent.left) { bother = parent.right; if (this.isRed(bother)) { this.leftRotation(parent); } if (!this.isRed(bother.left) \u0026amp;\u0026amp; !this.isRed(bother.right)) { if (this.isRed(parent)) { parent.color = NodeColor.BLACK; parent.right.color = NodeColor.RED; break; } bother.color = NodeColor.RED; currNode = parent; } else if (this.isRed(bother.left) \u0026amp;\u0026amp; !this.isRed(bother.right)) { this.rightRotation(bother); } else { this.leftRotation(parent); parent.color = NodeColor.BLACK; bother.right.color = NodeColor.BLACK; break; } } else { bother = parent.left; if (this.isRed(bother)) { this.rightRotation(parent); } if (!this.isRed(bother.left) \u0026amp;\u0026amp; !this.isRed(bother.right)) { if (this.isRed(parent)) { parent.color = NodeColor.BLACK; parent.left.color = NodeColor.RED; break; } bother.color = NodeColor.RED; currNode = parent; } else if (this.isRed(bother.right) \u0026amp;\u0026amp; !this.isRed(bother.left)) { this.leftRotation(bother); } else { this.rightRotation(parent); parent.color = NodeColor.BLACK; bother.left.color = NodeColor.BLACK; break; } } } }   紅黑樹總結 1. 紅黑樹和 AVL-Tree 比較 紅黑樹和 AVL-Tree 一樣是自平衡二元搜尋樹，都可以在 $O(\\log n)$ 時間內完成尋找、新增和刪除操作。\nAVL-Tree，屬於嚴格平衡樹，透過計算 BF，讓任意子節點的左右子樹高度相差不超過 1。\n而紅黑樹，透過增加節點顏色，來維持定義的特性，相對於 AVL-Tree 來說，犧牲了部分平衡性（多一層），換取平衡修正操作時的少量旋轉操作，整體來說效能要優於 AVL-Tree。\n 對於新增操作，AVL-Tree 和 紅黑樹 最多只需要執行 2 次旋轉操作，即平衡修正為 $O(1)$ 的時間複雜度 但刪除操作，AVL-Tree 需要維護被刪節點到根節點路徑上所有節點的平衡性，因此平衡修正時間複雜度需要 $O(\\log n)$。而紅黑樹的刪除操作，最多只需要三次旋轉，即平衡修正為 $O(1)$ 的時間複雜度。 查詢操作則是 紅黑樹 略遜於 AVL-Tree，因為它會比 AVL-Tree 多一層。  2. 視覺化 這是我用 Vue.js 製作的，可以很的方便觀察黑紅樹的結構變化：\nSee the Pen Red - Black Tree with Vue.js by Chupai@Design (@chupai) on CodePen. ","description":"最後我們來看紅黑樹刪除操作，相較於新增操作複雜。","id":18,"section":"posts","tags":["資料結構","二元搜尋樹","二元樹","紅黑樹","平衡樹","2-3 樹","2-3-4 樹","w3HexSchool"],"title":"JavaScript 學演算法（十八）- 紅黑樹（下）：刪除操作","uri":"https://chupai.github.io/posts/2007/ds_redblack-tree-3/"},{"content":"這週是六角鼠年鐵人賽第二十五週。\n上週我們簡單說明了紅黑樹的基本性質與理解 B 樹、2-3-4 樹，接下來，我們來看紅黑樹和 2-3-4 樹的等價關係與新增操作。\n 紅黑樹（上）：B 樹、2-3-4 樹 紅黑樹（中）：新增操作 紅黑樹（下）：刪除操作  \r紅黑樹和 2-3-4 樹的等價關係 2-3-4 樹在多數程式語言中實現起來相對困難，因為在樹上的操作涉及大量的特殊情況。而 紅黑樹 是基於它的理論基礎所發明的，實現起來更簡單一些。\n因此 紅黑樹本質上就是 2-3-4 樹，所有性質都可以從 2-3-4樹 來理解。\n1. 黑色節點 黑色節點，其實就是 2-3-4 樹的 2-節點，為一個中位數。。\ngraph TB; N[_ 40 _]; A((40)) --- n1 \u0026amp; n2; class A black; class n1,n2 transparent; classDef black fill:black,stroke:black,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 2. 紅色節點 黑色節點的子樹如果是紅色節點，表示彼此融合的意思，其實就是 2-3-4 樹的 3-節點、4-節點。\n3-節點：\ngraph TB; N[30 40 _]; A((40)) --- B((30)) \u0026amp; n1; N2[_ 40 50 ]; AA((40)) --- n2 \u0026amp; BB((50)); class A,AA black; class B,BB red; class n1,n2 transparent; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 4-節點：\ngraph TB; N[30 40 50]; A((40)) --- B((30)) \u0026amp; C((50)); class A black; class B,C red; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; 3. 2-3 樹 部分資料會說紅黑樹等價於 2-3 樹（3 階 B 樹），但正確來說，是「左傾紅黑樹」，屬於紅黑樹的變種，這裡不討論。\n紅黑樹的新增操作 紅黑樹新增節點後，會檢查樹使否平衡（是否違反紅黑樹性質），若不平衡，會透過「旋轉」和「變色」操作來修正。\n1. 保持根節點是黑色的 在 2-3-4 樹插入元素時，都是融合到節點中，因此在紅黑樹中，新增的節點一定的紅色的。\n首先，我們再一個空樹中新增一個節點：\ngraph TB; A((N)); classDef red fill:red,stroke:red,color:white; A:::red; 但紅黑樹的性質2：「樹的根節點為黑色」，因此需要將它修正成黑色的：\ngraph TB; A((N)); classDef black fill:black,stroke:black,color:white; A:::black; 2. 2-節點 一個黑色節點無任何子節點，表示它是一個 2-節點。\n那麼當我們新增節點，它會變成一個 3-節點，因此不需要做任何修正：\ngraph TB; A((P)) --- B((N)) \u0026amp; n1; AA((P)) --- n2 \u0026amp; BB((N)); class A,AA black; class B,BB red; class n1,n2 transparent; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 3. 3-節點 當我們對一個 3-節點新增節點，它會變成 4-節點，這時紅黑樹可能會違反性質4：「每個紅色節點必須有兩個黑色的子節點（不能有兩個連續的紅色節點）」，因此必須修正它。\n舉例來說，黑紅樹表示的 3-節在 2-3-4樹可能長這樣：\ngraph TB; N[30 40 _]; 但如果要再插入 20，左邊沒位置。因此要將 30 變成中位數：\ngraph TB; N[_ 30 40 ]; 這樣就能插入 20 了：\ngraph TB; N[20 30 40]; 接下來，我們來看需要修正的情況，首先來定義節點代號，方便說明：\n 祖父節點：G 父親節點：P 新增的節點：N  需要修正情況一：\ngraph TB; A((G)) --- B((P)) \u0026amp; n; B((P)) --- C((N)) \u0026amp; n1; class A black; class B,C red; class n,n1 transparent; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 需要對 G 執行右旋轉，並將 G 設為紅色、P 設為黑色：\ngraph TB; A((P)) --- B((N)) \u0026amp; C((G)); class A black; class B,C red; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; 如果你對旋轉操作不熟悉的話，可以先參考我的上一篇文章：AVL-Tree。\n需要修正情況二：\ngraph TB; A((G)) --- B((P)) \u0026amp; n; B((P)) --- n1 \u0026amp; C((N)); AA((G)) --- BB((N)) \u0026amp; nn; BB((N)) --- CC((P)) \u0026amp; nn1; class A,AA black; class B,C,BB,CC red; class n,n1,nn,nn1 transparent; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 需要先對 P 進行左旋轉，這樣就變成情況一了，再執行相同處理。\n情況三、四，基本上就是鏡像情況，先對 P 右旋轉：\ngraph TB; A((G)) --- n \u0026amp; B((P)); B((P)) --- C((N)) \u0026amp; n1; A1((G)) --- n11 \u0026amp; B1((N)); B1((N)) --- n111 \u0026amp; C1((P)); class A black; class B,C red; class n,n1 transparent; class A1 black; class B1,C1 red; class n11,n111 transparent; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 再對 G 左旋轉，並將 G 設為紅色、N 設為黑色：\ngraph TB; AA((N)) --- BB((G)) \u0026amp; CC((P)); class AA black; class BB,CC red; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; 4. 4-節點 如果對一個 4-節點新增節點，也就是會形成一個 5-節點，這時紅黑樹一樣會違反性質4。\ngraph TB; n --\u0026gt; A; A((A)) --- B((B)) \u0026amp; C((C)); B((B)) --- N((N)); class A black; class B,C red; class N red2; class n transparent; classDef black fill:black,stroke:black,color:black; classDef red fill:red,stroke:red,color:red; classDef red2 fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 我們會將整棵子樹執行「顏色翻轉 color flip」操作：\ngraph TB; n --\u0026gt; A; A((A)) --- B((B)) \u0026amp; C((C)); B((B)) --- N((N)); class A red; class B,C black; class N red2; class n transparent; classDef black fill:black,stroke:black,color:black; classDef red fill:red,stroke:red,color:red; classDef red2 fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 顏色翻轉，其實就是 2-3-4 樹中的拆分與向上融合。\n當執行完顏色翻轉後，需要重新檢查黑紅樹是否違反性質。\nJavaScript 實作紅黑樹新增操作 1. 本體 顏色：\n1 2 3 4  const NodeColor = { RED: true, BLACK: false, };   我們使用布林值來定義紅色與黑色。\n節點：\n1 2 3 4 5 6 7 8 9  class RBTNode { constructor(data, parent = null) { this.data = data; this.parent = parent; this.left = null; this.right = null; this.color = NodeColor.RED; } }    data：儲存資料 parent：父節點 left：左子節點 right：右子節點 color：節點顏色（新增節點一定是紅色的，所以預設紅色）  紅黑樹的節點比普通的二元搜尋樹多了顏色和紀錄父節點屬性，也就是說，它是一個雙向鏈結。\n根：\n1 2 3 4 5 6  class RedBlackTree { constructor() { this.root = null; } // methods }   2. 旋轉操作 紅黑樹因為多了顏色和父節點，因此旋轉操作還需要更新顏色、父節點。\n2.1 右旋轉 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  rightRotation(node) { const temp = node.left; node.left = temp.right; temp.right = node; // 更新顏色  temp.color = node.color; node.color = NodeColor.RED; // 更新父節點  this.replaceParent(node, temp); temp.parent = node.parent; node.parent = temp; if (node.left) { node.left.parent = node; } }   2.2 左旋轉 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  leftRotation(node) { const temp = node.right; node.right = temp.left; temp.left = node; temp.color = node.color; node.color = NodeColor.RED; this.replaceParent(node, temp); temp.parent = node.parent; node.parent = temp; if (node.right) { node.right.parent = node; } }   2.3 輔助方法 替換父節點的指向：\n1 2 3 4 5 6 7 8 9 10  replaceParent(curNode, newNode) { const { parent } = curNode; if (!parent) { this.root = newNode; } else if (curNode === parent.left) { parent.left = newNode; } else { parent.right = newNode; } }    如果父節點不存在，更新樹的根節點； 如果是左子樹，更新左子樹； 若不是，則更新右子樹。  3. 新增操作 基本上與普通二元搜尋樹相同，只是多了父節點的指向與檢查是否平衡。\n歸迴版本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  insert(data) { const insertHelper = (node) =\u0026gt; { const curNode = node; if (data \u0026lt; curNode.data) { if (curNode.left) { insertHelper(curNode.left); } else { curNode.left = new RBTNode(data); curNode.left.parent = curNode; this.insertFixRBT(curNode.left); } } else if (data \u0026gt; curNode.data) { if (curNode.right) { insertHelper(curNode.right); } else { curNode.right = new RBTNode(data); curNode.right.parent = curNode; this.insertFixRBT(curNode.right); } } }; if (!this.root) { this.root = new RBTNode(data); this.insertFixRBT(this.root); } else { insertHelper(this.root); } }   迭代版本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  insert(data) { if (!this.root) { this.root = new RBTNode(data); this.insertFixup(this.root); return this.root; } let curNode = this.root; while (curNode) { if (data \u0026lt; curNode.data) { if (curNode.left) { curNode = curNode.left; } else { curNode.left = new RBTNode(data, curNode); this.insertFixup(curNode.left); break; } } else if (data \u0026gt; curNode.data) { if (curNode.right) { curNode = curNode.right; } else { curNode.right = new Node(data, curNode); this.insertFixup(curNode.right); break; } } } return this.root; }   4. 新增操作平衡修正 新增節點後，檢查紅黑樹是否符合特性，並修正它。\n節點代號，方便說明：\n 當前節點：N 父親節點：P 祖父節點：G 叔叔節點：U  檢查是否需要修正，修正條件「P 是紅色且 G 存在」：\n 若 P 為 G 的左子節點：  判斷 U 是否為紅色節點，若是，則執行顏色翻轉。 若不存在，判斷 N 是否為 P 的右子節點：  如果是右子節點，先對 P 執行左旋轉；   對 G 執行右旋轉。   若 P 為 G 的右子節點：  判斷 U 是否為紅色節點，若是，則執行顏色翻轉。 若不存在，判斷 N 是否為 P 的左子節點：  如果是左子節點，先對 P 執行右旋轉；   對 G 執行左旋轉。   以上修正結束，將目前節點設為祖父節點，再次檢查是否需要修正。  修正結束後，記得將根結點設為黑色。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  insertFixup(node) { let curNode = node; while (this.isRed(curNode.parent) \u0026amp;\u0026amp; curNode.parent.parent) { const { parent } = curNode; const grandparent = parent.parent; if (parent === grandparent.left) { if (this.isRed(grandparent.right)) { this.flipColor(grandparent); } else { if (curNode === parent.right) { this.leftRotation(parent); } this.rightRotation(grandparent); } } else { if (this.isRed(grandparent.left)) { this.flipColor(grandparent); curNode = grandparent; } else { if (curNode === parent.left) { this.rightRotation(parent); } this.leftRotation(grandparent); } } curNode = grandparent; } this.root.color = NodeColor.BLACK; }   4.1 輔助方法 判斷節點顏色：\n1 2 3  isRed(node) { return node ? node.color : false; }   顏色翻轉：\n1 2 3 4 5  flipColor(node) { node.color = NodeColor.RED; node.left.color = NodeColor.BLACK; node.right.color = NodeColor.BLACK; }   總結 這是我用 Vue.js 製作的，可以很的方便觀察黑紅樹的結構變化：\nSee the Pen Red - Black Tree - insert with Vue.js by Chupai@Design (@chupai) on CodePen.  下週來說明更麻煩的刪除操作。\n","description":"紅黑樹和 2-3-4 樹的等價關係與新增操作。","id":19,"section":"posts","tags":["資料結構","二元搜尋樹","二元樹","紅黑樹","平衡樹","2-3 樹","2-3-4 樹","w3HexSchool"],"title":"JavaScript 學演算法（十七）- 紅黑樹（中）：新增操作","uri":"https://chupai.github.io/posts/2007/ds_redblack-tree-2/"},{"content":"這週是六角鼠年鐵人賽第二十四週。\n紅黑樹和 AVL-Tree 一樣是自平衡二元搜尋樹，因為比較難理解、篇幅較長，所以分成三個階段來說明：\n 紅黑樹（上）：B 樹、2-3-4 樹 紅黑樹（中）：新增操作 紅黑樹（下）：刪除操作  \r紅黑樹簡介 紅黑樹（Red–black tree） 是一種自平衡二元搜尋樹，它是由 Rudolf Bayer 於 1972年發明，當時稱為 對稱二元 B 樹（Symmetric binary B-trees）。後來因為 Leo J. Guibas 和 Robert Sedgewick 於 1978年寫的一篇論文改名成現今的名稱。\n紅黑樹和 AVL-Tree 一樣是自平衡二元搜尋樹，都可以在 $O(\\log n)$ 時間內完成尋找、新增和刪除操作。但 紅黑樹相對於 AVL-Tree 來說，犧牲了部分平衡性以換取新增、刪除操作時少量的旋轉操作，整體來說效能要優於 AVL-Tree。\n1. 性質 首先我們來看定義紅黑樹規則的五點性質：\n 任何一個節點非紅即黑； 樹的根節點為黑色； 葉子節點為黑色（NIL）； 每個紅色節點必須有兩個黑色的子節點（不能有兩個連續的紅色節點）； 從任一節點到其每個 NIL 的所有簡單路徑都包含相同數目的黑色節點。  在紅黑樹定義中，葉子節點並不是沒有子節點的節點，而是指最後的 空值（NULL）節點，稱作「NIL」。\n但我為了之後方便說明，我們葉子節點，統一指「沒有子節點的節點」，空值（NULL）節點，稱作「NIL」。\n graph TB; A((13)) --- B((8)) \u0026amp; C((17)); B((8)) --- D((1)) \u0026amp; E((11)); C((17)) --- F((15)) \u0026amp; G((25)); D((1)) --- N1[NIL] \u0026amp; I((6)); E((11)) --- N10[NIL] \u0026amp; N11[NIL]; F((15)) --- N2[NIL] \u0026amp; N3[NIL]; G((25)) --- K((22)) \u0026amp; L((27)); I((6)) --- N4[NIL] \u0026amp; N5[NIL]; K((22)) --- N6[NIL] \u0026amp; N7[NIL]; L((27)) --- N8[NIL] \u0026amp; N9[NIL]; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; class A,D,E,F,G,N1,N2,N3,N4,N5,N6,N7,N8,N9,N10,N11 black; class B,C,I,K,L red; 2. 說明紅黑樹前 紅黑樹如果直接依照性質來說明它的操作，會非常抽象難理解。\n因此再說明紅黑樹之前，必須先理解什麼是 B 樹、2-3-4 樹，對於理解紅黑樹有很大的幫助。因為紅黑樹是 2-3-4 樹的一種實現方式\nB 樹 B 樹（B-tree） 是一種自平衡的樹，B 是 Balance 平衡的意思，也是由普通的二元搜尋樹變換而來的，但最大的不同就是，它的節點可以擁有 2 個以上的子節點，也就說它已經不是二元樹了。\n1. 定義 一個 m 階的 B 樹 具有以下性質：\n 每一個節點最多有 m 個子節點； 每一個非葉子節點（根節點除外），最少有 ceil(m / 2) 個子節點； 若根節點非葉子節點時，它至少有 2 個子節點； 有 k 個子節點的非葉子節點擁有，擁有 k − 1 個 鍵 key（元素）； 所有的葉子節點都在同一層。  2. 絕對平衡 定義第 5 點：所有的葉子節點都在同一層，所以 B 樹是一顆絕對平衡的樹。\n絕對平衡，指的是對於任意一個節點，左右子樹高度相同。也就是說，節點不是沒子節點，就是子節點全滿。\n3. 插入操作 要插入一個新的元素，一定是在葉子結點中進行，並判斷當前節點的 key 數量是否小於最大值 m - 1：\n 若小於，表示當前節點有空間可以容納新元素，直接插入到這個節點中，並保持節點中的元素有序。 若節點已滿，將它拆分成一棵二元樹：  從該節點的原有元素和新元素選出中位數； 小於中位數的元素放入左邊節點，大於中位數的元素放入右邊節點，中位數作為分隔值； 最後，分隔值會被插入到父節點中，但可能會遇到以下情況：  若沒有父節點，創建一個新的根結點（增加了樹的高度）； 若父節點已滿，需要重複上述操作。      經過以上判斷，插入元素後，B 樹依然能保持絕對平衡。\n選出中位數可能會遇到插入新元素後，變成奇數的情況，無法整除，作法有很多種：\n 無條捨去或進位。 或是先選出中位數，才插入新元素。  4. 刪除操作 B 樹的刪除操作相對於插入操作是相對複雜一些。\n共有兩種策略：\n 定位並刪除元素，然後調整樹使它絕對平衡； 或是，從上到下處理這棵樹，在進入一個節點之前，調整樹使得之後一旦遇到了要刪除的 key，它可以被直接刪除而不需要再進行調整。  簡單來說，就是先刪除後調整，或者是先調整再刪除。\n以下使用前者來說明。\nB 樹 刪除一個元素時有以下兩種特殊情況：\n 這個元素位於葉子節點中，且是唯一的元素。 這個元素位於內部節點中。  下面分別是這些情況的處理過程。\n4.1 刪除葉子節點中的元素  搜尋要刪除的元素； 如果它在葉子節點，將它從中刪除； 若該元素是只唯一的元素，刪除後節點會不見，會導致父節點的子節點數量不符合性質 4，因此需要執行平衡修正。  4.2 刪除內部節點中的元素 內部節點（非葉子節點）中的每一個元素都是作為分隔兩顆子樹的分隔值。因此刪除後，我們可以取一個鄰近元素來作為新的分隔值，並刪除這個用替代的原素。\n取得新的分隔值共兩種方法：\n 從左子樹中，取最大的元素。 或是，從右子樹中，取最小的元素。  這個新的分隔值一定是位於葉子節點中，因此就變成了「刪除葉子節點中的元素」的情況。\n4.3 平衡修正 為了避免父節點的子節點數量不符合性質 4，我們會找一個元素來遞補遞補空缺。\n將缺少元素節點作為當前節點，判斷它的兄弟節點和父節點是否有多餘的元素：\n 如果兄弟節點存在，且有多餘的元素，那麼：  將父節點的分隔值下移，遞補被刪除元素的空缺； 將兄弟節點元素上移，遞補父節點下移分隔值的空缺； 樹重新平衡。   如果左、右弟都只有最小數量的元素，那麼：  將缺少元素節點與兄弟節點合併； 並將父節點的分隔值下移至合併後的節點； 最後檢查父節點：  若父節點依然保持最小數量的元素，樹重新平衡。否則： 父節點為根節點，且沒有元素，那麼刪除它，讓合併之後的節點成為新的根節點。否則： 不是根節點，將父節點作為當前節點，重新執行平衡修正。      若重新值行平衡修正，兄弟節點已經不是葉子節了，因此會有子樹，若父節點的分隔值下移，會繼承它的子樹（左兄繼承右子樹、右兄既成左子樹）。\n5. 實際應用 在實際應用中的 B 樹 的階數 m 都非常大，所以即使存儲大量的資料，B 樹 的高度依然很小。\n舉例來說，若資料量很大時，使用線性搜尋效率相當低，所以基本上會建立索引（index） 來取得資料。但資料量變得非常大時，索引大小也會變得很大，搜尋索引的效率也會降低，這時就可以透過 B 樹這種資料結構，將索引分成很多份（對應樹的節點），也就是分頁，從而增加效率。\nB 樹 主要是用外部儲存的一種資料結構，常被應用在資料庫和文件系統的實現上。\n2-3-4 樹 看完上面一堆說明後，可能會覺得這沙小🤣，我們還是直接來看 2-3-4 樹 吧。\n2-3-4 樹 就是階為 4 的 B 樹。\n 根據 B 樹性質 1，節點最多有 4 個子節點； 根據 B 樹性質 2，非葉子節點至少要有 2 個子節點； 根據 B 樹性質 1、4，每個節點最多擁有 3 個元素。  1. 節點 我們會用節點中存放的元素數量來決定節點的名稱：\n 當存放 1 個元素時，稱作「2-節點」，可擁有 2 個子節點； 當存放 2 個元素時，稱作「3-節點」，可擁有 3 個子節點； 當存放 3 個元素時，稱作「4-節點」，可擁有 4 個子節點。 因為是樹絕對平衡的，所以節點的子節點數量不是零，就是可擁有的最大數量。  這就是為什麼階為 4 的 B 樹叫作 2-3-4 樹。\n2. 插入操作 2.1 向空樹插入元素 首先，對一棵空樹，插入一個元素 70，那麼會產生樹的根節點：\ngraph TB; A[70]; 2.2 向有空間的節點插入元素 再插入一個元素 60 時，不會像二元搜尋樹一樣，插入到空節點中。而是「融合」到節點中，變成一個「3-節點」，並保持節點中的元素有序：\ngraph TB; A[60 70]; 繼續插入一個元素 50，會變成一個「4-節點」：\ngraph TB; A[50 60 70]; 注意，此時節點的空間已滿，已經是最大元素數量。\n2.3 向空間已滿的節點插入元素 如果繼續插入一個元素 40，你會發現，4-節點的可存放元素的空間已滿，因此需要「拆分」成一棵二元樹，再插入元素：\n 將 60 作為分隔值放入父節點中； 左邊節點放小於分隔值的元素； 右邊節點放大於分隔值的元素。  graph TB; A[60] --- B[50] \u0026amp; C[70]; AA[60] --- BB[40 50] \u0026amp; CC[70]; 接著要將這棵子樹插入到父節點中，但因為沒有父節點，所以節點 60 會作為新的根節點（樹高加 1）。\n2.4 父節點空間也已滿 接下來，我來看一個連續 4-節點的例子。\n假如要插入元素 10，會插入紅色框的這個 4-節點中：\ngraph TB; A[50 60 80] --- B[20 30 40] \u0026amp; C[55] \u0026amp; D[70] \u0026amp; E[90 100]; classDef red, fill:black,stroke:black,color:white; classDef red stroke:red; B:::red; 因此我們需要先將它拆分一棵二元樹：\ngraph TB; A[50 60 80] --- B[30] \u0026amp; C[55] \u0026amp; D[70] \u0026amp; E[90 100]; B[30] --- F[20] \u0026amp; G[40]; 將元素 10 插入到拆分後的子樹中：\ngraph TB; A[50 60 80] --- B[30] \u0026amp; C[55] \u0026amp; D[70] \u0026amp; E[90 100]; B[30] --- F[10 20] \u0026amp; G[40]; classDef green stroke:#61bfa6,stroke-width:2px; A:::green; 將子樹融合到父節點之前，需要檢查父節點是否也是 4-節點。\n如果是，一樣將它拆分：\ngraph TB; A[60] --- B[50] \u0026amp; C[80]; B[50] --- D[30] \u0026amp; E[55]; C[80] --- F[70] \u0026amp; G[90]; D[30] --- H[10 20] \u0026amp; I[40]; 接著就可以將之前的子樹向上融合。\n插入完成：\ngraph TB; A[60] --- B[50] \u0026amp; C[80]; B[30 50] --- D[10 20] \u0026amp; E[40] \u0026amp; H[55]; C[80] --- F[70] \u0026amp; G[90]; 3. 刪除操作 接下來看 2-3-4 樹的刪除操作，直接來看範例說明。\n刪除元素 5：\ngraph TB; A[50] --- B[30] \u0026amp; C[90]; B[20 40] --- D[5 10] \u0026amp; E[25 30] \u0026amp; F[45]; C[60 80] --- G[55] \u0026amp; H[70] \u0026amp; I[90]; D:::red; classDef red stroke:red,stroke-width:2px; 元素 5 不是葉節點中的唯一元素，可以直接刪除。\n刪除元素 45：\ngraph TB; A[50] --- B[30] \u0026amp; C[90]; B[20 40] --- D[10] \u0026amp; E[25 30] \u0026amp; F[45]; C[60 80] --- G[55] \u0026amp; H[70] \u0026amp; I[90]; F:::red; classDef red stroke:red,stroke-width:2px; 元素 45 是節點的唯一值，刪除後需要修正。兄弟節點有多餘元素：\n 分隔值 40 下移遞補空缺； 兄弟元素 30 上移，遞補分隔值空缺。  刪除元素 40：\ngraph TB; A[50] --- B[30] \u0026amp; C[90]; B[20 30] --- D[10] \u0026amp; E[25] \u0026amp; F[40]; C[60 80] --- G[55] \u0026amp; H[70] \u0026amp; I[90]; F:::red; classDef red stroke:red,stroke-width:2px; 元素 40 是節點的唯一值，刪除後需要修正它。兄弟節點只有最小數量的元素：\n 將 25 和空節點合併（刪除空節點）； 將分隔值 30 下移至合併後的節點； 父節點依然保持最小數量的元素。  刪除元素 25：\ngraph TB; A[50] --- B[30] \u0026amp; C[90]; B[20] --- D[10] \u0026amp; E[25 30]; C[60 80] --- G[55] \u0026amp; H[70] \u0026amp; I[90]; E:::red; classDef red stroke:red,stroke-width:2px; 元素 25 不是葉節點中的唯一元素，可以直接刪除。\n刪除元素 10：\ngraph TB; A[50] --- B[30] \u0026amp; C[90]; B[20] --- D[10] \u0026amp; E[30]; C[60 80] --- G[55] \u0026amp; H[70] \u0026amp; I[90]; D:::red; classDef red stroke:red,stroke-width:2px; 元素 40 是節點的唯一值，刪除後需要修正它。兄弟節點只有最小數量的元素：\n 將 30 和空節點合併（刪除空節點）； 將分隔值 20 下移至合併後的節點； 父節點無法保持最小數量的元素。  graph TB; A[50] --- B[null] \u0026amp; C[90]; B[null] --- D[20 30]; C[60 80] --- G[55] \u0026amp; H[70] \u0026amp; I[90]; B:::red; classDef red stroke:red,stroke-width:2px; 將空的父節點作為當前節點，重新執行平衡修正。兄弟節點有多餘元素：\n 分隔值 50 下移，並繼承分隔值 60 的左子樹 55； 兄弟元素 60 上移，遞補分隔值空缺。  刪除元素 90：\ngraph TB; A[60 ] --- B[50] \u0026amp; C[80]; B[50] --- D[20 30] \u0026amp; E[55]; C[80] --- H[70] \u0026amp; I[90]; I:::red; classDef red stroke:red,stroke-width:2px; 元素 90 是節點的唯一值，刪除後需要修正它。兄弟節點只有最小數量的元素：\n 將 70 和空節點合併（刪除空節點）； 將分隔值 80 下移至合併後的節點； 父節點無法保持最小數量的元素。  graph TB; A[60 ] --- B[50] \u0026amp; C[null]; B[50] --- D[20 30] \u0026amp; E[55]; C[null] --- H[70 80]; C:::red; classDef red stroke:red,stroke-width:2px; 將空的父節點作為當前節點，重新執行平衡修正。兄弟節點只有最小數量的元素：\n 將 50 和空節點合併（刪除空節點）； 將分隔值 60 下移至合併後的節點； 父節點為根節點，且沒有元素，讓合併之後的節點成為新的根節點。  刪除元素 60：\ngraph TB; A[50 60] --- B[20 30] \u0026amp; C[55] \u0026amp; D[70 80]; A:::red; classDef red stroke:red,stroke-width:2px; 從右子樹尋找最小值替代。接下來需要刪除替代元素 60：\ngraph TB; A[70 60] --- B[20 30] \u0026amp; C[55] \u0026amp; D[70 80]; D:::red; classDef red stroke:red,stroke-width:2px; 元素 70 不是葉節點中的唯一元素，可以直接刪除。\n刪除元素 50：\ngraph TB; A[50 70] --- B[20 30] \u0026amp; C[55] \u0026amp; D[80]; A:::red; classDef red stroke:red,stroke-width:2px; 從右子樹尋找最小值替代。接下來需要刪除替代元素 55：\ngraph TB; A[55 70] --- B[20 30] \u0026amp; C[null] \u0026amp; D[80]; C:::red; classDef red stroke:red,stroke-width:2px; 元素 55 是節點的唯一值，刪除後需要修正它。兄弟節點有多餘元素：\n 分隔值 55 下移； 兄弟元素 30 上移，遞補分隔值空缺。  graph TB; A[30 70] --- B[20] \u0026amp; C[55] \u0026amp; D[80]; 總結 對 B 樹 和 2-3-4 樹 有基本的概念，下週將說明 紅黑樹 與 2-3-4 樹 的等價關係，還有紅黑樹的新增操作。\n","description":"接下來我們來看與 AVL-Tree 一樣是自平衡二元搜尋樹的「紅黑樹」，因為比較難理解篇幅較長，所以分成三個階段來說明。","id":20,"section":"posts","tags":["資料結構","二元搜尋樹","二元樹","紅黑樹","平衡樹","B 樹","2-3-4 樹","w3HexSchool"],"title":"JavaScript 學演算法（十六）- 紅黑樹（上）：B 樹、2-3-4 樹","uri":"https://chupai.github.io/posts/2007/ds_redblack-tree-1/"},{"content":"這週是六角鼠年鐵人賽第二十三週。\n二元搜尋樹最大的問題就是，它會出現極端情況，傾斜某一邊，因此它的新增、搜尋、刪除操作最差時間複雜度為 $O(n)$。為了實現更高效的查詢，因此就有人發明了「平衡樹」。\n平衡樹概述 平衡樹（Balanced Tree） 是二元搜尋樹的改良版本，其目標在保持每一節點兩邊所含的項目數量相等，故可將根節點至任一葉節點之最長路徑最小化。\n「平衡」的意思，其實就是讓整棵樹看起來比較對稱、比較平衡，不會出現左右子樹其中一邊很高或很矮的情況。它能在 $O(\\log n)$ 內完成新增、搜尋和刪除操作。\n常見的平衡樹有：\n AVL-Tree：最早被發明的平衡樹，任意子節點的左右子樹高度相差不超過 1，屬於嚴格平衡樹。 紅黑樹（Red–black tree）：相較於 AVL-Tree，犧牲部分平衡（高 1 層），利用節點顏色，減少平衡操作的旋轉次數。 樹堆（Treap）：是有一個隨機附加域滿足堆積的性質的二元搜尋樹，其結構相當於以隨機資料新增的二元搜尋樹。  1. 旋轉（Rotation）操作 幾乎所有的平衡樹都是透過 旋轉（Rotate） 操作，使得樹趨於平衡。\n首先我們來看二元樹基本的旋轉操作，左旋轉和右旋轉：\n3.1 左旋轉 對 A 做左旋轉：\ngraph TB; A((A)) --- n1[null] \u0026amp; B((B)); B((B)) --- n2[null] \u0026amp; C((C)); C((C)) --- nnn1[null] \u0026amp; nnn2[null]; classDef n1 fill:#c2ff8b; classDef n2 fill:#ff8b8b; classDef n3 fill:#fff68b; n1:::n1; n2:::n2; 步驟如下：\n 將 B 的左子節點移動到 A 的右子節點位置； 再將 A 移動到 B 的左子節點位置；  graph TB; A((A)) --- n1[null] \u0026amp; n2[null]; classDef n1 fill:#c2ff8b; classDef n2 fill:#ff8b8b; classDef n3 fill:#fff68b; BB((B)) --- AA((A)) \u0026amp; C((C)); AA((A)) --- nn1[null] \u0026amp; nn2[null]; C((C)) --- nnn1[null] \u0026amp; nnn2[null]; classDef n1 fill:#c2ff8b; classDef n2 fill:#ff8b8b; n1:::n1; n2:::n2; nn1:::n1; nn2:::n2; 看上去，就像 A 逆時針旋轉。\n1.2 右旋轉 對 A 做右旋轉：\ngraph TB; A((A)) --- B((B)) \u0026amp; n1[null]; B((B)) --- C((C)) \u0026amp; n3[null]; C((C)) --- nnn1[null] \u0026amp; nnn2[null]; classDef n1 fill:#c2ff8b; classDef n2 fill:#ff8b8b; classDef n3 fill:#fff68b; n1:::n1; n3:::n3; 步驟如下：\n 將 B 的右子節點移動到 A 的左子節點位置； 再將 A 移動到 B 的右子節點位置；  graph TB; A((A)) --- n3[null] \u0026amp; n1[null] ; classDef n1 fill:#c2ff8b; classDef n2 fill:#ff8b8b; classDef n3 fill:#fff68b; BB((B)) --- C((C)) \u0026amp; AA((A)); AA((A)) --- nn3[null] \u0026amp; nn1[null]; C((C)) --- nnn1[null] \u0026amp; nnn2[null]; classDef n1 fill:#c2ff8b; classDef n2 fill:#ff8b8b; n1:::n1; n3:::n3; nn1:::n1; nn3:::n3; 看上去，就像 A 順時針旋轉。\nAVL-Tree AVL-Tree 全名為 Adelson-Velsky-Landis Tree，得名於它的發明者 G. M. Adelson-Velsky 和 Evgenii Landis，是最早被發明的平衡樹，因為是二元搜尋樹的優化版，因此又稱作「平衡二元搜尋樹」。\n它的任意子節點的左右子樹高度相差不超過 1，所以它也被稱為「高度平衡樹」。\n大部分的操作與二元搜尋樹相同，差異在於 AVL-Tree 新增或刪除資料時，會進行平衡操作（重新結構化），以保持性質及均勻的搜尋路徑，而不會導致樹過度傾斜。\n1. 平衡因子 BF 平衡因子（Balanced Factor，BF）是用來判斷節點的左右子樹高度相差多少。\n計算方式為，左子樹的高度減去它的右子樹的高度：\n 負數表示左子樹比右子樹高； 正數表示右子樹比左子樹高； 零表示左子樹和右子樹等高。  在 AVL-Tree 中，每一節點的平衡因子為 1、0 或 -1。帶有平衡因子 -2 或 2 的節點被認為是不平衡的，需要重新平衡。\n1.1 節點高度公式 節點高度為一個節點至某個葉節點的最長距離，其公式為：\n 節點高度 = max(左子節點高, 右子節點高) + 1\n 子節點為 null 時，高度視為 -1。\ngraph TB; classDef transparent fill:transparent,stroke:transparent,color:transparent; A((A)) --- B((B)); A((A)) --- C((C)); B((B)) --- D((D)) \u0026amp; E((E)); D((D)) --- F((F)) \u0026amp; F2((F2)); F2:::transparent;  F Height = max(-1, -1) + 1 = 0 D Height = max(0, -1) + 1 = 1 E Height = max(-1, -1) + 1 = 0 B Height = max(1, 0) + 1 = 2 C Height = max(-1, -1) + 1 = 0 A Height = max(2, 0) + 1 = 3  1.2 平衡因子計算  節點的平衡因子 = 左子樹的高度 - 右子樹的高度\n graph TB; classDef transparent fill:transparent,stroke:transparent,color:transparent; A((A)) --- B((B)); A((A)) --- C((C)); B((B)) --- D((D)) \u0026amp; E((E)); D((D)) --- F((F)) \u0026amp; F2((F2)); F2:::transparent;  F、E、C 沒有左、右子樹，所以左、右子樹高度為 -1  BF = -1 - (-1) = 0   D 左樹高度為 0、沒有右樹、  BF = 0 - (-1) = 1   B 左樹高度為 1、右樹高度為 0  BF = 1 - 0 = 1   A 左樹高度為 2、右樹高度為 0  BF = 2 - 0 = 2    2. 平衡操作 新增／刪除操作的平衡操作共有兩種策略：\n 預判是否影響樹的平衡，先調整樹再執行新增／刪除操作； 或是，執行新增／刪除操作後，再判斷樹是否需要執行平衡操作。  以下使用後者來說明，並使用新增節點為例。\n新增／刪除操作後，請考慮以下四種情況，會有不同的調整方式：\n LL 型 RR 型 LR 型 RL 型  4.1 LL 型 \u0026amp; RR 型 這兩種情況是鏡像的，所以處理的思路完全是一致的：\n LL 型：當新增的節點在不平衡的節點的左側的左側  對不平衡節點執行 右旋轉。   RR 型：當新增的節點在不平衡的節點的右側的右側  對不平衡節點執行 左旋轉。    直接看範例。\nLL 型：50 因為新增 30 而導致 BF 變成 2，因此需要調整，而 30 位於 50 的 左側的左側。\ngraph TB; A((50)) --- B((40)); A((50)) --- n1[null]; B((40)) --- C((30)); B((40)) --- n2[null]; class A red; class C green; class n1,n2 transparent; classDef red stroke:red,stroke-width:2px; classDef green stroke:#61bfa6,stroke-width:2px; classDef transparent fill:transparent,color:transparent,stroke:transparent; 處理方式，對 50 做右旋轉：\ngraph TB; B((40)) --- C((30)) \u0026amp; A((50)); 另一種情況，50 因為新增 20 而導致 BF 變成 2，而 20 位於 50 的左側的左側：\ngraph TB; A((50)) --- B((40)) \u0026amp; C((60)); B((40)) --- D((30)) \u0026amp; E((45)); D((30)) --- F((20)) \u0026amp; n1((null)); class A red; class F green; class n1,n2 transparent; classDef red stroke:red,stroke-width:2px; classDef green stroke:#61bfa6,stroke-width:2px; classDef transparent fill:transparent,color:transparent,stroke:transparent; 一樣對 50 做右旋轉：\ngraph TB; A((40)) --- B((30)) \u0026amp; C((50)); B((30)) --- D((20)) \u0026amp; n1((null)); C((50)) --- E((45)) \u0026amp; F((60)); class n1 transparent; classDef transparent fill:transparent,color:transparent,stroke:transparent; RR 型就是 LL 型的鏡像情況。\n4.2 LR 型 \u0026amp; RL 型 這兩種情況是鏡像的，所以處理的思路完全是一致的：\n LR 型：當新增的節點在不平衡的節點的左側的右側  先對不平衡節點的左子節點執行 左旋轉； 再對不平衡節點執行 右旋轉。   RL 型：當新增的節點在不平衡的節點的右側的左側  先對不平衡節點的右子節點執行 右旋轉； 再對不平衡節點執行 左旋轉。    直接看範例。\nLR 型：50 因為新增 45 而導致 BF 變成 2，因此需要調整，而 30 位於 50 的左側的右側。\ngraph TB; A((50)) --- B((40)); A((50)) --- n1[null]; B((40)) --- n2[null]; B((40)) --- C((45)); class A red; class C green; class n1,n2 transparent; classDef red stroke:red,stroke-width:2px; classDef green stroke:#61bfa6,stroke-width:2px; classDef transparent fill:transparent,color:transparent,stroke:transparent; 處理方式，先對 40 做左旋轉，會變成 LL 型，再對 50 做右旋轉：\ngraph TB; A((50)) --- B((40)) \u0026amp; n1[null]; B((45)) --- C((40)) \u0026amp; n2[null]; BB((45)) --- CC((40)) \u0026amp; AA((50)); class n1,n2 transparent; classDef red stroke:red,stroke-width:2px; classDef green stroke:#61bfa6,stroke-width:2px; classDef transparent fill:transparent,color:transparent,stroke:transparent; 另一種情況，50 因為新增 41 而導致 BF 變成 2，而 41 位於 50 的左側的右側：\ngraph TB; A((50)) --- B((40)) \u0026amp; C((60)); B((40)) --- D((30)) \u0026amp; E((45)); E((45)) --- F((41)) \u0026amp; n1((null)); class A red; class F green; class n1,n2 transparent; classDef red stroke:red,stroke-width:2px; classDef green stroke:#61bfa6,stroke-width:2px; classDef transparent fill:transparent,color:transparent,stroke:transparent; 一樣先對 40 做左旋轉，會變成 LL 型，再對 50 做右旋轉：\ngraph TB; AA((50)) --- BB((45)) \u0026amp; CC((60)); BB((45)) --- DD((40)) \u0026amp; n11((null)) DD((40)) --- FF((30)) \u0026amp; EE((41)); A((45)) --- B((40)) \u0026amp; C((50)); B((30)) --- D((30)) \u0026amp; E((41)); C((50)) --- n1((null)) \u0026amp; F((60)); class n1,n11 transparent; classDef transparent fill:transparent,color:transparent,stroke:transparent; RL 型就是 LR 型的鏡像情況。\nJavaScript 實作 AVL-Tree 二元樹的節點：\n1 2 3 4 5 6 7  class BTNode { constructor(data) { this.data = data; this.left = null; this.right = null; } }   本體：\n1 2 3 4 5 6  class AVLTree { constructor() { this.root = null; } // methods }   1. 計算平衡因子 計算平衡因子需要節點高度，因此我們需要計算節點高度的方法：\n1 2 3 4 5 6 7 8  getNodeHeight(node) { if(!node) { return -1; } // 1  // 2  const lh = this.getNodeHeight(node.left); const rh = this.getNodeHeight(node.right); return Math.max(lh, rh) + 1; // 3 }    子節點為 null 時，高度視為 -1。 使用歸迴取得左子節點高、右子節點高。 節點高度 = max(左子節點高, 右子節點高) + 1。  計算平衡因子：\n1 2 3  getBF(node) { return this.getNodeHeight(node.left) - this.getNodeHeight(node.right); }   公式：BF = 左子樹的高度 - 右子樹的高度。\n2. 旋轉操作 右旋轉：\n1 2 3 4 5 6  rightRotation(node) { const temp = node.left; node.left = temp.right; temp.right = node; return temp; }   左旋轉：\n1 2 3 4 5 6  leftRotation(node) { const temp = node.right; node.right = temp.left; temp.left = node; return temp; }   3. 平衡操作 平衡操作，檢查節點是否平衡：\n 若 BF \u0026gt; 1，表示不平衡，且左子樹高於右子樹，判斷是 LL、還是 LR：  若是 LR 型：  先對不平衡節點的左子節執行左旋轉，變成 LL 型；   LL 型，對不平衡節點執行右旋轉。   若 BF \u0026lt; -1，表示不平衡，且右子樹高於左子樹，判斷是 RR、還是 RL：  若是 RL 型：  先對不平衡節點的左子節執行右旋轉，變成 LL 型；   RR 型，對不平衡節點執行左旋轉。    判斷新增的節點是被加在左側還是右側，可以計算左、右子樹哪邊高，就能知道加在哪邊，因此我們可以計算 BF，若是負的右子樹高，反之，正的左子樹高。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  balance(node) { if (!node) { return node; } const nodeBF = this.getBF(node); if (nodeBF \u0026gt; 1) { if (this.getBF(node.left) \u0026lt; 0) { node.left = this.leftRotation(node.left); } node = this.rightRotation(node); } else if (nodeBF \u0026lt; -1) { if (this.getBF(node.right) \u0026gt; 0) { node.right = this.rightRotation(node.right); } node = this.leftRotation(node); } return node; }   4. 新增操作 新增節點後，需要檢查節點至根節點這條路徑，是否符合平衡條件，因此我們可以使用遞迴的方式回頭檢查節點是否符合平衡：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  insert(data) { const insertHelper = (node) =\u0026gt; { let curNode = node; if (!curNode) { return new BTNode(data); } if (data \u0026lt; curNode.data) { curNode.left = insertHelper(curNode.left); } else if (data \u0026gt; curNode.data) { curNode.right = insertHelper(curNode.right); } curNode = this.balance(curNode); return curNode; }; this.root = insertHelper(this.root); }   5. 刪除節點 刪除操作與普通的二元素搜尋樹相同，刪除節點後，檢查節點至根節點這條路徑，是否符合平衡條件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  remove(data) { const removeNode = (data, node) =\u0026gt; { let curNode = node; // let  if (!curNode) { return false; } if (data \u0026lt; curNode.data) { curNode.left = removeNode(data, curNode.left); } else if (data \u0026gt; curNode.data) { curNode.right = removeNode(data, curNode.right); } else { if (!curNode.left \u0026amp;\u0026amp; !curNode.right) { return null; } if (!curNode.left) { return curNode.right; } if (!curNode.right) { return curNode.left; } const aux = this.findMin(curNode.right); curNode.data = aux.data; curNode.right = removeNode(aux.data, curNode.right); } curNode = this.balance(curNode); // new  return curNode; }; this.root = removeNode(data, this.root); }   總結 1. 分析 二元搜尋樹最大的問題就是，它會出現極端情況，傾斜某一邊，因此它的新增、搜尋、刪除操作最差時間複雜度為 $O(n)$。\n而 AVL-Tree 再新增和刪除時，就會自動平衡二元樹，因此不會有極端情況發生。因此它的新增、搜尋、刪除操作平均、最差時間複雜度都為 $O(\\log n)$。\n2. 平衡操作時間複雜度 平衡操作是透過旋轉 1 次或 2 次來降低樹高。\n新增操作因為是增加樹高，而造成樹不平衡，因此最多只需要執行 1 次平衡操作即可平衡整棵樹（最多旋轉 2 次），所以新增的平衡操作時間複雜度為 $O(1)$。\n但刪除操作是因為降低樹高，而造成樹不平衡，因此執行平衡操作後，父節點可能又會不平衡，要再次執行平衡操作，所以最糟的情況下需要執行多次平衡操作，時間複雜度為 $O(\\log n)$。\n我們下週要講的紅黑樹的刪除平衡操作可以在 3 次旋轉內完成平衡操作。\n3. 視覺化 這是我用 Vue.js 製作的，可以很方便的觀察 AVL-Tree 結構變化：\nSee the Pen AVL-Tree Tree with Vue.js by Chupai@Design (@chupai) on CodePen.  ","description":"AVL-Tree 是最早被發明的平衡樹。","id":21,"section":"posts","tags":["資料結構","二元搜尋樹","二元樹","AVL-Tree","平衡樹","w3HexSchool"],"title":"JavaScript 學演算法（十五）- AVL-Tree","uri":"https://chupai.github.io/posts/2007/ds_avl-tree/"},{"content":"這週是六角鼠年鐵人賽第二十二週。\n之前我們已經簡單介紹 樹 \u0026amp; 二元樹，但我們沒有實作它，接下來我們將說明一種最常使用的二元樹資料結構：「二元搜尋樹（Binary Search Tree）」，還有實作二元樹的走訪。\n\r二元搜尋樹 二元搜尋樹（Binary Search Tree, BST）、二元搜索樹，也稱為 有序二元樹（Ordered binary tree） 或 排序二元樹（Sorted binary tree），是一種具有特殊性值的二元樹。\n1. 定義 可以是一棵空樹或者具有下列性質的二元樹：\n 若任意節點的左子樹不空，則左子樹上所有節點的值均小於它的根節點的值； 若任意節點的右子樹不空，則右子樹上所有節點的值均大於它的根節點的值； 任意節點的左、右子樹也分別為二元搜尋樹。  這個定義可能會出現一些變化：\n 上面的定義，不能允許出現重複的資料。 若允許重複的資料，定義會更改成：  左子樹，小於等於；或是： 右子樹，大於等於。    這是一顆普通的二元搜尋樹的結構：\ngraph TB; 10((10)) --- 5((5)); 10((10)) --- 15((15)); 5((5)) --- 4((4)); 15((15)) --- 12((12)); 5((5)) --- 8((8)); 8((8)) --- 6((6)); 8((8)) --- 9((9)); 15((15)) --- 16((16)); JavaScript 實作二元搜尋樹 1. 二元樹的基本結構 實作二元樹通常會用鏈結串列表示法。\n二元樹的節點：\n1 2 3 4 5 6 7  class BTNode { constructor(data) { this.data = data; this.left = null; this.right = null; } }    data：用來存放的資料值； left：指向左子樹的指標； right：指向右子樹的指標。  二元搜尋樹本體：\n1 2 3 4 5 6  class BinarySearchTree { constructor() { this.root = null; } // methods }   操作方法：\n 二元搜尋樹基本操作：  搜尋 新增 刪除   二元樹的走訪操作：  DFS：前序、中序、後序 BFS：層序    2. 搜尋操作 根據 BST 的性質，對於每個節點：\n 若目標值等於節點的值，則回傳節點； 若目標值小於節點的值，則繼續在左子樹中搜尋； 若目標值大於節點的值，則繼續在右子樹中搜尋； 若節點不存在，回傳 null。  使用迭代的方式實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  search(data, node = this.root) { let curNode = node; while (curNode) { if (data === curNode.data) { return curNode; } if (data \u0026lt; curNode.data) { curNode = curNode.left; } else { curNode = curNode.right; } } return null; }   使用遞迴實作：\n1 2 3 4 5 6 7 8 9 10 11 12  search(data, node = this.root) { if (!node) { return null; } if (data === node.data) { return node; } if (data \u0026lt; node.data) { return this.search(data, node.left); } return this.search(data, node.right); }   簡化：\n1 2 3 4  search(data, node = this.root) { if (!node || node.data === data) return node; return node.data \u0026lt; data ? this.search(data, node.right) : this.search(data, node.left); }   3. 新增操作 新增操作是建立 BST 的基礎操作，有許多不同的做法，但這裡只討論最經典的方式。\n與搜尋操作類似，對於每個節點：\n 若不允重複值，目標值等於節點的值時，結束操作。 若目標值小於節點的值，則前往左子樹； 若目標值大於節點的值，則前往右子樹； 若節點為空，設置新節點。  使用迭代實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  insert(data) { if (!this.root) { this.root = new BTNode(data); return; } let curNode = this.root; while (curNode) { if (data \u0026lt; curNode.data) { if (curNode.left) { curNode = curNode.left; } else { curNode.left = new BTNode(data); break; } } else if (data \u0026gt; curNode.data) { if (curNode.right) { curNode = curNode.right; } else { curNode.right = new BTNode(data); break; } } else { break; } } }    先判斷樹是否為空樹，若是，則將新節點設為根節點，新增結束；否則： 判斷當前節點，預設為根節點：  若小於當前節點資料，判斷左子樹是否存在：  存在，將當前節點設為左子樹，重新判斷。 不存在，將右子樹設為新節點，新增結束。   若大於當前節點資料，判斷右子樹是否存在：  存在，將當前節點設為右子樹，重新判斷。 不存在，將右子樹設為新節點，新增結束。。   若等於當前節點資料，新增失敗。    使用遞迴實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  insert(data) { const insertHelper = (node) =\u0026gt; { const curNode = node; if (data \u0026lt; curNode.data) { if (curNode.left) { insertHelper(curNode.left); } else { curNode.left = new BTNode(data); } } else if (data \u0026gt; curNode.data) { if (curNode.right) { insertHelper(curNode.right); } else { curNode.right = new BTNode(data); } } }; if (!this.root) { this.root = new BTNode(data); } else { insertHelper(this.root); } }   ４. 最小值／最大值 尋找最小值節點，就是一直往左子樹移動，直到空子樹，回傳最後一個左子樹：\n1 2 3 4 5 6 7  findMin(node = this.root) { let currentNode = node; while (currentNode \u0026amp;\u0026amp; currentNode.left ) { currentNode = currentNode.left; } return currentNode; }   尋找最大值節點，反過來就是一直往右子樹移動，直到空子樹，回傳最後一個右子樹：\n1 2 3 4 5 6 7  findMax(node = this.root) { let currentNode = node; while (currentNode \u0026amp;\u0026amp; currentNode.right) { currentNode = currentNode.right; } return currentNode; }   5. 刪除操作 在二元搜尋樹刪除一個節點，需要考慮節點的三種情況：\n 葉子節點（無子樹），直接刪除。 節點有單邊子樹，用子樹代替該節點。 節點有左右兩邊子樹，處理方式為：  尋找被刪除節點鄰近的節點值來代替； 取得鄰近的節點方式：  前驅節點：左子樹取最大值 後繼節點：右子樹取最小值（範例使用它）   接著刪除用來代替的節點。    比較麻煩的是，二元搜尋樹節點是單向的，沒有父節點指標，所以我們需要透過遞迴的方式來更新節點。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  remove(data) { const removeNode = (data, node) =\u0026gt; { const curNode = node; // 1  if (!curNode) { return false; } // 2  if (data \u0026lt; curNode.data) { curNode.left = removeNode(data, curNode.left); // 3  } else if (data \u0026gt; curNode.data) { curNode.right = removeNode(data, curNode.right); // 4  } else { // 4.1  if (!curNode.left \u0026amp;\u0026amp; !curNode.right) { return null; } // 4.2  if (!curNode.left) { return curNode.right; } if (!curNode.right) { return curNode.left; } // 4.3  const aux = this.findMin(curNode.right); curNode.data = aux.data; curNode.right = removeNode(aux.data, curNode.right); } return curNode; }; this.root = removeNode(data, this.root); }   要刪除節點，就比須先找到它：\n 節點不存在。 小於當前節點資料，前往左子樹； 大於當前節點資料，前往右子樹； 等於當前節點，刪除：  葉子節點，直接刪除。 單邊子樹，用子樹代替。 左右兩邊子樹：  取得右子樹最小值； 替換值； 刪除右子樹最小值節點。      6. DFS DFS 共有三種走訪順序：\n 前序走訪 中序走訪 後序走訪   關於走訪，之前在 樹 \u0026amp; 二元樹 有說明。\n 6.1 遞迴 首先是前序走訪，執行順序為：\n （N）訪問當前節點 （L）走訪左子樹 （R）走訪右子樹  遞迴：\n1 2 3 4 5 6 7 8 9 10 11 12 13  preOrderTraversal() { const temp = []; preHelper(this.root); return temp; function preHelper(node) { if (node) { temp.push(node.data); preHelper(node.left); preHelper(node.right); } } }   中序、後序走訪差異不大：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  inOrderTraversal() { const temp = []; inHelper(this.root); return temp; function inHelper(node) { if (node) { inHelper(node.left); temp.push(node.data); inHelper(node.right); } }; } postOrderTraversal() { const temp = []; postHelper(this.root); return temp; function postHelper(node) { if (node) { postHelper(node.left); postHelper(node.right); temp.push(node.data); } }; }   6.2 迭代 我們可以使用堆疊（stack）來模擬遞迴結構。\n前序走訪：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  preOrderTraversal() { const temp = []; const stack = []; if (this.root) { stack.push(this.root); } while (stack.length) { const node = stack.pop(); temp.push(node.data); if (node.right) { stack.push(node.right); } if (node.left) { stack.push(node.left); } } return temp; }   因為堆疊是後進先出，因此要先將右子樹推入堆疊再推入左子樹。\n中序走訪：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  inOrderTraversal() { const temp = []; const stack = []; let node = this.root; while (node || stack.length) { while (node) { stack.push(node); node = node.left; } node = stack.pop(); temp.push(node.data); node = node.right; } return temp; }   先將左子樹全部加入堆疊中，然後逐個取出。\n後序走訪可以將前序作法的右子樹與左子樹的堆入順序交換，即 NLR 變成 NRL，最後輸出時反轉陣列，變成 LRN。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  postOrderTraversal() { const temp = []; const stack = []; if (this.root) { stack.push(this.root); } while (stack.length) { const node = stack.pop(); temp.push(node.data); if (node.left) { stack.push(node.left); } if (node.right) { stack.push(node.right); } } return temp.reverse(); }   6.3 輸出 這是二元搜尋樹結構：\ngraph TB; 10((10)) --- 5((5)); 10((10)) --- 15((15)); 5((5)) --- 4((4)); 15((15)) --- 12((12)); 5((5)) --- 8((8)); 8((8)) --- 6((6)); 8((8)) --- 9((9)); 15((15)) --- 16((16)); 輸出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const nums = [10, 5, 4, 8, 6, 9, 15, 12, 16]; const BST = new BinarySearchTree(); for (const data of nums) { BST.insert(data); } console.log( BST.preOrderTraversal() ); // [ 10, 5, 4, 8, 6, 9, 15, 12, 16 ]  console.log( BST.inOrderTraversal() ); // [ 4, 5, 6, 8, 9, 10, 12, 15, 16 ]  console.log( BST.postOrderTraversal() ); // [ 4, 6, 9, 8, 5, 12, 16, 15, 10 ]   二元搜尋樹使用不同順序的走訪，有不同的功能：\n 使用先序走訪，可以結構化輸出。 使用中序走訪，可以從小到大輸出，具有排序的功能。 使用後序走訪，可以用於計算有層級關係的所有元素的大小。  7. BFS 層序走訪會先訪問離根節點最近的節點，也就是它會由上而下，並在同一個階層，由左至右依序訪問節點。\n通常會使用佇列（queue）來實現：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  levelorderTraversal() { const temp = []; const queue = []; if (this.root) { queue.push(this.root); } while(queue.length) { const node = queue.shift(); temp.push(node.data); if(node.left) { queue.push(node.left); } if(node.right) { queue.push(node.right); } } return temp; }   層序走訪會依照階層，由左至右依序訪問節點：\n1 2  console.log( BST.levelorderTraversal() ); // [ 10, 5, 15, 4, 8, 12, 16, 6, 9 ]   我們可以稍作修改，用陣列存儲每一層的節點：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  levelorderTraversal() { const temp = []; const queue = []; if (this.root) { queue.push(this.root); } while (queue.length) { const subTemp = []; const len = queue.length; for (let i = 0; i \u0026lt; len; i += 1) { const node = queue.shift(); subTemp.push(node.data); if (node.left) { queue.push(node.left); } if (node.right) { queue.push(node.right); } } temp.push(subTemp); } return temp; }   1 2  console.log( BST.levelorderTraversal() ); // [ [ 10 ], [ 5, 15 ], [ 4, 8, 12, 16 ], [ 6, 9 ] ]   總結 1. 分析 二元搜尋樹的新增、搜尋、刪除操作時間複雜度會根據樹的高來決定，最佳、平均的時間複雜度為 $O(\\log n)$。\n但二元搜尋樹最大的問題就是，它會出現極端情況，傾斜某一邊。舉例來說，當我們順序新增元素，二元搜尋樹會退化成鏈結串列，元素數量多少，樹高就是多少，造成新增、搜尋、刪除操作最差時間複雜度為 $O(n)$。\n舉例，依序輸入1 2 3 4：\ngraph TB; 11((1)) --- 2((null)) \u0026amp; 22((2)); 22((2)) --- 3((null)) \u0026amp; 33((3)); 33((3)) --- 4((null)) \u0026amp; 44((4)); 2. 將二元搜尋樹變平衡 如果要將一棵傾斜的二元搜尋樹變得平衡，可以這樣處理：\n 對二元搜尋樹執行的中序走訪取得有序的陣列； 利用有序的陣列，重建一棵平衡的二元搜尋樹：  從陣列的中間位置取一個元素，得到樹的根節點。 對陣列的左邊和右邊遞迴執行相同操作，得到根節點的左、右子樹。    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  balanceBST() { const nodeList = this.inOrderTraversal(); const { length } = nodeList; if (length \u0026lt; 3) { return this.root; } this.root = rebuild(0, length - 1); function rebuild(start, end) { if (start \u0026gt; end) { return null; } const mid = Math.floor((start + end) / 2); const node = new BTNode(nodeList[mid]); node.left = rebuild(start, mid - 1); node.right = rebuild(mid + 1, end); return node; } }   3. 平衡樹 為了避免二元搜尋樹出現極端情況，有人發明了「平衡樹（Balanced Tree）」，它能在新增節點時，自動平衡，下週詳細說明。\n4. 視覺化 這是我用 Vue.js 製作的，可以很方便的觀察二元搜尋樹結構變化：\nSee the Pen Binary Search Tree with Vue.js by Chupai@Design (@chupai) on CodePen. ","description":"二元搜尋樹是一種具有特殊性值的二元樹。","id":22,"section":"posts","tags":["資料結構","二元搜尋樹","二元樹","w3HexSchool"],"title":"JavaScript 學演算法（十四）- 二元搜尋樹","uri":"https://chupai.github.io/posts/2006/ds_binary_search_tree/"},{"content":"這週是六角鼠年鐵人賽第二十一週，上週已經簡單描述樹狀結構的概念，接下來繼續看排序演算法的 堆積排序。\n\r堆積（Heap） 堆積（Heap） 是一種用於排序的特殊二元樹，始於 J. W. J. Williams 在 1964年發表的 堆積排序（Heap sort），當時他提出了二元堆積樹作為此演算法的資料結構。\n堆積具有以下兩種特性：\n 為 Complete binary tree（完全二元樹），除了最底層，其他層的節點都是填滿的，而且最後一階層的節點必須由左至右填入； 任意節點小於（或大於）它的所有後裔，最小元（或最大元）在堆積的根上（堆積序性）。  所有的父節點都比子節點要小，稱作 最小堆積（Min Heap） 所有的父節點都比子節點要大，稱作 最大堆積（Max Heap）    1. Complete binary tree Complete tree，指的是一棵二元樹中，除了最後一層，其餘層都是滿的二元樹，最後一階層的節點必須由左至右填入。\n若樹的深度為 k，那麼至少有 $2^{k}$ 個節點，最多有 $2^{k+1} - 1$個節點。\ngraph TB; A((A)) --- B((B)) \u0026amp; C((C)); B((B)) --- D((D)) 這是一棵深度為 2 的二元樹，它至少有 $2^{2} = 4$ 的節點。\n2. 最小堆積 最小堆積，所有的父節點都比子節點要小。\ngraph TB; A((1)) --- B((3)) \u0026amp; C((4)); B((3)) --- D((6)) \u0026amp; E((7)) 3. 最大堆積 最大堆積，所有的父節點都比子節點要大。\ngraph TB; A((7)) --- B((6)) \u0026amp; C((4)); B((6)) --- D((3)) \u0026amp; E((1)) 堆積排序 堆積排序（Heap sort） 是指利用 堆積 所設計的一種排序演算法。可以看成是 選擇排序 的改良版。\n流程：\n 先將資料堆積化（最大或最小）； 然後將第一個元素與最後元素交換位置； 重複上述步驟，直到排序完成。  這裡有一組數列資料：\nnums = [10, 50, 30, 60, 15, 40] 將他轉成 Complete binary tree，結構如下：\ngraph TB; 0((10)) --- 1((50)) \u0026amp; 2((30)); 1((50)) --- 3((60)) \u0026amp; 4((15)); 2((30)) --- 5((40)); 接下來我們要將 Complete binary tree 調整成堆積資料結構，如果是遞增排序會調整成最大堆積，遞減排序則調整成最小堆積。\n兩者調整過程差異不大，這邊就只說明如何遞增排序。\n1. 堆積化 首先要取得最後一個父節點位置，如果節點數量為 n，那麼最後一個父節點的位置會是 n / 2（取商）。\n從最後一個父節點開始，由右至左開始比較其子節點，若子節點值大於父節點，則相互對調。\n6 / 2 = 3，從第三個位置的節點開始：\n 父節點 30  比 40 小，交換位置   父節點 50  50、60、15 三者之間左子節點最大，交換位置    graph TB; 0((10)) --- 1((50)) \u0026amp; 2((40)); 1((60)) --\u0026gt; 4((50)); 1((60)) --- 3((15)); 2((40)) --\u0026gt; 5((30)); 接下來，提升了一層，交換後還有子節點，需要繼續往下比較：\n 父節點 10  10、60、40 三者之間左子節點最大，交換位置 10、50、15 三者之間左子節點最大，交換位置    graph TB; 0((60)) --\u0026gt; 1((50)); 0((60)) --- 2((40)); 1((50)) --\u0026gt; 3((10)); 1((50)) --- 4((15)); 2((40)) --- 5((30)); 2. 排序 再來是排序動作，我們將最大堆積的最頂層元素，與最後一個元素交換位置：\ngraph TB; 0((30)) --- 1((50)) \u0026amp; 2((40)); 1((50)) --- 3((10)) \u0026amp; 4((15)); 2((40)) --- 5((60)); classDef sorted fill:#9dff96,stroke:#6afd5e; 5:::sorted; 如此一來我們的遞增排序就已經排好一個元素了，因此可以將它排除。\n接下來我們要繼續維持 最大堆積，因此要再次調整樹，最頂層的就會是第二大的：\ngraph TB; 0((50)) --- 1((30)) \u0026amp; 2((40)); 1((30)) --- 3((10)) \u0026amp; 4((15)); 2((40)) --- 5((60)); classDef sorted fill:#9dff96,stroke:#6afd5e; 5:::sorted; 一樣將它與最後一個元素交換位置後排除：\ngraph TB; 0((15)) --- 1((30)) \u0026amp; 2((40)); 1((30)) --- 3((10)) \u0026amp; 4((50)); 2((10)) --- 5((60)); classDef sorted fill:#9dff96,stroke:#6afd5e; 5:::sorted; 4:::sorted; 持續重複上述步驟，直到排序完成：\ngraph TB; 0((10)) --- 1((15)) \u0026amp; 2((30)); 1((15)) --- 3((40)) \u0026amp; 4((50)); 2((30)) --- 5((60)); 演算法實作 1. 將陣列調整成最大堆積 1 2 3 4 5 6 7 8  function buildMaxHeap(arr) { let n = arr.length; const lastParent = Math.floor(n / 2) - 1; for (let i = lastParent; i \u0026gt;= 0; i--) { maxHeapify(arr, i, n); } }    取得最後一個父節點索引位置。 從最後一個父節開始執行最大堆積調整操作至根節點。  2. 最大堆積調整操作： 參數：\n arr：待排序陣列。 index：檢查的起始索引位置。 heapSize：目前堆積大小，因為我們直接在原陣列上操作，因此這是用來判斷目前要調整的範圍。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function maxHeapify(arr, index, heapSize) { const iLeft = 2 * index + 1; // 1  const iRight = iLeft + 1; // 2  let iMax = index; // 3  // 4  if (iLeft \u0026lt; heapSize \u0026amp;\u0026amp; arr[iMax] \u0026lt; arr[iLeft]) { iMax = iLeft; } if (iRight \u0026lt; heapSize \u0026amp;\u0026amp; arr[iMax] \u0026lt; arr[iRight]) { iMax = iRight; } // 5  if (iMax !== index) { swap(arr, iMax, index); maxHeapify(arr, iMax, heapSize); } }    左子節點位置。 右子節點位置。 紀錄目前最大節點的位置，預設為當前節點。 首先判斷節點位置是否有超出堆積範圍，再比較是否為最大的。 如果目前最大節點的位置不等於當前節點位置，表示左或右子節點比較大，因此執行交換操作與繼續往下執行調整函式（遞迴操作）。  陣列交換函式：\n1 2 3 4 5  function swap(arr, a, b) { let temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; }   上面程式碼使用了使用到了遞迴操作，那麼當資料數量非常非常大時，很容易導致 堆疊溢位，因此可以改寫用迭代方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  function maxHeapify(arr, index, heapSize) { let iLeft; let iRight; let iMax; let iCur = index; while (true) { iLeft = 2 * iCur + 1; iRight = iLeft + 1; iMax = iCur; if (iLeft \u0026lt; heapSize \u0026amp;\u0026amp; arr[iMax] \u0026lt; arr[iLeft]) { iMax = iLeft; } if (iRight \u0026lt; heapSize \u0026amp;\u0026amp; arr[iMax] \u0026lt; arr[iRight]) { iMax = iRight; } if (iMax === iCur) { break; } else { swap(arr, iMax, iCur); iCur = iMax; } } }   3. 排序操作 1 2 3 4 5 6 7 8 9 10 11  function heapSort(arr) { const n = arr.length; buildMaxHeap(arr); // 1  // 2  for (let i = n - 1; i \u0026gt; 0; i--) { swap(arr, 0, i); // 3  maxHeapify(arr, 0, i); // 4  } }    將陣列調整成最大堆積，第一個節點將會是值最大的。 將最後一個節點與第一個節點交換位置，並重新對第一個節點執行堆積調整操作（記得移除已排序好節點）。 交換函式的 i 指的是最後一個節點位置。 調整操作的 i 指的是目前堆積長度。  分析 堆積排序 可以看成是 選擇排序 的改良版，利用 堆積 這種 半排序（partially sorted） 的資料結構輔助並加速排序。主要運行時間主要是消耗在初始堆積化與重新堆積化上。\n 不穩定排序 時間複雜度  最佳：$O(n \\log n)$ 最差：$O(n \\log n)$ 平均：$O(n \\log n)$   空間複雜度為：$O(1)$ ","description":"堆積排序（Heap Sort） 可以看成是 選擇排序 的改良版本。","id":23,"section":"posts","tags":["排序演算法","堆積排序","w3HexSchool"],"title":"JavaScript 學演算法（十三）- 堆積排序","uri":"https://chupai.github.io/posts/2006/sort_algorithm_heap_sort/"},{"content":"這週是六角鼠年鐵人賽第二十週，經典的排序演算法還有一個 堆積排序，再說明堆積排序前，先來看之前還沒提到的樹狀資料結構，之後才比較好理解 堆積排序。\n\r樹（Tree） 樹（Tree），是一種模擬現實生活中的樹幹和樹枝的資料結構。屬於一種階層架構的非線性資料結構。\n生活中常見樹狀結構資料，例如：家族族譜、決策模型、淘汰賽比賽圖等等。對於前端工程師來說，我們最常操作的 DOM 就是樹狀結構資料。\n1. 樹的基本觀念 在樹狀結構中的最基本單位，稱為 節點（Node），節點之間的連結即樹的 分支（Branch）。\ngraph TB; A((A)) --- B((B)) \u0026amp; C((C)); 樹的起點稱為 根節點（Root），具有唯一性，例如 A 即根節點。樹根延展出去就是樹枝，也就是根節點可以分支 0 至 n 個節點，分支出去的節點為 子節點（Child）。\ngraph TB; A((A)) --- B((B)) \u0026amp; C((C)); B((B)) --- D((D)) \u0026amp; E((E)); C((C)) --- F((F)) \u0026amp; G((G)) \u0026amp; H((H)); F((F)) --- I((I)); H((H)) --- J((J)); J((J)) --- K((K)); 在樹枝下一樣可以擁有下一層樹枝，D 和 E 為 B 的子節點，B 為 D 和 E 的 父節點（Parent）。B 和 E 因為父節點相同，兩者為 兄弟節點（Siblings）。從根節點到某節點 路徑（Path） 上的所有節點都是此節點的 祖先節點（Ancestor），例如 K 的祖先節點就包含 J、H、C、A。反之，某節點底下的所有節點稱為 後代節點（Descendant）。\n節點和其子節點可以構成 子樹（Subtree），例如 B、D、E 就形成一棵子樹。\n沒有子節點的節點稱為 葉節點（Leaf） 或 外部節點（External），例如 D、E、I、G、K。其餘有子節點的節點則稱作 分支（Branch）節點 或 內部節點（Internal） ，而一個節點擁有的子節點數量稱作 分支度（Degree）。\n節點的 階層（Level） 是從根開始定義起，根為第一層，根的子為第二層，以此類推，例如根節點於 1 階層，而 D 位於 3 階層。\n節點 深度（Depth） 為一個節點至根節點的距離，例如根節點的深度為 0，D 的深度為 2。階層與深度的關係為：Level = Depth + 1。\n一個節點至某個葉節點的最長距離則稱作 節點高度（Height of node），例如 F 的高度為 1、C 的高度為 3，所有葉節點的高度為 0。根節點的高度等同 樹高（Height of tree），也等同 樹的深度（Depth of tree）。\n注意，有部分的文獻會將根節點的 階層（Level） 定義為 0，也就是等同於 深度（Depth）。\r 2. 樹的特點 樹是由一個或多個節點所組成的有限集合，並且有以下特點：\n 存在且只有一個 根節點（Root）； 樹裡面不存在 環路（Cycle），若要尋找特定節點，只存在一條 路徑（Path）； 除了根節點外，每個節點只會有一個 父節點（Parent）。 除了根節點外，每個子節點可以分為多個不相交的子樹。  環路（Cycle），指的是樹在各節點之間不可以有迴圈，或不連結的左、右子樹。\n3. 樹的種類 除非特別指明，一般的樹都是 有序樹（OrderedTree），是指樹中任意節點的子節點之間有順序關係，每個結點的各子樹看成是從左到右有次序的（即不能互換），常見的有以下幾種：\n 二元樹（Binary tree） 二元搜尋樹（Binary Search Tree） AVL-Tree 紅黑樹（Red–black tree）  另外還有 無序樹（UnoderedTree），又稱「自由樹」，樹中任意節點的子節點之間沒有順序關係。\n什麼是二元樹 樹依不同分支度（Degree）可以區分程很多種，在資料結構中，最廣泛使用的樹狀結構就是 二元樹（Binary tree）。\n二元樹（Binary tree），簡單來說就是限制每個節點最多只能有兩個的子節點，也就是節點分支度只能小於等於 2。\n二元樹特點：\n 可以為空集合； 分支度只能小於等於 2； 子樹有左、右方向的分別。  1. 左子樹與右子樹 非空集合的二元樹由三個元素組合：\n 根節點（Root） 左子樹（Left Subtree） 右子樹（Right Subtree）  graph TB; A((A)) --- B((B)) \u0026amp; C((C)); subgraph Right Subtree C((C)) --- F((F)) \u0026amp; G((G)); G((G)) --- H((H)) \u0026amp; I((I)); end subgraph Left Subtree B((B)) --- D((D)) \u0026amp; E((E)); end 2. 歪斜樹 歪斜樹（Skewed Tree），指一棵樹完全沒有左或右其中一邊節點的二元樹，如果集中左邊稱作「左歪斜樹」，反之集中右邊稱作「右歪斜樹」。\ngraph TB; classDef transparent fill:transparent,stroke:transparent,color:transparent; A((A)) --- B((B)) \u0026amp; B2((B2)); B((B)) --- C((C)) \u0026amp; C2((C2)); B2((B2)):::transparent; C2((C2)):::transparent; 3. Strictly binary tree Strictly binary tree，指的是每個節點的子節點只能是 0 或 2 的二元樹，簡單來說就是「除了葉節點以外，每個節點都有兩個子節點」。\ngraph TB; A((A)) --- B((B)) \u0026amp; C((C)); B((B)) --- D((D)) \u0026amp; E((E)); 4. Perfect binary tree Perfect binary tree，指的是每一層上的節點數都是最大節點的二元樹。一棵深度為 k 的樹，它的總節點數量為 $2^{k+1} - 1$。特點是\ngraph TB; A((A)) --- B((B)) \u0026amp; C((C)); B((B)) --- D((D)) \u0026amp; E((E)); C((C)) --- F((F)) \u0026amp; G((G)); 這是一棵深度為 2 的樹，它的總節點數量為 $2^{2+1} - 1 = 7$。\n5. Complete binary tree Complete tree，指的是一棵二元樹中，除了最後一層，其餘層都是滿的二元樹，最後一階層的節點必須由左至右填入。\n若樹的深度為 k，那麼至少有 $2^{k}$ 個節點，最多有 $2^{k+1} - 1$個節點。\ngraph TB; A((A)) --- B((B)) \u0026amp; C((C)); B((B)) --- D((D)) 這是一棵深度為 2 的樹，它至少有 $2^{2} = 4$ 的節點。\n6. Full Binary tree Full Binary tree 定義基本上等同於 Strictly binary tree。但中文資料對於 Full Binary tree 的定義，大多數等同 Perfect binary tree。關於這部分的差異我就不知道為什麼了。\n二元樹的表示法 二元樹在實作上有多種方法可以建立，以下簡單說明最常見的兩種方式。\n1. 陣列表示法 使用一維陣列儲存，將二元樹的節點根據公式依序放在對應的陣列索引：\n 根節點放在陣列索引位置 0。 若節點索引為 i：  節點的左子節點，放在陣列索引位置 (2 * i) + 1。 節點的右子節點，放在陣列索引位置 (2 * i) + 2。 若節點不為根節點，節點的父節點放在陣列索引位置 (i - 1) / 2（取商）。    以一棵深度為 2 的 Perfect binary tree 為例：\ngraph TB; A((A)) --- B((B)) \u0026amp; C((C)); B((B)) --- D((D)) \u0026amp; E((E)); C((C)) --- F((F)) \u0026amp; G((G));    陣列索引 0 1 2 3 4 5 6     節點 A B C D E F G    B 節點的索引為 1：\n 左子節點（Ｄ）的索引位置為 2 * 1 + 1 = 3 右子節點（E）的索引位置為 2 * 2 + 2 = 4 父節點（A）的索引位置為 (2 - 1) / 2 = 0  陣列表示法適合用來儲存 Perfect binary tree，可以快速尋找左右子節點和父節點，但缺點也很明顯：\n 當二元樹稀疏或不平衡時，即使節點不存在，仍然會保留對應的陣列索引位置，因此會造成閒置的空間配置。 若增加或刪除節點時，需要移動多個節點。  2. 鏈結串列表示法 鏈結串列表示法是用一個節點結構表示樹上的每個節點，結構內除了儲存該節點本身的值，另外有兩個 指標（Pointer），分別指向節點的左子節點和右子節點，沒有子節點則指向 null。\n   指標 資料 指標     left data right    鏈結串列表示法，節點新增或刪除容易操作，但尋找父節點較不易，而且當二元樹稀疏或不平衡時，就會浪費指標空間。\n二元樹的走訪 二元樹的走訪（Binary tree traversal），走訪（Traversal） 或稱作 遍歷、搜尋（Search），簡單來說就是訪問樹中的每個節點，並執行特定的操作（可能是檢查值、更新、刪除等等）。\n二元樹的走訪方式有兩種：\n 深度優先搜尋（Depth-first Search，DFS）\n由根節點出發，選擇某一子樹並以垂直方向由上到下處理，將其後代節點訪問完後，再選擇另一子樹遞迴地處理。 廣度優先搜尋（Breath-first Search，BFS）\n由根節點出發，以水平方向由左到右處理，將同階層的兄弟節點訪問完畢後，接續處理下一接層的所有節點。  DFS - 前序：\nBFS：\n1. 深度優先搜尋 DFS 走訪一個節點有三個動作：\n （L）走訪左子樹 （R）走訪右子樹 （N）訪問當前節點  graph TB; N((N)) --- L((L)) \u0026amp; R((R)); 這三個動作根據執行順序，一共會有 3! = 6 種組合：NLR、NRL、LNR、LRN、RNL、RLN。限制只能先走左子樹、再走右子樹，因此只會剩下三種組合：NLR、LNR、LRN。\n所以，DFS 根據訪問節點的順序不同，有以下三種類型：\n 前序（Preorder） 中序（Inorder） 後序（Postorder）  graph TB; 1((1)) --- 2((2)) \u0026amp; 3((3)); 2((2)) --- 4((4)) \u0026amp; 5((5)); 3((3)) --- 6((6)) \u0026amp; 7((7)); 4((4)) --- 8((8)); 以中序 LNR 為例，執行動作順序：\n （L）走訪左子樹 （N）訪問當前節點 （R）走訪右子樹  從根節點 1 起步 走訪 1 左樹，2 走訪 2 左樹，4 走訪 4 左樹，8 走訪 8 左樹，空子樹 訪問：8 走訪 8 右樹，空子樹 訪問：4 走訪 4 右樹，空子樹 訪問：2 走訪 2 右樹，5 走訪 5 左樹，空子樹 訪問：5 走訪 5 右樹，空子樹 訪問：1 走訪 1 右樹，3 走訪 3 左樹，6 走訪 6 左樹，空子樹 訪問：6 走訪 6 右樹，空子樹 訪問：3 走訪 3 右樹，7 走訪 7 左樹，空子樹 訪問：7 走訪 7 右樹，空子樹 根據走訪過程，此中序走訪結果為：8 4 2 5 1 6 3 7  前序 NLR：  執行順序：1 2 4 8 5 3 6 7   中序 LNR：  執行順序：8 4 2 5 1 6 3 7   後序 LRN：  執行順序：8 4 5 2 6 7 3 1    DFS 通常會使用 遞迴（Recursion） 或 堆疊（Stack） 實作。\n2. 廣度優先搜尋 BFS 和深度優先搜尋不同，廣度優先搜尋會先訪問離根節點最近的節點。也就是它會由上而下，並在同一個階層，由左至右依序訪問節點，因此又稱作 層序走訪（Levelorder Traversal）。\nDFS 通常會使用 佇列（Queue） 實作。\n總結 簡單紀錄樹與二元樹的概念，下週會先說明堆積排序，而樹的實作部分則再之後會使用二元搜尋樹來說明。\n","description":"再說明堆積排序前，先來看之前還沒提到的樹狀資料結構。","id":24,"section":"posts","tags":["資料結構","樹","二元樹","w3HexSchool"],"title":"JavaScript 學演算法（十二）- 樹 \u0026 二元樹","uri":"https://chupai.github.io/posts/2006/ds_tree_and_binary_tree/"},{"content":"這週是六角鼠年鐵人賽第十九週，這週來說明 希爾排序（Shell Sort）。\n\r希爾排序（Shell Sort） 希爾排序（Shell Sort），也稱 遞減增量排序，是 插入排序 的一種更高效的改進版本，為不穩定排序。\n插入排序（Insertion Sort） 的兩點特性：\n 在已經排好序的資料操作時，是效率高的，即可以達到 $O(n)$。 但一般情況是低效，每次只能將資料移動一位。  而 希爾排序 是在 插入排序 基礎上添加了 間隔長度（gap） 的概念，使得 插入排序 可以分組執行，並且資料的移動距離可以大於一。\n其概念為，將整個陣依照預先指定的 gap，交錯分割成數個小陣列，並以插入排序的方式將這些小陣列個別排序，然後逐漸縮小 gap，直到 gap 等於 1。此時再作最後一次插入排序。\n舉例：\nnums = [9, 8, 7, 6, 5, 4, 3, 2, 1] gap = 3 9 8 7 6 5 4 3 2 1 9 6 3 =\u0026gt; 3 6 9 8 5 2 =\u0026gt; 2 5 8 7 4 1 =\u0026gt; 1 4 7 3 2 1 6 5 4 9 8 7 gap = 2 3 2 1 6 5 4 9 8 7 3 1 5 9 7 =\u0026gt; 1 3 5 7 9 2 6 4 8 =\u0026gt; 2 4 6 8 1 2 3 4 5 6 7 8 9 gap = 1 1 2 3 4 5 6 7 8 9 =\u0026gt; 1 2 3 4 5 6 7 8 9 演算法實作 這是基本的插入排序：\n1 2 3 4 5 6 7 8 9 10 11 12 13  function insertionSort(arr) { const n = arr.length; for (let i = 1; i \u0026lt; n; i++) { const temp = arr[i]; let j = i; while (j \u0026gt; 0 \u0026amp;\u0026amp; temp \u0026lt; arr[j - 1]) { arr[j] = arr[j - 1]; j -= 1; } arr[j] = temp; } return arr; }   希爾排序的設計者 Donald Shell 最初建議選擇 gap = n / 2 比較好理解。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function shellSort(arr) { const n = arr.length; let gap = Math.floor(n / 2); while (gap \u0026gt; 0) { // 與插入排序極為相似  for (let i = gap; i \u0026lt; n; i++) { const temp = arr[i]; let j = i; while (j \u0026gt;= gap \u0026amp;\u0026amp; temp \u0026lt; arr[j - gap]) { arr[j] = arr[j - gap]; j -= gap; } arr[j] = temp; } gap = Math.floor(gap / 2); // 縮小間隔長度  } return arr; }   簡易執行時間比較：\nSee the Pen Shell Sort by Chupai@Design (@chupai) on CodePen.  優化間隔長度 間隔長度的選擇是是希爾排序的重要部分。\n希爾排序的時間複雜度不容易計算，因為會根據間距值來決定。\n 使用最差的間距，最差時間複雜度：$O(n^2)$ 使用最佳的間距，最佳時間複雜度：$O(n \\log n)$ 平均複雜會根據間距值來決定 空間複雜度為： $O(1)$  最佳的間隔長度是透過複雜的數學公式所計算出來的，而且會根據資料大小，而有所不同。這裡不做深究，相關細節可參考 wikipedia。\n我們以最常見的 Marcin Ciura 為例。\n定義間隔長度常數，並在執行排序時傳入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  const CIURA_GAPS = [1750, 701, 301, 132, 57, 23, 10, 4, 1]; function shellSort(arr, gaps) { const n = arr.length; for (let gap of gaps) { for (let i = gap; i \u0026lt; n; i++) { const temp = arr[i]; let j = i; while (j \u0026gt;= gap \u0026amp;\u0026amp; temp \u0026lt; arr[j - gap]) { arr[j] = arr[j - gap]; j -= gap; } arr[j] = temp; } } return arr; } shellSort(arr, CIURA_GAPS);   ","description":"希爾排序（Shell Sort） 是插入排序的一種更高效的改進版本。","id":25,"section":"posts","tags":["排序演算法","希爾排序","w3HexSchool"],"title":"JavaScript 學演算法（十一）- 希爾排序","uri":"https://chupai.github.io/posts/2006/sort_algorithm_shell_sort/"},{"content":"這週是六角鼠年鐵人賽第十八週，這週簡單說明 快速排序（Quick Sort）。\n\r快速排序（Quick Sort） 快速排序（Quick Sort） 是實用性很高的排序法，與合併排序一樣是使用 分治法 的應用。\n操作流程：\n 快速排序是從數列中隨機選擇一個數作為 基準（pivot）。 將比基準小的移至 基準 左邊，形成左區塊 將比基準大的移至 基準 右邊，形成右區塊 分別對左邊和右邊的區塊重複前項 3 操作（遞迴），直到區塊中只剩一個元素。  演算法實作 1. 簡單好懂版本 此版本使用遞迴結構，並使用額外空間儲存比較後的元素，不會改變原陣列。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function quickSort(arr) { const n = arr.length; if (n \u0026lt; 2) { return arr; } // 1  const pivot = arr[0]; // 2  const [leftArr, rightArr] = [[], []]; // 3  for (let i = 1; i \u0026lt; n; i++) { if (pivot \u0026gt; arr[i]) { leftArr.push(arr[i]); } else { rightArr.push(arr[i]); } } // 4  return [...quickSort(leftArr), pivot, ...quickSort(rightArr)]; }    遞迴停止條件：如果陣列內只剩一個元素就停止或陣列為空，也可以寫成 n \u0026lt;= 1。 選擇第一個元素作為基準。 比較元素，將元素分為左右兩邊。 遞迴、合併（小的放基準前面，大的放後面），也可以寫成 quickSort(left).concat([pivot], quickSort(rightArr))。  此版本雖然簡單好懂，但空間複雜度不佳，會消耗大量記憶體。\n2. 原地（in-place）劃分版本 原地（in-place）劃分版本是使用交換位置來劃分兩個區塊。\n將第一個元素作為 基準，比較元素後，會分成兩個區塊：\n 左邊區塊：比基準小的元素 右邊區塊：比基準大的元素，包含等於  流程：\n 右邊區塊第一個元素預設為第二個位置。 當遇到比基準小的值，會與右邊區塊的第一個值交換位置。 全部比較完畢後，基準與左邊區塊最後一個元素交換位置。  See the Pen 快速排序 - 劃分操作：第一個元素為基準 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  劃分操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function partition(arr, start, end) { const swap = (arr, a, b) =\u0026gt; [arr[a], arr[b]] = [arr[b], arr[a]]; // 1  const pivot = arr[start]; // 2  let firstRightIndex = start + 1; // 3  // 4  for (let i = start + 1; i \u0026lt;= end; i++) { // 5  if (arr[i] \u0026lt; pivot) { swap(arr, i, firstRightIndex); firstRightIndex += 1; } } const lastLeftIndex = firstRightIndex - 1; // 6  swap(arr, start, lastLeftIndex); return lastLeftIndex; }    陣列交換位置函式 將第一元素作為基準元素。 紀錄目前左邊區塊的第一元素位置，預設為基準元素的下一個。 從第二個元素開始遍歷至最後一個。 遇到比基準小的元素就交換，並遞增紀錄變數 firstRightIndex。 firstMaxIndex - 1 右邊區塊的第一元素位置的前一個就是左邊區塊最後一個元素。 最後回傳目前基準元素的位置，因為已經交換位置了，所以回傳 lastLeftIndex。  接下來回到函式本體：\n1 2 3 4 5 6 7 8 9  function quickSort(arr, start = 0, end = arr.length - 1) { if( start \u0026gt;= end) { return arr; } // 1  const pivotIndex = partition(arr, start, end); // 2  // 3  quickSort(arr, start, pivotIndex - 1); quickSort(arr, pivotIndex + 1, end); return arr; }    停止歸遞條件 執行劃分操作 歸遞  最終程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  function quickSort(arr, start = 0, end = arr.length - 1) { if (start \u0026gt;= end) { return arr; } const pivotIndex = partition(arr, start, end); quickSort(arr, start, pivotIndex - 1); quickSort(arr, pivotIndex + 1, end); return arr; function partition(arr, start, end) { const swap = (arr, a, b) =\u0026gt; ([arr[a], arr[b]] = [arr[b], arr[a]]); const pivot = arr[start]; let firstRightIndex = start + 1; for (let i = start + 1; i \u0026lt;= end; i++) { if (arr[i] \u0026lt; pivot) { swap(arr, i, firstRightIndex); firstRightIndex += 1; } } const lastLeftIndex = firstRightIndex - 1; swap(arr, start, lastLeftIndex); return lastLeftIndex; } }   3. 優化基準的選擇 快速排序時間複雜最佳的情況必須剛好 基準 為數列的中間值，如果選取到最小或最大值，則會是最糟的情況。那麼我們選擇第一個元素作為 基準，如果數列已是排序狀態，就會導致演算法時間複雜度是最糟結果。\n為了避免這種極端的 基準 出現，比較常見的做法為選取中間位置或是隨機選取作為 基準，選取到最小或最大值的機率會降低。\n取中間位置的元素，再比較前需先將元素換到開頭。\nSee the Pen 快速排序 - 劃分操作：中間元素為基準 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function partition(arr, start, end) { const swap = (arr, a, b) =\u0026gt; [arr[a], arr[b]] = [arr[b], arr[a]]; const mid = Math.floor((start + end) / 2); // 1  const pivot = arr[mid]; let firstRightIndex = start + 1; swap(arr, mid, start); // 2  for (let i = start + 1; i \u0026lt;= end; i++) { if (arr[i] \u0026lt; pivot) { swap(arr, i, firstRightIndex); firstRightIndex += 1; } } const lastLeftIndex = firstRightIndex - 1; swap(arr, start, lastLeftIndex); return lastLeftIndex; }    取中間位置索引。 將基準元素先換至開頭。  隨機選取基準：\n1 2 3 4 5  // 1 改成 const pivotIndex = Math.floor(Math.random() * (end - start + 1) + start); const pivot = arr[pivotIndex]; // 2 改成 swap(arr, pivotIndex, start);   See the Pen 快速排序 - 劃分操作：隨機選取基準 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  除了選取中間位置元素和隨機選取元素作為 基準，另外還有其他避免極端情況的優化方式：\n 三數中位數 Median of three 中位數的中位數 Median of medians  4. 迭代結構 跟合併排序一樣，當資料數量非常非常大時，歸遞結構的操作很容易導致 堆疊溢位，因此可以改寫成迭代結構。\n我們可以用陣列模擬堆疊空間，將待劃分區塊的 start 和 end 保存在裡面。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function quickSort1(arr) { const stack = []; stack.push(0); stack.push(arr.length - 1); while (stack.length \u0026gt; 0) { const end = stack.pop(); const start = stack.pop(); if (start \u0026lt; end) { const pivotIndex = partition(arr, start, end); stack.push(start); stack.push(pivotIndex - 1); stack.push(pivotIndex + 1); stack.push(end); } } return arr; }   分析 簡易分析，若每次都會將數列剛好劃分成一半，反覆劃分直到剩一個元素，需要操作 $\\log_{2}n$ 次。每次劃分操作每個元素都會執行比較，也就是 $n$ 次，因此整體執行時間約為 $n \\log_{2} n$。\n但 基準 如果選取到最小或最大值，每次劃分元素都會集中一邊，需要操作 $n$ 次 才會剩一個元素。因此整體執行時間會變成為 $n^2$。\n 不穩定排序 時間複雜度  最佳：$O(n \\log n)$ 最差：$O(n^2)$ 平均：$O(n \\log n)$   空間複雜度為：根據實現的方式不同而不同 ","description":"快速排序（Quick Sort） 是實用性很高的排序法，與合併排序一樣是使用 分治法的應用。","id":26,"section":"posts","tags":["排序演算法","快速排序","w3HexSchool"],"title":"JavaScript 學演算法（十）- 快速排序","uri":"https://chupai.github.io/posts/2000601_sort_algorithm_quick_sort/"},{"content":"這週是六角鼠年鐵人賽第十七週，這週簡單說明 合併排序（Merge Sort）。\n\r合併排序（Merge Sort） 合併排序（Merge Sort） 又稱為 歸併排序，是建立在合併操作上的一種有效的排序演算法，是採用 分治法 的一個非常典型的應用。\n分治法（Divide and Conquer）簡單來說就是將問題分成兩個子問題或更多的子問題，再繼續將子問題分解成更小的子問題，直到可以簡單求解，接著將所有子問題的結果合併，就能求得元問題的解。分治法一般會使用遞迴實現。\n操作流程，採用分治法，分為兩個操作：\n 分割：將數列平均分割成兩半，重複操作直到區塊中只剩一個元素。 合併：接著再將各個子陣列合併，合併時會反覆比較第一個數，並將較小的元素移至上一層中。重複操作直到剩一個數列，排序完畢。  合併排序的實現有兩種方法：\n 遞迴結構（自頂向下 Top-down） 迭代結構（自底向上 Bottom-up）  一般來說，合併排序是使用遞迴結構來實現的，但遞迴有一個問題，就是需要使用到額外空間來儲存子陣列，而且當遞迴函式被呼叫的過於頻繁，可能導致 堆疊溢位。\n為了優化合併排序（迭代結構），我們可以跳過分割這個操作，也就是一開始就將它們視為已分割狀態，比較相鄰兩個元素進行合併操作，每輪進行合併操作的元素都會翻倍成長。\n遞迴結構實作 遞迴結構一共需要兩個函式，並透過遞迴函式的方式來處理。\n1. 分割操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function mergeSort(arr) { const n = arr.length; // 1  // 2  if (n \u0026lt; 2) { return arr; } const midIndex = Math.floor(n / 2); // 3  // 4  const leftArray = arr.slice(0, midIndex); const rightArray = arr.slice(midIndex); // 5  mergeSort(leftArray); mergeSort(rightArray); }    陣列元素數量。 遞迴停止條件：如果陣列內只剩一個元素就停止或陣列為空。 取陣列的中間索引。 使用 slice() 將陣列分割成兩個子陣列。 使用遞迴繼續分割兩個子陣列。  2. 合併操作 合併操作函式，會傳入兩個陣列，並依元素大小排序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function merge(leftArr, rightArr) { const temp = []; // 1  // 2  while (leftArr.length \u0026amp;\u0026amp; rightArr.length) { // 3  if (leftArr[0] \u0026lt; rightArr[0]) { temp.push(leftArr.shift()); } else { temp.push(rightArr.shift()); } } return temp.concat(leftArr, rightArr); // 4 }    宣告變數儲存合併結果。 while 迴圈終止條件：當一個陣列為空就跳出迴圈。 比較大小後，使用 shift() 將元素刪除，並加到結果陣列中。 將剩餘元素的陣列與結果合併。  以上實作法方邏輯上沒問題，網路上很多文章的範例也都是這樣實作的（包含 維基百科） 。\n但 shift 方法背後原理操作，在刪除第一個元素後，其餘的元素都會往前移動，其實並不高效。\n因此建議使用以下方式來實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  function merge(leftArr, rightArr) { const temp = []; // 1  let [leftIndex, rightIndex] = [0, 0]; // 2  // 3  while (leftIndex \u0026lt; leftArr.length \u0026amp;\u0026amp; rightIndex \u0026lt; rightArr.length) { if (leftArr[leftIndex] \u0026lt; rightArr[rightIndex]) { // 4  temp.push(leftArr[leftIndex]); leftIndex += 1; } else { temp.push(rightArr[rightIndex]); rightIndex += 1; } } // 5  while (leftIndex \u0026lt; leftArr.length) { temp.push(leftArr[leftIndex]); leftIndex += 1; } while (rightIndex \u0026lt; rightArr.length) { temp.push(rightArr[rightIndex]); rightIndex += 1; } return temp; }    宣告變數儲存合併結果。 宣告變數來紀錄當前索引。 while 迴圈終止條件：當前索引大於陣列長度，表示這個陣列都加到結果陣列中了。 比較大小後，將元素放進結果陣列中，並將當前索引往前（+1）。 將剩餘元素的陣列與結果合併。  更簡潔的寫法：\n1 2 3 4 5  // 4 temp.push(leftArr[leftIndex++]); // 5 return [...temp, ...leftArr.slice(leftIndex), ...rightArr.slice(rightIndex)];   以下為使用 shift() 和使用索引兩種方式的簡易的執行時間比較，你可以發現，雖然 shift() 實作簡潔好理解，但執行速度差異非常大。\nSee the Pen 合併排序（Merge Sort） by Chupai@Design (@chupai) on CodePen.  3. 完成演算法 將分割的子陣列，呼叫 merge() 合併：\n1 2 3 4 5 6 7 8 9 10 11  function mergeSort(arr) { const n = arr.length; if (n \u0026lt; 2) { return arr; } const midIndex = Math.floor(n / 2); const leftArray = arr.slice(0, midIndex); const rightArray = arr.slice(midIndex); return merge(mergeSort(leftArray), mergeSort(rightArray)); }   完整程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  function mergeSort(arr) { const n = arr.length; if (n \u0026lt; 1) { return arr; } const midIndex = Math.floor(n / 2); const leftArray = arr.slice(0, midIndex); const rightArray = arr.slice(midIndex); return merge(mergeSort(leftArray), mergeSort(rightArray)); function merge(leftArr, rightArr) { const temp = []; let [leftIndex, rightIndex] = [0, 0]; while (leftIndex \u0026lt; leftArr.length \u0026amp;\u0026amp; rightIndex \u0026lt; rightArr.length) { if (leftArr[leftIndex] \u0026lt; rightArr[rightIndex]) { temp.push(leftArr[leftIndex++]); } else { temp.push(rightArr[rightIndex++]); } } return [...temp, ...leftArr.slice(leftIndex), ...rightArr.slice(rightIndex)]; } }   這種實作方式，並不會更改原陣列，會回傳一個排序後的新陣列。\n4. 優化版本 使用 slice() 分割陣列的方式，雖然簡潔好理解，但會額外使用很多記憶體空間，因此我們可以直接在原陣列上進行分割的操作。\n要在原陣列上進行分割操作，我們會使用紀錄索引位置的方式。\n一共需要傳入 start 開頭和 end 結尾，再計算出 mid 中間位置。\n 左子陣列為 start 至 mid 右子陣列為 mid + 1 至 end  1 2 3 4 5 6 7 8 9 10 11 12 13  // 1 function mergeSort(arr, start = 0, end = arr.length - 1) { if (start === end) { return arr; } // 2  const mid = Math.floor((start + end) / 2); // 3  // 4  mergeSort(arr, start, mid); mergeSort(arr, mid + 1, end); merge(arr, start, mid, end); // 3  return arr; }    start 和 end 的參數預設值為陣列開頭和結尾。 停止歸遞條件：開頭與結尾索引相同時就停止。 計算中間的索引位置。 歸遞 合併操作  合併操作函式，基本邏輯與原本的差不多，但最後一步不回傳排序好的陣列，而是用記錄下來的索引位置，直接覆蓋掉原陣列：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  function merge(arr, start, mid, end) { let temp = []; let [leftIndex, rightIndex] = [start, mid + 1]; // 1  while (leftIndex \u0026lt;= mid \u0026amp;\u0026amp; rightIndex \u0026lt;= end) { if (arr[leftIndex] \u0026lt; arr[rightIndex]) { temp.push(arr[leftIndex++]); } else { temp.push(arr[rightIndex++]); } } while (leftIndex \u0026lt;= mid) { temp.push(arr[leftIndex++]); } while (rightIndex \u0026lt;= end) { temp.push(arr[rightIndex++]); } // 3  for (let i = start; i \u0026lt;= end; i++) { arr[i] = temp[i - start]; } }    左右陣列起始索引。 終止條件：起始索引等於結尾索引。 將排序完的元素，覆蓋掉原陣列。  完整程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  function mergeSort(arr, start = 0, end = arr.length - 1) { if (start === end) { return arr; } const mid = Math.floor((start + end) / 2); mergeSort(arr, start, mid); mergeSort(arr, mid + 1, end); merge(arr, start, mid, end); return arr; function merge(arr, start, mid, end) { let temp = []; let [leftIndex, rightIndex] = [start, mid + 1]; while (leftIndex \u0026lt;= mid \u0026amp;\u0026amp; rightIndex \u0026lt;= end) { if (arr[leftIndex] \u0026lt; arr[rightIndex]) { temp.push(arr[leftIndex++]); } else { temp.push(arr[rightIndex++]); } } while (leftIndex \u0026lt;= mid) { temp.push(arr[leftIndex++]); } while (rightIndex \u0026lt;= end) { temp.push(arr[rightIndex++]); } for (let i = start; i \u0026lt;= end; i++) { arr[i] = temp[i - start]; } } }   此作法可以減少記憶體的使用（減少空間複雜度），但會更動原陣列。\n迭代結構實作 當資料數量非常非常大時，歸遞結構的操作很容易導致 堆疊溢位，因此可以改用迭代結構。\n上面實作完成後，你可以發現，我們可以直接跳過分割這個步驟，直接將它視為已分割後的狀態，直接進行合併操作。\n流程：\n 將陣列中相鄰兩個元素進行合併操作（排序）。 每輪進行操作的元素數量會翻倍成長。 當長度大於等於陣列元素數量，排序完畢。  1 2 3 4 5 6 7 8 9 10 11 12  function mergeSort(arr) { let n = arr.length; for (let i = 1; i \u0026lt;= n; i *= 2) { for (let j = 0; j + i \u0026lt; n; j += i * 2) { const start = j; const end = Math.min(j + i * 2 - 1, n - 1); const mid = j + i - 1; merge(arr, start, mid, end); } } return arr; }    i = 1：起始元素數量為 1。 i \u0026lt;= n：當元素數量大於等於 n 表示排序完畢。 i *= 2：每輪元素數量會翻倍。 j = 0：從頭開始取元素遍歷。 j + i \u0026lt; n：當索引 j + i 超過 n 表示這輪都合併操作過了。 j += i * 2：一次操作元素的數量會是 i 兩倍。 end：若要操作的元素索引大於陣列，就取陣列的最後一個元素。  完整程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  function mergeSort(arr) { let n = arr.length; for (let i = 1; i \u0026lt;= n; i *= 2) { for (let j = 0; j + i \u0026lt; n; j += i * 2) { const start = j; const end = Math.min(j + i * 2 - 1, n - 1); const mid = j + i - 1; merge(arr, start, mid, end); } } return arr; function merge(arr, start, mid, end) { let temp = []; let [leftIndex, rightIndex] = [start, mid + 1]; while (leftIndex \u0026lt;= mid \u0026amp;\u0026amp; rightIndex \u0026lt;= end) { if (arr[leftIndex] \u0026lt; arr[rightIndex]) { temp.push(arr[leftIndex++]); } else { temp.push(arr[rightIndex++]); } } while (leftIndex \u0026lt;= mid) { temp.push(arr[leftIndex++]); } while (rightIndex \u0026lt;= end) { temp.push(arr[rightIndex++]); } for (let i = start; i \u0026lt;= end; i++) { arr[i] = temp[i - start]; } } }   分析 簡易分析，假設資料為 $n$，分割操作可以略過不計。每輪操作的資料數量固定為 $n$，共會執行 $\\log_{2}n$ 輪合併操作，整體執行時間約為 $n \\log_{2}n$。\n 穩定排序 時間複雜度  最佳：$O(n \\log n)$ 最差：$O(n \\log n)$ 平均：$O(n \\log n)$   空間複雜度為： $O(n)$ ","description":"合併排序（Merge Sort） 又稱為 歸併排序，是建立在合併操作上的一種有效的排序演算法，是採用 分治法 的一個非常典型的應用。","id":27,"section":"posts","tags":["排序演算法","排序演算法","合併排序","w3HexSchool"],"title":"JavaScript 學演算法（九）- 合併排序","uri":"https://chupai.github.io/posts/200525_sort_algorithm_merge_sort/"},{"content":"這週是六角鼠年鐵人賽第十六週，資料結構先暫停一下，換換口味，來看排序。排序演算法（Sort Algorithm）是基礎演算法之一，是一種能將一串資料依照特定排序方式進行排列的一種演算法。\n\r什麼是排序（Sort） 1. 定義 排序（Sort），將一組資料一使用者需求，予以重新排列其順序。\n一般會依資料之大小順序排序（由大至小、或由小至大）。\n2. 分類 排序演算法分類方式有以下這幾種。\n第一類：內部與外部\n 內部排序（Internal Sort） 又稱「陣列排序」  定義：排序之工作，主要在主記憶體（RAM）完成。 意指資料量小，可以直接放在記憶體內進行。   外部排序（External Sort） 又稱「檔案排序」  定義：排序之工作，主要是在輔助記憶體（Disk, File）完成。 意指資料量大，無法直接存放在記憶體，必須先存放於輔助記憶體內再處理。    第二類：穩定性與不穩定性\n 穩定性（Stable）：相同值的資料，排序後順序和排序前一樣。 不穩定性（Unstable）：相同值的資料，排序後順序不一定和排序前一樣。  第三類：簡單與高等\n 簡單排序：排序演算法簡單，但執行時間較長。 高等排序：排序演算法複雜，執行時間較短。  第四類：比較與非比較\n 比較排序：通過比較來決定元素間的相對次序。 非比較排序：不通過比較來決定元素間的相對次序。  3. 常見排序演算法 排序相關動畫影片，可以稍微的看一下：\n 如何最有效率地整理書架？ - Chand John 15 Sorting Algorithms in 6 Minutes  簡單排序：\n 氣泡排序（Bubble Sort） 選擇排序（Selection Sort） 插入排序法（Insertion Sort）  初學排序所必須知道的三個最基本排序演算法，但它們由於速度不快而不實用。\n高等排序：\n 合併排序 Merge Sort 快速排序 Quick Sort 希爾排序 Shell Sort 堆積排序 Heap Sort  高等排序通常用於高效處理大量資料（幾萬起跳），不過有些對於資料過於小（幾千幾百）可能反而比簡單排序還慢。\n簡單排序 1. 氣泡排序（Bubble Sort） 氣泡排序（Bubble Sort）又稱為冒泡排序、泡沫排序，是排序演算法中最簡單的，但運行時間是最差的。\n其排序方式為相臨資料反覆進行比較，若發現資料順序不對，就將資料互換。資料將如氣泡般，從一端漂浮到另一端。\n流程模擬動畫：\nSee the Pen Sort Algorithm - Bubble Sort with Vue.js by Chupai@Design (@chupai) on CodePen.  遞增排列運作原理：\n 第一輪\n比較相鄰的元素，如果前者大於後者就相互交換；\n從頭到尾執行比較動作，可以確保最後一個元素將會是最大的。 第二輪\n扣除最後一個元素（已排序完畢元素），針對其餘元素重複上述步驟；  每輪執行比較的元素會越來越少，執行至剩一個元素，排序完畢。\n氣泡排序的過程範例：\nnums = [4, 2, 3, 1]; 第一輪 4 2 交換 =\u0026gt; 2 4 3 1 4 3 交換 =\u0026gt; 2 3 4 1 4 1 交換 =\u0026gt; 2 3 1 4 第二輪 2 3 不換 =\u0026gt; 2 3 1 4 3 1 交換 =\u0026gt; 2 1 3 4 第三輪 2 1 交換 =\u0026gt; 1 2 3 4 氣泡排序分析：\n 穩定排序 時間複雜度  最佳：$O(n)$ 最差：$O(n^2)$ 平均：$O(n^2)$   空間複雜度為： $O(1)$  演算法實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function bubbleSort (arr) { const n = arr.length; // 1  // 2  for(let i = 0; i \u0026lt; n - 1; i++) { // 3  for(let j = 0; j \u0026lt; n - 1 - i; j++) { // 4  if(arr[j] \u0026gt; arr[j + 1]) { // 5  const temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } return arr; }    元素數量。 執行 n - 1 輪（最後一次只剩自己，所以不比較）。 交換 n - 1 - i 次（兩兩互相比較，所以 -1，並扣除每輪已經排好的元素，所以減 i）。 比較大小。 元素交換位置。  交換位置也可以使用 ES6 的解構指定（destructuring assignment）：\n1  [arr[j], arr[j+1]] = [arr[j+1], arr[j]];   你可以建立一個交換函式，之後很多排序法都會用到：\n1 2 3 4 5 6 7 8  function swap(arr, index1, index2) { const temp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = temp; // - ES6 的方式  // [array[index1], array[index2]] = [array[index2], array[index1]]; }   氣泡排序的平均與最差的時間複雜度都是 $O(n^2)$，但最佳的情況（輸入陣列已是排序好的）時間複雜度為 $O(n)$（元素不做任何的交換）。\n要讓最佳的情況時間複雜度為 $O(n)$，需要優化一下程式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function bubbleSort (arr) { const n = arr.length; let swapped = true; for(let i = 0; (i \u0026lt; n - 1) \u0026amp;\u0026amp; swapped; i++) { swapped = false; for(let j = 0; j \u0026lt; n - 1 - i; j++) { if(arr[j] \u0026gt; arr[j + 1]) { swapped = true; swap(arr, j, j + 1); } } } return arr; }   加上一個標注（flag），在新的一輪開始時，判斷上一輪是否有發生交換，如果沒有表示剩餘的元素已經排序完畢，下一輪會因為 swapped 被設為 false 就會跳出迴圈。\n2. 選擇排序（Selection Sort） 選擇排序（Selection Sort） 是一種簡單直觀的排序演算法，類似氣泡排序。\n其排序方式為反覆進行搜數列中的最小值，並與最左側的資料交互。\n流程模擬動畫：\nSee the Pen Sort Algorithm - Selection Sort with Vue.js by Chupai@Design (@chupai) on CodePen.  遞增排列運作原理：\n 第一輪\n預設第一個元素為最小值，往右側進行搜尋最小值；\n若遇到比目前最小值還小的元素就替換掉；\n搜尋至最後，將最小值與最左側元素交換位置。 第二輪\n扣除第一個元素，針對其餘元素重複以上的步驟。  持續上述步驟，每輪執行比較的元素會越來越少，直到排序完畢。\n選擇排序的過程範例：\nnums = [4, 1, 3, 2]; 第一輪 min 4 (預設) min 1 交換位置 =\u0026gt; 1 4 3 2 第二輪 min 4 (預設) min 3 min 2 交換位置 =\u0026gt; 1 2 4 3 第三輪 min 4 (預設) min 3 交換位置 =\u0026gt; 1 2 3 4 選擇排序分析：\n 不穩定排序。 時間複雜度  Best Case：$O(n^2)$ Worst Case：$O(n^2)$ Average Case：$O(n^2)$   空間複雜度為： $O(1)$  演算法實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function selectionSort(arr) { const n = arr.length; // 1  // 2  for(let i = 0; i \u0026lt; n; i++) { // 3  let minIndex = i; // 4  for(let j = 1 + i; j \u0026lt; n; j++) { // 5  if(arr[j] \u0026lt; arr[minIndex]) { minIndex = j; } } swap(arr, i, minIndex); // 6  } return arr; }    元素數量。 執行 n 輪。 minIndex 用來紀錄最小值的索引。 因為 minIndex 預設為第一元素 j 從 1 開始尋找，每輪會扣除已排好的元素，所以加 i。 比較是否為最小值。 一輪結束後就將最小值與 i 交換。  選擇排序就算陣列已經是排序好的狀態，還是要經過多輪比較，所以不論是最好、最壞、平均的時間複雜度皆為 $O(n^2)$。但跟氣泡排序比起來，執行交換操作只需要 n 次。\n3. 插入排序（Insertion Sort） 插入排序（Insertion Sort）是也一種簡單直觀的排序演算法，你如果玩過撲克牌，就都有用過。\n其排序方式為，將左側作為已排序數列，右側為未排序數列，從未排序的數列中取第一個，放到已排序數列中的適當位置。\n流程模擬動畫：\nSee the Pen Sort Algorithm - Insertion Sort with Vue.js by Chupai@Design (@chupai) on CodePen.  遞增排列運作原理：\n 第一輪\n從第一個元素開始，該元素視為已經被排序；\n取出下一個元素，判斷要插入左側元素的前面還是後面。 第二輪\n已經被排序已有兩個元素；\n取出下一個元素，判斷要插入左側元素的前面還是後面；\n如果是前面就依序往下判斷。  持續上述步驟，右側位被排序的元素會遞減，直到排序完畢。\n插入排序的過程範例：\nnums = [4, 2, 3, 1]; 第一輪 [4] [2 3 1] [ 4] 2 [2 4] 第二輪 [2 4] [3 1] [2 4] 3 [2 3 4] 第三輪 [2 3 4] [1] [2 3 4] 1 [2 3 4] 1 [ 2 3 4] 1 [1 2 3 4] 分析：\n 穩定排序。 時間複雜度  Best Case：$O(n)$ Worst Case：$O(n^2)$ Average Case：$O(n^2)$   空間複雜度為： $O(1)$  演算法實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function insertionSort(arr) { const n = arr.length; // 1  // 2  for (let i = 1; i \u0026lt; n; i++) { let temp = arr[i]; // 3  let j = i; // 4  // 5  while (j \u0026gt; 0 \u0026amp;\u0026amp; temp \u0026lt; arr[j - 1]) { arr[j] = arr[j - 1]; // 6  j -= 1; } arr[j] = temp; // 7  } return arr; }    元素數量。 從第二個元素開始，所以 i = 1。 使用一個變數儲存要判斷元素的值。 使用一個變數儲存前要判斷元素的當前索引。 只要當前索引比 0 大，並且小於左側的值，就繼續比較。 將左側的值往後移。 將要判斷元素的值插入正確位置上。  4. 總結 這三種簡單演算法複雜度基本上差不多：\n   排序方法 最佳時間 最差時間 平均時間 空間 穩定性     氣泡 Bubble $O(n)$ $O(n^2)$ $O(n^2)$ $O(1)$ 穩定   選擇 Selection $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不穩定   插入 Insertion $O(n)$ $O(n^2)$ $O(n^2)$ $O(1)$ 穩定    這是一個簡易的執行時間計時器，對 100 ~ 10000 個隨機數字進行排序。\nSee the Pen Simple Sorting Algorithm EXECUTION TIME by Chupai@Design (@chupai) on CodePen.  執行時間會根據執行環境而有所不同，不過基本上元素數量越小，看不出彼此間的差異，但你可以觀察到當元素達到 10000 時，氣泡排序明顯是最差的，而插入排序稍微快於選擇排序。\n不過這三種排序法，資料量非常大時（幾十萬起跳），基本上都要跑很久，所以實際應用上都不適合，下週來看比較實用的合併排序。\n","description":"排序演算法（Sort Algorithm）是基礎演算法之一，是一種能將一串資料依照特定排序方式進行排列的一種演算法。","id":28,"section":"posts","tags":["排序演算法","氣泡排序","插入排序","選擇排序","w3HexSchool"],"title":"JavaScript 學演算法（八）- 排序演算法","uri":"https://chupai.github.io/posts/200518_sort_algorithm/"},{"content":"這週是 六角鼠年鐵人賽 第十五週，這週來看具有不重父元素特性的資料結構，「集合」 \u0026amp;「 映射」。\n\r集合（Set） 集合（Set） 是一組無順序且唯一的資料所組成的資料結構，概念衍生自數學的「集合」。\n特性：\n 無序性：集合內各元素無特定排序或排序不重要。 互異性：集合內每個元素且只能出現一次。 確定性：給定一個集合，任給一個元素，該元素或者屬於或者不屬於該集合，二者必居其一。  基本操作：\n 檢查某元素是否在集合內 新增元素 刪除元素。  集合的基本操作，沒有取得指定元素的操作，這是因為集合是無序的資料結構，沒有索引或鍵名可以快速取得元素，必須透過迭代來查詢。\n運算：\n 聯集：將兩個集合的元素合併成一個新集合（元素不重複）。 交集：將兩個集合中共有的元素，組成一個新集合。 對稱差：將兩個集合中不重複的元素，組成一個新集合。 差集：給定兩集合，回傳一個包含存在第一個集合元素但不存在於第二集合的集合  JavaScript 實作集合 JavaScript 在 ES6 就新增了 Set 物件，但我們這裡嘗試使用物件模擬簡易的 Set。\n1. 建立類別 1 2 3 4 5 6  class MySet { constructor() { this.items = {}; } // methods }   裝資料的容器 items 使用物件而非陣列，是因為 JavaScript 的物件屬性不會重複，可以確保集合內的元素都是唯一的。\n2. 方法 基本操作：\n add(element)：新增元素。 delete(element)：移除元素。 has(element)：檢查元素是否存在。  因為 add 和 delete 方法會用到 has 方法，所以先來實現 has 方法。可以使用 in 關係運算子，來判斷元素是否是 items 物件的屬性：\n1 2 3  has(element) { return element in this.items; }   或是使用 hasOwnProperty() 來判斷物件是否有該屬性：\n1 2 3  has(element) { return this.items.hasOwnProperty(element); }   如果你有使用 ESLint 會拋出 錯誤，可以改成 Object.prototype.hasOwnProperty.call(this.items, element)。\n新增元素 add 方法，必須先檢查元素是否存在，如果元素已存在就跳出：\n1 2 3 4  add(element) { if (this.has(element)) return; this.items[element] = element; }   刪除元素 delete 方法，也要檢查元素是否存在，如果元素已存在就刪除：\n1 2 3 4 5  delete(element) { if (this.has(element)) { delete this.items[element]; } }   其餘輔助屬性方法：\n clear()：清空。 size()：元素數量。 values()：回傳一個包含所有元素的陣列。  最終程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class MySet { constructor() { this.items = {}; } has(element) { return Object.prototype.hasOwnProperty.call(this.items, element); } add(element) { if (this.has(element)) return; this.items[element] = element; } delete(element) { if (this.has(element)) { delete this.items[element]; } } clear() { this.items = {}; } size() { return Object.keys(this.items).length; } values() { return Object.values(this.items); } }   建立實體：\n1 2 3 4 5 6 7 8 9  const set = new MySet(); set.add(1); set.add(2); set.add(3); console.log(set.values()); // [1, 2, 3]  set.delete(1); console.log(set.values()); // [2, 3]   因為是簡易的 Set，所以有很多問題，例如：物件的屬性只能儲存字串，如果元素值為其他的型別都會被強制轉型成字串。\n3. ES6 原生 Set Set 只能使用建構式建立：\n1  new Set([iterable]);   能夠接受一個參數 iterable（可迭代物件）。\n1 2 3 4 5  const set1 = new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); console.log(set1); // Set {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;}  const set2 = new Set(\u0026#39;Hello\u0026#39;); console.log(set2); // Set {\u0026#39;H\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;}   屬性方法：\n add()：新增元素。 clear()：移除其所有元素。 delete()：移除指定元素。 has()：檢查員素是否存在。 values()：回傳一個 Iterator 物件，包含著 Set 物件中所有元素，由插入順序排序。 size：元素數量。 forEach()：迭代處理元素，用法等同陣列的 forEach()。  1 2 3 4 5 6 7 8 9  const set = new Set(); set.add(\u0026#39;a\u0026#39;); set.add(\u0026#39;b\u0026#39;); set.add(\u0026#39;c\u0026#39;); console.log(set); // Set {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;}  set.delete(\u0026#39;b\u0026#39;); console.log(set);    更詳細內容請參考 MDN。\n 集合操作 使用 ES6 原生 Set。\n1. 聯集 創建一個函式，回傳兩個集合中所有元素的新集合。\n最基本的作法就是迭代集合，將元素新增至新集合中：\n1 2 3 4 5 6  function uion(set1, set2) { const newSet = new Set(); set1.forEach(item =\u0026gt; newSet.add(item) ); set2.forEach(item =\u0026gt; newSet.add(item) ); return newSet; }   更簡單的的作法就是，使用展開運算子（spread operator），將兩個集合在一個陣列中展開，並建立新集合。\n1 2 3  function union(set1, set2) { return new Set([...set1, ...set2]); }   1 2 3 4  const set1 = new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); const set2 = new Set([\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;]); console.log(union(set1, set2)); // Set {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;}   2. 交集 將兩個集合中共有的元素，組成一個新集合。\n1 2 3 4 5 6 7 8 9  function intersection(set1, set2) { const temp = new Set(); set1.forEach(item =\u0026gt; { if(set2.has(item)) { temp.add(item); } }); return temp; }   使用 has() 去檢查元素。\n1 2 3 4  const set1 = new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); const set2 = new Set([\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;]); console.log(intersection(set1, set2)); // Set {\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;}   3. 對稱差 將兩個集合中不重複的元素，組成一個新集合。\n1 2 3 4 5 6 7 8 9 10 11  function difference(set1, set2) { const temp = union(set1, set2); const intersectionSet = intersection(set1, set2); intersection.forEach(item =\u0026gt; { if(temp.has(item)) { temp.delete(item); } }); return temp; }   簡單來說就是聯集減去交集。\n1 2 3 4  const set1 = new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); const set2 = new Set([\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;]); console.log(difference(set1, set2)); // Set {\u0026#39;b\u0026#39;, \u0026#39;e\u0026#39;}   4. 差集 給定兩集合，回傳一個包含存在第一個集合元素但不存在於第二集合的集合。\n1 2 3 4 5 6 7 8 9  function subtracting(set1, set2) { const temp = new Set(set1); set2.forEach((item) =\u0026gt; { if (temp.has(item)) { temp.delete(item); } }); return temp; }   先複製 set1 再減去 set2 擁有的元素。\n或者是新建一個集合，再將沒重複的元素新增至新集合中：\n1 2 3 4 5 6 7 8 9  function subtracting(set1, set2) { const temp = new Set(); set2.forEach((item) =\u0026gt; { if (!temp.has(item)) { temp.add(item); } }); return temp; }   1 2 3 4  const set1 = new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); const set2 = new Set([\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;]); console.log(subtracting(set1, set2)); // Set {\u0026#39;b\u0026#39;}   5. 子集 檢查該集合是是否為另一個集合的子集。\n1 2 3 4 5 6 7 8  function subSet(set1, set2) { if (set1.size \u0026gt; set2.size) return false; for (let item of set1) { if (!set2.has(item)) return false; } return true; }   forEach 沒辦法 return 所以我們使用 for of 來迭代 Set。\n1 2 3 4 5  console.log(subSet(new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]), new Set([\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;]))); // false  console.log(subSet(new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]), new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;]))); // true   映射（Map） 映射（Map）或稱 關聯陣列（Associative Array）、字典（Dictionary）是一種以「鍵值對 {key: value} 」形式儲存的有序資料結構，會根據不同語言有不同的名稱。\n映射，就如同電話簿中的名字和號碼一樣，先找到名字，就知道它的電話號碼。鍵（key）就是姓名，而值（value）如同電話號碼。\n定義：\n key 一定對映 value 一個映射不能包含重複的 key 每個 key 最多只能對映到一個 value  基本操作：\n 新增 刪除 查詢  JavaScript 中的映射 JavaScript 的物件物件本質上是鍵值對的資料結構，當你需要將 key 對應到 value 時，可以將字串作為 key 對應到任何型別的 value，搭配 in、delete、[] 等，能達到映射的相關操作。\n然而，物件終究不是映射類型，可能會遇到以下問題：\n 因為物件原型的特性，因此可能對應到意外的東西。 不易知道物件裡有多少對應。 物件無法使用非字串值作為 key。 無法保證 key 的順序。  請考慮以下情況，物件無法使用非字串值作為屬性名：\n1 2 3 4 5 6 7 8 9  const m = {}; const x = { id: 1 }; const y = { id: 1 }; m[x] = \u0026#39;foo\u0026#39;; m[y] = \u0026#39;bar\u0026#39;; console.log(m[x]); // bar   你可以發現 { id: 1 } 被強制轉型成字串，m[x] 與 m[y] 指向同一個屬性。\n1. ES6 原生 Map 物件 JavaScript 在 ES6 實現了 Map 物件，就是字典。\nMap 只能使用建構式建立：\n1  new Map([iterable]);   iterable 基本上為陣列（或其他元素成鍵值對的可迭代物件）。\n用法如下：\n1 2 3 4 5 6  const m = new Map([ [\u0026#39;a\u0026#39;, 1], [\u0026#39;b\u0026#39;, 2], ]); console.log(m); // Map { \u0026#39;a\u0026#39; =\u0026gt; 1, \u0026#39;b\u0026#39; =\u0026gt; 2 }   陣列的第一個項目就 key，第二個為 value。\n或是使用 Object.entries 方法，它回傳的格式就如同上面所需要的：\n1 2 3 4 5 6  const obj = { a: 1, b: 2 }; const iterable = Object.entries(obj); console.log(iterable); // [ [ \u0026#39;a\u0026#39;, 1 ], [ \u0026#39;b\u0026#39;, 2 ] ]  const m = new Map(iterable); console.log(m); // Map { \u0026#39;a\u0026#39; =\u0026gt; 1, \u0026#39;b\u0026#39; =\u0026gt; 2 }   也就是說可以使用此方法將物件轉成 Map。\n存取元素的方法為：\n set(key, value)：根據 key 存儲 value。 get(key)：根據 key 回傳 value，如果 map 中該 key 不存在，回傳 undefined。  1 2 3 4 5 6  const m = new Map(); m.set(\u0026#39;a\u0026#39;, 1); console.log( m.get(\u0026#39;a\u0026#39;) ); // 1 console.log( m.get(\u0026#39;b\u0026#39;) ); // undefined   set() 會回傳當前 map 實體，因此可以採鏈式寫法：\n1 2 3 4 5  const m = new Map(); m.set(\u0026#39;a\u0026#39;, 1) .set(\u0026#39;b\u0026#39;, 2) .set(\u0026#39;c\u0026#39;, 3);   移除元素需要使用 delete(key)，而不是 delete 運算子，而 has(key) 可以判斷 key 是否存在。\n1 2 3 4 5 6 7 8  const m = new Map([ [\u0026#39;a\u0026#39;, 1], [\u0026#39;b\u0026#39;, 2] ]); console.log( m.has(\u0026#39;a\u0026#39;) ); // true m.delete(\u0026#39;a\u0026#39;); console.log( m.has(\u0026#39;a\u0026#39;) ); // false   Map 與物件另一個最大差異就是有 forEach 方法和可以使用 for of 迭代：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const m = new Map([ [\u0026#39;a\u0026#39;, 1], [\u0026#39;b\u0026#39;, 2], [\u0026#39;c\u0026#39;, 3], ]); m.forEach((value, key) =\u0026gt; { console.log(value, key); }); // 1 \u0026#39;a\u0026#39; // 2 \u0026#39;b\u0026#39; // 3 \u0026#39;c\u0026#39;  for (let key of m) { console.log(key); } // [\u0026#39;a\u0026#39;, 1] // [\u0026#39;b\u0026#39;, 2] // [\u0026#39;c\u0026#39;, 3]    更詳細內容請參考 Map。\n 2. WeakMap 除了 Map，ES6 還新增了 WeakMap。\nWeakMap 與 Map 基本上一樣，除了以下幾點：\n WeakMap 的 key 只接受物件作為 key 。 WeakMap 的 key 所指向的物件可以被垃圾回收。 WeakMap 無法被迭代或清除。  1 2 3 4 5 6  const wm = new WeakMap(); const obj = {}; wm.set(obj, 1); // 正常 wm.set(\u0026#39;a\u0026#39;, 2); // Uncaught TypeError Invalid value used as weak map key   WeakMap 只有以下屬性方法：\n get(key) set(key, value) delete(key) has(key)  size、values()、entries()、forEach() 等皆沒有。\nWeakMap 對 key 引用是「弱引用」，這意味著若沒有其他引用存在時，垃圾回收機制就會釋放該物件所佔用的記憶體空間。因此 WeakMap 被設計成無法迭代。\n舉例來說，我們使用一個 Map 來記錄用戶的訪問次數：\n1 2 3 4  let john = { name: \u0026#39;John\u0026#39; }; const visitsCountMap = new Map(); visitsCountMap.set(john, 1);   某天這個用戶都不會來了，所以我們不需要它的訪問資料了，我們如果只有移除 john 的指向，map 內的內容還是會存在：\n1 2 3  john = null; console.log( visitsCountMap.size ); // 1   因為還需要清除 map 的內容，所以不能先移除 john 的指向，需要改成先移除 map 內的引用，再移除 john 的指向：\n1 2 3 4 5 6 7  // 上段程式碼改成這樣  visitsCountMap.delete( john ); console.log( visitsCountMap.size ); // 0  // 清除 map 的內容再移除指向 john = null;   但這樣的資料移除非常麻煩，因此就有了 WeakMap：\n1 2 3 4 5  let john = { name: \u0026#39;John\u0026#39; }; const visitsCountWeakMap = new WeakMap(); visitsCountWeakMap.set(john, 1); john = null;   { name: 'John' } 這個物件，除了 WeakMap 沒有其他引用了，所以這個物件會自動的從記憶體和 visitsCountWeakMap 中刪除。\n 更詳細內容請參考 WeakMap。\n","description":"這週是六角鼠年鐵人賽第十五週，這週來看具有不重複元素特性的資料結構，「集合」與「 映射」。","id":29,"section":"posts","tags":["資料結構","集合","映射","w3HexSchool"],"title":"JavaScript 學演算法（七）- 集合 \u0026 映射","uri":"https://chupai.github.io/posts/200517_ds_set_map/"},{"content":" JavaScript筆記 目錄\n \rDate 物件 JavaScript 沒有日期資料型態，但是它有提供 Date 物件，使用內件的日期物件與方法、可以取得與操作日期時間。\nDate 物件以世界標準時間（UTC） 1970 年 1 月 1 日為零點，範圍為前後各 1 億天（+-100,000,000），單位為毫秒。\nDate 物件只能由 new Date() 作為建構器來產生，如果 Date() 作為普通函式直接呼叫，會回傳當前時間的字串，而非 Date 物件：\n1 2  console.log( Date ); // \u0026#34;Sat Jan 11 2020 06:49:39 GMT+0800 (台北標準時間)\u0026#34;   1. 多時區  UTC 指的是世界協調時間（Coordinated Universal Time）。 GTM 指格林威治標準時間（Greenwich Mean Time）。  GMT 和 UTC 在一般使用的情況下沒有差別，你要說台灣的時區是 UTC+8 或是 GMT+8 都可以。\n 偏移（offset） 指的是某地區與 UTC 偏移的時間，例如 +08:00 表示該地區的時間比 UTC 快了 8 小時。 夏日時間（Daylight Saving Time, DST）  建立 Date 物件 new Date() 的使用方法基本為四種：\n1 2 3 4  new Date(); new Date(milliseconds); new Date(dateString); new Date(year, month, date, [hours, minutes, seconds, ms]);   1. 不帶參數 new Date() 不帶參數，表示當前日期和時間的 Date 物件。\n1 2 3 4  let now = new Date(); console.log( now ); // Sat Jan 11 2020 06:41:55 GMT+0800 (台北標準時間)   2. milliseconds new Date(milliseconds)，milliseconds 表示從 1970-01-01 00:00:00 UTC+0 開始所經過的毫秒數。\n1 2 3 4 5  console.log( new Date(0) ); // Thu Jan 01 1970 08:00:00 GMT+0800 (台北標準時間)  console.log( new Date(24 * 3600 * 1000) ); // 增加 24 小時 // Fri Jan 02 1970 08:00:00 GMT+0800 (台北標準時間)   3. datestring new Date(datestring)，datestring 表示一個日期或時間格式的字串，該參數會通過 Date.parse 算法解析字串。\n注意時間格式，你可以發現，不同的時間格式，會有不同的結果：\n1 2 3 4 5  console.log(new Date(\u0026#39;2020/01/01\u0026#39;)); // Wed Jan 01 2020 00:00:00 GMT+0800 (台北標準時間)  console.log(new Date(\u0026#39;2020-01-01\u0026#39;)); // 多了8小時 // Wed Jan 01 2020 08:00:00 GMT+0800 (台北標準時間)   這是因為 2020-01-01 方式建立的 Date 物件，會被瀏覽器解析為格林威治標準時間的日期，但台灣本地時間會多 8 個小時，因此顯示上會自動加上。\n日期或時間格式字串定義，其實有特定要求（ISO8601）：\nYYYY-MM-DDTHH:mm:ss.sssZ 遵循上述規格是最安全的用法。\n 日期 YYYY-MM-DD：年-月-日 字串 \u0026quot;T\u0026quot;：是一個分隔符 時間 HH:mm:ss.sss：小時、分鐘、秒、毫秒 可選字串 \u0026quot;Z\u0026quot;：代表時區，單個字符 Z 代表 UTC+0  4. 時間單位 new Date(year, month, [date, hours, minutes, seconds, ms])\n 必要參數：年、月  年（必須是四位數） 月（月份是從 0（一月）開始到 11（十二月））   選擇性的參數：日、時、分、秒、毫秒  日（預設為 1） 時、分、秒、毫秒（預設為 0）    1 2  console.log( new Date(2020,0) ); // Wed Jan 01 2020 00:00:00 GMT+0800 (台北標準時間)   如果超出正確範圍內的數字會自動轉換成對應時間：\n1 2  console.log( new Date(2020, 0, 31, 25) ); // Sat Feb 01 2020 01:00:00 GMT+0800 (台北標準時間)   獲取/設定 1. 獲取 從 Date 物件取的相對應的時間數值（number）：\n getFullYear()：年份（四位數） getMonth()：月份從 0 到 11 getDate()：當月的日期，從 1 到 31 getHours()：時 getMinutes()：分 getSeconds()：秒 getMilliseconds()：毫秒 getDay()：獲取一週中的第幾天，0（星期天）到 6（星期六）  1 2 3 4 5 6 7 8 9  let today = new Date(); console.log( today.getFullYear() ); // 2020 console.log( today.getMonth() ); // 0 console.log( today.getDate() ); // 11 console.log( today.getHours() ); // 8 console.log( today.getSeconds() ); // 35 console.log( today.getMilliseconds() ); // 111 console.log( today.getDay() ); // 6   以上所有的方法回傳的訊息都是基於當地時區的。\n如果要獲取標準時間，則可以加上 UTC，例如 getUTCHours()：\n1  console.log( today.getUTCHours() ); // 0   2. 設定 以下方法可以設置時間訊息：\n setFullYear(year [, month, date]) setMonth(month [, date]) setDate(date) setHours(hour [, min, sec, ms]) setMinutes(min [, sec, ms]) setSeconds(sec [, ms]) setMilliseconds(ms)  以上方法會回傳改變後的時間戳，另外，也都有對應的 UTC 版本，例如 setUTCHours()。\n3. 結合使用 獲取/設定 方法結合使用，得到相對時間：\n1 2 3 4 5 6 7 8  let d = new Date(); // 將日期向後推1000天 console.log( d.setDate(d.getDate() + 1000) ); // 將時間設為6小時後 console.log( d.setHours(d.getHours() + 6) ); // 將年份設為去年 console.log( d.setFullYear(d.getFullYear() - 1) );   時間戳（Timestamp） 時間戳（Timestamp）從 1970-1-1 00:00:00 UTC+0 開始的毫秒數。\nDate 的靜態方法：\n Date.now()：回傳當前時間的時間戳。 Date.parse()：解析日期或時間格式的字串，回傳該時間的時間戳。 Date.UTC()：需要傳入與建構器相同的參數（即年月日等等參數），回傳該時間的時間戳。  1 2 3 4  console.log( Date.now() ); // 1578705450196 console.log( Date.parse(\u0026#39;2020-01-01\u0026#39;) ); // 1577836800000 console.log( Date.parse(\u0026#39;2020/01/01\u0026#39;) ); // 1577808000000 console.log( Date.UTC(2020, 0, 1) );   Date 物件轉時間戳的方法：\n getTime()：回傳日期的時間戳  1 2 3  let time = new Date(2020, 0, 1); console.log( time.getTime() ); // 1577808000000   如果將 Date 物件轉成數值（呼叫 valueOf()），相當於 getTime() 方法：\n1  console.log( Number(time) ); // 1577808000000   1. Unix 時間戳 一般來說，後端給的時間會是以秒為單位的 Unix 時間戳，而 JavaScript 的時間戳為毫秒。\n目前取得 Unix 時間戳 最簡單和快速的方式是：\n1 2 3 4 5 6  const dateTime = Date.now(); const timestamp = Math.floor(dateTime / 1000); // 或是 const dateTime = new Date().getTime(); const timestamp = Math.floor(dateTime / 1000);   轉換格式  toString()：回傳完整的日期字串。 toUTCString()：回傳 UTC 時間。 toISOString()：回傳 ISO8601 格式。 toJSON()：回傳符合 JSON 格式的 ISO 日期字串，與 toISOString() 回傳結果相同。 toDateString()：回傳日期字串，不含小時、分和秒 toTimeString()：回傳時間字串，不含年月日  1 2 3 4 5 6 7 8  let d = new Date(2020, 0, 1); console.log( d.toString() ); // \u0026#34;Wed Jan 01 2020 00:00:00 GMT+0800 (台北標準時間) \u0026#34; console.log( d.toUTCString() ); // \u0026#34;Tue, 31 Dec 2019 16:00:00 GMT\u0026#34; console.log( d.toISOString() ); // \u0026#34;2019-12-31T16:00:00.000Z\u0026#34; console.log( d.toJSON() ); // \u0026#34;2019-12-31T16:00:00.000Z\u0026#34; console.log( d.toDateString() ); // \u0026#34;Wed Jan 01 2020\u0026#34; console.log( d.toTimeString() ); // \u0026#34;00:00:00 GMT+0800 (台北標準時間)\u0026#34;   本地時間：\n toLocaleString()：完整的本地日期時間 toLocaleDateString()：本地日期，不含小時、分和秒 toLocaleTimeString()：本地時間，不含年月日  1 2 3 4 5  let d = new Date(2020, 0, 1); console.log(d.toLocaleString()); // \u0026#34;2020-1-1 00:00:00\u0026#34; console.log(d.toLocaleDateString()); // \u0026#34;2020-1-1\u0026#34; console.log(d.toLocaleTimeString()); // \u0026#34;00:00:00\u0026#34;   這三個方法都有兩個可選的參數\n locales：字串，指定所用語言 options：選項物件，設定格式化規則  格式化規則的詳細參數可以參考 Natively Format JavaScript Dates and Times。\n","description":"JavaScript 沒有日期資料型態，但是它有提供 Date 物件，使用內件的日期物件與方法、可以取得與操作日期時間。","id":30,"section":"posts","tags":["JavaScript","日期時間","Date 物件"],"title":"日期時間","uri":"https://chupai.github.io/posts/200516_js_date/"},{"content":" JavaScript筆記 目錄\n \rES6 為 {} 物件字面值新增了幾個方便擴充功能，以下只提幾個常用。\n簡寫 1. 屬性值簡寫 舉一個簡單的範例來說明。\n變數與屬性名相同，這種應用場景很常見：\n1 2 3 4 5 6 7 8  function foo(a, b) { return { a: a, b: b }; } console.log(foo(1, 2)); // {a: 1, b: 2}   但在 ES6 環境下，可以這樣寫：\n1 2 3 4 5  function foo(a, b) { return { a, b }; } console.log(foo(1, 2)); // {a: 1, b: 2}   當屬性名與值名稱相同時，可以省略後面的值。\n或者是：\n1 2 3 4 5  const foo = \u0026#39;bar\u0026#39;; const baz = {foo}; // 等同於 const baz = {foo: foo};   2. 方法簡寫 定義方法時，都會有 function 宣告。\n1 2 3 4 5 6 7  const obj = { foo: function(a) { console.log(a); }, }; obj.foo(1); // 1   在 ES6 環境下，可以省略這個 function 宣告：\n1 2 3 4 5 6 7  const obj = { foo(a) { console.log(a); }, }; obj.foo(1); // 1   但使用簡寫的放式，函式為不具名，而且無法使用箭頭函式。\n屬性名稱 在 ES6 新增了可計算的功能，可以利用 [] 包裹運算式，當作鍵名。\n1 2 3 4 5 6 7 8 9  let prefix = \u0026#39;foo\u0026#39;; let myObject = { [prefix + \u0026#39;bar\u0026#39;]: \u0026#39;hello\u0026#39;, [prefix + \u0026#39;baz\u0026#39;]: \u0026#39;world\u0026#39; }; myObject.foobar; // hello myObject[\u0026#39;foobaz\u0026#39;]; // world   ","description":"ES6 為物件字面值 {} 新增了幾個重要的方便擴充功能。","id":31,"section":"posts","tags":["JavaScript","物件字面值擴充功能","ES6"],"title":"物件字面值擴充功能","uri":"https://chupai.github.io/posts/200515_js_object_literal_extension/"},{"content":" JavaScript筆記 目錄\n \r解構指定 ES6 引進了一個新語法功能，解構指定（destructuring assignment）或稱解構賦值，可以想成是一種有結構的指定。\n在 JavaScript 中最常用的兩種資料結構為陣列與物件，而解構指定用於提取陣列或物件中的資料，存放到一系列的變數中。\n請考慮以下程式碼：\n1 2 3  function foo() { return [1, 2, 3]; }   如果有一個函式回傳了一個陣列，要將陣列中的內容一一用變數儲存。\n傳統作法為：\n1 2 3 4 5 6  var tmp = foo(); var a = tmp[0]; var b = tmp[1]; var c = tmp[2]; console.log(a, b, c); // 1 2 3   必須先將函式結果儲存，在一個一個宣告變數給值。\n但如果改用新語法：\n1 2 3  let [a, b ,c] = foo(); console.log(a, b, c); // 1 2 3   就這麼麼簡單。\n1. 陣列解構 陣列解構的基本語法：\n1 2 3  let [a,b] = [1, 2]; console.log(a, b); // 1 2   2. 物件解構 物件解構的基本語法：\n1 2 3  let { a, b } = { x: 1, y: 2 }; console.log(a, b); // 1 2   左邊實際上是 **物件字面值的簡短語法：\n1 2 3 4  // 等同 let { a: a, b: b } = { a: 1, b: 2 }; console.log(a, b); // 1 2   左側的屬性值屬於變數名稱：\n1 2 3  let { a: x, b: y } = { a: 1, b: 2 }; console.log(x, y); // 1 2   必須注意，左側的必須有對應的的屬性名才能指定：\n1 2 3  let { a } = { b: 1 }; console.log(a); // undefined   屬性順序並不重要，只要有對應的屬性名即可：\n1 2 3  let { a, b } = { b: 2, a: 1 }; console.log(a, b); // 1 2   允許同一個屬性被列出多次：\n1 2 3  let { a: x, a: y } = { a: 1 }; console.log(x, y); // 1 1   這表示能夠解構一個子物件，並且捕捉那個子物件，舉例來說：\n1 2 3 4 5 6 7 8  let { a: { x: X, x: Y }, a: a, } = { a: { x: 1 } }; console.log(X); // 1 console.log(Y); // 1 console.log(a); // { x: 1 }   子陣列也可以：\n1 2 3 4 5  let { a: X, a: Y, a: [Z] } = { a: [1] }; console.log(X); // [1] console.log(Y); // [1] console.log(Z); // 1   3. 不只是宣告 指定就是使用 = 運算子，所以解構指定不一定只能用在宣告上。\n舉例來說：\n1 2 3 4  let a,b; [a, b] = [1, 2]; console.log(a, b); // 1 2   變數已宣告，解構只負責進行指定動作。\n但如果是物件就需要注意：\n1 2 3  let a,b; {a, b} = {a:1, b: 2}; // SyntaxError: Unexpected token \u0026#39;=\u0026#39;   會拋出錯誤是因為 {a, b} 的 {} 被解析成區塊，而非物件字面值，因此可以加上 ()，避免這種情況：\n1 2 3 4  let a, b; ({ a, b } = { a: 1, b: 2 }); console.log(a, b); // 1 2   應用 交換值：\n1 2 3 4 5 6  let a = 1; let b = 2; [a, b] = [b, a]; console.log(a, b); // 2 1   建立物件映射（map）：\n1 2 3 4 5 6  let o1 = { a: 1, b: 2, c: 3 }; let o2 = {}; ({ a: o2.x, b: o2.y, c: o2.z } = o1); console.log(o2); // {x: 1, y: 2, z: 3}   或是將一個物件映射至陣列，或是反過來：\n1 2 3 4 5 6 7 8 9 10 11 12 13  let o1 = { a: 1, b: 2, c: 3 }; let a2 = []; ({ a: a2[0], b: a2[1], c: a2[2] } = o1); console.log(a2); // [1, 2, 3]  // 反過來 let a1 = [1, 2, 3]; let o2 = {}; [o2.a, o2.b, o2.c] = a1; console.log(o2); // {a: 1, b: 2, c: 3}   解構指定運算式 解構指定運算式會回傳右邊完整的物件或陣列。\n1 2 3 4  let o = {a:1, b:2}; let a,b; console.log({a,b} = o); // {a: 1, b: 2}   驗證：\n1 2 3 4 5 6  let obj = { a: 1, b: 2 }; let a, b, obj2; obj2 = { a, b } = obj; console.log(obj2 === obj); // ture   陣列也是如此：\n1 2 3 4 5 6  let arr = [1, 2]; let a, b, arr2; arr2 = [a, b] = arr; console.log(arr === arr2); // ture   解構的數量 不必指定所有出現的值：\n1 2 3 4 5 6 7 8 9  let [a] = [1, 2, 3, 4]; let [, b] = [1, 2, 3, 4]; console.log(a); // 1 console.log(b); // 2  let {c} = {a:1, b:2, c: 3}; console.log(c); // 3   也可以留空來略過某些值。\n如果指定過多的值，變數沒有對應值，內容就會是 undefined。\n1 2 3 4 5 6 7  let [a, b, c] = [1, 2]; console.log(c); // undefined  let { x, y } = { x: 1 }; console.log(y); // undefined   1. 展開運算子 在解構中，使用展開運算子，將會收集那些多出來的值。\n陣列：\n1 2 3 4  let [a, ...b] = [1, 2, 3, 4]; console.log(a); // 1 console.log(b); // [2, 3, 4]   物件：\n1 2 3 4  let { a, ...b } = { a: 1, b: 2, c: 3, d: 4 }; console.log(a); // 1 console.log(b); // {b: 2, c: 3, d: 4}   預設值 使用類似預設函式引數的 = 語法，就可以給予變數預設值。\n1 2 3 4 5 6 7 8 9  let [a = 1, b = 2] = [10]; console.log(a); // 10 console.log(b); // 2  let { x = 5, y = 10 } = { x: 20 }; console.log(x); // 20 console.log(y); // 10   參數解構 一個簡單的函式與呼叫：\n1 2 3 4 5  function foo(x) { console.log(x); } foo(42);   foo(42) 執行的時候，引數 42 被指定給了參數 x。由上述可合理推論解解構指定，當然也可以用於函式參數。\n參數的解構：\n1 2 3 4 5 6 7 8 9 10  function foo([a, b]) { console.log(a, b); } function boo({ a, b }) { console.log(a, b); } foo([1, 2]); // 1 2 boo({ a: 1, b: 2 }); // 1 2   1. 預設值 上面有提到解構賦值也能給予預設值，函式參數也能給預設值，因此必須留意兩者之間的行為差異。\n1 2 3 4 5 6 7 8 9  function foo({ x = 10 }) { console.log(x); } foo(123); // 10 foo(1); // 10 foo([]); // 10 foo({}); // 10 foo(); // TypeError   輸入的引數，沒有對應的值將會使用預設值，但如果引數是空的將會拋出錯誤。\n因此可以使用參數預設值來解決，預設給予一個空物件：\n1 2 3 4 5 6 7 8  function foo({ x = 10 } = {}) { console.log(x); } foo(123); // 10 foo(1); // 10 foo([]); // 10 foo({}); // 10 foo(); // 10   別寫成這樣：\n1 2 3 4 5  function foo({ x } = { x: 10 }) { console.log(x); } foo(); // 10   雖然當引數沒有傳入，也會得到預設值，但完全是不同意思。\n1 2 3 4 5 6  // 承接上方程式碼  foo(123); // undefined foo(1); // undefined foo([]); // undefined foo({}); // undefined   第一種作法為，當引數沒輸入會套用空物件，不論引數是啥，都會套用 { x: 10 } 來解構。\n而第二種做法則是將 { x: 10 } 作為參數預設值，而非解構預設值，因此只在引數沒被輸入時適用，如果輸入的引數無法解構，都會獲得 undefined 的結果。\n1. 具名參數 有時候一個函式可能會有許多參數，舉例來說：\n1 2 3  function showMenu(title, width, height, items) { // ... }   當參數變多時，要輸入引數時，就必須記住輸入順序，才能正確輸入，而且當要插入新參數，以前所呼叫的函式會變得難以維護。\n因此這裡就可以用解構賦值語法來處理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function showMenu({ title = \u0026#39;new Title\u0026#39;, width = 200, height = 200, items = [], }) { //... } let options = { title: \u0026#39;My menu\u0026#39;, items: [\u0026#39;Item1\u0026#39;, \u0026#39;Item2\u0026#39;], }; showMenu(options);   具名參數的優點：\n 參數多的情況下，也容易理解程式意義 方便顯示可省略參數 自由變更參數順序  另外要注意，定義具名參數要記得給參數預設值空物件 {}，否則沒輸入引數會拋出錯誤。\n2. 其餘預算子 其餘預算子可以被解構，換句話說，可以把這個陣列解開，並將各個元素取出成為個別的變數。\n1 2 3 4 5 6 7  function foo(...[a, b, c]) { console.log(a, b, c); } foo(1); // 1 undefined undefined foo(1, 2, 3); // 1 2 3 foo(1, 2, 3, 4); // 1 2 3   ","description":"ES6 引進了一個新語法功能，解構指定（destructuring assignment）或稱解構賦值，可以想成是一種有結構的指定。","id":32,"section":"posts","tags":["JavaScript","解構指定","ES6"],"title":"解構指定","uri":"https://chupai.github.io/posts/200514_js_destructuring_assignment-copy/"},{"content":" JavaScript筆記 目錄\n \r\u0026hellip; 運算子 ES6 新增了 ... 運算子，但在不同位置，會有不同的功能，所以會有兩種叫法：\n 展開運算子（Spread Operator） 其餘運算子（Rest Operator）  展開運算子 展開運算子（Spread Operator）可用於陣列、類陣列、物件，但使用地點有些微差異。\n 陣列、類陣列  陣列字面值 函式呼叫時作為引數   物件  只能於物件字面值中使用    1. 基本用法 展開運算子會將陣列展開為個別的值。\n1 2 3 4 5 6 7 8 9  let number = [1, 2, 3]; let string = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; console.log(...number); // 1 2 3 console.log(...string); // \u0026#39;a\u0026#39; \u0026#39;b\u0026#39; \u0026#39;c\u0026#39;  // 等同於 console.log(1, 2, 3); console.log(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;);   主要是用在呼叫函式時的要傳入引數：\n1 2 3 4 5 6 7 8  function foo(a, b, c) { console.log(a + b + c); } foo(...[1, 2, 3]); // 6  // 等同 apply() foo.apply(null, [1, 2, 3]); // 6   ES6 之前，如果要將陣列拆開當作引數傳入都會用函式的 apply() 方法，但現在展開運算子完全可以取代它。\n展開運算子除了用在陣列本身，也可以用在陣列字面值中，將陣列展開：\n1 2 3  let number = [2, 3]; console.log([1, ...number, 5]); // [1, 2, 3, 5]   用於合併陣列非常方便，原本需要使用 concat()，現在可以使用 ... 來代替：\n1 2 3 4 5 6 7 8  let arr1 = [1, 2, 3]; let arr2 = [4, 5, 6]; let temp1 = arr1.concat(arr2); console.log(temp1); // [1, 2, 3, 4, 5, 6]  let temp2 = [...arr1, ...arr2]; console.log(temp2); // [1, 2, 3, 4, 5, 6]   也可利用它來淺拷貝陣列：\n1 2 3 4 5  let arr1 = [1, 2, 3]; let arr2 = [...arr]; console.log(arr2); // [1, 2, 3] console.log(arr1 === arr2); // false   2. 類陣列（Array-likes） 展開運算子不只是陣列可用，類陣列（Array-likes）也能使用，因為它具有索引和 length 屬性。\narguments 物件：\n1 2 3 4 5 6 7  function foo() { console.log(arguments instanceof Array); // false  let arg = [...arguments]; console.log(arg instanceof Array); // true } foo();   DOM 物件操作後所得到的串列：\n1 2 3 4  const list = document.getElementsByTagName(\u0026#39;body\u0026#39;); console.log(list instanceof Array); // false console.log([...list] instanceof Array); // true   字串：\n1 2 3  let string = \u0026#39;hello\u0026#39;; console.log([...\u0026#39;hello\u0026#39;]); // [\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;]   2. 物件 展開運算子如果直接用在物件上會拋出錯誤，因為展開運算子只能用於具有索引和 length 屬性的物件。\n1 2 3  let obj = { a: 1, b: 2 }; console.log(...obj); // Uncaught TypeError: Found non-callable @@iterator   你可以想成 a: 1, b: 2 沒東西裝。\n但如果要展開一個物件，可於物件字面值內。你可以想成 a: 1, b: 2 外面還有一個 {} 裝它。\n因此可以應用在淺拷貝物件上：\n1 2 3 4 5  let obj = { a: 1, b: 2 }; let obj2 = { ...obj }; console.log(obj2); // { a: 1, b: 2 } console.log(obj === obj2); // false   其餘運算子 在函式宣告中的最後一個參數加上 ... 運算子，會稱其為「其餘運算子（Rest Operator）」，它與展開運算子效果上剛好完全相反，其餘運算子是把許多的參數轉換成一個陣列。\n1 2 3 4 5  function foo(...args) { console.log(args); } foo(1, 2, 3); // [1, 2, 3]   其餘運算子因為是用於參數上，因此又稱為「其餘參數」，應用於參數不固定的函式上。\nES6 之前，會利用 arguments 物件來存取傳入的引數。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function foo(var_args) { for (var i = 0; i \u0026lt; arguments.length; i++) { var tmp = arguments[i]; if (typeof tmp !== \u0026#39;number\u0026#39;) { console.log(\u0026#39;輸入的值不是數字：\u0026#39; + tmp); } else { console.log(\u0026#39;輸入的值是數字：\u0026#39; + tmp); } } } foo(1, 2, 5, \u0026#39;a\u0026#39;); // \u0026#34;test.js:6 輸入的值是數字：1\u0026#34; // \u0026#34;test.js:6 輸入的值是數字：2\u0026#34; // \u0026#34;test.js:6 輸入的值是數字：5\u0026#34; // \u0026#34;test.js:4 輸入的值不是數字：a\u0026#34;   arguments 物件是類陣列，因此如果使用陣列方法需要將其轉換成陣列。\n為了程式碼的可讀性，通常會給可變長度的參數一個假名稱，讓閱讀程式碼時，知道這裡是輸入可變長度的參數。\n上段程式碼改用其餘運參數：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function foo(...args) { args.forEach(i =\u0026gt; { if (typeof i !== \u0026#39;number\u0026#39;) { console.log(\u0026#39;輸入的值不是數字：\u0026#39; + i); } else { console.log(\u0026#39;輸入的值是數字：\u0026#39; + i); } }); } foo(1, 2, 5, \u0026#39;a\u0026#39;); // \u0026#34;test.js:6 輸入的值是數字：1\u0026#34; // \u0026#34;test.js:6 輸入的值是數字：2\u0026#34; // \u0026#34;test.js:6 輸入的值是數字：5\u0026#34; // \u0026#34;test.js:4 輸入的值不是數字：a\u0026#34;   如果使用箭頭函式，其餘運算子必須以小括號標記，即使函式只有一個參數：\n1 2 3  let sumAll = (...number) =\u0026gt; number.reduce((total, next) =\u0026gt; total + next); console.log(sumAll(1, 3, 5)); // 9   ","description":"ES6 新增了... 運算子，但在不同位置，會有不同的功能，所以會有兩種叫法，分別為「展開」和「其餘」運算子。","id":33,"section":"posts","tags":["JavaScript","展開運算子","其餘運算子","ES6"],"title":"展開／其餘運算子","uri":"https://chupai.github.io/posts/200513_js_spread_and_rest_operator/"},{"content":"這週是 六角鼠年鐵人賽 第十四週，讓我們來看只關注頭尾的資料結構「堆疊」和「佇列」。\n\r堆疊（Stack） 堆疊（Stack），中國稱「栈」，是一種 後入先出（LIFO, Last In First Out） 的資料結構。\n1. 後入先出 LIFO 在 LIFO 的資料結構中，將優先處理最晚加進來的元素（最新）。\n堆疊使用兩種基本操作：\n push：將資料放入堆疊頂端（新增） pop：拿出疊頂端的資料（刪除）  簡單來說，就是先進去資料的最後出來、最後進去的資料最先出來。可以將堆疊想像成疊盤子，不論放盤子或取盤子，都只能從最上方，最先拿的盤子一定是最後一個放上來的。\n也就是說，在堆疊中，越底層的資料越舊，越靠近頂層越新，而且只能讀取最上層的資料（最新的）。\n2. JavaScript 實作堆疊 大部分的程式語言都提供內置的堆疊，但 JavaScript 沒有，所以我們用陣列來實作一個。\n2.1 宣告類別 宣告一個 Stack 類別：\n1 2 3 4 5 6  class Stack { constructor() { this.items = []; } // methods }   我們需要一個能夠存儲堆疊裡的元素的資料結構，因此我們可以使用陣列來實作。\n2.2 屬性方法 主要方法：\n push(element(s))：新增一個或多個元素到堆疊頂部。 pop()：移除堆疊頂部元素，同時回傳被移除的元素。  為了符合 LIFO 原則，我們使用陣列的 push 和 pop 方法實作。\n1 2 3 4 5 6 7  push(element) { this.items.push(element); } pop() { return this.items.pop(); }   輔助工具：\n peek() 或 top()：僅回傳堆疊頂端的元素。 isEmpty()：檢查堆疊內是否有元素，是空的回傳 true，否則回傳 false。 clear()：移除堆疊內的所有元素。 size()：回傳堆疊裡的元素個數，也就是資料長度。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 獲取最後一個元素 peek() { return this.items[this.items.length - 1]; } // 判斷儲存堆疊資料的陣列長度是否為 0 isEmpty() { return this.items.length === 0; } // 最簡單的清空，給一個新的空陣列 clear() { this.items = []; } // 回傳儲存堆疊資料的陣列長度 size() { return this.items.length; }   最終程式碼如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Stack { constructor() { this.items = []; } push(element) { this.items.push(element); } pop() { return this.items.pop(); } peek() { return this.items[this.items.length - 1]; } isEmpty() { return this.items.length === 0; } clear() { this.items = []; } size() { return this.items.length; } }   2.3 建立實體 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  const stack1 = new Stack(); // 新增元素 stack1.push(\u0026#39;盤子1\u0026#39;); stack1.push(\u0026#39;盤子2\u0026#39;); // 印出長度 console.log(stack1.size()); // 2  // 移除最上方元素 console.log(stack1.pop()); // \u0026#39;盤子2\u0026#39;  // 最上方元素 console.log(stack1.peek()); // \u0026#39;盤子1\u0026#39;  // 清除 stack1.clear(); // 是否為空 console.log(stack1.isEmpty()); // true   2.4 基於物件的堆疊 除了使用陣列來儲存堆疊元素，也可以改用物件來儲存堆疊裡的元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class Stack { constructor() { this.items = {}; this.count = 0; } push(element) { this.items[this.count] = element; this.count += 1; } pop() { if (this.isEmpty()) { return undefined; } this.count -= 1; const result = this.items[this.count]; delete this.items[this.count]; return result; } isEmpty() { return this.count === 0; } clear() { this.items = {}; this.count = 0; } size() { return this.count; } }   佇列（Queue） 佇列（Queue），中國稱「队列」，特性是 先進先出（FIFO, First-In-First-Out） 的資料結構。\n1. 先入先出 FIFO 在 FIFO 的資料結構中，會優先處理最早加進來的元素（最舊）。\n佇列使用兩種基本操作：\n enqueue：由佇列的後端（Rear / Back）添加新資料。 dequeue：由佇列的前端（Front）移除資料。  舉個生活上的例子，排隊上廁所：先到的人先上，後來的排後面。\n當你想要按順序處理元素時，使用佇列會是一個很好的選擇。\n2. JavaScript 實作佇列 大部分的程式語言都提供內置的佇列，但 JavaScript 沒有，所以我們用陣列來實作一個。\n2.1 宣告類別 宣告一個 Queue 類別：\n1 2 3 4 5 6  class Queue { constructor() { this.items = []; } // methods }   並用陣列來儲存佇列裡的元素。\n2.2 屬性方法 佇列的兩種主要操作方法：\n enqueue(element(s))：新增一個或多個元素到佇列尾部。 dequeue()：移除佇列的第一個元素，並回傳被移除的元素。  1 2 3 4 5 6 7 8  enqueue(element) { this.items.push(element); } dequeue() { return this.items.shift(); }   輔助工具：\n front() 或 head()：僅回傳佇列的第一個元素。 rear() 或 tail()：僅回傳佇列的最一個元素。 isEmpty()：檢查佇列內是否有元素，是空的回傳 true，否則回傳 false。 clear()：移除佇列內的所有元素。 size()：回傳佇列裡的元素個數，也就是資料長度。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  front() { return this.items[0]; } rear() { return this.items[this.items.length - 1]; } isEmpty() { return this.items.length === 0; } clear() { this.items = []; } size() { return this.items.length; }   最終程式碼如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class Queue { constructor() { this.items = []; } enqueue(element) { this.items.push(element); } dequeue() { return this.items.shift(); } front() { return this.items[0]; } rear() { return this.items[this.items.length - 1]; } isEmpty() { return this.items.length === 0; } clear() { this.items = []; } size() { return this.items.length; } }   2.3 建立實體 模擬排隊：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const queue = new Queue(); // 隊伍空的嗎? console.log(queue.isEmpty()); // ture  // 排隊 queue.enqueue(\u0026#39;A\u0026#39;); queue.enqueue(\u0026#39;B\u0026#39;); queue.enqueue(\u0026#39;C\u0026#39;); // 先出隊的 console.log(queue.dequeue()); // \u0026#39;A\u0026#39;  // 剩幾個? console.log(queue.size()); // 2  // 隊伍最後一個 console.log(queue.rear()); // \u0026#39;C\u0026#39;   3. 優先佇列（Priority Queue） 在一般情況下，從佇列中處理（刪除）的一定是第一個加入的元素，但優先佇列（Priority Queue），不必遵守佇列 FIFO 的特性，每個元素都會設定優先級，優先級最高（數字越小越高）的會優先處理，若相同級別才看排列順序。\n用排隊來比喻就是 VIP 會員等級，等級越高優先服務，或是醫院急診室會評估傷患等級來給予治療順序。\n優先佇列的差異在於 enqueue 方法，在加入元素時，會根據優先級決定插入的位置。\n priority 為優先級，預設值給它無限大。 我們用一個 queueElement 物件來儲存元素和優先級的值。 如果佇列為空直接入列，否則比較優先級。 一個一個比較元素優先級：  優先級較高就用插入在它的前面，並結束函式； 如果都沒有就加到佇列後端。    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Priorityqueue extends Queue { enqueue(element, priority = Infinity) { const queueElement = { element, priority }; if (this.isEmpty()) { this.items.push(queueElement); } else { for (let i = 0; i \u0026lt; this.items.length; i++) { if (priority \u0026lt; this.items[i].priority) { this.items.splice(i, 0, queueElement); return; } } this.items.push(queueElement); } } }   建立實體：\n1 2 3 4 5 6 7 8 9 10 11  const pq = new Priorityqueue(); pq.enqueue(\u0026#39;A\u0026#39;, 1); pq.enqueue(\u0026#39;B\u0026#39;); pq.enqueue(\u0026#39;C\u0026#39;, 1); pq.enqueue(\u0026#39;D\u0026#39;, 2); console.log(pq.dequeue()); // { element: \u0026#39;A\u0026#39;, priority: 1 } console.log(pq.dequeue()); // { element: \u0026#39;C\u0026#39;, priority: 1 } console.log(pq.dequeue()); // { element: \u0026#39;D\u0026#39;, priority: 2 } console.log(pq.dequeue()); // { element: \u0026#39;B\u0026#39;, priority: Infinity }   堆疊的應用 1. 十進制轉二進制 十進制轉二進制轉換過程：\n 10 / 2 = 5 餘 0 5 / 2 = 2 餘 1 2 / 2 = 1 餘 0 1 / 2 = 0 餘 1 10 的二進制結果為 1010  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function divideBy2(decNumber) { const remStack = new Stack(); let number = decNumber; let rem = null; // 餘數  // 將餘數放進堆疊中  while (number \u0026gt; 0) { rem = Math.floor(number % 2); remStack.push(rem); number = Math.floor(number / 2); } // 將結果連成字串  let baseString = \u0026#39;\u0026#39;; while (!remStack.isEmpty()) { baseString += remStack.pop(); } return baseString; }   將上面程式碼稍微修改，可以改成十進制轉 2 ~ 36 進制，10 ~ 35 用英文字母表示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function baseConverter(decNumber, base) { if (!(base \u0026gt;= 2 \u0026amp;\u0026amp; base \u0026lt;= 36)) { return \u0026#39;\u0026#39;; } const remStack = new Stack(); const DIGITS = \u0026#39;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39;; let number = decNumber; let rem = null; while (number \u0026gt; 0) { rem = Math.floor(number % base); remStack.push(rem); number = Math.floor(number / base); } let baseString = \u0026#39;\u0026#39;; while (!remStack.isEmpty()) { baseString += DIGITS[remStack.pop()]; } return baseString; }   2. 驗證括號的問題  Leetcode: 20. Valid Parentheses\n驗證括號（Valid Parentheses）或稱 平衡括號（Balanced Brackets）。\n 給定一個包括 (、{、[、)、}、] 的字串，判斷字串是否有效。\n有效字串需滿足：\n 左括號必須用相同類型的右括號閉合。 左括號必須以正確的順序閉合。  注意空字串可被認為是有效字串。\n範例：\n1 2 3 4 5  \u0026#39;()\u0026#39; // ture \u0026#39;()[]{}\u0026#39; // true \u0026#39;(]\u0026#39; // false \u0026#39;([)]\u0026#39; // false \u0026#39;{[]}\u0026#39; // true   流程：\n 檢查字串，遇到 ( { [ 就放到堆疊中 若遇到 ) ] } 就去找堆疊頂端的資料是否有相對應的 ( { [  沒有就回傳 false 若有就將堆疊頂端對應的 ( { [ 移除   最後檢查堆疊內使否為空  如果是空的回傳 true 不是空的，表示有沒對應到的 ( { [ 回傳 false    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function isValid(s) { const stack = []; const OPENING = { \u0026#39;(\u0026#39;: 0, \u0026#39;[\u0026#39;: 1, \u0026#39;{\u0026#39;: 2 }; const CLOSEING = { \u0026#39;)\u0026#39;: 0, \u0026#39;]\u0026#39;: 1, \u0026#39;}\u0026#39;: 2 }; for (let i = 0; i \u0026lt; s.length; i++) { const character = s[i]; if (OPENING[character] \u0026gt;= 0) { stack.push(character); } else if (CLOSEING[character] \u0026gt;= 0) { const peek = stack[stack.length - 1]; if (OPENING[peek] === CLOSEING[character]) { stack.pop(); } else { return false; } } } return stack.length === 0; }   總結 堆疊和佇列這類最基本的資料結構，它們因為特殊條件限制，只關心頭尾的新增、刪除、獲取的操作，並不關心內部的元素的狀態。\n","description":"這週是六角鼠年鐵人賽第十四週，讓我們來看只關注頭尾的資料結構「堆疊」和「佇列」。","id":34,"section":"posts","tags":["資料結構","堆疊","佇列","w3HexSchool"],"title":"JavaScript 學演算法（六）- 堆疊 ＆ 佇列","uri":"https://chupai.github.io/posts/200504_ds_stack_queue/"},{"content":"這週是 六角鼠年鐵人賽 第十三週，要來簡單說明與陣列類似的資料結構「鏈結串列 Linked list」。\n\r前言 首先來談談陣列的缺點，在大多數的程式語言中，陣列的長度（大小）宣告後就是固定的，也就是說，宣告時已經決定最大空間，如果預設的空間太小容易發生上溢，如果太大容易造成記憶體空間浪費。\n而且從陣列的開頭或中間插入、刪除元素時，往往需要般動其他元素，因此效率不佳。\n鏈結串列是什麼 鏈結串列（Linked list），中國稱「链表」，與陣列一樣都是線性資料結構，但不同於陣列，它為鏈式儲存結構，也就是記憶體位置儲存為不連續性。\n1. 定義 鏈結串列是由一連串 節點（node） 組成，節點之間是透過指標來連接。所以儲存上並不需要連續的空間。\n每個節點包含：\n 資料元素 指標  指標（又稱鏈結、引用），通常為一或兩個，用來指向上／下個的位置，若沒有上／下一個節點，則為空。如果指標斷裂，資料就遺失。\n舉生活上的例子來說，鏈結串列如同火車的車廂一樣，一節拉著一節。\n相較於陣列，鏈結串列的元素並不是連續放置的，插入或移除元素不需要移動其他元素，只需要修改上／下個指標的指向。\n因為鏈結串列沒有索引，若要存取特定特定，需要從頭開始找起，因此相較於陣列，存取資料較費時。\n2. 類型 鏈結串列有很多種不同的類型：\n 單向鏈結串列（Singly Linked List） 雙向鏈結串列（Doubly Linked List） 迴圈鏈結串列（Circularly Linked List）  2.1 單向鏈結串列 單向鏈結串列，又稱單鏈結串列、線性鏈結串列、普通鏈結串列，是最基本的鏈結串列，其特點是鏈結串列的鏈結方向是單向的，對鏈結串列的存取要通過從頭部開始，依序往下讀取。\n2.2 雙向鏈結串列 雙向鏈結串列，又稱為雙鏈結串列，它與單向鏈結串列最大的區別在於，每個結點中都有兩個指標，分別指向上一個和下一個結點。\n所以，從雙向鏈結串列中的任意一個結點開始，都可以很方便地存取它的上一個和下一個結點。\n2.3 迴圈鏈結串列 迴圈鏈結串列，又稱環狀鏈結串列、循環鏈結串列，它與一般的鏈結串列操作基本一致，但串列頭尾的指標會連接再一起，形成一個環。\n3. 時間複雜度 不管是維基百科還是其他鏈結串列相關文章，都只寫鏈結串列的時間複雜度分別為：\n 插入、刪除：$O(1)$ 存取、查詢：$O(n)$  但要注意的是，插入與刪除的 $O(1)$ 指的是，已經獲取節點的前提下所執行的動作。沒有獲取節點，要插入或刪除指定位置的節點，會先經過查詢節點這個動作，所以時間複雜度會變為 $O(n)$。\n但假如節點位置為開頭，時間複雜度也為 $O(1)$。\n4. 優缺點比較 鏈結串列與陣列的優缺點比較。\n陣列的優點：\n 可利用 index 隨機存取（Random Access）只需要 $O(1)$ 的時間。 可靠度高，不會因為鏈結斷裂而遺失資料。  陣列的缺點：\n 在開頭或中間插入、刪除元素，需要花費 $O(n)$ 的時間將元素移動。 連續的記憶體空間，可能會有用不到的空間，而造成浪費。 若陣列已滿，會需要花費 $O(n)$ 的時間搬動資料到新的陣列內。  鏈結串列的優點：\n 資料在記憶體中非連續。 插入、刪除元素只需要修改上／下個指標的指向。  鏈結串列的優點：\n的缺點：\n 只能順序存取，需要花費 $O(n)$ 的時間。 鏈結斷裂就會遺失資料。  JavaScript 實作鏈結串列 JavaScript 沒有內建鏈結串列，我們使用物件來模擬。\n鏈結串列的資料結構：\n1 2 3 4 5 6 7 8 9 10  { data: \u0026#39;data1\u0026#39;, next: { data: \u0026#39;data2\u0026#39;, next: { data: \u0026#39;data3\u0026#39;, next: null } } }   首先會建立兩個類別，分別是 Node 表示節點、LinkedList 提供插入、刪除節點以及其他輔助方法。\n1. Node 節點 Node 包含資料和指標：\n data：資料 next：指向下一個節點。  1 2 3 4 5 6  class Node { constructor(data) { this.data = data; this.next = null; } }   2. LinkedList 基本屬性：\n head：指向串列開頭節點 tail：指向串列結尾節點 length：節點數量  1 2 3 4 5 6 7 8  class LinkedList { constructor() { this.head = null; this.tail = null; this.length = 0; } // methods }   2.1 輔助方法 先建立會用到的輔助方法。\nisEmpty() 檢查串列是否為空：\n1 2 3  isEmpty() { return this.length === 0; }   getNode() 取得指定位置節點：\n1 2 3 4 5 6 7 8 9 10 11 12  getNode(index) { // 判斷指定位置是否在範圍內  if (index \u0026lt; 0 || index \u0026gt;= this.length) return null; // 從頭開始迭代到指定位置訪問  let currNode = this.head; let currIndex = 0; while (currIndex \u0026lt; index) { currIndex += 1; currNode = currNode.next; } return currNode; }   為了方便驗證，建立一個 print() 照順序印出所有節點資料值：\n1 2 3 4 5 6 7 8 9  print() { const temp = []; let currNode = this.head; while (currNode) { temp.push(currNode.data); currNode = currNode.next; } return temp.join(\u0026#39;, \u0026#39;); }   2.2 插入新節點  append(data)：在串列尾部插入一個節點。 insert(index, data)：在指定位置插入一個節點。  在串列尾部插入一個節點可分為兩種情況：\n 串列為空，更新 head 和 tail。 串列不為空，則更新 tail。  需要先將原本的 tail 指向新的節點； 再更新 tail。    1 2 3 4 5 6 7 8 9 10 11  append(data) { const newNode = new Node(data); if (this.isEmpty()) { this.head = newNode; this.tail = newNode; } else { this.tail.next = newNode; this.tail = newNode; } this.length += 1; }   在指定位置插入元素，需要考慮三種情況：\n 插入串列結尾後面，等同使用 append 方法。 插入串列開頭，為取代 head。 在中間位置插入，需要修改上一個節點的指標。  取得指定位置的上一個節點； 再取得指定位置上原本的節點； 重新定義上一個節點指標，指向新插入的節點； 最後將新插入的節點指標，指向原本的節點。    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  insert(index, data) { if (index \u0026gt;= this.length) { this.append(data); return; } const newNode = new Node(data); if (index \u0026lt;= 0) { newNode.next = this.head; this.head = newNode; } else { const prevNode = this.getNode(index - 1); const currNode = prevNode.next; prevNode.next = newNode; newNode.next = currNode; } this.length += 1; }   驗證：\n1 2 3 4 5 6 7 8 9 10 11 12 13  const list = new LinkedList(); list.append(\u0026#39;data1\u0026#39;); list.append(\u0026#39;data2\u0026#39;); list.append(\u0026#39;data3\u0026#39;); console.log(list.print()); // \u0026#39;data1, data2, data3\u0026#39;  list.insert(0, \u0026#39;a\u0026#39;); console.log(list.print()); // \u0026#39;a, data1, data2, data3\u0026#39; list.insert(4, \u0026#39;b\u0026#39;); console.log(list.print()); // \u0026#39;a, data1, data2, data3, b\u0026#39; list.insert(2, \u0026#39;b\u0026#39;); console.log(list.print()); // \u0026#39;a, data1, b, data2, data3, b\u0026#39;   2.3 刪除節點 先判index 有效，刪除指定位置的節點：\n 刪除的節點是開頭，重新指定 head。 其他節點，則找到目標節點，並修改上一個節點的指向，如果目標節點是 tail（指標指向 null）記得要重新指定。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  removeAt(index) { if (index \u0026lt; 0 || index \u0026gt;= this.length) return; if (index === 0) { this.head = this.head.next; } else { const prevNode = this.getNode(index - 1); const delNode = prevNode.next; const nextNode = delNode.next; prevNode.next = nextNode; if (nextNode === null) { this.tail = prevNode; } } this.length -= 1; }   2.4 其他方法 getData() 取得指定位置節點的資料值：\n1 2 3 4  get(index) { const node = this.getNode(index); return node ? node.data : null; }   indexOf() 根據資料的值，回傳索引（第一個符合條件的），沒有則回傳 -1：\n1 2 3 4 5 6 7 8 9 10  indexOf(data) { let currNode = this.head; let currIndex = 0; while (currNode) { if (currNode.data === data) return currIndex; currIndex += 1; currNode = currNode.next; } return -1; }   remove() 根據資料的值，刪除符合的第一個節點：\n1 2 3 4  remove(data) { const index = this.indexOf(data); return this.removeAt(index); }   clear() 清空串列：\n1 2 3 4 5  clear() { this.head = null; this.tail = null; this.length = 0; }   size() 回傳串列的節點個數：\n1 2 3  size() { return this.length; }   3. 最終程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118  class Node { constructor(data) { this.data = data; this.next = null; } } class LinkedList { constructor() { this.head = null; this.tail = null; this.length = 0; } append(data) { const newNode = new Node(data); if (this.isEmpty()) { this.head = newNode; this.tail = newNode; } else { this.tail.next = newNode; this.tail = newNode; } this.length += 1; } insert(index, data) { if (index \u0026gt;= this.length) { this.append(data); return; } const newNode = new Node(data); if (index \u0026lt;= 0) { newNode.next = this.head; this.head = newNode; } else { const prevNode = this.getNode(index - 1); const currNode = prevNode.next; prevNode.next = newNode; newNode.next = currNode; } this.length += 1; } removeAt(index) { if (index \u0026lt; 0 || index \u0026gt;= this.length) return; if (index === 0) { this.head = this.head.next; } else { const prevNode = this.getNode(index - 1); const delNode = prevNode.next; const nextNode = delNode.next; prevNode.next = nextNode; if (nextNode === null) { this.tail = prevNode; } } this.length -= 1; } indexOf(data) { let currNode = this.head; let currIndex = 0; while (currNode) { if (currNode.data === data) return currIndex; currIndex += 1; currNode = currNode.next; } return -1; } remove(data) { const index = this.indexOf(data); return this.removeAt(index); } getNode(index) { if (index \u0026lt; 0 || index \u0026gt;= this.length) return null; let currNode = this.head; let currIndex = 0; while (currIndex \u0026lt; index) { currIndex += 1; currNode = currNode.next; } return currNode; } getData(index) { const node = this.getNode(index); return node ? node.data : null; } isEmpty() { return this.length === 0; } clear() { this.head = null; this.tail = null; this.length = 0; } size() { return this.length; } print() { const temp = []; let currNode = this.head; while (currNode) { temp.push(currNode.data); currNode = currNode.next; } return temp.join(\u0026#39;, \u0026#39;); } }   4. 雙向鏈結串列 接下來我們來實作雙向鏈結串列，它與單向鏈結串列的差異在於，節點會有兩個指標。\n節點上會多一個指向上一個節點的指標：\n1 2 3 4 5 6 7  class DoublyNode { constructor(data) { this.data = data; this.next = null; this.prev = null; } }   除了插入、刪除節點要多加處理 prev 指標，其他方法操作與單向鏈結串列相同，我們這裡直接繼承 LinkedList：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  class DoublyLinkedList extends LinkedList { append(data) { const newNode = new DoublyNode(data); if (this.isEmpty()) { this.head = newNode; this.tail = newNode; } else { newNode.prev = this.tail; // new  this.tail.next = newNode; this.tail = newNode; } this.length += 1; return true; } insert(index, data) { if (index \u0026gt;= this.length) { this.append(data); return; } const newNode = new DoublyNode(data); if (index \u0026lt;= 0) { this.head.prev = newNode; // new  newNode.next = this.head; this.head = newNode; } else { const prevNode = this.getNode(index - 1); const currNode = prevNode.next; prevNode.next = newNode; newNode.next = currNode; } this.length += 1; } removeAt(index) { if (index \u0026lt; 0 || index \u0026gt;= this.length) return; if (index === 0) { this.head = this.head.next; this.head.prev = null; // new  } else { const prevNode = this.getNode(index - 1); const delNode = prevNode.next; const nextNode = delNode.next; prevNode.next = nextNode; if (nextNode === null) { this.tail = prevNode; } else { nextNode.prev = prevNode; // new  } } this.length -= 1; } }   5. 迴圈鏈結串列 迴圈鏈結串列 tail 的 next 指標會指向 head、head 的 prev 指標會指向 tail，而非 null。\nLeetCode 相關題目  707. Design Linked List 設計鏈結串列 141. Linked List Cycle 迴圈鏈結串列 206. Reverse Linked List 反轉鏈結串列  總結 陣列是 JavaScript 最常使用的資料結構，JavaScript 的陣列與其它語言相比很特殊，沒有元素型別與大小限制，但將元素從開頭插入或移除，時間複雜度一樣需要 $O(n)$，而鏈結串列只需要 $O(1)$。\n如果沒有頻繁存取元素的需求，而有需要頻繁將元素插入開頭，可以考慮使用鏈結串列的資料結構邏輯。\n","description":"這週是六角鼠年鐵人賽第十三週，要來簡單說明與陣列類似的資料結構「鏈結串列 Linked list」。","id":35,"section":"posts","tags":["資料結構","鏈結串列","w3HexSchool"],"title":"JavaScript 學演算法（五）- 鏈結串列 Linked list ","uri":"https://chupai.github.io/posts/200427_ds_linkedlist/"},{"content":"這週是 六角鼠年鐵人賽 第十二週，要來簡單說明，最基本的資料結構「陣列 Array」。\n\r陣列是什麼 在計算機科學中，陣列資料結構（array data structure），簡稱 陣列（Array），中國稱「数组」，是最基本的資料結構，屬於線性有序的資料結構。\n大多數的高階程式語言都會內建的陣列資料型別（type），少部分是由雜湊表、連結串列、搜尋樹來實現。\n1. 定義 陣列是由相同類型的元素所組成的有序的資料結構，通常由一塊連續的記憶體位置儲存。\n因為是連續的記憶體位置，所以大部分的高階語言，陣列宣告後的長度（大小）是不能改變的，如果需要調整陣列大小，需要將所有元素搬到新的陣列。\n陣列在插入、刪除元素的效率非常差，因為需要移動（往前或往後）其餘元素。\n元素可以透過索引（index）做隨機存取（Random Access），有時亦稱直接存取。\n陣列特色：\n 線性有序的資料結構 相同類型的元素所組成 由一塊連續的記憶體位置儲存 可以透過索引隨機存取 索引初始位置為 0  JavaScript 的陣列 JavaScript 的陣列與大部分的高階語言的陣列相比，非常不一樣。\n我們上面提到，陣列的定義最主要就是：\n 相同類型的元素所組成 由一塊連續的記憶體位置儲存  但 JavaScript 屬於於動態型別的程式語言，變數單純只是容器，型別是根據賦予的值來決定。因此陣列可以存放不同型別的元素。\nJavaScript 是基於原型模式的物件導向語言，幾乎所有的事物都是物件，或是具有類似物件的行為，陣列也不例外，它本質上屬於一種特殊的物件。\n1 2 3 4  typeof [] // \u0026#34;object\u0026#34;  const array = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; console.log( Object.keys(array) ); // [\u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;]   所以 JavaScript 的陣列與其它程式語言相比，執行速度較慢。\n1. 記憶體儲存 另外，JavaScript 的陣列並不一定是儲存於連續記憶體空間。\n早期的 JavaScript 引擎用為「鏈式儲存結構」，而到了 Chrome 的 V8 才使用「順序儲存結構」與「鏈式儲存結構」混合模式。\n在多數的情況下，V8 引擎的陣列是「順序儲存結構」也就是分配連續記憶體，而以下情況為非連續記憶體：\n 稀疏陣列 元素的非單一型別  非連續記憶體的陣列用的是類似雜湊表（hash table）對映的方式存在。\n陣列的操作 JavaScript 基本操作請參考：\n 陣列 迭代陣列 ","description":"這週是六角鼠年鐵人賽第十二週，最基本的資料結構「陣列 Array」。","id":36,"section":"posts","tags":["資料結構","陣列 Array","w3HexSchool"],"title":"JavaScript 學演算法（四）- 陣列 Array ","uri":"https://chupai.github.io/posts/200426_ds_array/"},{"content":" JavaScript筆記 目錄\n \r對陣列做迭代 對陣列做迭代是最常見的陣列操作，最基本的的迭代方式就是使用 for 迴圈：\n1 2 3 4 5 6 7 8 9  let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; for (let i = 0; i \u0026lt; arr.length; i++) { console.log(arr[i]); } // \u0026#34;a\u0026#34; // \u0026#34;b\u0026#34; // \u0026#34;c\u0026#34;   但如果需要對陣列從頭到尾的迭代，使用 for 迴圈太繁瑣，需要索引值、結束條件。\n因此可以改用 forEach 方法或 ES6 的 for of 迴圈來迭代陣列。\n   類型 效能 說明     for 最高 雖然繁瑣，但自由度高，可使用變數改變索引值，也可以使用 break、return、continue 等語句   for in 最低 可用於物件，但不建議用於陣列   forEach 中間 搭配箭頭函式可使程式碼更簡潔   for of 中間（高於 forEach） 簡潔，而且比起 forEach 可使用 break、return、continue 等語句，但沒有索引    1. forEach 首先我們來看看 forEach 方法，它會將陣列內的每個元素，皆傳入並執行給定的函式一次，不會產生新的陣列。\n語法如下：\n1 2 3  arr.forEach(function callback(currentValue[, index[, array]]) { //your iterator }[, thisArg]);    callback 函式共有三個參數：  currentValue：陣列當前元素 index：陣列當元素的索引值 array：陣列本身   thisArg：執行 callback 回呼函式的 this（即參考之 Object）值 回傳值： undefined  currentValue 為必填參數，而 index 與 array 則選擇性。\n試著改寫開頭的 for 迴圈，達到結果。\n1 2 3 4 5 6 7 8 9 10 11 12  let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; arr.forEach(function(item) { console.log(item); }) // \u0026#34;a\u0026#34; // \u0026#34;b\u0026#34; // \u0026#34;c\u0026#34;  // 使用箭頭函式 arr.forEach((item) =\u0026gt; console.log(item));   當傳入參數 thisArg，callback 函式的 this 就會指向你所傳入的物件。\n1 2 3 4 5 6 7 8 9 10  const arr = [1, 2, 3]; const arr2 = [\u0026#39;一\u0026#39;, \u0026#39;二\u0026#39;, \u0026#39;三\u0026#39;]; arr.forEach(function(item, index) { console.log(item + \u0026#39;：\u0026#39; + this[index]); }, arr2); // \u0026#34;1：一\u0026#34; // \u0026#34;2：二\u0026#34; // \u0026#34;3：三\u0026#34;   2. for of 迴圈 在 ES6 新增了 for of 迴圈，它可以用於可迭代物件（Array、Map、Set、String、TypedArray，arguments）上，也就是只要是實現了 Interable 介面的資料型別都能被遍歷。\n1 2 3 4 5 6 7 8 9  let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; for (let element of arr) { console.log(element); } // \u0026#34;a\u0026#34; // \u0026#34;b\u0026#34; // \u0026#34;c\u0026#34;   使用 for of 遍與 forEach 的最大差異就是可以中斷：\n1 2 3 4 5 6 7 8 9 10 11  let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;]; for (let element of arr) { if (element === \u0026#39;c\u0026#39;) { break; } console.log(element); } // \u0026#34;a\u0026#34; // \u0026#34;b\u0026#34;   操作陣列元素 處理陣列中的元素，並不更動原陣列是常見的操作。\n使用 forEach 方法，須先建立一個新的陣列搭配 push 方法。\n舉例，合併姓名：\n1 2 3 4 5 6 7 8 9 10 11 12  const inventors = [ { first: \u0026#39;Albert\u0026#39;, last: \u0026#39;Einstein\u0026#39; }, { first: \u0026#39;Isaac\u0026#39;, last: \u0026#39;Newton\u0026#39; }, ]; const names = []; inventors.forEach((item) =\u0026gt; { names.push(`${item.first}${item.last}`); }); console.log(names); // [\u0026#34;Albert Einstein\u0026#34;, \u0026#34;Isaac Newton\u0026#34;]   如果改用 map 方法：\n1 2 3 4 5 6  inventors.map(function(item) { return `${item.first}${item.last}`; }); // 箭頭函式 inventors.map(item =\u0026gt; `${item.first}${item.last}`);   map 方法會建立一個新的陣列，其內容為原陣列的每一個元素經由回呼函式運算後所回傳的結果之集合。\n參數基本上與 forEach() 相同，但回呼函式多了一個 return 可以將會將處理結果放到新的陣列中，並回傳新的陣列。\n讓我們來實作一下 map 方法，瞭解其原理：\n1 2 3 4 5 6 7 8 9  function map(arr, callback) { let result = []; for (let i = 0; i \u0026lt; arr.length; i++) { result.push(callback(arr[i])); } return result; } map(inventors, (item) =\u0026gt; `${item.first}${item.last}`);   其他陣列迭代操作方法：\n map() ：執行結果存到新陣列。 filter()：將符合條件的元素存到新陣列。 find()：找到第一個符合條件的元素。 some() ：判斷有元素符合條件。 every()：判斷所有元素都符合條件。 reduce()：根據規則縮減陣列。  1. 過濾陣列 filter 方法會建立一個經指定之函式運算後，由原陣列中通過該函式檢驗之元素所構成的新陣列。 return 是用來判斷條件。如果 return 值為 true 會將該元素放入新陣列。\n通常用來篩選資料：\n1 2 3 4 5 6 7  const numbers = [33, 22, 66, 88, 10, 5, 6, 9]; const bigNum = numbers.filter(function(item) { return item \u0026gt; 30; }); console.log( bigNum ); // [33, 66, 88]   找出大於 30 的數值。\n3. 陣列搜尋 some 方法會測試陣列中是否至少有一個元素通過由給定之函式所實作的測試。return 判斷條件。如果至少 return 一次 true 則回傳 true。\n尋找陣列中使否有元素是奇數值：\n1 2 3 4 5 6 7 8  const array = [1, 2, 3, 4, 5]; const arraySome = array.some(function (even) { return even % 2 === 0; }); console.log( arraySome ); // true   要在一個陣列中搜尋某個值，一般來說會使用 indexOf()，它會回傳第一個符合的值的索引，沒找到回傳 -1。\n1 2 3  const arr = [1, 2, 3, 4, 5]; console.log(arr.indexOf(2)); // 1   但 indexOf() 是使用 === 來進行比較，因此如果傳入字串'2'，就會找不到。\n1 2 3  // 承接上段程式碼  console.log(arr.indexOf(\u0026#39;2\u0026#39;)); // -1   在 ES5 時，會使用 some() 來變通比對邏輯，但也只能判斷該陣列是否擁有該元素，無法實際獲取實際符合條件元素。\n1 2 3 4 5 6 7  // 承接上段程式碼  let result = arr.some(function(even) { return even == \u0026#39;2\u0026#39;; }) console.log(result); // true   而到了 ES6 新增了 find()，解決了這個問題。\nfind 方法會回傳第一個滿足所提供之測試函式的成員值。否則回傳 undefined。與 some() 的差異在於，回傳第一個 return 值為 true 的元素。\n找出第一個符合條件的元素：\n1 2 3 4 5 6 7 8 9 10 11 12  const inventory = [ {name: \u0026#39;apples\u0026#39;, quantity: 2}, {name: \u0026#39;bananas\u0026#39;, quantity: 0}, {name: \u0026#39;cherries\u0026#39;, quantity: 5} ]; const inventoryFind = inventory.find(function(item) { return item.name === \u0026#39;cherries\u0026#39;; }); console.log( inventoryFind ); // { name: \u0026#39;cherries\u0026#39;, quantity: 5 }   findIndex() 也是 ES6 新增的方法，findIndex() 與 find() 差異只在於，其會回傳其索引，如果沒有符合的元素，將返回 -1。\n1 2 3 4 5 6 7 8  // 承接上段程式碼  const inventoryIndexFind = inventory.findIndex(function(item) { return item.name === \u0026#39;cherries\u0026#39;; }); console.log(inventoryIndexFind); // 2   因此 find() 可以應用在更新資料，而 findIndex() 會用來刪除資料。\n1 2 3 4 5 6  const cart = [ {id: 1, count: 0}, {id: 2, count: 0}, {id: 3, count: 0}, {id: 4, count: 0}, ];   找出 id 為 3 並將 count 更新成 5：\n1 2 3 4 5 6 7 8 9 10 11  let item = cart.find((item)=\u0026gt; item.id === 3); item.count = 5; console.log( cart ); // [ // {id: 1, count: 0}, // {id: 2, count: 0}, // {id: 3, count: 5}, // {id: 4, count: 0}, // ]   刪除 id 為 3 的元素：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const cart = [ {id: 1, count: 0}, {id: 2, count: 0}, {id: 3, count: 0}, {id: 4, count: 0}, ]; let index = cart.findIndex((item)=\u0026gt; item.id === 3); cart.splice(index, 1); console.log( cart ); // [ // {id: 1, count: 0}, // {id: 2, count: 0}, // {id: 4, count: 0}, // ]   every 方法會測試陣列中的所有元素是否都通過了由給定之函式所實作的測試。\n與 some() 的差異在於，every() 必須要全部的元素都符合條件才會回傳 true。\n是否全部都是基數：\n1 2 3 4 5 6 7 8  const array = [1, 2, 3, 4, 5]; const arrayEvery = array.every(function (even) { return even % 2 === 0; }); console.log( arrayEvery ); // false   4. reduce reduce 方法將一個累加器及陣列中每項元素（由左至右）傳入回呼函式，將陣列化為單一值。其實就是帶有暫存器的 forEach()。\n語法：\n1  arr.reduce(callback[accumulator, currentValue, currentIndex, array], initialValue)    accumulator：用來累積回呼函式回傳值的累加器，若有提供的話，詳如下敘。累加器是上一次呼叫後，所回傳的累加數值。 initialValue：於第一次呼叫 callback 時要傳入的累加器初始值。若沒有提供初始值，則原陣列的第一個元素將會被當作初始的累加器。假如於一個空陣列呼叫 reduce() 方法且沒有提供累加器初始值，將會發生錯誤。 return：放入累加器中  假設要計算一個數值陣列的總合值為多少，使用 for 迴圈都會額外宣告一個 total 變數來當作累加器。\n1 2 3 4 5 6 7 8 9  const numbers = [1, 2, 3, 4, 5, 6]; let total = 0; for(let i = 0; i \u0026lt; numbers.length; i++) { total += numbers[i]; } console.log( total ); // 21   使用 reduce()：\n1 2 3 4 5 6 7 8  const numbers = [1, 2, 3, 4, 5, 6]; const numTotal = numbers.reduce(function(total, item) { return total + item }, 0); console.log( numTotal ); // 21   而 reduceRight() 基本上與 reduce() 一樣，差異是從右到左進行累加。\n我們用扁平化（flatten）一個元素為陣列的陣列來觀察差異：\n1 2 3 4 5 6 7 8 9 10 11  const arr = [[0, 1], [2, 3], [4, 5]]; function callback(a, b) { return a.concat(b); } let result1 = arr.reduce(callback, []); let result2 = arr.reduceRight(callback, []); console.log(result1); // [0, 1, 2, 3, 4, 5] console.log(result2); // [4, 5, 2, 3, 0, 1]   ","description":"對陣列做迭代是最常見的陣列操作。","id":37,"section":"posts","tags":["JavaScript","陣列 Array"],"title":"迭代陣列","uri":"https://chupai.github.io/posts/200425_js_array_iterate/"},{"content":" JavaScript筆記 目錄\n \r概述 在 JavaScript 中的陣列與其他語言的不同之處在於，JavaScript 的陣列只是容器。任何類型的資料，都可以放入陣列。\n1. 陣列其實就是物件 每個陣列都會有索引值（index），是從 0 開始的順序整數值，但陣列其實就是擁有固定鍵名的物件。\n1 2 3 4 5  typeof [] // \u0026#34;object\u0026#34;`  const array = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; console.log( Object.keys(array) ); // [\u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;]   使用 Object.keys() 傳回陣列的所有 鍵名（key name）。可以看到陣列的鍵名就是整數 0、1、2。\n雖然 typeof 無法判斷陣列與物件，但可以利用 instanceof 運算子區分陣列和物件。\n1 2 3 4 5  const o = {}; const a = []; console.log( o instanceof Array ); // false console.log( a instanceof Array ); // true   或是使用 Array.isArray() 來判斷：\n1 2 3 4  // 承接上方程式碼  console.log( Array.isArray(o) ); // false console.log( Array.isArray(a) ); // true   2. 為何要使用陣列？ 假設需要儲存一年中每個月的平均溫度：\n1 2 3 4 5 6  let averageTep1 = 25; let averageTep2 = 22; let averageTep3 = 24; let averageTep4 = 28; let averageTep5 = 29; ...   使用變數來存放絕對不是一個好辦法。\n因此可以使用陣列來存放資料，能夠一次管理多個變數，\n1 2 3 4 5 6 7 8 9 10  const averageTep = []; averageTep[0] = 25; averageTep[1] = 22; averageTep[2] = 24; averageTep[3] = 28; averageTep[4] = 29; ... console.log( averageTep ); // [25, 22, 24, 28, 29 ...]   還可以搭配物件使用：\n1 2 3 4 5 6 7 8  const person = [ {name: \u0026#39;Peter\u0026#39;, sex: \u0026#39;male\u0026#39;}, {name: \u0026#39;Mike\u0026#39;, sex: \u0026#39;male\u0026#39;}, {name: \u0026#39;Merry\u0026#39;, sex: \u0026#39;female\u0026#39;} ] console.log( person[0].name ); // \u0026#34;Peter\u0026#34; console.log( person[2].sex ); // \u0026#34;female\u0026#34;   基本操作 1. 建立 建立陣列有兩種基本方式：\n 建構函式 Array() 陣列實值 []  1 2 3 4 5  const arr1 = [1, 2, 3]; const arr2 = new Array(1, 2, 3); console.log( arr1 ); // [1, 2, 3] console.log( arr2 ); // [1, 2, 3]   new Arry() 與 Arry() 同義，表示 new 可省略。。\n但是，在 JavaScript 應該優先考慮使用 [] 陣列實值。除了用到字元比較少之外，還有 JavaScript 是自由度高的程式語言，new Array() 有可能會被複寫，創造出不是陣列的東西。\n另外 Array 建構式有一種特殊的使用方式，如果只傳入一個數值引數被傳入，那此建構函式不會把該值當成陣列中內容，而是當作長度 lenght。\nJavaScript 的陣列不需要預設大小，宣告後就可以新增需要的值（大部分高階語言的陣列宣告後大小就固定了）。\n2. 取值 可以透過索引取得元素的指定值：\n1 2 3 4 5 6 7  const array = [1, 2, 3, 4, 5]; console.log( array[0] ); // 1 console.log( array[1] ); // 2 console.log( array[2] ); // 3 console.log( array[3] ); // 4 console.log( array[4] ); // 5   3. 陣列內容操作 除了一開始宣告就有的元素，還可以直接透過賦值方式新增陣列元素：\n1 2 3 4 5 6  const array = []; array[0] = 1; array[1] = 2; console.log( array ); // [1, 2];   如果該索引位置已經有該元素，那將會覆蓋原來的值。\n新增／刪除頭尾的元素可以使用：\n push() 會添加一個或多個元素至陣列的末端，並且回傳陣列的新長度。 unshift() 會添加一個或多個元素至陣列的開頭，並且回傳陣列的新長度。 pop() 會移除並回傳陣列的最後一個元素。此方法會改變陣列的長度。 shift() 會移除並回傳陣列的第一個元素。此方法會改變陣列的長度。  以下兩個陣列方法能新增最後或最前的元素：\n1 2 3 4 5 6 7 8 9 10  // 承接上段程式碼  array.push(3); console.log( array ); // [1, 2, 3]  array.push(4, 5, 6); console.log( array ); // [1, 2, 3, 4, 5, 6]  array.unshift(0, 0); console.log(array); // [0, 0, 1, 2, 3, 4, 5, 6]   以下兩個陣列方法能移除最後或最前的元素：\n1 2 3 4 5 6 7  const array = [1, 2, 3, 4]; array.pop(); console.log( array ); // [1, 2, 3]  array.shift(); console.log( array ); // [2, 3]   如果要刪除特定位置的元素，如果用 deleta 運算子將其移除，會有以下問題：\n1 2 3 4 5 6  const array = [1, 2, 3, 4]; delete array[1]; console.log( array.length ); // 4 console.log( array ); // [1, undefined, 3, 4]   這樣會導致陣列變成稀疏陣列（關於稀疏陣列將在下面說明）。\n3.1 特定位置插入元素、刪除特定位置元素 要在陣列中插入元素、移除特定元素，可以使用 splice()，能通過刪除或替換現有元素或者原地添加新的元素來修改陣列，並以陣列形式回傳被修改的內容。\n此方法會改變原陣列。\n語法：\n1  array.splice(start[, deleteCount[, item1[, item2[, ...]]]])    start：指定修改的起始位置，可以是負數，由末尾計算索引。 deleteCount：表示要移除的數組元素的個數，從起始位置開始刪除。 item1, item2, ...：要插入的元素，由起始位置之後插入，如果不設定將只會刪除元素。  假設我們要在索引位置 2 之後插入一個新的元素：\n1 2 3 4 5  const array = [0, 1, 2, 3, 4, 5]; array.splice(2, 0, \u0026#39;a\u0026#39;); console.log( array ); // [0, 1, \u0026#34;a\u0026#34;, 2, 3, 4, 5]   起始位置設為 2，刪除個數 0。\n如果我們要刪除索引位置 3 的元素：\n1 2 3 4 5  const array = [0, 1, 2, 3, 4, 5]; array.splice(3, 1); console.log( array ); // [0, 1, 2, 4, 5]   起始位置設為 3，刪除個數 1，不設定插入元素。\n3.2 填充陣列 fill() 為 ES6 新增的方法，可以一次設定，起始位置至終止位置的值。不包含終止位置。\n此方法會改變原陣列。\n語法：\n1  array.fill(value[, start[, end]])    value 設定值 start 起始位置 end 終止位置  1 2 3 4 5 6 7  let arr = [0, 1, 2, 3]; console.log(arr.fill(\u0026#39;a\u0026#39;, 1, 3)); // [0, \u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;, 3]  console.log(arr.fill(\u0026#39;b\u0026#39;)); // ) [\u0026#34;b\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;b\u0026#34;]   3.3 複製貼上 copyWithin() 是 ES6 新增的方法，它能夠複製陣列中的某一段，並貼到陣列的其他位置，並取代原本的值。copyWithin() 並不會改變陣列的長度，如果貼上的長度會超過結尾會停止。\n語法：\n1  array.copyWithin(target[, start[, end]])    target：要貼上的起始位置。 start：要複製的起始位置。 end：要複製的結束位置，不包括這個位置元素。 如果是負數由結尾計算。  1 2 3 4 5 6  console.log([1, 2, 3, 4, 5].copyWithin(2)); console.log([1, 2, 3, 4, 5].copyWithin(-2)); console.log([1, 2, 3, 4, 5].copyWithin(0, 2)); console.log([1, 2, 3, 4, 5].copyWithin(0, -2)); console.log([1, 2, 3, 4, 5].copyWithin(0, 3, 4)); console.log([1, 2, 3, 4, 5].copyWithin(-2, -3, -1));   4. 提取陣列中的元素 slice() 會回傳一個新的陣列，這一對是一個由 begin 和 end 決定的原陣列的淺拷貝（包括 begin，不包括end）。\n此方法原陣列不會被改變。\n語法：\n1  array.slice([begin[, end]]);    begin：提取起始處的索引（從 0 開始），從該索引開始提取原陣列元素。 end：提取終止處的索引（從 0 開始），在該索引處結束提取原陣列元素。slice 會提取原陣列中索引從 begin 到 end 的所有元素（包含 begin，但不包含 end）。  begin 和 end 都可以是負數，在這種情況下，從末尾計算索引。\n從陣列中提取索引位置 1 到 2 的元素到新陣列：\n1 2 3 4  const arr = [0, 1, 2, 3, 4]; let newArr = arr.slice(1, 3); console.log( newArr );   如果要提取某位置後的所有元素，可以省略 end：\n1 2 3 4  const arr = [0, 1, 2, 3, 4]; let newArr = arr.slice(2); console.log(newArr); // [2, 3, 4]   因為會建立新的陣列，因此可用來淺拷貝陣列：\n1 2 3 4  const arr = [0, 1, 2, 3, 4]; let newArr = arr.slice(); console.log( newArr ); // [0, 1, 2, 3, 4]   如果搭配展開運算子 ... ，可以建立出一個移除特定位置的新陣列。\n假設要移除索引 3 的元素：\n1 2 3 4 5 6 7  const arr = [0, 1, 2, 3, 4, 5]; let index = 3; let newArr = [...arr.slice(0, index), ...arr.slice(index + 1)]; console.log( newArr ); // [0, 1, 2, 4, 5]   5. 元素數量 陣列的 length 屬性可以查看裡面存放多少資料。\n1 2 3  let array = [1, 2, 3, 4, 5]; console.log( array.length ); // 5   length 屬性可讀可寫，因此也可以將其賦值為0，會等同清空陣列。\n1 2 3  array.length = 0; console.log( array ); // []   如果將 length 屬性賦值的數值小於元素，將會刪除後面的元素。\n但這裡需要注意，如果將 length 給予大於其元素的數值，那會導致陣列變成稀疏陣列。\n5.1 清空 Array 的操作 常見的作法有兩種，兩種看似都是清空陣列，但並不相同：\n Array.length = 0 Array = []  第一種在上面有提到過，就是將陣列元素都移除。\n而第二種要注意的是，陣列跟物件一樣是傳址，每個陣列都會有自己的記憶體位址，而 Array = [ ] 其實是將一個新的空陣列記憶體位置傳給原本存放舊陣列的變數。\n簡單來說，Array.length = 0，是將原本的陣列所有元素移除，而 Array = [] 是重新給一個新陣列。\n舉例說明：\n1 2 3 4 5 6 7 8 9  const myCart = []; myCart.push(\u0026#39;手機\u0026#39;, \u0026#39;電視\u0026#39;); console.log( myCart ); // [\u0026#34;手機\u0026#34;, \u0026#34;電視\u0026#34;]  const MingCart = myCart; MingCart.push(\u0026#39;風扇\u0026#39;); console.log( myCart ); // [\u0026#34;手機\u0026#34;, \u0026#34;電視\u0026#34;, \u0026#34;風扇\u0026#34;]   假設我有一個空購物車，我買了手機、電視，放進購物車。\n小明也有一個購物車，而且跟我共用。\n所以小明加入、刪除商品，我的購物車都會受到影響。\n如果使用 Array.length = 0，因為是共用的購物車，所以小明的購物車也會被清空。\n1 2 3 4  // 承接第一段程式碼  myCart.length = 0; console.log( MingCart ); // []   但如果使用 Array = []，那我會得到一個新的空購物車，而小明還是使用原本的購物車。\n1 2 3 4  // 承接第一段程式碼  myCart = []; console.log( MingCart ); // [\u0026#34;手機\u0026#34;, \u0026#34;電視\u0026#34;, \u0026#34;風扇\u0026#34;]   6. 合併陣列 concat() 用於合併兩個或多個陣列。此方法不會更改現有陣列，而是返回一個新陣列。\n1 2 3 4 5  const arr1 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; const arr2 = [\u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; console.log( arr1.concat(arr2) ); // [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;]   7. 字串相關方法 陣列有自己的 toString 方法，會回傳以逗號分隔的元素列表的字串：\n1 2 3  const arr = [1, 2, 3]; console.log( arr.toString() ); // \u0026#34;1,2,3\u0026#34;   其他轉字串操作的也是一樣結果：\n1 2 3 4  // 承接上方程式碼  console.log( String(arr) ); // \u0026#34;1,2,3\u0026#34; console.log( arr + \u0026#39;\u0026#39; ); // \u0026#34;1,2,3\u0026#34;   因為陣列沒有 Symbol.toPrimitive，也沒有 valueOf()，它們只能執行 toString() 進行轉換。\njoin()  能將一個陣列的所有元素連接成一個字串並回傳這個字符串。如果陣列只有一個項目，那麼將回傳該項目而不使用分隔符號。\n語法：\n1  array.join([separator])   separator 分隔符號，預設為 ,。\n1 2 3 4  let arr = [1, 2, 3]; console.log( arr.join() ); // \u0026#34;1,2,3\u0026#34; console.log( arr.join(\u0026#39;?\u0026#39;) ); // \u0026#34;1?2?3\u0026#34;   9. 排序陣列 reverse() 方法會原地（in place）反轉（reverses）一個陣列。陣列中的第一個元素變為最後一個，而最後一個元素則變成第一個。\n1 2 3 4 5  const arr = [1, 2, 3, 4]; arr.reverse(); console.log(arr); // [4, 3, 2, 1]   sort()方法會原地（in place）對一個陣列的所有元素進行排序，並回傳此陣列。\n語法：\n1  arr.sort([compareFunction])    compareFunction 指定一個函式來定義排序順序。假如省略此參數，陣列將根據各個元素轉為字串後的每一個字元之 Unicode 編碼位置值進行排序。 回傳值：排序後的陣列  如果使用 compareFunction 函式，就要定義這個回呼函式 compareFunction（a, b），讓排序演算法知道兩筆資料項之間的關係，可能的執行結果包括：\n 如果回呼函式回傳值小於 0，則會把 a 排在小於 b 之索引的位置，即 a 排在 b 前面。 如果回呼函式回傳值等於 0，a 與 b 皆不會改變彼此的順序，但會與其他全部的元素比較來排序。 如果回呼函式回傳值大於 0，則會把 b 排在小於 a 之索引的位置，即 b 排在 a 前面。  所以，比較函式會是以下形式：\n1 2 3 4 5 6 7 8 9 10  function compare(a, b) { if (在某排序標準下 a 小於 b) { return -1; } if (在某排序標準下 a 大於 b) { return 1; } // a 必須等於 b  return 0; }   如果比較數值而不是字串，比較函式可以僅僅利用 a 減 b。以下函式將會升冪排序陣列：\n1 2 3  function compareNumbers(a, b) { return a - b; }   如果要降冪排序就改成 b - a。\n範例說明：\n1 2 3 4 5 6 7 8  const inventors = [ { name: \u0026#39;Albert\u0026#39;, year: 1879 }, { name: \u0026#39;Isaac\u0026#39;, year: 1643 }, { name: \u0026#39;Galileo\u0026#39;, year: 1564 }, { name: \u0026#39;Marie\u0026#39;, year: 1867 }, { name: \u0026#39;Johannes\u0026#39;, year: 1571 }, { name: \u0026#39;Nicolaus\u0026#39;, year: 1473 } ];   排序數值大小，將資料依據出生年分排序：\n1 2 3 4 5 6 7 8 9 10 11 12 13  const yearSort = inventors.sort(function(a, b) { return a.year - b.year; }); console.log( yearSort ); // [ // { name: \u0026#39;Nicolaus\u0026#39;, year: 1473 }, // { name: \u0026#39;Galileo\u0026#39;, year: 1564 }, // { name: \u0026#39;Johannes\u0026#39;, year: 1571 }, // { name: \u0026#39;Isaac\u0026#39;, year: 1643 }, // { name: \u0026#39;Marie\u0026#39;, year: 1867 }, // { name: \u0026#39;Albert\u0026#39;, year: 1879 } // ]   排序字串，將資料依據字串第一個字母排序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  inventors.sort(function(a, b) { if(a.name[0] \u0026lt; b.name[0]) { return -1; } if(a.name[0] \u0026gt; b.name[0]) { return 1; } return 0; }); console.log( inventors ); // [ // { name: \u0026#39;Albert\u0026#39;, year: 1879 }, // { name: \u0026#39;Galileo\u0026#39;, year: 1564 }, // { name: \u0026#39;Isaac\u0026#39;, year: 1643 }, // { name: \u0026#39;Johannes\u0026#39;, year: 1571 }, // { name: \u0026#39;Marie\u0026#39;, year: 1867 }, // { name: \u0026#39;Nicolaus\u0026#39;, year: 1473 } // ];   也可以使用 ?: 三元條件運算子簡化：\n1 2 3 4 5 6 7 8 9 10 11 12 13  inventors.sort(function(a, b) { return (a.name[0] \u0026gt; b.name[0]) ? 1 : (a.name[0] \u0026lt; b.name[0]) ? -1 : 0 }); console.log( inventors ); // [ // { name: \u0026#39;Albert\u0026#39;, year: 1879 }, // { name: \u0026#39;Galileo\u0026#39;, year: 1564 }, // { name: \u0026#39;Isaac\u0026#39;, year: 1643 }, // { name: \u0026#39;Johannes\u0026#39;, year: 1571 }, // { name: \u0026#39;Marie\u0026#39;, year: 1867 }, // { name: \u0026#39;Nicolaus\u0026#39;, year: 1473 } // ];   注意事項：\n sort() 不會產生新陣列，會變動原本的陣列。 排序不一定是穩定的，各家瀏覽器都不同，可以參考下面文章。   從 Array 的 sort 方法，聊到各瀏覽器的實作，沒想到 Chrome 和FireFox 的排序如此不同\n 8. 查詢陣列  indexOf(item, from)：從索引 from 的位置往右查詢 item，如果 from 省略則從頭開始。回傳符合的第一個元素的索引，沒有則回傳 -1。 lastIndexOf(item, from)：和上面相同，只是往 from 的左邊查詢，如果省略就是從尾部開始。 includes(item, from)：從索引 from 查詢 item，如果找到則回傳 true。  1 2 3 4 5 6 7 8 9 10  const arr = [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;a\u0026#39;]; console.log(arr.indexOf(\u0026#39;c\u0026#39;)); // 1 console.log(arr.indexOf(\u0026#39;c\u0026#39;, 2)); // 2  console.log(arr.lastIndexOf(\u0026#39;c\u0026#39;)); // 2 console.log(arr.lastIndexOf(\u0026#39;c\u0026#39;, 1)); // 1  console.log(arr.includes(\u0026#39;c\u0026#39;)); // ture console.log(arr.includes(\u0026#39;c\u0026#39;, 2)); // ture   但要注意的是，這些方法是使用 === 嚴格比較。\n如果要處理比較複雜的比較，可以改使用 find() 或 findIndex()。\n陣列兩個容易誤用的重點 陣列兩個容易誤用的重點：\n 稀疏陣列（Sparse Array） 類陣列（Array-Like）  1. 稀疏陣列 稀疏陣列是指陣列中有 插槽（slot） 可能未定義其值或被略過而導致存放 undefined 的狀況，範例如下：\n1 2 3 4 5 6 7  const arr = []; arr[0] = 1; arr[2] = [ 3 ]; console.log( arr[1] ); // undefined console.log( arr.length ); // 3   雖然這樣不會出錯誤，但如果不注意這種小細節，在之後的陣列操作上會出現難以發現的 BUG。\n若使用「很像數字」的字串當成鍵名來存資料，鍵值會被強制轉型為數字。\n1 2 3 4 5  const arr = [ ]; arr[\u0026#39;13\u0026#39;] = 42; console.log( arr.length ); // 14   這樣導致 arr 成了稀疏陣列，其長度就被誤判，因此沒事別對陣列額外新增 鍵值對（key-value）。若索引值非數值還是用乖乖使用物件吧。\n1.1 Array.of() Array() 建構函式建立陣列，有一個常見陷阱，就是當只有一個引數傳入，並不會產生已那個數字為元素的陣列。\n預期建立的陣列為 [3]，但實際結果為一個長度為 3 的稀疏陣列：\n1 2 3 4  const arr = Array(3); console.log( arr[0] ); // undefined console.log( arr.length ); // 3   ES6 新增了 Array.of() 用來取代 Array()，不會發上述的怪異行為：\n1 2 3 4  const arr = Array.of(3); console.log(arr[0]); // 3 console.log(arr.length); // 1   不過一樣很少會用到，使用陣列實值建立陣列優先。\n2. 類陣列（Array-Like） 類陣列（Array-Like）是具有有索引和 length 屬性的物件，可能各種形式的 串列（lists） 或字串，看起來很像陣列，但並非真正的陣列，所以沒有繼承陣列的方法。\n有時候為了使用陣列的方法（例如 map、indexOf 等等方法）來處理類陣列的元素，因此會需要將其轉成真正的陣列。\n舉例來說 DOM 物件操作後所得到的串列：\n1 2 3 4 5  const list = document.getElementsByTagName(\u0026#39;div\u0026#39;); list console.log( list ); // HTMLCollection(3) [div, div, div] console.log( list.length ); // 3   document.getElementsByTagName 會得到一個節點集合，並非真正的陣列，因此沒有繼承陣列的方法，因此需要將它轉成陣列，才能使用陣列的方法。\n轉換串列成陣列的方法\n Array.prototype.slice.call() Array.apply() [...] ES6 新增 Array.from() ES6 新增  1 2 3 4 5 6 7  const link = document.links; Array.isArray( link ); // false Array.isArray( Array.prototype.slice.call(link)); // true Array.isArray( Array.apply(null, link)); // true Array.isArray( [...link]); // true Array.isArray( Array.from(link)); // true   ","description":"幾乎所有程式語言都支援陣列，因為陣列是最簡單的資料結構。","id":38,"section":"posts","tags":["JavaScript","陣列 Array"],"title":"陣列","uri":"https://chupai.github.io/posts/200424_js_array/"},{"content":"這週是 六角鼠年鐵人賽 第十一週，學習基礎演算法之前，先來瞭解基本的資料結構。\n\r為什麼要學習資料結構 因為不同的資料結構，將會影響程式設計（演算法）的方法與效率。\n 程式 = 資料結構 + 演算法\nAlgorithms + Data Structures = Programs\n 選擇正確的資料結構，可以提高演算法的效率。\n什麼是資料結構 在電腦科學中，資料結構（Data Structure）是電腦中儲存、組織資料的方式。簡單來說，當資料存在記憶體中的時候，決定資料的存放順序及存放位置的，就是資料結構。\n舉例來說，假設要儲存考試成績，你不會用變數一個一個去存它，通常會用一個陣列來存放：\n1 2 3 4 5  let score1 = 80; let score2 = 60; let score3 = 70; let scores = [80, 60 , 70];   因為當要儲存的資料變多時，用變數一個一個去存資料，要處理資料時，非常麻煩。\n換句話說，所謂資料結構，就是考慮如何運用變數儲存要處理的資料，而演算法就是要處理這些資料的方法。將資料有組織的存放在程式內，可以提升程式的執行效率。\n常見的資料結構  陣列（Array） 連結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹狀結構（Tree） 圖形結構（Graph） 堆積（Heap） 雜湊表（Hash table）  資料結構的分類 資料結構，根據元素之間的關係，分為兩大類：\n 線性關係的資料結構 非線關係的性結構  1. 線性關係 線性關係的資料結構，其組成資料元素間具有線性關係，簡單來說就是「資料會排成一直線」。\n每個元素只有另外兩個元素相鄰，也就是只有前、後兩個方向：\n 第一個元素沒有前驅者（前面的元素） 最後一個元素沒有後繼者（後面的元素） 其餘的元素都各只有一個前驅者（predecessor）和一個後繼者（successor）  線性關係的資料結構又分為兩種物理結構：\n 順序儲存結構，例：陣列、堆疊、佇列 鏈式儲存結構，例：連結串列  2. 非線性關係 而非線性關係的資料結構，簡單來說就是資料元素間不是只有前後關係。\n非線性關係的資料結構包含：\n 階層關係，例：樹 相鄰關係，例：圖  資料結構操作 常見的資料結構操作的時間複雜度與空間複雜度。\n圖片來源：Know Thy Complexities!\n總結 不過大多數情況下 Javascript 開發關心的是「資料的邏輯結構」而非「資料的儲存結構」。因為 JavaScript 只有物件，陣列實際上也是物件，多數的資料結構都必須使用物件或陣列來模擬實作。\n","description":"這週是六角鼠年鐵人賽第十一週，學習基礎演算法之前，先來瞭解基本的資料結構。","id":39,"section":"posts","tags":["演算法 Algorithm","資料結構","w3HexSchool"],"title":"JavaScript 學演算法（三）- 資料結構概述","uri":"https://chupai.github.io/posts/200419_data_structure/"},{"content":"這週是 六角鼠年鐵人賽 第十週（是不是有銅角獎啦？！），說明如何評估演算法的好壞。\n\r演算法的好壞 一個問題不一定只有一種演算法能解決。那我們怎麼評估演算法的好壞呢？\n最直覺的方式，就是測量程式的執行時間、程式的記憶體使用量。\n但是，即便是相同的演算法，也會因為以下變數而有所不同：\n 不同電腦的處理速度 實作的程式語言 輸入的大小 不同情況的資料  所以需要用一個「不受環境、數據狀況，比較客觀的方式」去分析一個演算法。\n所以我們會用 複雜度 來分析演算法：\n 時間複雜度（Time complexity）\n指演算法所耗費的時間。 空間複雜度（Space Complexity）\n指演算法所需要消耗的儲存記憶體資源。  時間複雜度與空間複雜度是相互影響的，當追求一個較好的時間複雜度時，可能會使空間複雜度的性能變差。舉例來說，Google Chrome 相較於其他瀏覽器，運行速度較快，但它的缺點就是占用很多記憶體。\n根據調查顯示，用戶對於執行效率有極高的要求，對於網頁開啟的忍耐極限是 6 秒甚至更短。在這個大背景下，一個好的演算法，更專注於討論時間複雜度。另外，現在的儲存空間很便宜，而且當 資料量變大 時，空間複雜度的差異通常不大，但 時間複雜度則會有極大的差異。\n不同情況下的分析 每當輸入資料的情況不同時，演算法呈現的效果也不同，舉例來說，在圖書館找一本書，並一本一本找：\n 最佳情況：第一本就是要找的書 最糟情況：最後一本才是要找的書 平均情況：中途就找到要找的書  上述三種情況都可以被用來分析演算法。但最佳情況對演算法沒有多大幫助，通常我們只考慮最糟情況，也就是演算法複雜度的上限值。\n輸入大小與執行時間的關係 我們舉一個非常簡單的例子。\n以 求等差數列的和 來說，假設要求出 1 + 2 + 3 + \u0026hellip; + n 的和，有兩種作法：\n 一個一個加 套用公式計算  用 for 迴圈一個一個的加：\n1 2 3 4 5 6 7  function sum(n) { let sum = 0; for(let i = 0; i \u0026lt;= n; i++) { sum += i; } return sum; }   等差數列的和公式，我們小時候應該都有學過：\n 一個等差數列的和，等於其首項與末項的和，乘以項數除以 2。\n 1 2 3  function sum(n) { return (1 + n) * n / 2; }   兩種作法的時間差異：\n 如果 $1$ 累加到 $n$ 迴圈需要跑 $n$ 次 不論 $n$ 多大，都只需要執行 $1$ 次。  假設執行一次只需要 0.01毫秒，當 $n$ 不大時，一個一個加與套用公式計算的時間差異並不大，但隨著 $n$ 越來越大，你會發現使用一個一個加的時間會變得非常可觀。\n由此可知，當輸入量非常大時，不同演算法執行上效率差異會非常大。\n 演算法效率：執行所需時間與資料量 $n$ 的關係。\n 演算法執行時間的計算方式  執行時間 = 執行次數 * 每次執行所需的時間\n 但是 每次執行所需的時間 會根據機器和語言的的差異而有所不同，因此演算法只考慮執行的次數。\n將演算法中基本操作的執行次數作為演算法時間複雜度的度量，即時間複雜度不是演算法程式的運行時間，而是其中基本操作的總次數。\n舉例來說：\n1 2 3 4 5 6 7  function sum(n) { let sum = 0; for(let i = 0; i \u0026lt; n; i++) { sum += i; } return sum; }   假設每行的執行時間都一樣，記做 $t$。\n line2：需要 $1$ 個 $t$ 的時間 line3：需要 $n$ 個 $t$ 的時間 line4：也是 $n$ 個 $t$ 的時間 line6：需要 $1$ 個 $t$ 的時間 那麼執行時間就是 $(2n + 2) * t$ 執行次數為 $2n + 2$  再考量下面這個例子：\n1 2 3 4 5 6 7 8 9  function sum(n) { let sum = 0; for(let i = 0; i \u0026lt; n; i++) { for(let j = 0; j \u0026lt; n; j++) { sum += i * j; } } return sum; }    line2：需要 $1$ 個 $t$ 的時間 line3：需要 $n$ 個 $t$ 的時間 line4：也是 $n^2$ 個 $t$ 的時間 line5：也是 $n^2$ 個 $t$ 的時間 line8：需要 $1$ 個 $t$ 的時間 執行次數為 $2n^2 + n + 2$  複雜度分析工具 我們在之前已經提過，演算法通常只考慮最糟情況，也就是演算法複雜度的上限值。\n因此我們會用 Big O Notation 來表示演算法的複雜度。\n Big O Notation（$O$），念作 Big Oh 😮，是用於描述函數漸近行為的數學符號，更確切地說，它是用另一個函數來描述一個函數數量級的漸近上界，用 $O(f(n))$ 表示。\n 假設輸入 $n$，而演算法的執行時間為一個函數 $f(n)$，以下五個演算法分別為：\n $1$ $10$ $2n + 1$ $2n^2$ $\\log_2n$  當 $1$ 與 $10$ 比較時，並不會說 $1$ 比 $10$ 有效率，因為當 $n$ 趨近無限大時，$1$ 與 $10$ 兩者差異不大，舉例來說：假如你身上有一千億，當你要花 1元跟 10元時，你會認為 10元的比較貴嗎？不會都是小錢。\n分析演算法是看當資料量「最多」會達到怎麼樣的趨勢，也就是 $n$ 趨近無限大時，並不會在意細節，只看函數的最高次方，會忽略係數、其他次方項與常數。\n用 Big O 表示上述函數之複雜度分析：\n $O(1)$ $O(1)$ $O(n)$ $O(n^2)$ $O(\\log n)$  由此可知，當我們在計算演算法的時間時，只需要大概的算一下迴圈數，大致上判斷一下丟進去的資料量會讓程式執行幾次即可，不需要像之前一樣計算的那麼仔細。\n常見時間複雜度 圖片來源：8 time complexities that every programmer should know\n根據上圖，若同樣處理 $n$ 筆資料，那麼各個時間複雜度成本如下：\n$O(1)\u0026lt;O(\\log n)\u0026lt;O(n)\u0026lt;O(n \\log n)\u0026lt;O(n^2)\u0026lt;O(2^n)\u0026lt;O(n!)$\n成本越高，表示效率越差。\n常見的時間複雜度：\n   執行時間 名稱 演算法舉例     $O(1)$ 常數時間 Constant time 普通數學運算   $O(\\log n)$ 對數時間 Logarithmic time 二分搜尋   $O(n)$ 線性時間 Linear time 簡易搜尋、插入排序法   $O(n \\log n)$ 線性對數時間 Linearithmic Time 比較排序   $O(n^2)$ 平方時間 Quadratic time 選擇排序、泡沫排序   $O(2^n)$ 指數時間 Exponential time 費波那契數列   $O(n!)$ 階乘時間 Factorial time 暴力搜尋解決旅行推銷員問題    輸入 10、100、1000 資料量需花費的時間比較：\n   執行時間 10個資料量 100個資料量 1000個資料量     $O(1)$ 1 1 1   $O(\\log n)$ 3 6 9   $O(n)$ 10 100 1000   $O(n \\log n)$ 30 600 9000   $O(n^2)$ 100 10000 1000000   $O(2^n)$ 1024 1.26e+29 1.07e+301   $O(n!)$ 3628800 9.3e+157 4.02e+2567    當複雜度到達或超過 $O(2^n)$ 時，只要 $n$ 稍大一點，基本上程式就會跑到天荒地老都跑不出來，因此最好避免過高的複雜度。\n空間複雜度 上邊説了那麼一大堆的時間複雜度，相比空間複雜度就是指演算法執行時所花費的記憶體空間的趨勢。\n其計算方式與時間複雜度相似，也使用 Big-O 來表示其複雜度。\n1. 計算演算法使用記憶體量 計算演算法所需的記憶體量，只需要計算使用的變數量。\n舉例來說：\n1 2 3 4 5 6 7  function sum(n) { let sum = 0; for(let i = 0; i \u0026lt; n; i++) { sum += i; } return sum; }   不管程式的執行步驟數是多少，我們的變數始終只有 sum 與 i，也就是變數量只有 2。因此空間複雜度為 $O(1)$。\n再考量下面這個例子：\n1 2 3 4 5 6 7  function show(n) { let arr = []; for (let i = 0; i \u0026lt; n; i++) { arr.push(i); } return arr; }   迴圈每次執行一次 push 方法，就會申請一個空間存儲變量，很明顯的，記憶體的佔用量會隨著輸入量而線性成長，故這個演算法的空間複雜度為 $O(n)$。\n2. 常見的空間複雜度 常見的空間複雜度只有 $O(1)$、$O(n)$、$O(n^2)$，其他的話很少會用到。\n總結 評估演算法的好壞，就是要分析演算法的複雜度，而時間複雜度與空間複雜度式相互影響的，但時間複雜度比空間複雜度重要。\n","description":"這週是 六角鼠年鐵人賽 第十週（是不是有銅角獎啦？！），說明如何評估演算法的好壞。","id":40,"section":"posts","tags":["演算法 Algorithm","w3HexSchool"],"title":"JavaScript 學演算法（二）- 演算法分析","uri":"https://chupai.github.io/posts/200406_analysis_of_algorithms/"},{"content":"這週是 六角鼠年鐵人賽 第九週，接下來幾週大概是我學習演算法筆記，既然是學前端，當然就是使用 JavaScript 來實作。\n\r何謂演算法？ 演算法，英文名稱 Algorithm，中國稱為 算法。\n 演算法，簡單來就是一套解決問題的方法。\n 要簡單明瞭何謂演算法，推薦觀看這個影片：人腦也可以執行演算法 - David J. Malan。\n1. 演算法與程式 演算法通常是電腦所執行的，但演算法在電腦誕生之前就存在，演算法是數學家所提出來的。\n電腦看起來很聰明，但其實電腦只會做 0 跟 1 的運算，而我們就是透過 程式，把現實世界需要解決的問題變成數學問題，丟給電腦來幫我們做運算處理，而這個解題的方法就是演算法。\n所以說，演算法是用以執行計算或完成作業的程序，所有步驟都要能用數學方式表現，而程式是實作演算法的方式。也就是說：\n 演算法相當於「思考程序」 程式相當於為了表現演算法的「語言」  2. 演算法的表示方式  設計程式時，通常會使用 虛擬碼 pseudocode 來表示； 設計電子電路，會使用 流程圖 來表示； 而為了理解演算法，會使用文字與圖片來輔助說明。  演算法的定義 演算法 是對特定問題求解步驟的一種描述，一般演算法嚴謹的條件必須符合五個標準：\n 輸入（Input）：至少有零個或以上的輸入（可以沒輸入或多個輸入）。 輸出（Output）：至少有一個或以上回傳結果（經過演算法計算獲得）。 確定性/明確性（Definiteness）：每一個指令步驟必須明確而不造成混淆。在一定條件下，相同的輸入只能有唯一結果。 有限性（Finiteness）：在有限步驟後一定會結束（完成或終止），確保不會進入無窮迴圈。 可行性/有效性（Effectiveness）：步驟清楚可行，能使用數學運算出結果（表示能夠實現）。  一個好的演算法 一個演算法如果要設計好，必須達到以下目標：\n 正確性（correctness）：不含語法錯誤，對各種需求的輸入數據都能滿足。 可讀性（readability）：簡潔易懂。 健壯性（robustness）：非法數據被輸入時，不會引起演算法崩潰、出錯。 效率與低存儲量需求：即，演算法執行時間短 或 演算法記憶體使用量低。  總結 這週就簡敘述何謂演算法，下週將說明如何分析演算法的好壞。\n目錄 前言：\n 何謂演算法？ 演算法分析  資料結構：\n 資料結構概述 陣列 Array 鏈結串列 Linked list 堆疊 ＆ 佇列 集合 \u0026amp; 映射  排序演算法：\n 排序演算法 合併排序 快速排序 ","description":"這週是 六角鼠年鐵人賽 第九週，接下來幾週大概用記錄我學習演算法的筆記，既然是學前端，當然就是使用 JavaScript。","id":41,"section":"posts","tags":["演算法 Algorithm","w3HexSchool"],"title":"JavaScript 學演算法（一）- 何謂演算法？","uri":"https://chupai.github.io/posts/200404_algorithm/"},{"content":"這週是 六角鼠年鐵人賽 第八週，紀錄 Vue 表單驗證套件 - Vee Validate 操作方法。\n前言  VeeValidate 官網\n VeeValidate 是專用於 Vue.js 的表單驗證套件。它有很多預設驗證規則，也支持自定義驗證規則。\n由於 2.x版本 與 3.x版本 的操作非常不同，所以簡單紀錄一下。\nVeeValidate 2 1. 安裝 安裝舊版本：\nnpm install vee-validate@2.2.15 --save 導入：\n1 2 3  // main.js import VeeValidate from \u0026#39;vee-validate\u0026#39;; Vue.use(VeeValidate);   1.1 會遇到的問題 如果 Focus 到 input 標籤再點外面，不會進行驗證，可以修改 events，加上 blur：\n1 2 3 4 5  // main.js  Vue.use(VeeValidate, { events: \u0026#39;input|blur\u0026#39;, });   1.2 中文化 舊方法 2.1.0-beta.24版之前：\n1 2 3 4 5 6 7  // main.js  import VeeValidate from \u0026#39;vee-validate\u0026#39;; import zhTW from \u0026#39;vee-validate/dist/locale/zh_TW\u0026#39;; VeeValidate.Validator.localize(\u0026#39;zhTW\u0026#39;, zhTW); Vue.use(VeeValidate);   新方法，必須先安裝 vue-i18n：\nnpm install vue-i18n --save 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // main.js import VeeValidate from \u0026#39;vee-validate\u0026#39;; import zhTW from \u0026#39;vee-validate/dist/locale/zh_TW\u0026#39;; import VueI18n from \u0026#39;vue-i18n\u0026#39;; Vue.use(VueI18n); const i18n = new VueI18n({ locale: \u0026#39;zhTW\u0026#39;, }); Vue.use(VeeValidate, { events: \u0026#39;input|blur\u0026#39;, i18n, dictionary: { zhTW, }, }); // 記得載入 i18n new Vue({ i18n, router, render: (h) =\u0026gt; h(App), }).$mount(\u0026#39;#app\u0026#39;);   2. 基本用法 1 2 3 4 5 6 7 8  \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34; placeholder=\u0026#34;輸入姓名\u0026#34; v-validate=\u0026#34;\u0026#39;required\u0026#39;\u0026#34; :class=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: errors.has(\u0026#39;name\u0026#39;) }\u0026#34; /\u0026gt; \u0026lt;span v-if=\u0026#34;errors.has(\u0026#39;name\u0026#39;)\u0026#34;\u0026gt;請輸入姓名\u0026lt;/span\u0026gt;    input 標籤內要設定 name 這個特性，特性值的部分則是根據該欄位性質做設定，例：姓名就是 name，地址就是 address。 加上 v-validate=\u0026quot;'required'\u0026quot;，表示這一個欄位是必填的。 errors.has('name') ，填入 name 特性值。初始值為 fasle，當觸發 input 標籤時，就會開始驗證，如果欄位未填寫值為 true。  可以配合 v-if 顯示提式字； 或是搭配 :class 加入提式樣式。    假設要驗證 email 格式，則可以使用 v-validate=\u0026quot;'required|email'\u0026quot;。\n而 errors.first('email') 它會根據 email 驗證的各種狀態來顯示不同的提示文字。\n2.1 獲取錯誤訊息  errors.first('field')：獲取關於當前 field 的第一個錯誤訊息 collect('field')：獲取關於當前 field 的所有錯誤訊息 has('field')：當前 filed 是否有錯誤 all()：當前表單所有錯誤 any()：當前表單是否有任何錯誤  ３. 表單提交前的處理 最後我們還需要設定表單驗證方法，來避免送出錯誤的資料格式：\n1 2 3 4 5 6 7  this.$validator.validate().then((result) =\u0026gt; { if (result) { // 當驗證成功時執行 AJAX 的行為  } else { // 驗證失敗產生的行為  } });   VeeValidate 3 VeeValidate 在 v3.x版本之後的使用方法與之前完全不同。\n1. 安裝 安裝最新版本 vee-validate：\nnpm install vee-validate --save 導入：\n1 2 3 4 5 6 7 8 9 10 11 12 13  // main.js import { ValidationObserver, ValidationProvider, extend, localize} from \u0026#39;vee-validate\u0026#39;; import * as rules from \u0026#39;vee-validate/dist/rules\u0026#39;; import TW from \u0026#39;vee-validate/dist/locale/zh_TW.json\u0026#39;; Object.keys(rules).forEach((rule) =\u0026gt; { extend(rule, rules[rule]); }); localize(\u0026#39;zh_TW\u0026#39;, TW); Vue.component(\u0026#39;ValidationObserver\u0026#39;, ValidationObserver); Vue.component(\u0026#39;ValidationProvider\u0026#39;, ValidationProvider);   安裝內容會在下方依序說明。\n2. 添加規則 預設情況下，VeeValidate 不附帶任何驗證規則，這是為了使檔案輕量。\n首先導入定義規則所需的 extend 函式：\n1 2 3  import { extend } from \u0026#39;vee-validate\u0026#39;; // rules   接下來，就是加入規則。\n2.1 安裝所有規則 安裝所有規則有兩種遍歷作法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  import { extend } from \u0026#39;vee-validate\u0026#39;; import * as rules from \u0026#39;vee-validate/dist/rules\u0026#39;; // 作法一 Object.keys(rules).forEach((rule) =\u0026gt; { extend(rule, rules[rule]); }); // 作法二(with typescript) for (let [rule, validation] of Object.entries(rules)) { extend(rule, { ...validation, }); }   除了上述方法，另一種方法是安裝 vee-validate 的完整捆綁包，而不是預設捆綁包，該捆綁包預裝了所有驗證規則及其英文消息。\n將 'vee-validate' 替換成 'vee-validate/dist/vee-validate.full.esm'，就可以一次安裝所有驗證規則，而不用導入 extend 函式。\n1  import { ValidationObserver, ValidationProvider } from \u0026#39;vee-validate/dist/vee-validate.full.esm\u0026#39;;   但不建議一次安裝全部規則，應該使用下面的方式，按照需求安裝。\r 2.2 導入規則 為了避免一次加載全部規則，我們可以選擇需求來導入規則：\n1 2 3 4 5  import { extend } from \u0026#39;vee-validate\u0026#39;; import { required, email } from \u0026#39;vee-validate/dist/rules\u0026#39;; // 按需求導入規則  extend(\u0026#39;required\u0026#39;, required); extend(\u0026#39;email\u0026#39;, email);   更多可用規則可以參考 官方文件。\n3. 基本用法 導入 ValidationProvider 元件：\n1 2 3 4 5 6 7 8 9 10 11  import { ValidationProvider } from \u0026#39;vee-validate\u0026#39;; // 在 main.js 全域註冊元件 Vue.component(\u0026#39;ValidationProvider\u0026#39;, ValidationProvider); // 區域註冊元件（推薦） export default { components: { ValidationProvider, }, };   2.X 版原本是添加 v-validate，而 3.X版則改用 ValidationProvider 元件進行包裹：\n1 2 3 4 5 6 7 8 9 10  \u0026lt;ValidationProvider v-slot=\u0026#34;{ failed, errors }\u0026#34; name=\u0026#34;name\u0026#34; rules=\u0026#34;required\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34;\u0026gt;*收件人姓名\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34; :class=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: failed }\u0026#34; placeholder=\u0026#34;輸入姓名\u0026#34; /\u0026gt; \u0026lt;span v-if=\u0026#34;failed\u0026#34; class=\u0026#34;text-danger\u0026#34;\u0026gt;{{ errors[0] }}\u0026lt;/span\u0026gt; \u0026lt;/ValidationProvider\u0026gt;    name 為報錯時，顯示的名稱。 在 rules 上，添加要驗證的規則。 插槽範圍內可用的屬性，可以參考 官方文件。  errors：錯誤訊息列表，errors[0] 則代表驗證錯誤規則底下定義的 messages failed：如果經過驗證且無效，則值為 false    預設情況下，ValidationProvider 渲染器為 span 標籤，可以使用套件提供的 prop 來改變呈現標籤：\n1  \u0026lt;ValidationProvider tag=\u0026#34;div\u0026#34;\u0026gt;\u0026lt;/ValidationProvider\u0026gt;   3.3 更詳細 更多可用 prop 可以參考 官方文件。\n另外還提供了許多方法可以使用，可以參考 官方文件。\n4. 表單提交前的處理 1 2 3 4 5 6 7 8 9 10 11  import { ValidationObserver } from \u0026#39;vee-validate\u0026#39;; // 在 main.js 全域註冊元件 Vue.component(\u0026#39;ValidationObserver\u0026#39;, ValidationObserver); // 區域註冊元件（推薦） export default { components: { ValidationObserver, }, };   詳細的處理表單範例，可以參考 官方文件。\n基本範例：\n1 2 3 4 5 6  \u0026lt;ValidationObserver v-slot=\u0026#34;{ invalid }\u0026#34;\u0026gt; \u0026lt;form @submit.prevent=\u0026#34;onSubmit\u0026#34;\u0026gt; \u0026lt;!-- .... --\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; :disabled=\u0026#34;invalid\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/ValidationObserver\u0026gt;   提交按鈕目前為禁用，只有當表單通過驗證才可以送出。\n提交前驗證：\n1 2 3 4 5  \u0026lt;ValidationObserver v-slot=\u0026#34;{ handleSubmit }\u0026#34;\u0026gt; \u0026lt;form @submit.prevent=\u0026#34;handleSubmit(onSubmit)\u0026#34;\u0026gt; \u0026lt;!-- .... --\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/ValidationObserver\u0026gt;   ValidationObserver 提供了一個 handleSubmit 可用於保護表單提交的 handleSubmit 功能。\n重置表單：\n1 2 3 4 5 6  \u0026lt;ValidationObserver v-slot=\u0026#34;{ reset }\u0026#34;\u0026gt; \u0026lt;form @reset.prevent=\u0026#34;reset\u0026#34;\u0026gt; \u0026lt;!-- .... --\u0026gt; \u0026lt;button type=\u0026#34;reset\u0026#34;\u0026gt;Reset\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/ValidationObserver\u0026gt;   4.1 使用 $refs 先通過 $refs 找到 ValidationObserver 元件，呼叫組件中的方法 validate()，如果所有條件都為真（就是說所有的校驗都通過了）回傳 true，否則回傳 false。\n1 2 3 4 5  \u0026lt;ValidationObserver ref=\u0026#34;form\u0026#34;\u0026gt; \u0026lt;form @submit.prevent=\u0026#34;onSubmit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/ValidationObserver\u0026gt;   1 2 3 4 5 6 7 8 9  onSubmit () { this.$refs.form.validate().then((success) =\u0026gt; { if (success) { // 證成功後的行為包含 AJAX傳送、重製表單等等  } else { // 驗證失敗產生的行為  } }); },    官方文件。\n 4.2 顯示初始驗證狀態 使用 immediate顯示　初始驗證狀態：\n1 2 3  \u0026lt;ValidationObserver rules=\u0026#34;required\u0026#34; v-slot=\u0026#34;{ errors }\u0026#34;　immediate\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/ValidationObserver\u0026gt;   詳細的互動和用戶體驗範例，可以參考 官方文件。\n4.3 更詳細 插槽範圍內可用的屬性，可以參考 官方文件。\n更多可用 prop 可以參考 官方文件。\n5. 驗證狀態 驗證狀態\n6. 中文化 vee-validate 附帶了一個很小的 i18n 字典，可滿足基本的 i18n 需求。vee-validate 的預設語言是 en。\n雖然 vee-validate 具有 40 多個可用於互動的驗證的語言環境，但是預設情況下不會安裝它們，因此我們需要導入所需的語言環境。\n導入安裝語言環境所需的 localize 函式：\n1  import { localize } from \u0026#39;vee-validate\u0026#39;;   安裝需要的使用語言環境，並使用 localize() 增加新的語言環境：\n1 2 3  import TW from \u0026#39;vee-validate/dist/locale/zh_TW.json\u0026#39;; localize(\u0026#39;zh_TW\u0026#39;, TW);   ","description":"這週是 六角鼠年鐵人賽 第八週，紀錄 Vue 表單驗證套件 - Vee Validate 操作方法。","id":42,"section":"posts","tags":["VeeValidate","Vue","w3HexSchool"],"title":"Vue筆記 - 表單驗證套件 VeeValidate","uri":"https://chupai.github.io/posts/200328_vee-validate/"},{"content":"這週是 六角鼠年鐵人賽 第七週，挑戰剛開始時，我的文章是放在 Bloggi，而且第一週文章就是 Bloggi 如何使用（明顯混分😂），但後來想想，Bloggi 沒有留言、沒有備份、嵌入 CodePen 會跑版，為了避免之後不必要的麻煩，還是用自己建立一個 Blog 吧。\n\rGitHub Pages 架設部落格最頭痛的問題就是放網站的空間，通常架設網站不是自己用 NAS 來架設，就是花錢租主機空間。\n以上兩種方法都是需要一定的花費，但是透過 GitHub Pages 來架站，則完全免費，但也有一定的 條件：\n 網站大小不能超過 1 GB 網站每月流量不能超過 100 GB 一小時內的網站更新不得超過 10 次  以上限制對一般需求一定夠用，而且 GitHub 是著名的軟體原始碼代管服務，有一定的穩定性。\n要說唯一的缺點，就是 GitHub Pages 只能架設「靜態網站」，因此無法架設 Wordpress 之類的部落格。\n這時候就需要使用到 靜態網頁產生器 來建立 Blog。\n1. 熱門靜態網頁產生器  Top 5 Static Site Generators for 2020 10 best static site generators  Hugo 簡介  Hugo 官網\n Hugo 是一個用 Go 語言編寫的靜態網站生成器，最大的優點就是編譯速度相對於 Jekyll、Hexo 簡直是飛快。\n 基於 go 語言開發，沒有錯綜複雜的依賴關係 社區活躍 功能完善 前端語言支持的種類豐富 整體框架靈活易懂 修改即時預覽  近期有越來越多人因為 Hugo 的編譯速度，將部落格從 Hexo 搬移到 Hugo，不過 Hugo 也有一個很大的缺點，就是相對 Hexo 來說，Blog 的主題太少，也是有人因為 Hexo 有喜歡的主題而捨棄 Hugo。\n搭建 Hugo 1. 前置作業 MacOS 可以直接使用 Homebrew 安裝 Hugo。\nbrew install hugo 在 Windsow 環境必須先下載 hugo_extended_0.67.0_Windows-64bit.zip。\n解壓縮後，會有一個 hugo.exe 檔案。創建一個新資料夾：C:\\hugo，並將 hugo.exe 檔案放到裡面。\n接下來配置環境變數，點選本機（右鍵） \u0026gt; 內容 \u0026gt; 進階系統設定 \u0026gt; 環境變數 \u0026gt; Path \u0026gt; 編輯 \u0026gt; 新增路徑：C:\\hugo。\n2. 建立一個專案 開啟終端機並切換到 hugo/ 資料夾下，執行以下命令：\nhugo new site myBlog myblog 可以替換成任意名稱。\n機器上會產生一個 myBlog 資料夾，結構如下：\nmyBlog/ │ ├── archetypes/ │ │ │ └─ default.md # 預設 markdown ├── content/ # 頁面、文章（markdown） ├── data/ # 資料庫 ├── layouts/ # 自定義的樣板 ├── static/ # 靜態資源 ├── themes/ # 網站的主題 └── config.toml # 網站的配置 3. 加入主題 因為 Hugo 預設沒有任何主題的，因此必須在 Hugo Themes 選擇一個來套用。\n記得先安裝 git 工具，接下來在 myBlog/ 資料夾下加入 git 版控：\ngit init 從 Github 下載主題並將其添加到 theme 目錄中：\ngit submodule add https://github.com/AmazingRise/hugo-theme-diary.git themes/diary 如果沒安裝 git：\n 可以直接下載該主題最新版本，並解壓縮； 將資料夾重新命名 並將其移至 themes 資料夾。  最後開啟跟目錄下的 config.toml 檔案，設定使用主題：\ntheme = \u0026quot;diary\u0026quot; 或是將 theme/ 內的 config.toml 取代根目錄的。\n最基本的主題安裝流程大概是這樣。\n但要注意，因為 config 配置檔，支援 toml、yaml、json 三種格式，也可以放在 config/ 資料夾內，然後拆分不同模組的配置。所以並不是每個主題的安裝方式都相同，因此最好詳細閱讀每個主題下方的說明。\n4. 新增頁面 hugo new 會根據 archetypes/ 資料夾下的 default.md 產生在 content/ 資料夾下。\nhugo new [路徑]頁面名.md 單頁面，一般會放在 content/ 資料夾下，例如：\nhugo new about.md 文章一般會放在 content/posts/ 內，例如：\nhugo new posts/my-first-post.md 不同的主題，會有不同的資料夾結構，單頁面與文章的 Front Matter 設定也都不相同，因此可以查看主題文件說明。\n5. 本地端測試 預覽草稿 Draft：\nhugo server -D 預覽（不包含草稿）：\nhugo server 預覽網址：http://localhost:1313/\n建議在本地測試時，config.toml 設定檔內的 baseURL 先設為空值。\n自定義 1. Front Matter Front-matter 是 md 檔案最上方的分隔區域，用於指定個別檔案的變數。\n預設使用 yaml 格式，使用 --- 分隔：\n1 2 3 4 5  --- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true ---   另外還支持 toml、json 格式，分別使用 +++ 與 {} 分隔。\n預設屬性分別為：\n title：標題名，使用 hugo new 建立會與檔名相同。 date：日期，使用 hugo new 建立為目前時間。 draft：草稿，如果是 true 生成網站時，不包括此頁面。  1.1 常用 Front Matter 屬性 另外，列出其他 Hugo 支持的常用 Front Matter 屬性：\n description：內容描述，主要用於 SEO 優化。 tags：標籤。 categories：分類。 keywords：關鍵字。 url：文章 url 名稱，預設使用檔案名稱。 weight：列表頁的文章排序，越小越靠前，無設定則依照時間排序。  其他屬性，主要看你用的主題所對應到板模上的變數，主題的文件都會詳細說明。\n1.2 Archetypes Archetypes 意思為原型，可以當作是生成 md 檔案的模板。\n當我們使用 hugo new 建立 md 檔案時，會根據 archetypes/ 資料夾下的模板來建立。\n舉例來說，如果 archetypes/ 下有一個 about.md，那麼以下指令就會根據它來產生檔案。\nhugo new about.md 如果沒有相同的檔名，會根據 default.md 來產生檔案。\n2. Config Hugo 將整個網站的設定配置都集中在 config.toml 檔中，預設為 toml 格式，一樣支持另外兩種格式（yaml、json）。\n 完整 Hugo Config 可以詳閱官方文件 Configure Hugo。\n 發佈到 Github Pages 上  Host on GitHub\n 事前準備：\n 安裝 Git 2.8 以上 GitHub 帳號 Hugo 網站  1. 建立 repository 在 GitHub 建立一個 repository，命名為：帳號.github.io。\n2. 設定 baseURL 將 config.toml 配置檔內的 baseURL 設為：\n1  baseURL = \u0026#34;http://帳號.github.io/\u0026#34;   3. 建立 public 資料夾 hugo 執行 hugo 就會產生 public/ 的資料夾。\n4. 上傳 在 public/ 資料夾下執行以下命令：\ngit init git remote add origin https://github.com/帳號/帳號.github.io.git git add . git commit -m \u0026quot;my Blog\u0026quot; git push -u origin master 接下來可能會讓你輸入你的 Github 帳號和密碼，之後就可以去 Github 和 http://帳號.github.io 查看是否成功。\n5. 更新 之後添加文章，只需要重新編譯 Hugo，重新提交到 Github 即可。\ngit add . git commit -m \u0026quot;本次更新的說明\u0026quot; git push origin master 新增留言板 因為是靜態網頁，所以留言板就區要依賴第三方。\nDisqus 是整合性留言管理系統，用來管理各種社群的留言平台。\n1. 註冊帳號 註冊帳號並取得 shortname。\n流程蠻簡單的，如果不清楚，可以自行搜尋一下教學流程，這裡就不多做說明。\nLanguage 如果選擇 Chinese 只有簡體。\n2. 在 Hugo 啟用 假設你的主題已經預設 Disqus 留言板了，那麼只需要在config.toml 配置檔填入 Disqus 的 shortname。\n1  disqusShortname = \u0026#34;yourdiscussshortname\u0026#34;   如果沒有，就需要將官方提供的檔案加到你的網站中。\n在 layouts/partials/ 資料夾下，加入 disqus.html 檔案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026lt;div id=\u0026#34;disqus_thread\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; (function() { // Don\u0026#39;t ever inject Disqus on localhost--it creates unwanted  // discussions from \u0026#39;localhost:1313\u0026#39; on your Disqus account...  if (window.location.hostname == \u0026#34;localhost\u0026#34;) return; var dsq = document.createElement(\u0026#39;script\u0026#39;); dsq.type = \u0026#39;text/javascript\u0026#39;; dsq.async = true; var disqus_shortname = \u0026#39;{{ .Site.DisqusShortname }}\u0026#39;; dsq.src = \u0026#39;//\u0026#39; + disqus_shortname + \u0026#39;.disqus.com/embed.js\u0026#39;; (document.getElementsByTagName(\u0026#39;head\u0026#39;)[0] || document.getElementsByTagName(\u0026#39;body\u0026#39;)[0]).appendChild(dsq); })(); \u0026lt;/script\u0026gt; \u0026lt;noscript\u0026gt;Please enable JavaScript to view the \u0026lt;a href=\u0026#34;https://disqus.com/?ref_noscript\u0026#34;\u0026gt;comments powered by Disqus.\u0026lt;/a\u0026gt;\u0026lt;/noscript\u0026gt; \u0026lt;a href=\u0026#34;https://disqus.com/\u0026#34; class=\u0026#34;dsq-brlink\u0026#34;\u0026gt;comments powered by \u0026lt;span class=\u0026#34;logo-disqus\u0026#34;\u0026gt;Disqus\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;   如果要在本地端測試 Disqus，可以將 if (window.location.hostname == \u0026quot;localhost\u0026quot;) return; 註解掉。\n最後開啟你主題內的 layouts/_default/ 資料夾中的 single.html 在適當位置貼上下面這段：\n1  {{ partial \u0026#34;disqus.html\u0026#34; . }}   這樣就完成了。\nGoogle Analytics 1. 建立帳戶 前往 Google Analytics，可以使用 Google 帳號，直接註冊。\n建立帳戶取得 Tracking ID。\n2. Hugo 設定 在 config.toml 加入 Tracking ID：\ngoogleAnalytics = \u0026quot;UA-XXXXX-Y\u0026quot; 在主題內的 layouts/partials/ 資料夾中的 head.html 在適當位置貼上下面這段：\n1  {{ template \u0026#34;_internal/google_analytics_async.html\u0026#34; . }}   容易遇到的問題 1. Markdown 圖片路徑 在 Markdown 圖片路徑中，是以 static/ 為根目錄寫全路徑。\n圖片位置：/static/imgae/cover/post1.png，那麼在 Markdown 中寫作：\n1  ![圖片說明](/imgae/cover/post1.png)   總結 目前就先記錄到這，之後如果有用到 Hugo 其他功能再補上。\n文章部分，之後會慢慢把 Blogger 的舊文搬過來，還有 Hackmd 的筆記整理後丟過來 🙂\n","description":"這週是 六角鼠年鐵人賽 第七週，Hugo 建立 Blog。","id":43,"section":"posts","tags":["Hugo","w3HexSchool"],"title":"Hugo 建立 Blog","uri":"https://chupai.github.io/posts/200316_hugo/"},{"content":"這週是 六角鼠年鐵人賽 第六週，上週剛好接觸到 Lodash，就簡單紀錄一下。\n\r簡介 你很可能需要經常重複寫一些工具函式，尤其是處理字串與陣列或是物件。為了使開發專案更有效率且好維護，Lodash 可能是你好選擇。\nLodash 是一個一致性、模組化、高性能的 JavaScript 實用工具函式庫，包含對字串、陣列、物件等常見型別的處理函式。\n其中部分是目前 ECMAScript 尚未制訂的規範，但同時被業界所認可的輔助函式。\n Lodash Lodash 中文網  目前在寫這篇文章時，Lodash 在 github 上星數高達 43.8k，版本為 4.17.15。\n另外，在 npm 中依賴 Lodash 的 package 非常多：packages depending on lodash。\nAPI Lodash 提供了非常多的工具方法，包含\n Array：適用於 陣列，例如分割、合併、刪除、查詢、重組等操作。 Collection：適用於 陣列 和 物件，部分可用於字串，例如遍歷、分組、查詢、過濾等操作。 Date：只有一個 now 方法。 Function：函式的操作。 Lang：各種型別的轉換、判斷或是深拷貝。 Math：基本的數學運算，例如數值的四捨五入、數組的最大、最小值等等。 Number：取得隨機數、判斷數值區間、求中間值。 Object：適用於 物件，例如物件的創建、擴展、轉換、搜索、集合等操作。 Seq：常用於創建鏈式呼叫，提高執行性能（惰性計算）。 String：適用於 字串 操作。 Util：實用工具函式。  1. 為什麼不用 ES6 語法就好？ Lodash 有很多方法 ES6 已經封裝好了，而且部分方法也可以使用 ES6 語法替換。加上 ES6 越來越多主流瀏覽器支持，另外還可以使用 Babel 將 ES6 編譯成 ES5。那麼我們還需要使用 Lodash 嗎？\n可以參考以下兩篇文章：\n 在 ES6 大行其道的今天，還有必要使用 lodash 之類的庫嗎？ 為什麼不用 ES6 完全替換 Lodash  2. 惰性求值 Lodash 另一個優勢就是其優異的計算性能。很大部分就來源於其使用的算法「惰性求值」。\n關於 惰性求值 可以參考以下文章：\n 惰性求值——lodash源碼解讀  3. SameValueZero 相等比 部分方法使用 SameValueZero 相等比，關於 SameValueZero 可以看這篇文章： ECMAScript 6相等演算 。\n安裝 1. 瀏覽器 下載檔案，直接引入：\n1  \u0026lt;script src=\u0026#34;lodash.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   或是使用 CDN。\n2. 在專案中使用 lodash 透過 npm 安裝：\nnpm i --save lodash 接著在你的程式碼中 import 即可：\n1  import _ from \u0026#39;lodash\u0026#39;;   但這樣做會將整包 Lodash 打包進去。如果只使用 Lodash 其中一兩個方法，會造成了不必要的資源浪費。\n解決辦法有三種：\n 單獨引入：lodash 每個函式都具有單獨的模組，可以只引入需要的模組。  1 2 3 4 5  import _map from \u0026#39;lodash.map\u0026#39;; import _random from \u0026#39;lodash.random\u0026#39;; // or import _map from \u0026#39;lodash/map\u0026#39;; import _random from \u0026#39;lodash/random\u0026#39;;    使用套件優化：  lodash-webpack-plugin babel-plugin-lodash   使用 lodash-es：  1  import { mapm , random } from \u0026#39;lodash-es\u0026#39;;   不過，是否需要對 Lodash 優化，可以參考這篇文章：lodash 在 webpack 中的各項優化的嘗試。\n2. Vue Cli Vue 除了上述方式，還可以使用 vue-lodash 套件：\n1 2 3 4 5  // main.js import Vue from \u0026#39;vue\u0026#39;; import VueLodash from \u0026#39;vue-lodash\u0026#39;; import lodash from \u0026#39;lodash\u0026#39;; Vue.use(VueLodash, { name: \u0026#39;custom\u0026#39;, lodash: lodash });   1 2 3 4 5 6 7 8 9 10 11 12 13  export default { methods: { test() { console.log( this.lodash.random(20) ); console.log( this._.random(20) ); console.log( this.custom.random(20) ); }, } }; console.log( Vue.lodash.random(20) ); console.log( Vue._.random(20) ); console.log( Vue.custom.random(20) );   常用方法 由於 Lodash 中 API 太多了，這裡只會列幾個會常用到的方法並簡單說明。更詳細的用法、參數可以看官方 API 文件。\n1. Array _.union() 將陣列合併，並去除重複的元素（SameValueZero 相等比較），會回傳一個新陣列。\n1  _.union([arrays])    [arrays] (...Array): 陣列組 回傳值：回傳新的陣列  1 2 3 4 5  let arr1 = [1, 2, 3, 4]; let arr2 = [2, 4, 6, 8]; let arr3 = [3, 5, 7, 9]; console.log( _.union(arr1, arr2, arr3) );   如果元素是物件，可使用 _.unionBy，另外還有 _.unionWith() 可以呼叫一個比較函式。\n_.intersection() 取得陣列組的交集元素（使用 SameValueZero 相等比較）。\n1  _.intersection([arrays])    [arrays] (...Array)：陣列組 回傳值：交集元素陣列  1 2 3 4 5 6 7  let arr1 = [0, 1, 2, 3, 4]; let arr2 = [0, 2, 4, 6, 8]; let arr3 = [0, 2, 3, 5, 7, 9]; console.log( _.intersection(arr1, arr2, arr3) ); // [0, 2]   如果元素是物件，可使用 _.intersectionBy()，另外還有 _.intersectionWith() 可以呼叫一個比較函式。\n_.difference() 檢查一個陣列，並將指定的值排除（SameValueZero 相等比較），會回傳一個新陣列。\n與 _.difference() 類似的方法還有 _.without() 與 _.pull()。\n1  _.difference(array, [values])    array (Array)：需要被檢查的陣列 [values] (...Array)：需要排除的值（放在陣列中） 回傳值：回傳新的陣列  1 2 3  let arr = [0, 1, 2, 3, 4]; console.log( _.difference(arr, [2, 4, 6, 8]) ); // [0, 1, 3]   如果元素是物件，可使用 _.differenceBy()，另外還有 _.differenceWith() 可以呼叫一個比較函式。\n_.uniq() 陣列重組，去除重複的元素（SameValueZero 相等比較），會回傳一個新陣列。\n1  _.uniq(array)    array (Array): 要檢查的陣列 回傳值：回傳新的陣列  1 2  console.log( _.uniq([1, 2, 2, 4, 1, 5]) ); // [1, 2, 4, 5]   如果元素是物件，可使用 _.uniqBy()，另外還有 _.uniqWith() 可以呼叫一個比較函式。\n_.indexOf() 搜尋陣列是否有值為 value 的元素（使用 SameValueZero 等值比較），並回傳第一個符合的索引值。\n1  _.indexOf(array, value, [fromIndex=0])    array (Array)：要查詢的陣列 value (*)：條件值 [fromIndex=0] (number)：初始位置  預設值為 0 也就是開頭 如果 fromIndex 為負值，則從陣列結尾數過來   回傳值：匹配值的索引值，否則回傳 -1  1 2 3 4 5  let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; console.log( _.indexOf(arr, \u0026#39;b\u0026#39;) ); // 1 console.log( _.indexOf(arr, \u0026#39;b\u0026#39;, -1) ); // -1 console.log( _.indexOf(arr, \u0026#39;b\u0026#39;, -2) ); // 4   _.lastIndexOf() 這個方法類似 indexOf ，區別是它是從右到左遍歷陣列的元素，預設起始位置為結尾。\n1  _.lastIndexOf(array, value, [fromIndex=array.length-1])    array (Array)：要查詢的陣列 value (*)：條件值 [fromIndex=array.length-1](number)：初始位置  預設值為 array.length-1 也就是結尾 如果 fromIndex 為負值，則從陣列結尾數過來   回傳值：匹配值的索引值，否則回傳 -1  1 2 3 4 5 6  let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; console.log( _.lastIndexOf(arr, \u0026#39;b\u0026#39;) ); // 4 console.log( _.lastIndexOf(arr, \u0026#39;b\u0026#39;, 0) ); // -1 console.log( _.lastIndexOf(arr, \u0026#39;b\u0026#39;, 2) ); // 1 console.log( _.lastIndexOf(arr, \u0026#39;b\u0026#39;, -2) ); // 4   2. Collection Collection（集合）的方法 陣列 或 物件 都可以使用，部分方法字串也可以。\n其中 map 及 filter 方法最常使用，因為原生 JavaScrtip 中是不支援物件的，因此當需要迭代物件時，會使用 for in 或 Object.keys。\n_.map() 迭代的集合的方法，回傳一個新陣列。\n1  _.map(collection, [iteratee=_.identity])    collection (Array|Object)：用來迭代的集合。 [iteratee=_.identity] (Array|Function|Object|string)：每次迭代呼叫的函式。  參數：(value, index|key, collection)   回傳值：新陣列  Lodash 中有許多方法是防止作為其他方法的迭代函式（註：即不能作為 iteratee 參數傳遞給其他方法），例如： _.every、 _.filter、 _.map、 _.mapValues、 _.reject 和 _.some。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  console.log( _.map([4, 8], (n) =\u0026gt; n * n) ); // [16, 64]  const square = (n) =\u0026gt; n * n; let arr = [2, 4]; let obj = { a: 2, b: 4 }; console.log( _.map(arr, square) ); // [4, 16]  console.log( _.map(obj, square) ); // [4, 16]  let users = [{ user: \u0026#39;barney\u0026#39; }, { user: \u0026#39;fred\u0026#39; }]; console.log( _.map(users, \u0026#39;user\u0026#39;) ); // [\u0026#39;barney\u0026#39;, \u0026#39;fred\u0026#39;]   另外可以參考這篇文章：map () 誰比較快和輕量？ Lodash vs ES6。\n_.filter() 根據條件過濾出符合條件的元素。\n1  _.filter(collection, [predicate=_.identity])    collection (Array|Object)：一個用來迭代的集合。 [predicate=_.identity] (Array|Function|Object|string)：每次迭代呼叫的函式。 回傳值：回傳新的陣列  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  let users = [ { user: \u0026#39;barney\u0026#39;, age: 36, active: true }, { user: \u0026#39;fred\u0026#39;, age: 40, active: false }, ]; _.filter(users, function(o) { return !o.active; }); // =\u0026gt; objects for [\u0026#39;fred\u0026#39;]  // The `_.matches` iteratee shorthand. _.filter(users, { age: 36, active: true }); // =\u0026gt; objects for [\u0026#39;barney\u0026#39;]  // The `_.matchesProperty` iteratee shorthand. _.filter(users, [\u0026#39;active\u0026#39;, false]); // =\u0026gt; objects for [\u0026#39;fred\u0026#39;]  // The `_.property` iteratee shorthand. _.filter(users, \u0026#39;active\u0026#39;); // =\u0026gt; objects for [\u0026#39;barney\u0026#39;]   _.includes() 檢查 value 是否在 collection中。\n1  _.includes(collection, value, [fromIndex=0])   collection (Array|Object|string)：要檢索的集合。\nvalue (*)：要檢索的值。\n[fromIndex=0] (number)：要檢索的索引位置。\n 回傳值：布林值  如果 collection 是一串，value 就是字元，否則使用 SameValueZero 做等值比較。\n1 2 3 4 5 6 7 8 9 10 11  _.includes([1, 2, 3], 1); // =\u0026gt; true  _.includes([1, 2, 3], 1, 2); // =\u0026gt; false  _.includes({ user: \u0026#39;fred\u0026#39;, age: 40 }, \u0026#39;fred\u0026#39;); // =\u0026gt; true  _.includes(\u0026#39;pebbles\u0026#39;, \u0026#39;eb\u0026#39;); // =\u0026gt; true   _.shuffle() 將集合打亂（使用 Fisher-Yates shuffle 洗牌算法）。\n1  _.shuffle(collection)    collection (Array|Object)：要打亂的集合 回傳值：回傳隨機元素的陣列  1 2 3 4 5 6 7 8 9  let arr = [0, 1, 2, 3, 4]; console.log( _.shuffle(arr) ); // [ 3, 4, 1, 0, 2 ] console.log( _.shuffle(arr) ); // [ 3, 0, 2, 4, 1 ]  let obj = { a: 1, b: 2, c: 3 }; console.log( _.shuffle(obj) ); // [ 2, 3, 1 ] console.log( _.shuffle(obj) ); // [ 1, 3, 2 ]   _.sampleSize() 從集合中獲得 n 個隨機元素。\n1  _.sampleSize(collection, [n=1])    collection (Array|Object)：要取樣的集合 [n=1] (number)：取樣的元素個數。 回傳值：回傳隨機元素的陣列  1 2 3 4 5 6  let arr = [0, 1, 2, 3, 4]; console.log( _.sampleSize(arr, 1) ); // [2] console.log( _.sampleSize(arr, 1) ); // [0] console.log( _.sampleSize(arr, 2) ); // [2, 1] console.log( _.sampleSize(arr, 2) ); // [0, 4]   _.sortBy() 創建一個元素陣列。以 iteratee 處理的結果升序排序。這個方法執行穩定排序，也就是說相同元素會保持原始排序\n1  _.sortBy(collection, [iteratees=[_.identity]])    collection (Array|Object)：用來迭代的集合。 [iteratees=[_.identity]] (...* (Array|Array[]|Function|Function[]|Object|Object[]|string|string[]))：這個函式決定排序。 回傳值：排序後的陣列  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  let arr = [1, 65, 44, 2, 3, 55]; console.log( _.sortBy(arr) ); let users = [ { user: \u0026#39;fred\u0026#39;, age: 48 }, { user: \u0026#39;barney\u0026#39;, age: 36 }, { user: \u0026#39;fred\u0026#39;, age: 40 }, { user: \u0026#39;barney\u0026#39;, age: 34 }, ]; console.log(_.sortBy(users, (item) =\u0026gt; item.user)); // [ { user: \u0026#39;barney\u0026#39;, age: 36 }, // { user: \u0026#39;barney\u0026#39;, age: 34 }, // { user: \u0026#39;fred\u0026#39;, age: 48 }, // { user: \u0026#39;fred\u0026#39;, age: 40 } ]  console.log(_.sortBy(users, \u0026#39;age\u0026#39;)); // [ { user: \u0026#39;barney\u0026#39;, age: 34 }, // { user: \u0026#39;barney\u0026#39;, age: 36 }, // { user: \u0026#39;fred\u0026#39;, age: 40 }, // { user: \u0026#39;fred\u0026#39;, age: 48 } ]  console.log(_.sortBy(users, [\u0026#39;user\u0026#39;, \u0026#39;age\u0026#39;])); // [ { user: \u0026#39;barney\u0026#39;, age: 34 }, // { user: \u0026#39;barney\u0026#39;, age: 36 }, // { user: \u0026#39;fred\u0026#39;, age: 40 }, // { user: \u0026#39;fred\u0026#39;, age: 48 } ]   3. Object _.get() 根據物件的路徑取值，沒有則回傳 undefined，可以設定預設值。\n1  _.get(object, path, [defaultValue])    object (Object)：要檢索的物件。 path (Array|string)：要獲取屬性的路徑，可以是字串或陣列。 [defaultValue] (*)：預設值。 回傳值：解析的值  1 2 3 4 5 6 7  let obj = { id: \u0026#39;1234\u0026#39;, list: [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;] }; console.log( _.get(obj, \u0026#39;id\u0026#39;) ); // \u0026#39;1234\u0026#39; console.log( _.get(obj, \u0026#39;list[0]\u0026#39;) ); // \u0026#39;a\u0026#39; console.log( _.get(obj, [\u0026#39;list\u0026#39;, \u0026#39;3\u0026#39;]) ); // \u0026#39;d\u0026#39; console.log( _.get(obj, \u0026#39;name\u0026#39;); // undefined console.log( _.get(obj, \u0026#39;name\u0026#39;, \u0026#39;no-find\u0026#39;) ); // \u0026#39;no-find\u0026#39;   _.pick() 創建一個從 object 中選中的屬性的物件。\n1  _.pick(object, [props])    object (Object)：來源物件。 [props] (...(string|string[]))：選中的屬性。（註：單獨指定或指定在陣列中。） 回傳值：回傳新物件  1 2 3  let object = { a: 1, b: \u0026#39;2\u0026#39;, c: 3 }; console.log( _.pick(object, [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;]) ); // { a:1, c:3 }   _.omit 為反向版的 _.pick。\n_.pickBy() 創建一個物件，這個物件組成為從 object 中經 predicate 判斷為真值的屬性。\n1  _.pickBy(object, [predicate=_.identity])    object (Object)：來源物件。 [predicate=_.identity] (Function)：呼叫每一個屬性的函式。  有 2個參數：(value, key)。   回傳值：回傳新物件  1 2 3 4  let obj = { a: 1, b: \u0026#39;2\u0026#39;, c: 3 }; console.log( _.pickBy(obj, _.isNumber) ); // { \u0026#39;a\u0026#39;: 1, \u0026#39;c\u0026#39;: 3 }   _.omitBy 為反向版的 _.pickBy。\n_.defaults() 安全的合併物件，遇到重複的屬性則忽略。\n1  _.defaults(object, [sources])    object (Object)：目標物件。 [sources] (...Object)：來源物件。 回傳值：這方法會改變目標物件，回傳目標物件  1 2 3 4 5 6 7 8  let obj1 = { foo: 1, boo: 2 }; let obj2 = { foo: 3, zoo: 4 }; let r = _.defaults(obj1, obj2); console.log(r); // { foo: 1, boo: 2, zoo: 4 } console.log(obj1); // { foo: 1, boo: 2, zoo: 4 } console.log(obj1 === r); // true   4. Lang _.cloneDeep() 資料的深拷貝。\n1  _.cloneDeep(value)    value (*)：要拷貝的資料。 回傳值：回傳拷貝的資料。  1 2 3 4  let obj = { a: { b: 1 } }; let newObj = _.cloneDeep(obj); console.log( obj.a === newObj.a ); // false   另外，可以參考以下文章：\n lodash源碼分析——deepclone，基於4.17.10版本\n Lodash 是如何實現深拷貝的  _.isEqual() 執行深比較來確定兩者的值是否相等。\n1  _.isEqual(value, other)    value (*)：用來比較的值。 other (*)：另一個用來比較的值。 回傳值：布林值  如果是物件，則比較自身的屬性，不包括繼承的和可列舉的屬性。不支持函式和DOM 節點比較。\n1 2 3 4 5 6 7  let object = { a: 1 }; let other = { a: 1 }; console.log(object === other); // false console.log(_.isEqual(object, other)); // true   5. Number _.clamp() 設定數值上下限，超出範圍，回傳上限或下限，否則回傳數值本身。\n1  _.clamp(number, [lower], upper)    number (number)：被限制的值。 [lower] (number)：可選，下限值。 upper (number)：上限值。 回傳值：  number 大於 upper 回傳 lower number 小於 lower 回傳 lower 在 upper 之間 lower 回傳 number 本身    1 2 3 4 5 6  console.log( _.clamp(5, 10) ); // 5 console.log( _.clamp(11, 10) ); // 10  console.log( _.clamp(11, -10, 10) ); // 10 console.log( _.clamp(-11, -10, 10) ); // -10 console.log( _.clamp(0, -10, 10) ); // 0   _.random() 隨機產生一個包括 lower 與 upper 之間的數，如果只設置一個參數則回傳 0 到該數之間的數值。\n1  _.random([lower=0], [upper=1], [floating])    [lower=0] (number)：下限。 [upper=1] (number)：上限。 [floating] (boolean)：指定是否回傳浮點數。  lower 與 upper 非浮點數預設為 false    1 2 3 4 5 6 7 8 9 10  _.random(5); // between 0 and 5 _.random(-5); // between -5 and 0 _.random(5, 10); // between 5 and 10 _.random(5, true); // a floating-point number between 0 and 5 _.random(1.2, 5.2); // a floating-point number between 1.2 and 5.2   _.inRange() 檢查 number 是否在 start 與 end 之間（但不包括 end）。\n1  _.inRange(number, [start=0], end)    number (number)：要檢查的值。 [start=0] (number)：開始範圍。  可選，沒設置預設值為 0。   end (number)：結束範圍。  如果第二個參數大於第三個參數，大的為 end。    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  _.inRange(3, 2, 4); // 3 是否在 2~3 之間 =\u0026gt; true _.inRange(4, 8); // 4 是否在 0~7 之間 =\u0026gt; true _.inRange(4, 2); // 4 是否在 0~1 之間 =\u0026gt; false _.inRange(2, 2); // 2 是否在 0~1 之間 =\u0026gt; false _.inRange(1.2, 2); // 1.2 是否在 0~1 之間 =\u0026gt; true _.inRange(3.2, 4); // 3.2 是否在 0~3 之間 =\u0026gt; false _.inRange(0, 4, 0); // 0 是否在 0~3 之間 =\u0026gt; true _.inRange(-3, -2, -6); // -3 是否在 -6~-2 之間 =\u0026gt; true   6. Util _.range() 建立一個指定範圍的數值陣列。\n1  _.range([start=0], end, [step=1])    [start=0] (number：開始的範圍。 end (number)：結束的範圍（不包括自己）。 [step=1] (number)：範圍的增量 或者 減量。  只有一個參數 _.range(n) 等同 _.range(0, n, 1)，如果是負數 _.range(-n) 等同 _.range(0, n, -1)。\nend 小於 start 而且 step 非負數，會創建一個空陣列。\n1 2 3 4 5 6  console.log( _.range(4) ); // [0, 1, 2, 3, 4] console.log( _.range(-4) ); // [0, -1, -2, -3] console.log( _.range(1, 4) ); // [1, 2, 3] console.log( _.range(0, 10, 5) ); // [0, 5, 10] console.log( _.range(0, -4, -1) ); // [0, -1, -2, -3] console.log( _.range(1, 4, 0) ); // [1, 1, 1]   _.times() 呼叫 iteratee 函式 n 次，並將結果存到陣列中，並回傳該陣列。\n1  _.times(n, [iteratee=_.identity])    n (number)：呼叫 iteratee 的次數。 [iteratee=_.identity] (Function)：每次迭代呼叫的函式，參數為 index。  1 2 3 4  console.log(_.times(3, String)); // [\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;] console.log(_.times(3, (index) =\u0026gt; index * index)); // [0, 1, 4]   _.uniqueId() 生成唯一 ID，可以添加前綴。\n1  _.uniqueId([prefix=\u0026#39;\u0026#39;])    [prefix=''] (string)：要添加到 ID 前綴的值。 回傳值：回傳生成的唯一 ID 字串。  1 2 3  console.log( _.uniqueId() ); // \u0026#39;1\u0026#39; console.log( _.uniqueId() ); // \u0026#39;2\u0026#39; console.log( _.uniqueId(\u0026#39;book\u0026#39;) ); // \u0026#39;book3\u0026#39;   7. Math _.sum() 陣列的總和。\n1  _.sum(array)   1 2  _.sum([4, 2, 8, 6]); // =\u0026gt; 20   如果元素是物件，可以使用 _.sumBy()。\n總結 這週先記錄到這邊，有空慢慢補上，下週見。\n","description":"這週是 六角鼠年鐵人賽 第六週，上週剛好接觸到 Lodash，就簡單紀錄一下。","id":44,"section":"posts","tags":["Lodash","w3HexSchool"],"title":"Lodash - JS 實用工具函式庫","uri":"https://chupai.github.io/posts/200315_lodash/"},{"content":"這週是 六角鼠年鐵人賽 第五週，紀錄一下 Vue Transition 用法。\n前言 在日常開發中，網頁動態效果是必不可少的一部分，不僅能讓元素直接的切換顯得更加自然，同時也能極大的增強用戶體驗。\n雖然我們可以使用原生 CSS 或 JS 來實現動態效果，但 Vue 提供了更簡單和高效的方式。\n1. Vue 的轉場工具 Vue 在插入、更新或者移除 DOM 時，提供多種不同方式的應用轉場效果。包括以下工具：\n 在 CSS transition 和 animation 中自動應用 class 名稱； 也可以配合使用第三方 CSS 動畫庫，例如 Animate.css。 在轉場鉤子函式中使用 JavaScript 直接操作 DOM； 也可以配合使用第三方 JavaScript 動畫庫，例如 Velocity.js。  transition 元件 Vue 提供了 transition 的封裝元件，在下列情形中，可以給任何元素和元件添加進入/離開的轉場效果：\n 元素或元件初始渲染時 元素或元件顯示/隱藏時（使用 v-if 或 v-show） 元素或元件切換時  先看一個簡單的基本範例：\n1 2 3 4  \u0026lt;button v-on:click=\u0026#34;show = !show\u0026#34;\u0026gt;Toggle\u0026lt;/button\u0026gt; \u0026lt;transition\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   1 2 3  data: { show: true, },   1 2 3 4 5 6 7 8 9 10 11  .v-enter, .v-leave-to { opacity: 0; } .v-leave, .v-enter-to { opacity: 1; } .v-enter-active, .v-leave-active { transition: opacity 1s; }   當我們使用 transition 元件將元素包住，Vue 會做以下處理：\n 自動偵測目標元素是否應用 CSS transition/animation 如果是，在恰當的時機添加/刪除 CSS 類別名稱。 如果 transition 元件提供了 JavaScript 鉤子函式，這些鉤子函式將在恰當的時機被呼叫。 如果沒有找到 JavaScript 鉤子並且也沒有檢測到 CSS transition/animation，DOM 操作 (插入/刪除) 在下一幀中立即執行。  See the Pen Vue CSS 轉場 基本範例 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  1. CSS 轉場的類別名稱 transition 元件共提供了，六種類別名稱提供切換。\n進場：\n v-enter：定義進場的開始狀態。  在元素被插入之前生效，插入之後的下一幀被移除   v-enter-active：定義進場生效時的狀態，在整個進場的階段中應用。  在元素被插入之前生效，在 transition/animation 完成之後移除 可用來定義進場的過程時間，延遲和曲線函數   v-enter-to：2.1.8版及以上 定義進場的結束狀態。  在元素被插入之後下一幀生效（與此同時 v-enter 被移除），在 transition/animation 完成之後移除    離場：\n v-leave：定義離場的開始狀態。  在離場被觸發時立刻生效，下一幀被移除   v-leave-active：定義離場生效時的狀態，在整個離場的階段中應用。  在離場被觸發時立刻生效，在 transition/animation 完成之後移除 這個類可以被用來定義離場的過程時間，延遲和曲線函數   v-leave-to：2.1.8版及以上 定義離場的結束狀態。  在離開轉場被觸發之後下一幀生效（與此同時 v-leave 被移除），在 transition/animation 完成之後移除    通常會設定 v-enter 與 v-leave-active 相同的效果、v-leave 與 v-enter-to 相同的效果，達到同尾相接形成一個循環，而 v-enter-to 與 v-leave-to 會用來設定轉場時間或動畫。\nenter-to 預設 opacity: 1、transform: none，所以不一定要設定。\r1.1 CSS transition transition 元件預設使用上述 v- 前綴的類別名稱。請參考一開始基本範例。\n因為不可能只用一種動態效果，因此使用自訂義的前綴，需要加上 name 特性，舉例來說，\u0026lt;transition name=\u0026quot;fade\u0026quot;\u0026gt;，套用的那麼類別名稱的前綴就會是 fade-enter。\n1 2 3 4 5 6  \u0026lt;button v-on:click=\u0026#34;show = !show\u0026#34;\u0026gt; Toggle \u0026lt;/button\u0026gt; \u0026lt;transition name=\u0026#34;fade\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   設定一個進場由透明度 0 變 1 並由右測 100px 處滑入，並且進場、離場分別設定不同的曲線函數：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  .fade-enter, .fade-leave-to { opacity: 0; transform: translateX(100px); } .fade-leave, .fade-enter-to { opacity: 1; } .fade-enter-active { transition: all 0.3s ease; } .fade-leave-active { transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1); }   See the Pen Vue CSS 轉場 轉場範例 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  再舉一個例子，由下往上進場，由右出場：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  .fade-enter { opacity: 0; transform: translateY(100%); } .fade-enter-to, .fade-leave { opacity: 1; } .fade-leave-to { opacity: 0; transform: translateX(100%); } .fade-enter-active,.fade-leave-active { transition: all 0.8s ease; }   See the Pen Vue CSS 轉場 轉場範例2 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  1.2 CSS animation CSS animation 用法同 CSS transition，區別是在動畫中 v-enter 類名在節點插入 DOM 後不會立即刪除，而是在 animationend 事件觸發時刪除。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  .bounce-enter-active { animation: bounce-in 0.5s; } .bounce-leave-active { animation: bounce-in 0.5s reverse; } @keyframes bounce-in { 0% { transform: scale(0); } 50% { transform: scale(1.5); } 100% { transform: scale(1); } }   See the Pen Vue CSS 轉場 動畫範例 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 使用自訂義類別名稱 我們可以通過以下 transition 元件特性來使用自訂義類別名稱：\n enter-class enter-active-class enter-to-class 2.1.8+ leave-class leave-active-class leave-to-class 2.1.8+  他們的優先級高於普通的類別名稱。\n舉個簡單得範例，來說明使用方式：\n1 2 3 4 5 6 7  .opacity-0 { opacity: 0; } .trs-time-3 { transition-duration: 3s; }   1 2 3 4 5 6 7 8  \u0026lt;transition enter-class=\u0026#34;opacity-0\u0026#34; leave-to-class=\u0026#34;opacity-0\u0026#34; enter-active-class=\u0026#34;trs-time-3\u0026#34; leave-active-class=\u0026#34;trs-time-3\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   See the Pen Vue CSS 轉場 自訂義 class by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2.1 第三方 CSS 動畫庫 自訂義類別名稱，對於套用第三方 CSS 動畫庫結合非常方便。\n舉例來說，使用 Animate.css 的動畫效果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;button v-on:click=\u0026#34;show = !show\u0026#34;\u0026gt; Toggle \u0026lt;/button\u0026gt; \u0026lt;transition enter-active-class=\u0026#34;animated tada\u0026#34; leave-active-class=\u0026#34;animated bounceOutRight\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;transition enter-active-class=\u0026#34;animated fadeInUp\u0026#34; leave-active-class=\u0026#34;animated flipInY\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   See the Pen Vue CSS 轉場 Animate.css by CHUPAIWANG (@CHUPAIWANG) on CodePen.  或者是 magic.css：\n1 2 3 4 5 6 7 8 9  \u0026lt;button v-on:click=\u0026#34;show = !show\u0026#34;\u0026gt; Toggle \u0026lt;/button\u0026gt; \u0026lt;transition enter-active-class=\u0026#34;magictime foolishIn\u0026#34; leave-active-class=\u0026#34;magictime tinDownOut\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   See the Pen Vue CSS 轉場 magic by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 轉場時間 3.1 同時使用 transition/animation Vue 為了知道轉場的完成，必須設置相應的事件監聽器。它可以是 transitionend 或 animationend，這取決於給元素應用的 CSS 規則。如果你使用其中任何一種，Vue 能自動識別類型並設置監聽。\n但有時候會遇到需要同時設置的情況，但兩邊的完成時間不一致，這時候就需要手動設置 transitionend 或 animationend 來明確告知 Vue 要監聽的類型。\n舉例來說，假設你分別使用自訂義的類別名稱和 Animate.css ：\n1 2 3 4 5 6 7 8 9 10 11  .fade-enter,.fade-leave-to { opacity: 0; } .fade-enter-to, .fade-leave { opacity: 1; } .fade-enter-active,.fade-leave-active { transition: opacity 3s; }   1 2 3 4 5 6 7 8  \u0026lt;transition name=\u0026#34;fade\u0026#34; type=\u0026#34;transition\u0026#34; enter-active-class=\u0026#34;animated swing fade-enter-active\u0026#34; leave-active-class=\u0026#34;animated bounce fade-leave-active\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   這裡要注意，使用自訂義類別名稱優先度大於普通的類別名稱，所以fade-enter-active 和 fade-leave-active 記得要補上。\nAnimate.css 預設動畫時間為 1s，而我們設置的 transition 時間為 3s，Animate.css 的動畫很外就觸發完成了，而轉場還沒結束。在很多情況下，Vue 可以自動得出轉場效果的完成時機，但還是有可能出現例外。\n為了避免出現例外，你就需要手動設定 type=\u0026quot;transition\u0026quot; 以 transition 的時間為準。反之動畫時間大於轉場就以動畫時間為準。\nSee the Pen Vue CSS 轉場 同时使用轉場和動畫 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3.2 顯性的轉場持續時間 上面已經提過了，在很多情況下，Vue 可以自動得出轉場效果的完成時機。預設情況下，Vue 會等待其在轉場效果的根元素的第一個 transitionend 或 animationend 事件。\n但在某些情況下，還可以自定義整個動態效果總時間長，使用的是 duration 特性搭配 v-bind。\n舉例來說，總時常為 5s：\n1  \u0026lt;transition :duration=\u0026#34;5000\u0026#34;\u0026gt;...\u0026lt;/transition\u0026gt;   也可以分別設定進入和移除持續時間：\n1  \u0026lt;transition :duration=\u0026#34;{ enter: 500, leave: 800 }\u0026#34;\u0026gt;...\u0026lt;/transition\u0026gt;   這是一個 transition 需要 5秒，但總轉場時間強制設為 1秒的範例：\nSee the Pen Vue CSS 轉場 顯性的轉場持續時間 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  4.初始渲染的轉場 透過設定 appear 特性，設置節點在初始渲染的轉場。\n1 2 3  \u0026lt;transition appear\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/transition\u0026gt;    CodePen，載入畫面時，會有進場效果。\n appear 預設使用進場的類別，如果要與進場套用不同的動畫效果，需要使用自定義的類別名稱：\n1 2 3  \u0026lt;transition appear\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/transition\u0026gt;    CodePen，載入畫面時，會有進場效果。\n appear 預設使用進場的類別，如果要與進場套用不同的動畫效果，需要使用自定義的類別名稱：\n1 2 3 4 5 6 7 8  \u0026lt;transition appear appear-class=\u0026#34;custom-appear-class\u0026#34; appear-to-class=\u0026#34;custom-appear-to-class\u0026#34; (2.1.8+) appear-active-class=\u0026#34;custom-appear-active-class\u0026#34; \u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/transition\u0026gt;   多個元素的轉場 \u0026lt;transition\u0026gt; 也可以用在多個元素的轉場。\n舉例來說：\n1 2 3 4 5 6  \u0026lt;transition\u0026gt; \u0026lt;table v-if=\u0026#34;items.length \u0026gt; 0\u0026#34;\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;p v-else\u0026gt;Sorry, no items found.\u0026lt;/p\u0026gt; \u0026lt;/transition\u0026gt;   但要注意，Vue 在切換畫面時，並不會完全置換元素，會使用一種最大限度減少動態元素並且儘可能的嘗試修復/再利用相同類型元素的算法。\n因此當有相同標籤的元素在做切換時，需要使用 key 特性設置唯一的值來標記以讓 Vue 區分它們。\n1 2 3 4 5 6 7 8  \u0026lt;transition\u0026gt; \u0026lt;button v-if=\u0026#34;isEditing\u0026#34; key=\u0026#34;save\u0026#34;\u0026gt; Save \u0026lt;/button\u0026gt; \u0026lt;button v-else key=\u0026#34;edit\u0026#34;\u0026gt; Edit \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   在一些場景中，也可以通過給同一個元素的 key 特性設置不同的狀態來代替 v-if 和 v-else，上面的範例可以重寫為：\n1 2 3 4 5  \u0026lt;transition\u0026gt; \u0026lt;button v-bind:key=\u0026#34;isEditing\u0026#34;\u0026gt; {{ isEditing ? \u0026#39;Save\u0026#39; : \u0026#39;Edit\u0026#39; }} \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   使用多個 v-if 的多個元素的轉場可以重寫為綁定了動態屬性的單個元素轉場。例如：\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;transition\u0026gt; \u0026lt;button v-if=\u0026#34;docState === \u0026#39;saved\u0026#39;\u0026#34; key=\u0026#34;saved\u0026#34;\u0026gt; Edit \u0026lt;/button\u0026gt; \u0026lt;button v-if=\u0026#34;docState === \u0026#39;edited\u0026#39;\u0026#34; key=\u0026#34;edited\u0026#34;\u0026gt; Save \u0026lt;/button\u0026gt; \u0026lt;button v-if=\u0026#34;docState === \u0026#39;editing\u0026#39;\u0026#34; key=\u0026#34;editing\u0026#34;\u0026gt; Cancel \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   可以重寫為：\n1 2 3 4 5 6  \u0026lt;!-- .html --\u0026gt; \u0026lt;transition\u0026gt; \u0026lt;button :key=\u0026#34;docState\u0026#34;\u0026gt; {{ buttonMessage }} \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   1 2 3 4 5 6 7 8 9 10  // ... computed: { buttonMessage: function () { switch (this.docState) { case \u0026#39;saved\u0026#39;: return \u0026#39;Edit\u0026#39; case \u0026#39;edited\u0026#39;: return \u0026#39;Save\u0026#39; case \u0026#39;editing\u0026#39;: return \u0026#39;Cancel\u0026#39; } } }   1. 轉場模式 請考慮以下程式碼：\n1 2 3 4 5  \u0026lt;transition\u0026gt; \u0026lt;button :key=\u0026#34;isEditing\u0026#34; @click=\u0026#34;isEditing = !isEditing\u0026#34;\u0026gt; {{ isEditing ? \u0026#39;On\u0026#39; : \u0026#39;Off\u0026#39; }} \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   See the Pen Vue CSS 轉場 轉場模式 問題 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  在 on 按鈕和 off 按鈕的轉場中，兩個按鈕都被重繪了，一個離開轉場的時候另一個開始進入轉場。這是 \u0026lt;transition\u0026gt; 的預設行為，進入和離開同時發生。\n你可能會想到，可以加上 position: absolute，因為兩者重疊了，所以不會產生元素位移的情況：\n1 2 3  button { position: absolute; }   See the Pen Vue CSS 轉場 轉場模式 絕對定位 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  但如果加上 translate 讓它們運動像滑動，還是會有兩個元素同時出現的破綻：\n1 2 3 4 5  .v-enter, .v-leave-to { opacity: 0; transform: translateX(100%); }   See the Pen Vue CSS 轉場 轉場模式 絕對定位 + 滑動 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  同時生效的進入和離開的轉場不能滿足所有要求，所以 Vue 提供了轉場模式：\n in-out：新元素先進行轉場，完成之後當前元素轉場離開。 out-in：當前元素先進行轉場，完成之後新元素轉場進入。  加上 mode=\u0026quot;out-in\u0026quot; 的效果：\n1 2 3 4 5  \u0026lt;transition mode=\u0026#34;out-in\u0026#34;\u0026gt; \u0026lt;button :key=\u0026#34;isEditing\u0026#34; @click=\u0026#34;isEditing = !isEditing\u0026#34;\u0026gt; {{ isEditing ? \u0026#39;On\u0026#39; : \u0026#39;Off\u0026#39; }} \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   1 2 3  .v-enter-active, .v-leave-active { transition: 1.5s opacity; }   See the Pen Vue CSS 轉場 轉場模式 out-in by CHUPAIWANG (@CHUPAIWANG) on CodePen.  in-out 模式的範例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  button { position: absolute; } .v-enter,.v-leave-to { opacity: 0; } .v-enter { transform: translateX(100%); } .v-leave-to { transform: translateX(-100%); }   See the Pen Vue CSS 轉場 轉場模式 in-out by CHUPAIWANG (@CHUPAIWANG) on CodePen.  多個元件的轉場 多個元件的轉場簡單很多，我們不需要使用 key 特性。只需要使用 動態切換 元件：\n1 2 3 4 5 6 7 8  \u0026lt;!-- .html --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; value=\u0026#34;v-a\u0026#34; v-model=\u0026#34;view\u0026#34; /\u0026gt;A \u0026lt;input type=\u0026#34;radio\u0026#34; value=\u0026#34;v-b\u0026#34; v-model=\u0026#34;view\u0026#34; /\u0026gt;B \u0026lt;transition name=\u0026#34;component-fade\u0026#34; mode=\u0026#34;out-in\u0026#34;\u0026gt; \u0026lt;component v-bind:is=\u0026#34;view\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10  .component-fade-enter, .component-fade-leave-to { opacity: 0; } .component-fade-enter-active, .component-fade-leave-active { transition: opacity 0.3s ease; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14  const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { view: \u0026#39;v-a\u0026#39;, }, components: { \u0026#39;v-a\u0026#39;: { template: \u0026#39;\u0026lt;div\u0026gt;Component A\u0026lt;/div\u0026gt;\u0026#39;, }, \u0026#39;v-b\u0026#39;: { template: \u0026#39;\u0026lt;div\u0026gt;Component B\u0026lt;/div\u0026gt;\u0026#39;, }, }, });   transition-group 元件 1. 大量元素的轉場 目前為止，都是針對單個節點，或是同一時間渲染多個節點中的一個。如果要針對由 v-for 產生的大量元素（例如：列表），就要改為使用 transition-group 元件。\ntransition-group 元件有以下幾個特點：\n 不同於 \u0026lt;transition\u0026gt;，它會以一個真實元素呈現：預設為一個 \u0026lt;span\u0026gt;。可以通過 tag 特性更換為其他元素。 轉場模式（in-out 與 out-in）不可用，因為我們不再相互切換特有的元素。 內部元素 總是需要 提供唯一的 key 屬性值。 CSS 轉場的類將會應用在內部的元素中，而不是這個組/容器本身。  1.1 進入/離開的轉場 首先我們看一段程式碼：\n1 2 3 4 5 6 7  \u0026lt;button v-on:click=\u0026#34;add\u0026#34;\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;button v-on:click=\u0026#34;remove\u0026#34;\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item\u0026#34; class=\u0026#34;list-item\u0026#34;\u0026gt; {{ item }} \u0026lt;/ul\u0026gt;   按下 Add 會隨機插入數字，按下 Remove 會隨機移除數字。\nSee the Pen Vue 大量元素的轉場  by CHUPAIWANG (@CHUPAIWANG) on CodePen.  接下來我們改用 transition-group 元件，增加轉場效果。\ntransition-group 元件預設會有一個 \u0026lt;span\u0026gt; 的根元素，它會包住由 v-for 產生的多個元素當成其子元素。\n我們透過 tag 特性，將其改成 \u0026lt;ul\u0026gt;：\n1 2 3 4 5  \u0026lt;transition-group name=\u0026#34;list\u0026#34; tag=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;item in items\u0026#34; v-bind:key=\u0026#34;item\u0026#34; class=\u0026#34;list-item\u0026#34;\u0026gt; {{ item }} \u0026lt;/li\u0026gt; \u0026lt;/transition-group\u0026gt;   並加上 CSS：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  .list-enter, .list-leave-to { opacity: 0; transform: translateY(100%); } .list-leave, .list-enter-to { opacity: 1; } .list-enter-active, .list-leave-active { transition: all 1s; }   See the Pen Vue 大量元素的轉場 - transition-group by CHUPAIWANG (@CHUPAIWANG) on CodePen.  不過這個範例有一個明顯問題，當新增和移除元素的時候，周圍的元素會瞬間移動到他們的新佈局的位置，這會顯得不自然，我們將會在之後解決這個問題。\n1.2 排序轉場 transition-group 元件還有一個特殊之處。不僅可以進入和離開動畫，還可以改變定位。\nv-move 特性，它會在元素的改變定位的過程中應用。像之前的列別名稱一樣，可以通過 name 屬性來自定義前綴，也可以通過 move-class 屬性手動設置。\nv-move 對於設置轉場的切換時機和轉場曲線非常有用。\n1 2 3 4 5 6 7 8 9  \u0026lt;button v-on:click=\u0026#34;items.reverse()\u0026#34;\u0026gt;Reverses\u0026lt;/button\u0026gt; \u0026lt;transition-group name=\u0026#34;flip-list\u0026#34; tag=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item\u0026#34; class=\u0026#34;list-item\u0026#34;\u0026gt;{{ item }} \u0026lt;/li\u0026gt; \u0026lt;/transition-group\u0026gt;   1 2 3  .flip-list-move { transition: transform 1s; }   1 2 3 4 5 6  const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { items: [1, 2, 3, 4, 5, 6, 7, 8, 9], }, });   See the Pen Vue 大量元素的轉場 - v-move by CHUPAIWANG (@CHUPAIWANG) on CodePen.  Vue 使用了一個叫 FLIP 簡單的動畫隊列。使用 transforms 將元素從之前的位置平滑轉場新的位置。\n讓我們修正上節不自然的的程式碼：\n1 2 3 4 5 6 7  .list-leave-active { position: absolute; } .list-move { transition: 1s; }   See the Pen Vue 大量元素的轉場 - 進入/離開的轉場 v-move by CHUPAIWANG (@CHUPAIWANG) on CodePen.  另外要注意，FLIP 轉場的元素不能設置為 display: inline。作為替代方案，可以設置為 display: inline-block、display: flex-block 或者放置於 FlexBox 父容器中\rSee the Pen Vue 大量元素的轉場 - 打亂 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  JavaScript 鉤子 transition/animation 的核心概念，就是在對應的時間點新增、移除類別。除了這種在被動的時間點加上類別的方式外，Vue 也提供對應時間的 JavaScript 鉤子讓我們在該時間點使用 JavaScript。\n事件鉤子：\n before-enter：進場前啟動。 enter：進場時啟動。 after-enter：進場結束後啟動。 enter-cancelled：在未完成進場時取消動作。 before-leave：離場前啟動。 leave：離場時啟動。 after-leave：離場結束後啟動。 leave-cancelled：在未完成離場時取消動作。（只用於 v-show 中）  1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;transition v-on:before-enter=\u0026#34;beforeEnter\u0026#34; v-on:enter=\u0026#34;enter\u0026#34; v-on:after-enter=\u0026#34;afterEnter\u0026#34; v-on:enter-cancelled=\u0026#34;enterCancelled\u0026#34; v-on:before-leave=\u0026#34;beforeLeave\u0026#34; v-on:leave=\u0026#34;leave\u0026#34; v-on:after-leave=\u0026#34;afterLeave\u0026#34; v-on:leave-cancelled=\u0026#34;leaveCancelled\u0026#34; \u0026gt; \u0026lt;/transition\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  methods: { beforeEnter: function(el) {}, enter: function(el, done) { done(); }, afterEnter: function(el) {}, enterCancelled: function(el) {}, beforeLeave: function(el) {}, leave: function(el, done) { done(); }, afterLeave: function(el) {}, leaveCancelled: function(el) {}, }    如果只要單獨使用 JS 鉤子轉場，可以設置 v-bind:css=\u0026quot;false\u0026quot;，Vue 會跳過 CSS 的檢測，避免轉場過程受到 CSS 的影響。 enter 和 leave 的回呼函式 done 是可選的：  參數不注入 done 時，預設為同步呼叫，會自動呼叫 done()。 如果有 done 參數，就需要手動呼叫 done()，沒呼叫就不會進入　after-enter／after-leave。 如果想要搭配 CSS 同步自動 call done 的話，就不要帶 done 參數 只使用 JavaScript 鉤子的時候，要記得呼叫 done()。    初始渲染也有事件鉤子：\n before-appear：載入前。 appear：載入時。 after-appear：載入後。 appear-cancelled：載入開始後，執行取消載入。  路由轉場 \u0026lt;router-view\u0026gt; 一樣可以使用 \u0026lt;transition\u0026gt; 元件：\n1 2 3  \u0026lt;transition\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/transition\u0026gt;   1. 單個路由的轉場 如果要讓每個路由元件有各自的轉場效果，可以在元件內使用 \u0026lt;transition\u0026gt; 元件並設置不同的 name。\n1 2 3 4 5 6  \u0026lt;!-- Views1.vue --\u0026gt; \u0026lt;template \u0026gt; \u0026lt;transition name=\u0026#34;slide\u0026#34;\u0026gt; ... \u0026lt;/transition\u0026gt; \u0026lt;/template\u0026gt;   1 2 3 4 5 6  \u0026lt;!-- Views2.vue --\u0026gt; \u0026lt;template \u0026gt; \u0026lt;transition name=\u0026#34;fade\u0026#34;\u0026gt; ... \u0026lt;/transition\u0026gt; \u0026lt;/template\u0026gt;   2. 動態轉場 1 2 3  \u0026lt;transition :name=\u0026#34;transitionName\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/transition\u0026gt;   在接著在父元件內，監聽 $route 決定使用哪種轉場效果：\n1 2 3 4 5 6 7  watch: { \u0026#39;$route\u0026#39; (to, from) { const toDepth = to.path.split(\u0026#39;/\u0026#39;).length const fromDepth = from.path.split(\u0026#39;/\u0026#39;).length this.transitionName = toDepth \u0026lt; fromDepth ? \u0026#39;slide-right\u0026#39; : \u0026#39;slide-left\u0026#39; } }   3. Vueg  Vueg\n為 vue-router 添加轉場效果的開源 Vue 套件。\n 交錯轉場 這裡有一段程式碼：\n1 2 3 4 5 6  \u0026lt;button @click=\u0026#34;show = !show\u0026#34;\u0026gt;show\u0026lt;/button\u0026gt; \u0026lt;ul v-if=\u0026#34;show\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;n in num\u0026#34; :key=\u0026#34;n\u0026#34;\u0026gt; {{ n }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;   1 2 3 4  data: { num: 5, show: false, },   See the Pen 交錯轉場 範例 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  我們要如何將它改成交錯轉場？\n1. transition-delay 最簡單的方式，就是透過 transition-delay 來實現列表的交錯轉場。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  .custom-appear-active-class { transition: opacity 0.3s; } .custom-appear-active-class:nth-child(5n + 2) { transition-delay: 0.3s; } .custom-appear-active-class:nth-child(5n + 3) { transition-delay: 0.5s; } .custom-appear-active-class:nth-child(5n + 4) { transition-delay: 0.7s; } .custom-appear-active-class:nth-child(5n + 5) { transition-delay: 0.9s; }   但缺點也很明顯，要寫大量的 CSS，修改起來也不靈活。\nSee the Pen 交錯轉場 transition-delay by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 透過 data 屬性與 JavaScript 交流 透過 data 屬性取得元素的 index，所以補上 :data-index = index：\n1 2 3 4 5 6 7 8 9  \u0026lt;transition-group tag=\u0026#34;ul\u0026#34; v-if=\u0026#34;show\u0026#34; v-bind:css=\u0026#34;false\u0026#34; @appear=\u0026#34;appear\u0026#34; appear \u0026gt; \u0026lt;li v-for=\u0026#34;(n,index) in num\u0026#34; :key=\u0026#34;n\u0026#34; :data-index = index \u0026gt; {{ n }} \u0026lt;/li\u0026gt; \u0026lt;/transition-group\u0026gt;   利用 el.dataset 取取得元素的 data 屬性。\n1 2 3 4 5 6 7 8 9 10 11 12  methods:{ appear(el, done) { const index = el.dataset.index; // 取得 index  const delay = index * 0.3; gsap.from(el,{ duration: 0.3, opacity: 0, delay: delay, }) done(); }, },   我這裡使用 GSAP3 動畫來設置動畫。\nSee the Pen 交錯轉場 GSAP3 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  或是使用 Velocity.js 搭配 setTimeout：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  methods:{ beforeAppear(el) { el.style.opacity = 0; }, appear(el, done) { const index = el.dataset.index; const delay = index * 300; setTimeout(function () { Velocity( el, { opacity: 1 }, { complete: done } ); }, delay); }, },   See the Pen 交錯轉場 Velocity by CHUPAIWANG (@CHUPAIWANG) on CodePen. ","description":"這週是 六角鼠年鐵人賽 第五週，紀錄一下 Vue Transition 用法。","id":45,"section":"posts","tags":["Vue Transition","Vue","w3HexSchool"],"title":"Vue筆記 - Transition","uri":"https://chupai.github.io/posts/200307_vue-transition/"},{"content":"這週是 六角鼠年鐵人賽 第四週，之前沒碰過 TweenMax，但 GSAP 已經升級 GSAP3，就簡單研究一下 GSAP3。\nGSAP3 GSAP 是 GreenSock Animation Platform 的簡稱，是一套專門處理動畫與特效的 JS 套件。\nGSAP 採用模組化與插件式的結構，保持了核心引擎的輕量。有四個核心 API，TweenLite、TimelinLite、TimelineMax、TweenMax，而 TweenMax 是所有 API 與 Plugin 的集合。\n但 2019年底 GSAP 從 GSAP2 升級到 GSAP3，不再區分 TweenLite、TimelineLite、TimelineMax、TweenMax，全部合並為 gsap 物件。\nGSAP3 的優點：\n 檔案大小為 TweenMax 的一半，但新增了 50多個功能。 全部合並為 gsap 物件，不用在區分 TweenLite 和 TimelineMax 物件。 新版本相容舊版本寫法，所以可以沿用，新寫法提供更好的可讀性。  官網：\n GreenSock 英文官網 TweenMax 中文官網  下載安裝  GSAP Installation\n npm install gsap // or yarn add gsap CDN\nhttps://cdnjs.cloudflare.com/ajax/libs/gsap/3.1.1/gsap.min.js 版本差異 1. gsap 物件 原本須要用 Tweens（補間），就要使用 TweenLite/TweenMax 物件。要用到 Timelines（時間軸），就要使用 TimelineLite/TimelineMax 物件。\nGSAP3 統一使用 gsap 物件。gsap 物件，具有各種方法和屬性，可用來創建 Tweens（補間）和 Timelines（時間軸）。\n舊的 Tween 的創建方式：\n1 2 3  TweenMax.method(\u0026#39;selector\u0026#39;, {}); // or TweenLite.method(\u0026#39;selector\u0026#39;,{});   現在統一使用 gsap 物件：\n1  gsap.method(\u0026#39;selector\u0026#39;, {});   舊的 Timeline 的創建方式：\n1 2 3 4 5 6 7  const tl = new TimelineMax(); tl.method(\u0026#39;selector\u0026#39;, {}); // or const tl = new TimelineLite(); tl.method(\u0026#39;selector\u0026#39;, {});   現在 Timeline 一樣也只需要使用 gsap 物件：\n1 2 3  const tl = gsap.timeline(); tl.method(\u0026#39;selector\u0026#39;, {});   2. duration 參數 原來的寫法 duration 為方法的參數：\n1  TweenMax.to(\u0026#39;.box\u0026#39;, 1, { x: 100 });   新寫法被整合到了 vars 物件中了：\n1 2 3 4  gsap.to(\u0026#39;.box\u0026#39;, { duration: 1, x: 100, });   擁有更佳的可讀性。\n3. Timeline 預設值 原本的 Timeline 寫法：\n1 2 3 4 5 6 7 8 9  const t = new TimelineMax(); t.to(\u0026#39;.box1\u0026#39;, 1, { x: 100, ease: \u0026#39;elastic\u0026#39; }).to(\u0026#39;.box2\u0026#39;, 1, { y: 100, ease: \u0026#39;elastic\u0026#39; });   使用新的寫法，如有有相同的參數，可以設定預設值：\n1 2 3 4 5 6 7 8 9  const t = gsap.timeline({ defaults: { duration: 1, ease: \u0026#39;elastic\u0026#39; } }); t.to(\u0026#39;.box1\u0026#39;, { x: 100 }) .to(\u0026#39;.box2\u0026#39;, { y: 100 });   4. 交錯屬性 原本交錯動畫，要使用到額外的方法創建 Tween 實體，例如staggerTo()、staggerFrom()、staggerFromTo()：\n1  TweenMax.staggerTo(\u0026#39;.box\u0026#39;, 1, {rotation:360, x:100}, 0.5);   現在只需要設置 stagger 屬性即可：\n1 2 3 4 5 6  gsap.to(\u0026#39;.box\u0026#39;, { duration: 1, stagger: 0.5, rotation: 360, x: 100 });   5. 全新的亂數功能 1 ~ 400 之間：\n1 2 3  gsap.to(\u0026#39;.box\u0026#39;, { x: \u0026#39;random(100, 400)\u0026#39;, });   隨機選擇一個數字，可以使用陣列表示：\n1 2 3  gsap.to(\u0026#39;.box\u0026#39;, { x: \u0026#39;random([0，100，400，500])\u0026#39;, });   6. 全新的影格功能 Keyframes 大家一定都知道 CSS 動畫的 keyframes。那 GSAP 中的 keyframes 是什麼？\n原本要建立一連串的動畫（例如，先移動，再下移，最後旋轉），需要為每個動作建立 Tween 或使用 Timeline。而 keyframes 可以在同一個 Tween 內完成。\n1 2 3 4 5 6 7  gsap.to(\u0026#39;.box\u0026#39;, { keyframes: [ { duration: 1, x: 100, }, { duration: 1, y: 100 }, { duration: 1, rotation: 360 }, ] });   7. 全新的 repeatRefresh 開啟 repeatRefresh: true，會在重複執行時（設定 repeat），紀錄當前狀態再執行，而不會回到初始狀態。\n1 2 3 4 5 6  gsap.to(\u0026#39;.box\u0026#39;, { duration: 1, repeat: 5, repeatRefresh: true, x: \u0026#39;random(100, 400)\u0026#39;, });   8. 全新的全域動畫 Global timeline 可以控制全部的動畫實體。\n1 2 3 4  gsap.globalTimeline.timeScale(0.1); // 控制所有動畫的速率 0 ~ 1 gsap.globalTimeline.pause(); // 停止目前所有動畫 gsap.globalTimeline.play(); // 播放目前所有動畫 gsap.globalTimeline.paused(); // 回傳目前動畫狀態 true:暫停 / false:播放   9. 新的動畫輔助工具  Utility Methods\n  gsap.utils.checkPrefix() gsap.utils.clamp() gsap.utils.distribute() gsap.utils.getUnit() gsap.utils.interpolate() gsap.utils.mapRange() gsap.utils.normalize() gsap.utils.pipe() gsap.utils.random() gsap.utils.snap() gsap.utils.splitColor() gsap.utils.toArray() gsap.utils.unitize() gsap.utils.wrap() gsap.utils.wrapYoyo()  10. 相對動畫時間 原本會需要標籤來添加相對動畫時間：\n1 2 3 4 5 6  gsap.timeline() .add(\u0026#39;s\u0026#39;) .to(\u0026#39;.box1\u0026#39;, { ... }, \u0026#39;s\u0026#39;) .to(\u0026#39;.box2\u0026#39;, { ... }, \u0026#39;s\u0026#39;) .to(\u0026#39;.box3\u0026#39;, { ... }, \u0026#39;s+=0.8\u0026#39;) .to(\u0026#39;.box4\u0026#39;, { ... }, \u0026#39;s+=0.8\u0026#39;);   GSAP3 新增了最近的動畫時間：\n \u0026gt;：最近添加的動畫的開始時間 \u0026lt;：最近添加的動畫的結束時間  1 2 3 4 5  gsap.timeline() .to(\u0026#39;.box1\u0026#39;, { ... }) .to(\u0026#39;.box2\u0026#39;, { ... }, \u0026#39;\u0026lt;\u0026#39;) .to(\u0026#39;.box3\u0026#39;, { ... }, \u0026#39;\u0026lt;0.8\u0026#39;) .to(\u0026#39;.box4\u0026#39;, { ... }, \u0026#39;\u0026lt;\u0026#39;);   補間動畫 Tween 補間是 flash 時代的專業詞彙，意思是在起始狀態和終點狀態之間補全中間過程。\n包含四個要素：\n 動畫目標（target） 起始狀態 終點狀態 補間效果  1. 創建 Tween 創建 Tween 的常用方法（所有這些方法都會回傳 Tween 實體）：\n gsap.to(target, vars) gsap.from(target, vars) gsap.fromTo(target, fromVars , toVars )  參數說明：\n target：需要動畫的元素  target 使用 document.querySelectorAll()，所有符合的 CSS 選擇器都會是設置動畫的對象。 如果有多個元素對象，則使用陣列 [element1, element2]   vars：設置補間效果及屬性狀態  Timeline Timeline 就是「時間軸」，可以用來控制、管理一連串的動畫。\n 控制多段動畫 / 序列動畫 自由與重疊排序 添加 Tag 掌握動畫片段  舉例來說，我們要對多個元素作一連串的動畫，需要建立多個 Tween 並用 delay 設置延遲時間，非常麻煩：\n1 2 3  gsap.to(\u0026#39;.box1\u0026#39;, { duration: 1, x: 100, }); gsap.to(\u0026#39;.box2\u0026#39;, { delay: 1, duration: 1, y: 100 }); gsap.to(\u0026#39;.box1\u0026#39;, { delay: 2, duration: 1, rotation: 360 });   而且還無法對這一連串的動畫做控制。點我看範例。\n這時候可以使用 Timeline，建立一個時間軸，來管理這些動畫。\n1 2 3 4 5  const t1 = gsap.timeline(); t1.to(\u0026#39;.box1\u0026#39;, { duration: 1, x: 100, }) .to(\u0026#39;.box2\u0026#39;, { duration: 1, y: 100 }) .to(\u0026#39;.box1\u0026#39;, { duration: 1, rotation: 360 });   點我看範例。\n如果有相同動畫狀態，可以設定預設值，使程式碼更簡潔：\n1 2 3 4 5 6 7 8 9  const t1 = gsap.timeline({ defaults: { duration: 1, }, }); t1.to(\u0026#39;.box1\u0026#39;, { x: 100, }) .to(\u0026#39;.box2\u0026#39;, { y: 100, }) .to(\u0026#39;.box1\u0026#39;, { rotation: 360, });   1. 在時間軸中放置動畫 在時間軸建立動畫：\n to() from fromTo set()  1 2 3  const tl = gsap.timeline(); tl.to(element, {duration: 1, x: 100, opacity: 0.5});   Timeline 可以鏈式呼叫：\n1 2 3 4  const tl = gsap.timeline(); tl.from(element, {duration: 1, x: -100}) .to(element, {duration: 1, y: 50});   在時間軸中，加入一段已建立的動畫，使用 add()：\n1 2 3 4  const tween = tween = gsap.to(element, {duration: 1, x: 100, opacity: 0.5}); const tl = gsap.timeline(); tl.add(tween);   Timeline 許多方法都多 position 參數，可用來控制動畫插入點：\n 無設置：時間軸末尾 1：絕對時間，指定時間處 '+=1'、-=1：相對時間，相對於時間軸的結尾 'someLabel'：指定標籤處（建立標籤使用 addLabel()） ‵someLabel+=1'、‵someLabel-=1'：相對於指定標籤 \u0026lt;：最近動畫的開頭 \u0026gt;：最近動畫的結尾 \u0026lt;1、\u0026lt;-1：相對於最近動畫的開頭 \u0026gt;1、\u0026gt;-1：相對於最近動畫的結尾  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 插入至時間軸末尾 tl.to(element, 1, {}); // 插入至時間軸2秒處 tl.to(element, 1, {}, 2); // 在時間軸結束後2秒鐘插入 tl.to(element, 1, {}, \u0026#39;+=2\u0026#39;); // 在時間軸結束前2秒鐘插入 tl.to(element, 1, {}, \u0026#39;-=2\u0026#39;); // 在3秒處建立spin標籤 t1.addLabel(\u0026#39;spin\u0026#39;, 3); // 在spin標籤處插入動畫 tl.to(element, 1, {}, \u0026#39;spin\u0026#39;); // 在spin標籤處前三秒入動畫 tl.to(element, 1, {}, \u0026#39;spin+=3\u0026#39;); // 在最近一次動畫的開頭插入 tl.to(element, {x: 100}, \u0026#39;\u0026lt;\u0026#39;); // 在最近一次動畫的開始後1秒插入 tl.to(element, {x: 100}, \u0026#39;\u0026lt;1\u0026#39;);   基本用法 1. 數字動畫 0~100 最基本的用法，對物件的屬性去做變化。\nSee the Pen GSAP3 Demo - 基本數字動畫 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. CSS 動畫 See the Pen GSAP3 Demo - CSS 動畫 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 動畫控制  .play()：播放動畫 .pause()：暫停動畫播放 .paused()：獲取或設置動畫暫停狀態  myAnimation.paused(!myAnimation.paused()) 暫停動畫切換   .resume()：繼續動畫播放 .restart()：重新開始動畫 .reverse()：反轉播放動畫 .reversed()：獲取或設置動畫反轉狀態  myAnimation.reversed( !myAnimation.reversed() ) 動畫撥放方向切換。   .seek()：不改變狀態下，跳至動畫某個時間點  See the Pen GSAP3 Demo - 動畫控制 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  4. 重複撥放、來回撥放 1 2 3  repeat: 10, // 設置動畫重複次數 repeatDelay: 0.5, // 設置重複的間隔時間(秒) yoyo: true, // 設為true時，動畫會反轉重複   See the Pen GSAP3 Demo - 重複、來回 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  5. 錯開動畫 1  stagger: 0.5, // 設置錯開時間   See the Pen GSAP3 Demo - 重複、來回 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  6. 週期 GSAP2 的 cycle 屬性，被 GSAP3 的 gsap.utils.wrap() 給取代，而且更加靈活。\nSee the Pen GSAP3 Demo - 週期 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  簡易應用 Mousemove Event 1. Image Trail Effects See the Pen GSAP3 - Image Trail Effects by Chupai@Design (@chupai) on CodePen.  2. Slinky Text See the Pen GSAP3 - Slinky Text by Chupai@Design (@chupai) on CodePen.  Image Block Reveal See the Pen GSAP3 - Image Block Reveal by Chupai@Design (@chupai) on CodePen.  Text Animation  SplitText 商業插件\n 1. 重組文字 See the Pen GSAP3 - 重組文字 by Chupai@Design (@chupai) on CodePen. ","description":"這週是 六角鼠年鐵人賽 第四週，之前沒碰過 TweenMax，但 gsap 已經升級 GSAP3，就簡單研究一下 GSAP3。","id":46,"section":"posts","tags":["GSAP3","TweenMax","w3HexSchool"],"title":"GSAP3 - 專門處理動畫與特效的 JS 套件","uri":"https://chupai.github.io/posts/200229_gsap3/"},{"content":"這週是 六角鼠年鐵人賽 第三週，不知道要寫啥，就重新整理了一下 Flexbox 的筆記。\nFlexbox 概述 Flexbox 全稱為 CSS Flexible Box Layout，也就是 CSS 彈性盒子佈局。是一種新的 CSS3 佈局模式，在彈性盒子佈局中，彈性容器的子項目們可以伸展到任何方向、並讓他們的尺寸更加「彈性」、或者持續增大，以填補未使用的空間，抑或縮小，以避免父元素溢出。子元素的橫向或縱向對齊都很容易操作。\n1. 為何流行？ 為何開始流行了呢？最主要也是因為 CSS3 的規範終於普及，加上行動裝置的發展促成了響應式佈局興起，自適應長寬彈性相當大的 Flexbox 就趁勢而起了。\n 非常適合單向排版，例如導覽列、Gird-Layout 許多 CSS 框架也使用（Bootstrap、Foundation 等）  跟毒品一樣，用過就回不去了。\n2. 瀏覽器的支援 瀏覽器支援高達 97%。\n Can I use CSS Flexible Box Layout Module ?\n 3. Flexbox 規格歷史  2009 年的版本：display: box 現在已經不再跟 Flexbox 有任何關係。 2011 過渡期版本：display: flexbox 只是草稿，只被 IE10 實作, 如果可能的話應該避免使用。 2012 最終版：display: flex  模型概念 來源：CSS彈性盒子用法｜MDN \n容器與項目：\n 彈性容器（Flex container）\n將元素的 display 屬性設為 flex 或 inline-flex，就會變彈性容器。 彈性項目（Flex item）\n所有彈性容器的子元素都會變成彈性項目，包含文字。  彈性容器具有主軸與交錯軸：\n 主軸（main axis） 交錯軸（cross axis）  方向：\n 主軸起點與終點（main start/main end） 交錯軸點與終點（cross start/cross end）  彈性項目具有：\n 水平尺寸與垂直尺寸（main size、cross size）  屬性介紹 Flexbox 可分成外層元素（彈性容器）與內層元素（彈性項目）。\n外容器屬性：\n display：flex、inline-flex，啟用 Flexbox 的必備屬性 flex-flow  flex-direction：決定主軸線的方向 flex-wrap：決定是否換行   justify-content：主軸線的對齊 align-items：交錯軸的對齊 align-content：整體的對齊  內層元素屬性：\n align-self：單一個物件的交錯軸對齊 order：排序 flex  flex-grow：伸展比，其數值與其它物件可分配伸展比有關 flex-shrink：收縮比 flex-basis：絕對值    1. Emmet 速寫格式 Flexbox 相關屬性的 Emmet 速寫格式：\ndisplay\n d:f：display:flex; d:if：display:inline-flex;  flex-direction\n fxd：flex-direction:; fxd:c：flex-direction:column; fxd:cr：flex-direction:column-reverse; fxd:r：flex-direction:row; fxd:rr：flex-direction:row-reverse;  justify-content\n jc：justify-content:; jc:c：justify-content:center; jc:fe：justify-content:flex-end; jc:fs：justify-content:flex-start; jc:sa：justify-content:space-around; jc:sb：justify-content:space-between;  flex-wrap\n fxw：flex-wrap: ; fxw:n：flex-wrap:nowrap; fxw:w：flex-wrap:wrap; fxw:wr：flex-wrap:wrap-reverse;  align-items\n ai：align-items:; ai:b：align-items:baseline; ai:c：align-items:center; ai:fe：align-items:flex-end; ai:fs：align-items:flex-start; ai:s：align-items:stretch;  align-content\n ac：align-content:; ac:c：align-content:center; ac:fe：align-content:flex-end; ac:fs：align-content:flex-start; ac:s：align-content:stretch; ac:sa：align-content:space-around; ac:sb：align-content:space-between;  align-self\n as：align-self:; as:a：align-self:auto; as:b：align-self:baseline; as:c：align-self:center; as:fe：align-self:flex-end; as:fs：align-self:flex-start; as:s：align-self:stretch;  order\n ord：order:;  flex\n fx：flex:; fxb：flex-basis:; fxd：flex-direction:; fxd:c：flex-direction:column; fxd:cr：flex-direction:column-reverse; fxd:r：flex-direction:row; fxd:rr：flex-direction:row-reverse; fxf：flex-flow:; fxg：flex-grow:; fxsh：flex-shrink:; fxw：flex-wrap: ; fxw:n：flex-wrap:nowrap; fxw:w：flex-wrap:wrap; fxw:wr：flex-wrap:wrap-reverse;  外容器屬性 1. 必備屬性 使用 Flexbox 就是要將 display 設為 flex 或 inline-block。\n display: flex 其布局方式與 block 一樣，都會強迫換行； 而 inline-flex 和 inline-block 也 一樣，在後方的元素不會換行。  唯一不同的是，flex 與 inline-flex 的子元素具備了更多彈性的設定。\n1 2 3 4  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;text\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9  .container { display: block; } .box { display: flex; /* or inline-flex */ width: 100px; height: 100px; }   See the Pen Flex - demo1 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 主軸方向 flex-direction 可以決定主軸的方向，主軸的方向將會影響容器內的元素排序順序、方向。\nflex-direction 設定值共有以下四種：\n row：預設值，由左到右，從上到下 row-reverse：與 row 相反 column：從上到下，再由左到右 column-reverse：與 column 相反  1 2 3 4 5  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9  .container { display: flex; flex-direction: row; } .item { width: 50px; height: 50px; }   See the Pen flex-direction demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 主軸對齊 justify-content 決定了內容元素與整個 Flexbox 的「主軸對齊」位置，設定值共有以下五種：\n flex-start：預設值，對齊主軸線最前端 flex-end：對齊主軸線最終端 center：對齊主軸線中央 space-between：平均分配寬度，第一項和最後一項貼齊邊緣 space-around：平均分配寬度、間距  1 2 3 4 5  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9  .container { display: flex; justify-content: flex-start; } .item { width: 50px; height: 50px; }   See the Pen justify-content demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  4. 交錯軸對齊 align-items 剛好和 justify-content 相反，align-items 決定了內容元素與整個 Flexbox 的「交錯軸對齊」位置，設定值總共有下列五個：\n stretch：預設值，如果子元素 height: auto，會將撐開至父元素的高度 flex-start：對齊交錯軸線最前端 flex-end：對齊交錯軸線最末端 center：對齊交錯軸線中央 baseline：對齊子元素的基線  1 2 3 4 5  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item h100\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item h-auto\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  .container { display: flex; justify-content: flex-start; } .item { width: 50px; height: 50px; } .h-100 { height: 100px; } .h-auto { height: auto; }   See the Pen align-items demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  5. 換行 當我們把父容器的 display 設定為 flex 或 inline-flex 的時候，子元素就是以單行的方式排列，因為預設不會行，因此當遇到邊界會彈性調整元素。\nflex-wrap 可以調整元素是否換行，共有三個設定值：\n nowrap：預設值，不斷行 wrap：多行 wrap-reverse：多行，但主軸線起點與終點相反  1 2 3 4 5 6  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9  .container { display: flex; flex-wrap: nowrap; } .item { width: 50px; height: 50px; }   See the Pen flex-wrap by CHUPAIWANG (@CHUPAIWANG) on CodePen.  6. 多行交錯軸對齊 align-items 是針對內容為單行的子元素進行處理，如果遇到多行的子元素（flex-wrap: wrap），就要使用 align-content 這個屬性，這個屬性總共有六個設定值：\n stretch：預設值，會平均分配行距，height: auto 會撐開填滿整行。 flex-start：對齊交錯軸線最前端 flex-end：對齊交錯軸線最末端 center：對齊交錯軸線中央 space-between：第一行與最後一行分別對齊交錯軸線最上方與最下方 space-around：平均分配行距，兩端會有行距一半的間距  1 2 3 4 5 6  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10  .container { display: flex; flex-wrap: wrap; align-content: stretch, } .item { width: 50px; height: 50px; }   See the Pen align-content demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  內層元素屬性 1. 交錯軸位置 align-self 作用於內層容器，也就是子元素本身，會覆蓋外層容器的 align-items。\n設定值與 align-items 相同：\n stretch：預設值，如果子元素 height: auto，會將撐開至父元素的高度 flex-start：對齊交錯軸線最前端 flex-end：對齊交錯軸線最末端 center：對齊交錯軸線中央 baseline：對齊子元素的基線  1 2 3 4 5 6  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt;   1 2 3  .item { align-self: stretch; }   See the Pen align-self demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 排序 order 屬性可以直接指定一個數字，就可以由小到大的排列順序。\n 預設值為 0，只給一個元素設置會跑到最後面 要設置到最前頭，可以設值負值 相同的數字，看元素排序  注意，order 僅僅對元素的視覺順序 (visual order) 產生作用，並不會影響元素的邏輯或順序。\n1 2 3 4 5 6  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item item1\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item2\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item3\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item4\u0026#34;\u0026gt;4\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3  .item1 { order: 2; }   See the Pen align-self demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 伸縮比 FlexBox 最重要的屬性「flex」，個別調整子元素長度「伸展」、「壓縮」的比例以及基本大小。\nflex 是簡寫，裡面依序包含三個屬性：\n flex-grow：預設值為 0，負值無效 flex-shrink：預設值為 1，負值無效 flex-basis：預設值為 auto，若值為 0，則必須加上單位，以免被視作伸縮性  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /* 單值語法 無單位數值 unitless number: flex-grow */ flex: 2; /* 單值語法 有效寬高單位 width/height: flex-basis */ flex: 10em; flex: 30px; /* 雙值語法 flex-grow | flex-basis */ flex: 2 2; /* 三值語法 flex-grow | flex-shrink | flex-basis */ flex: 2 2 10%;   三個屬性可以分開設定，也可以合在一起用一個 flex 統一設定。\n3.1 伸展比 flex-grow 元素的伸展性，是一個數值，當子元素的寬度「小」於它自己在父元素分配到的寬度，按照數字做相對應的「伸展」比例分配（剩餘空間）。\n預設值為 0，不會進行彈性變化，不可為負值，設為 1 則會進行彈性變化。\nSee the Pen flex-grow  by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3.2 壓縮比 flex-shrink 元素收縮性，是一個數值，當子元素的寬度「大」於它自己在父元素分配到的寬度時，會進行壓縮。\n預設值為 1，設為 0 的話不會進行彈性變化（全部都 0 可能超出邊界），不可為負值。\nSee the Pen flex-shrink by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3.3 基本大小 flex-basis flex-basis 為子元素的基本大小，作為父容器的大小比較基準，預設值為 auto。\n在分配空間之前，子元素會依 flex-basis 或者 width/height，預約空間，剩餘空間會依 flex-grow 分配。\n主軸方向 flex-direction：\n 水平 row： flex-basis 為 width 的替代 垂直 column：flex-basis 為 height 的替代  優先級：\n 如果同時設置，那麼 width/height 會被覆蓋（flex-basis 的優先級較高）； 其中有一個是 auto，那麼另外一個非 auto 的屬性優先級會更高。  一些常見問題 一些新手使用 FlexBox，沒注意到的問題。\n1. 子元素高度被強制拉伸對齊 常見的情況是，當子元素 col 內，放置不同高度的元素 box，每個子元素 col 都會被強制拉伸對齊。\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box3\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3  .container { display: flex; }   See the Pen 子元素高度被強制拉伸對齊 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  這是因為 align-items 預設 stretch。因此可以透過改變 align-items 的值解決，或是使用 align-self 個別調整。\n2. 元素被壓縮 我們都知道 FlexBox 預設不換行，因此當容器大小不足時，各個子元素會被壓縮。會被壓縮的原因是 flex-shrink 預設為 1。\n所以如果不希望元素被壓縮，可以將 flex-shrink 設為 0。\n1 2 3 4 5 6 7  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col flex-shrink-0\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://picsum.photos/300/300\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   See the Pen 子元素高度被強制拉伸對齊 by CHUPAIWANG (@CHUPAIWANG) on CodePen. ","description":"這週是 六角鼠年鐵人賽 第三週，不知道要寫啥，就重新整理了一下 Flexbox 的筆記。","id":47,"section":"posts","tags":["Flex","CSS排版","w3HexSchool"],"title":"CSS筆記 - Flexbox","uri":"https://chupai.github.io/posts/200220_flex/"},{"content":"這週是 六角鼠年鐵人賽 第二週，就簡單的整理 Swiper 如何使用。\n簡介 Swiper 是一款免費以及輕量級的 JS 框架，常用於移動設備的內容觸摸滑動。\n最重要的是 「不需要使用到 jQuery」。\n更詳細介紹，請見官方：\n Swiper Swiper 中文網  目前 Swiper 版本為 Swiper5，Swiper5 對比 Swiper4 的 API 並無太大變化。Swiper5 增加了 cssMode，並且可以通過 CSS 修改 Swiper 顏色風格。\n 一些基本範例，可以參考 Swiper Demos。\n 安裝 需要用到的檔案有 swiper.min.js 和swiper.min.css 檔案。\n下載：\n Swiper GitHub repository NPM：  $ npm install swiper CDN：\n1 2 3 4 5  \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/swiper/css/swiper.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/swiper/css/swiper.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/swiper/js/swiper.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/swiper/js/swiper.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;    cdnjs - Swiper\n 配置：\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; ... \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/swiper/css/swiper.min.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ... \u0026lt;script src=\u0026#34;https://unpkg.com/swiper/js/swiper.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   初始化 Swiper 1  new Swiper(swiperContainer, parameters);    swiperContainer：要控制的 Swiper 容器，可以是 DOM 元素 或 字串（CSS 選擇器） parameters：一個物件，為 Swiper 的配置參數  1 2 3  var mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { // 配置參數 });    詳細配置參數，可以參考 Swiper API。\n 假設初始化時，沒有定義 Swiper 實體，可以透過 Swiper 的HTML 元素來獲取該實體。\n1 2 3  new Swiper(\u0026#39;.swiper-container\u0026#39;); var mySwiper = document.querySelector(\u0026#39;.swiper-container\u0026#39;).swiper;   Swiper 實體有屬性與方法可以使用，還可以監聽事件。\nLayout 1. Swiper 容器 一個 Swiper 就對應到一個 container。\n1 2  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;/div\u0026gt;   1  var mySwiper = new Swiper (\u0026#39;.swiper-container\u0026#39;);   如果一個頁面有很多個 Swiper，可以給每個容器加上 ID 或 Class 區分。\n1 2 3  \u0026lt;div class=\u0026#34;swiper-container\u0026#34; id=\u0026#34;swiper1\u0026#34;\u0026gt;....\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-container\u0026#34; id=\u0026#34;swiper2\u0026#34;\u0026gt;....\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-container\u0026#34; id=\u0026#34;swiper3\u0026#34;\u0026gt;....\u0026lt;/div\u0026gt;   1 2 3  var swiper1 = new Swiper(\u0026#39;#swiper1\u0026#39;); var swiper2 = new Swiper(\u0026#39;#swiper2\u0026#39;); var swiper3 = new Swiper(\u0026#39;#swiper3\u0026#39;);   我們可以為這個容器設置大小：\n1 2 3 4  .swiper-container { width: 600px; height: 300px; }   2. slide 元件 Swiper 的每個展示區塊為一個 slide，全部的 slide 會放在一個 wrapper 中。\n1 2 3 4 5 6 7  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   See the Pen Swiper - 基本範例 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 控制元件 除了 slide 外，還可以包含其他控制元件，可以自由選擇你需要的。。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- Pagination --\u0026gt; \u0026lt;div class=\u0026#34;swiper-pagination\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- Navigation --\u0026gt; \u0026lt;div class=\u0026#34;swiper-button-prev\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-button-next\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- Scrollbar --\u0026gt; \u0026lt;div class=\u0026#34;swiper-scrollbar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  var mySwiper = new Swiper (\u0026#39;.swiper-container\u0026#39;, { // Pagination  pagination: { el: \u0026#39;.swiper-pagination\u0026#39;, }, // Navigation  navigation: { nextEl: \u0026#39;.swiper-button-next\u0026#39;, prevEl: \u0026#39;.swiper-button-prev\u0026#39;, }, // Scrollbar  scrollbar: { el: \u0026#39;.swiper-scrollbar\u0026#39;, }, });   See the Pen Swiper - 控制元件 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  控制元件可以放在 container 之外，但需要設置 uniqueNavElements: false。\n3. 對應的 class 名稱 容器、元件、狀態，對應的 class 名稱，都可以透過選項更改。\n舉例來說，將預設的 swiper-wrapper 替換成 my-wrapper：\n1 2 3  var mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;,{ wrapperClass : \u0026#39;my-wrapper\u0026#39;, });   容器：\n swiper-container：Swiper 容器  選項：containerModifierClass   swiper-wrapper：slide 容器  選項：wrapperClass    slide 元件：\n swiper-container：slide 元件  選項：slideClass   swiper-slide-active：active 狀態的 slide 元件  選項：slideActiveClass   swiper-slide-visible：可視區塊的 slide 元件  選項：slideVisibleClass   swiper-slide-next：active slide 的下一個 slide 元件  選項：slideNextClass   swiper-slide-prev：active slide 的上一個 slide 元件  選項：slidePrevClass    基本配置 1. background-img 1 2 3 4 5 6  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34; style=\u0026#34;background-image:url(\u0026#39;\u0026#39;)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10  .swiper-container { width: 600px; height: 300px; } .swiper-slide { background-repeat: no-repeat; background-position: center center; background-size: cover; }   See the Pen Swiper Demos - background-img by Chupai@Design (@chupai) on CodePen.  2. \u0026lt;img\u0026gt; 1 2 3 4 5 6 7 8  \u0026lt;div id=\u0026#34;swiper1\u0026#34; class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11  .swiper-container { width: 600px; height: 300px; } .swiper-slide \u0026gt; img { display: block; width: 100%; height: 100%; object-fit: cover; }   1  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;);   See the Pen Swiper Demos - img by Chupai@Design (@chupai) on CodePen.  3. slidesPerView slidesPerView 能設置同時顯示的 slide 數量，slide 的大小由 container 寬去等分。\n1 2 3  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { slidesPerView: 2, });   See the Pen Swiper Demos - slidesPerView by Chupai@Design (@chupai) on CodePen.  4. 依 slide 大小顯示 如果想要依 slide 大小來顯示，可以將 slidesPerView 設為 'auto'。\n1 2 3 4 5 6 7 8 9 10  .swiper-slide { width: 300px; height: 200px; } .swiper-slide \u0026gt; img { width: 100%; height: 100%; object-fit: cover; }   1 2 3  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { slidesPerView: \u0026#39;auto\u0026#39;, });   See the Pen Swiper Demos - 依 slide 大小顯示 by Chupai@Design (@chupai) on CodePen.  3D Cube Effect 3D Cube Effect：effect: 'cube'。\ncubeEffect 參數：\n slideShadows：slide 陰影。預設為 true。 shadow：投影。預設為 true。 shadowOffset：投影距離（px）。預設為 20。 shadowScale： 投影縮放比例。預設為 0.94。  1 2 3 4 5 6 7 8 9  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;cube\u0026#39;, cubeEffect: { slideShadows: true, // slide 陰影  shadow: true, // 投影  shadowOffset: 20, // 投影距離（px）  shadowScale: 0.94, // 投影縮放比例  }, });   1. 基本 將 container 設為方塊大小。\n1 2 3 4 5 6 7  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34; style=\u0026#34;background-image:url(\u0026#39;\u0026#39;)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34; style=\u0026#34;background-image:url(\u0026#39;\u0026#39;)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10  .swiper-container { width: 300px; height: 300px; } .swiper-slide { background-repeat: no-repeat; background-position: center center; background-size: cover; }   1 2 3  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;cube\u0026#39;, });   See the Pen 3D Cube Effect - Basic by Chupai@Design (@chupai) on CodePen.  2. 卡片 slide 內放置 card 元件，將 container 的寬設為 card 的寬，card 不需設置寬度：。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card__img\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card__body\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;card__title\u0026#34;\u0026gt; Lorem ipsum \u0026lt;span\u0026gt;Web Designer\u0026lt;/span\u0026gt; \u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9  .swiper-container { width: 300px; height: auto; } .card { background-color: white; } .card ...   See the Pen 3D Cube Effect - Card by Chupai@Design (@chupai) on CodePen.  3D Coverflow Effect 3D Coverflow：effect : 'coverflow'。\ncoverflowEffect 參數：\n slideShadows：slide 陰影。預設為 true。 rotate：slide 做 3D 旋轉時 Y 軸的旋轉角度。預設為 50。 stretch：每個 slide 之間的拉伸直，越大 slide 靠得越緊。預設為 0。 depth：slide 的位置深度值，值越大 z 軸距離越遠，看起來越小。預設為 100。 modifier：depth 和 rotate 和 stretch 的倍率。預設為 1。  1 2 3 4 5 6 7 8 9 10 11 12  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;,{ slidesPerView: \u0026#39;auto\u0026#39;, centeredSlides: true, effect : \u0026#39;coverflow\u0026#39;, coverflowEffect: { slideShadows : true, rotate: 50, stretch: 0, depth: 100, modifier: 1, }, });   1. 基本 1 2 3 4 5 6 7  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34; style=\u0026#34;background-image:url(\u0026#39;\u0026#39;)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34; style=\u0026#34;background-image:url(\u0026#39;\u0026#39;)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11  .swiper-container { width: 100%; } .swiper-slide { width: 200px; height: 200px; background-repeat: no-repeat; background-position: center center; background-size: cover; }   1 2 3 4 5  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;coverflow\u0026#39;, slidesPerView: \u0026#39;auto\u0026#39;, centeredSlides: true, });   必設參數：\n slidesPerView: 'auto'，根據 slide 的寬度來設定 slide 可視數量。 centeredSlides，active slide 會置中，而不是預設狀態下的靠左。  See the Pen coverflowEffect - Basic by Chupai@Design (@chupai) on CodePen.  2. Card 將 card 元件加上 swiper-slide，並設置寬度：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;div id=\u0026#34;mySwiper\u0026#34; class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card swiper-slide\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34; class=\u0026#34;card__img\u0026#34;/\u0026gt; \u0026lt;div class=\u0026#34;card__body\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Lorem ipsum0\u0026lt;/h3\u0026gt; \u0026lt;span\u0026gt;Web Designer\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card swiper-slide\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card swiper-slide\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card swiper-slide\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10  .swiper-container { width: 100%; } .card { width: 240px; border-radius: 8px; background: white; overflow: hidden; }   如果 Card 元件要放在 swiper-slide 內有兩種做法：\n 將 slide 的寬設為 card 寬度，card 寬度設為 100%。 將 slide 的寬設為 auto !important，並設置 card 寬度。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;div id=\u0026#34;mySwiper\u0026#34; class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34; class=\u0026#34;card__img\u0026#34;/\u0026gt; \u0026lt;div class=\u0026#34;card__body\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Lorem ipsum0\u0026lt;/h3\u0026gt; \u0026lt;span\u0026gt;Web Designer\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /* 作法一 */ .swiper-slide { width: 240px; } .card { width: 100%; /* ... */ } /* 作法二 */ .swiper-slide { width: auto !important; } .card { width: 240px; /* ... */ }   這個範例稍微修改一下 coverflow 參數：\n1 2 3 4 5 6 7 8 9 10 11 12  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;coverflow\u0026#39;, slidesPerView: \u0026#39;auto\u0026#39;, centeredSlides: true, coverflowEffect: { slideShadows: true, rotate: 20, stretch: 0, depth: 350, modifier: 1, }, });   See the Pen coverflowEffect - Card by Chupai@Design (@chupai) on CodePen.  3D Flip Effect 3D Flip Effect：effect: 'cube'。\nflipEffect 參數：\n slideShadows：slide 的陰影。預設為 true。 limitRotation：限制最大旋轉角度為 180 度。預設為 true。  1 2 3 4 5 6 7  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;,{ effect : \u0026#39;flip\u0026#39;, flipEffect: { slideShadows : true, limitRotation : true, } });   1. 基本 配置跟 3D Cube Effect 配置一樣：\n1 2 3  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;,{ effect : \u0026#39;flip\u0026#39;, });   See the Pen 3D Flip Effect - Basic by Chupai@Design (@chupai) on CodePen.  2. 卡片 See the Pen 3D Flip Effect - Card by Chupai@Design (@chupai) on CodePen.  Fade Effect Fade Effect effect: 'fade'。\nfadeEffect 效果參數：\n crossFade：淡出效果，預設為 false。  預設 crossFade 是關閉的，也就是所有 slide 是重疊在一起的。\n1 2 3 4 5 6  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;fade\u0026#39;, fadeEffect: { crossFade: false }, });   1. 基本 配置跟 3D Cube Effect 配置一樣：\n1 2 3  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;fade\u0026#39;, });   See the Pen Fade Effect - Basic by Chupai@Design (@chupai) on CodePen.  Thumbs Thumbs 元件為專門用於製作帶縮略圖的 Swiper，比使用 Controller 更為簡便，且在 loop 狀態下更友好。\n有兩種寫法：\n1 2 3 4 5 6 7 8 9 10  var thumbsSwiper = new Swiper(\u0026#39;.swiper-container-thumbs\u0026#39;, { slidesPerView: 5, }); var mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { ... thumbs: { swiper: thumbsSwiper } });   或是：\n1 2 3 4 5 6 7 8 9 10  var mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { ... thumbs: { swiper: { el: \u0026#39;.swiper-container-thumbs\u0026#39;, slidesPerView: 5, ... } } });   縮圖的 Swiper active 狀態 slide 會被加上 .swiper-slide-thumb-active 的類名。\n但不知道為什麼，我使用 4.5.1 版本的 CDN，.swiper-slide-thumb-active 不會加上去。\n1. Thumbs Gallery 1 2 3 4 5 6 7 8  \u0026lt;div class=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-container gallery-top\u0026#34;\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-container gallery-thumbs\u0026#34;\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  .wrapper { width: 600px; } .swiper-slide { background-repeat: no-repeat; background-size: cover; background-position: center center; } .gallery-top { width: 100%; height: 400px; bottom: 10px; } .gallery-thumbs { width: 100%; height: 100px; } .gallery-thumbs .swiper-slide { opacity: 0.4; } .gallery-thumbs .swiper-slide-thumb-active { opacity: 1; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const mySwiper = new Swiper(\u0026#39;.gallery-top\u0026#39;, { spaceBetween: 10, thumbs: { swiper: { el: \u0026#39;.gallery-thumbs\u0026#39;, spaceBetween: 10, slidesPerView: 4, freeMode: true, }, }, navigation: { nextEl: \u0026#39;.swiper-button-next\u0026#39;, prevEl: \u0026#39;.swiper-button-prev\u0026#39;, }, });   See the Pen Thumbs Gallery by Chupai@Design (@chupai) on CodePen.  總結 這週就先整理到這，有空補上自動撥放、循環模式，我們下週見。\n2020-03-04\n被分享了，有點驚訝，是不是要來加上封面圖了 🤣。\n","description":"這週是 六角鼠年鐵人賽 第二週，就簡單的整理 Swiper 如何使用。","id":48,"section":"posts","tags":["Swiper.js","w3HexSchool"],"title":"Swiper - 不需要使用到 jQuery 的輪播套件","uri":"https://chupai.github.io/posts/200212_swiper/"},{"content":"前言 之前都是使用 Blogger 來放筆記，但 Blogger 沒辦法使用 Markdown 語法，所以筆記幾乎都使用 HackMD 來寫作，有空時才會將文章轉好丟到 Blogger 上，如果文章作修改要同步很麻煩。\n最近六角學院舉辦的 w3HexSchool 鼠年全馬鐵人挑戰 開跑了，有想過使用 Hexo + GitHub pages 建立 Blog，但實在是沒空。\n就在不知道要將文章丟哪時，發現了支援 Markdown 語法的簡易部落格「Bloggi」。\n2020-03-16 第七週已經找時間將全部文章搬到 Hugo 了，可以參考 第七週的文章。\n 原 Blog 新 Blog  有空再把 Blogger 的文章全部搬過來。\n\rBloggi Bloggi 是一個免費的網誌網誌寫作平台，支援 Markdown 語法，介面簡潔、無廣告，只需要簡單的註冊就可以立即使用。\n Bloggi 官網\n 1. 簡單註冊  部落格名稱 電子郵件 密碼  2. 教學手冊 帳號註冊完成後，進到「Posts」，會兩篇預設文章，為教學手冊及 Bloggi 的介紹。看完之後就可以刪除了。\n3. 設定 接下來進到「Settings」，可以編輯部落格名稱、簡介、LOGO、網址名稱等等資訊。\n部分功能則需要付費才使用，例如自訂網域名稱、Favicon、Navigation 等等。\n4. 新增文章 接下來回到「Posts」，如果要新增文章點選「New post」即可。\n編輯器很簡易，只有標題和內文，寫作格式為 Markdown 語法。\n左上分別是：\n Publish 發布文章 Preview 預覽文章 Settimgs 文章設定  5. 預覽  我的 Bloggi\n 總結 優點：\n 支援 Markdown 語法 免費、無廣告 簡單好懂的介面 簡易客製化與設定  缺點：\n 需要第三方圖片空間，管理上略麻煩 匯入匯出功能，期待未來加入  ","description":"這週是 六角鼠年鐵人賽 第一週，支援 Markdown 語法的簡易部落格「Bloggi」。","id":49,"section":"posts","tags":["Bloggi","w3HexSchool"],"title":"Bloggi - 支援 Markdown 語法的簡易部落格","uri":"https://chupai.github.io/posts/200205_bloggi/"},{"content":"\r基本語法與文法：\n 變數  資料操作：\n 陣列 迭代陣列 Slice、Splice、Split 的區別 連續的數字陣列 日期時間 物件字面值擴充功能 展開／其餘運算子 解構指定  函式：\n 函式呼叫與 this  非同步：\n 非同步 回呼函式 Promise Async/Await  BOM：\n window.location ","description":"JavaScript筆記 目錄","id":50,"section":"posts","tags":["JavaScript"],"title":"JavaScript筆記 目錄","uri":"https://chupai.github.io/posts/190620_javascript/"}]