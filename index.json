[{"content":" JavaScript筆記 目錄\n \r基本的過濾查詢 資料：\n1  const data = [0, 11, 22, 33, 44, 55, 66, 77, 88, 99];\r  filter()，將符合條件的元素存到新陣列，並回傳新陣列。\n1 2  const result = data.filter((item)=\u0026gt; item \u0026gt; 50);\rconsole.log(result); // [66, 77, 88, 99]\r  indexOf() 回傳第一個符合條件的元素索引，沒有找到回傳 -1。內部使用嚴格相等 === 比較。\n1 2  const result = data.indexOf(55);\rconsole.log(result); // 5\r  includes() 會判斷陣列使否包含特定的元素，有的話回傳 true，沒有則回傳 false。\n1 2  const result = data.includes(99);\rconsole.log(result); // true\r  some()，若至少有一個元素符合條件，回傳 true，沒有則回傳 false。\n1 2  const result = data.some((item) =\u0026gt; item === 55);\rconsole.log(result); // true\r  find()，回傳第一個符合條件的元素，沒有則回傳 undefined。\n1 2  const result = data.find((item) =\u0026gt; item === 55);\rconsole.log(result); // 55\r  findIndex()，回傳第一個符合條件的元素的索引，沒有則回傳 -1。\n1 2  const result = data.findIndex((item) =\u0026gt; item === 55);\rconsole.log(result); // 5\r  進階資料過濾查詢 資料：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const data = [\r{\rid: 1,\ruser: \u0026#39;Chupai\u0026#39;,\risActive: false,\r},\r{\rid: 2,\ruser: \u0026#39;ET\u0026#39;,\risActive: false,\r},\r{\rid: 3,\ruser: \u0026#39;Even\u0026#39;,\risActive: true,\r},\r// ...\r];\r  1. 單一條件 1 2 3 4 5 6  const key = \u0026#39;user\u0026#39;;\rconst target = \u0026#39;ET\u0026#39;;\rconst result = data.filter((item) =\u0026gt; item[key] === target);\rconsole.log(result);\r// [ { id: 2, user: \u0026#39;ET\u0026#39;, isActive: false } ]\r  2. 複數條件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const condition = {\ruser: \u0026#39;ET\u0026#39;,\risActive: false,\r};\rconst result = data.filter((item) =\u0026gt; {\rfor (const key in condition) {\rif (!item.hasOwnProperty(key) || item[key] !== condition[key]) {\rreturn false;\r}\r}\rreturn true;\r});\rconsole.log(result);\r// [ { id: 2, user: \u0026#39;ET\u0026#39;, isActive: false } ]\r  3. 單一條件 + 多目標 1 2 3 4 5 6 7 8 9  const key = \u0026#39;user\u0026#39;;\rconst targets = [\u0026#39;ET\u0026#39;, \u0026#39;Chupai\u0026#39;];\rconst result = data.filter((item) =\u0026gt; targets.includes(item[key]));\rconsole.log(result);\r// [\r// { id: 1, user: \u0026#39;Chupai\u0026#39;, isActive: false },\r// { id: 2, user: \u0026#39;ET\u0026#39;, isActive: false }\r// ]\r  4. 複數條件 + 多目標 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const condition = {\ruser: [\u0026#39;ET\u0026#39;, \u0026#39;Even\u0026#39;],\risActive: [true],\r};\rconst result = data.filter((item) =\u0026gt; {\rfor (const key in condition) {\rif (!item.hasOwnProperty(key) || !condition[key].includes(item[key])) {\rreturn false;\r}\r}\rreturn true;\r});\rconsole.log(result);\r// [ { id: 3, user: \u0026#39;Even\u0026#39;, isActive: true } ]\r  ","description":"JavaScript 陣列資料過濾查詢。","id":0,"section":"posts","tags":["JavaScript","Array","資料過濾查詢"],"title":"JavaScript 陣列資料過濾查詢","uri":"https://chupai.github.io/posts/2104/array_filtersearch/"},{"content":" JavaScript筆記 目錄\n \r前言 當專案越來越大時，龐大的程式碼會變得難以離解及維護，因此模組化管理就變得非常重要。模組化就是將程式分解成多個群集，可方便管理維護，不但可以提升程式碼的複用性，更能避免命名上的衝突。\n但 JavaScript 早期作為輕量級的腳本語言，只用於在 Web 上與使用者進行簡單的互動，並沒有依賴管理的概念，因此在 ES6 Module 出現前，都未內建支援模組系統。為了解決模組化的問題，JavaScript 社群發展出許多解決方案。\n主流的模組化規範為以下兩種：\n CommonJS，最早是在 Server 架構下設計出來的，最初名為 ServerJS。Node.js 曾經遵循 CommonJS 來實現模組管理，許多開法者將其視為 CommonJS 實作代表。 AMD（Asynchronous Module Definition），是一個在瀏覽器端模組化開發的規範。而 RequireJS 為最受歡迎的 AMD 實作。  關於 CommonJS 與 AMD 歷史，可以參考以下文章：\n 前端模塊化開發那點歷史 #588 《編程時間簡史系列》JavaScript 模塊化的歷史進程  ES6 Module 1. script 標籤 使用 ES6 Module，需要在 \u0026lt;script\u0026gt; 上添加 type=\u0026quot;module\u0026quot;，否則會拋出錯誤。\n1 2  \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;js/index.js\u0026#34;/\u0026gt;   當 type 設置為 \u0026quot;module\u0026quot; 時，預設具有 defer 的特性，.js 檔案會以非同步的方式下載，也就是會在 DOM 解析完畢後執行。\n另外，ES6 Module 自動採用嚴格模式。\n2. export 和 import 模組功能主要是由 export 和 import 關鍵字構成：\n export 用於匯出 import 用於匯入  每個檔案都是一個獨立的模組，模組內部的所有變數都是私有的，其他模組無法訪問。因此若希望外部能夠讀取模組內部的變數、函式或類別，可以用 export 匯出想要公開的名稱。這樣就可以在另一個模組中用 import 匯入使用。\n基本範例：\n1 2  // moduleA.js\rexport const a = \u0026#39;hi\u0026#39;;\r  1 2 3  // index.js\rimport { a } from \u0026#39;./moduleA.js\u0026#39;;\rconsole.log(a); // \u0026#34;hi\u0026#34;\r  export 與 import 只能出現在頂層作用域，它們必須出現在所有區塊與函式之外。舉例來說，你無法使用 if 條件式將 export 或 import 包起來。\r export 每個模組中可以使用多個 export：\n1 2 3 4 5 6 7 8 9 10  // moduleA.js\rexport const a = \u0026#39;hi!\u0026#39;;\rexport function foo() {\r// ...\r}\rexport class User {\rconstructor(name) {\r// ...\r }\r}\r  除了上述的直接匯出，也可以先宣告，並使用大括號將要匯出的名稱包起來。：\n1 2 3 4 5 6 7 8 9 10 11 12  // moduleA.js\rconst a = \u0026#39;hi\u0026#39;;\rfunction foo() {\r// ...\r}\rclass User {\rconstructor() {\r// ...\r }\r}\rexport { a, foo, User };\r  兩種寫法是等價的，但它可以很清楚這個模組對外公開的名稱。\nexport 必須與模組內部的變數建立對應的關係，否則會報錯。\r 1 2 3 4 5 6  // 錯誤範例 1\rexport \u0026#39;hi\u0026#39;;\r// 錯誤範例 2\rconst a = \u0026#39;hi\u0026#39;;\rexport a;\r  export 匯出的名稱可以使用 as 關鍵字重新命名：\n1 2 3 4 5 6 7 8  // moduleA.js\rconst a = \u0026#39;hi\u0026#39;;\rfunction foo() {}\rexport { a as newA,\rfoo as newFoo\r};\r  1 2 3  // index.js\rimport { newA, newFoo } from \u0026#39;./moduleA.js\u0026#39;;\rconsole.log(newA); // \u0026#34;hi\u0026#34;\r  import import 一樣可以使用 as 關鍵字，將匯入的名稱重新命名：\n1 2 3  // index.js\rimport { a as newA } from \u0026#39;./moduleA.js\u0026#39;;\rconsole.log(newA); // \u0026#34;hi\u0026#34;\r  假設要一次匯入所有模組匯出內容，可以使用 * as：\n1 2 3 4  // index.js\rimport * as moduleA from \u0026#39;./moduleA.js\u0026#39;;\rconsole.log(moduleA.a); // \u0026#34;hi\u0026#34;\r  import 指定的名稱，相當於 const 宣告，因此無法在匯入的檔案內改寫。\r 1 2 3  // index.js\rimport { a } from \u0026#39;./moduleA.js\u0026#39;;\ra = \u0026#39;hello\u0026#39;; // 報錯\r  如果是該變數是物件，因為傳址特性改寫屬性是允許的，但這種操作很難除錯，因此不建議這樣操作。\r import 具有提升（Hoisting）效果：\n1 2 3  // index.js\rconsole.log(newA); // \u0026#34;hi\u0026#34;\rimport { a } from \u0026#39;./moduleA.js\u0026#39;;\r  若該模組沒有任何值需要匯出，僅執行某些功能， import 路徑即可：\n1 2 3 4 5 6  // index.js\rfunction foo() {\rconsole.log(\u0026#39;hi\u0026#39;);\r}\rfoo();\r  1 2 3  // index.js\rimport \u0026#39;./moduleA.js\u0026#39;;\r// \u0026#34;hi\u0026#34;\r  export default export 屬於 具名匯出（named export） 的用法，模組就算公開的名稱只有一個，也必須定義名稱：\n1 2 3  // moduleA.js\rconst a = \u0026#39;hi\u0026#39;;\rexport { a };\r  使用 import 時，還需要查閱公開名稱。\n而匯出還有一種 預設匯出（default export），使用 export default 關鍵字，可以直接匯出不需要定義名稱。\n1 2 3 4 5 6 7 8  // 函式\rexport default function () {};\r// 或者物件\rexport default {};\r// 或值\rexport default \u0026#39;hi\u0026#39;;\r  但要注意，模組內只能有一個 export default。\r 一樣可以先宣告，但不需要 {}：\n1 2 3  // moduleA.js\rconst a = \u0026#39;hi\u0026#39;;\rexport default a;\r  使用 import 匯入時，可以任意指定名稱，不需要 {}。：\n1 2  // index.js\rimport a from \u0026#39;./moduleA.js\u0026#39;;\r  export 和 export default 可以同時存在：\n1 2 3  // moduleA.js\rexport const a = \u0026#39;hi\u0026#39;;\rexport default \u0026#39;hello\u0026#39;;\r  1 2 3 4 5 6  // index.js\rimport { a } from \u0026#39;./moduleA.js\u0026#39;;\rimport b from \u0026#39;./moduleA.js\u0026#39;;\r// 或者合併匯入，預設一定要在前\rimport b, { a } from \u0026#39;./moduleA.js\u0026#39;;\r  合併使用 如果模組作為入口，可能會先後輸出同一個模組。\n1 2 3 4  // moduleA.js\rexport const a = \u0026#39;hi\u0026#39;;\r// moduleB.js\rexport const b = \u0026#39;hello\u0026#39;;\r  1 2 3 4 5  // index.js\rimport { a } from \u0026#39;./moduleA.js\u0026#39;;\rimport { b } from \u0026#39;./moduleB.js\u0026#39;;\rexport { a, b };\r  你可以將 import 和 export 寫在一起：\n1 2 3 4 5 6 7  // index.js\rexport { a } from \u0026#39;./moduleA.js\u0026#39;;\rexport { b } from \u0026#39;./moduleB.js\u0026#39;;\r// or 全部匯出\rexport * from \u0026#39;./moduleA.js\u0026#39;;\rexport * from \u0026#39;./moduleB.js\u0026#39;;\r  ","description":"ES6 Module。","id":1,"section":"posts","tags":["JavaScript","ES6 Module"],"title":"ES6 Module","uri":"https://chupai.github.io/posts/2104/es6module/"},{"content":"\r簡介 Teleport 是 Vue 3 新增的功能，它是一個內建元件 \u0026lt;teleport\u0026gt;，可以讓我們將模板內的 DOM 渲染到指定位置。\n Vue 的 Teleport 類似於 React 的 Portals。\n 使用場景 在開發過程中，常常會使用到 Modal、Alert、Message 等這類視覺上有「跳出」容器感覺的元件。這類元件通常會顯示在最上層，並且使用 position: fixed 定位視窗，還有覆蓋整個視窗的遮罩。\n但通常這類元件會放置在某個元件內，那麼就必須要處理定位、層疊樣式、溢出邊界等等問題（例如，父元素若使用了 transform 會導致 position: fixed 失效）。若放置在最外層，資料狀態的傳遞就變的麻煩。\n現在你可以使用 \u0026lt;teleport\u0026gt; 將元件渲染到父元件以外的地方。\nTeleport 語法 \u0026lt;teleport\u0026gt; 有兩個 prop：\n to（字串） disabled（布林值，可選）  1. to to 可以指定將在其中移動 \u0026lt;teleport\u0026gt; 內容的目標元素。\n值必須是 有效的查詢選擇器 或 HTML 元素：\n1 2 3 4 5 6 7 8  \u0026lt;!-- 正確 --\u0026gt;\r\u0026lt;teleport to=\u0026#34;#some-id\u0026#34; /\u0026gt;\r\u0026lt;teleport to=\u0026#34;.some-class\u0026#34; /\u0026gt;\r\u0026lt;teleport to=\u0026#34;[data-teleport]\u0026#34; /\u0026gt;\r\u0026lt;!-- 錯誤 --\u0026gt;\r\u0026lt;teleport to=\u0026#34;h1\u0026#34; /\u0026gt;\r\u0026lt;teleport to=\u0026#34;some-string\u0026#34; /\u0026gt;\r  2. disabled disabled 預設值為 false，設為 true 可用於禁用 \u0026lt;teleport\u0026gt; 的功能。\n應用：\n1 2 3  \u0026lt;teleport to=\u0026#34;#popup\u0026#34; :disabled=\u0026#34;displayVideoInline\u0026#34;\u0026gt;\r\u0026lt;video src=\u0026#34;./my-movie.mp4\u0026#34;\u0026gt;\r\u0026lt;/teleport\u0026gt;\r  Modal 元件應用 使用 Teleport 將 .modal 渲染到 \u0026lt;body\u0026gt; 下，就不會受到上層元素的 CSS 影響。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const ModalButton = {\rprops: [\u0026#39;show\u0026#39;],\remits: [\u0026#39;update:show\u0026#39;],\rtemplate:`\r\u0026lt;button type=\u0026#34;button\u0026#34; @click=\u0026#34;$emit(\u0026#39;update:show\u0026#39;, true)\u0026#34;\u0026gt;show\u0026lt;/button\u0026gt;\r\u0026lt;teleport to=\u0026#34;body\u0026#34;\u0026gt;\r\u0026lt;div v-if=\u0026#34;show\u0026#34; class=\u0026#34;modal\u0026#34;\u0026gt;\r\u0026lt;div class=\u0026#34;modal-container\u0026#34;\u0026gt;\r\u0026lt;h2\u0026gt;Modal\u0026lt;/h2\u0026gt;\r\u0026lt;button @click=\u0026#34;$emit(\u0026#39;update:show\u0026#39;, false)\u0026#34;\u0026gt;close\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/teleport\u0026gt;\r`,\r};\r  CodePen Demo：Vue 3.x - Teleport modal\n","description":"Teleport 是 Vue 3 新增的功能，它是一個內建元件，可以讓我們將模板內的 DOM 渲染到指定位置。","id":2,"section":"posts","tags":["Vue3","Teleport","Vue 3 全新功能"],"title":"Vue 3 - Teleport","uri":"https://chupai.github.io/posts/2104/teleport/"},{"content":"\r前言 Composition API（組合式 API） 是 Vue 3 的最大特點，為 Vue 元件的另一種編寫方式。\n首先，來探討 Options API 遇到的問題。\nOptions API 結構：\n1 2 3 4 5 6 7 8 9  export default {\rprops: {},\rdata() {\rreturn {};\r},\rwatch: {},\rcomputed: {},\rmethods: {},\r};\r  隨著專案複雜度提高，程式碼會不斷膨脹，後續的維護成本會逐漸增加，因此我們會想要將功能切割，提升程式碼的複用性及維護性。但 Options API 形成了一種強制的約定，導致邏輯分散在各個選項中，造成程式碼難以閱讀理解及分割，雖然有 mixins，但大量使用時，容易出現命名衝突、來源不清晰等問題。\nComposition API 改善的問題：\n 程式能依功能分類使用，增加可讀性； 封裝功能，可跨元件使用，增加複用性； 提供更好的 TypeScript 支持。  入口函式 Setup 全新的 setup 選項為一個函式，它會在元件實體尚未被建立之前執行，是使用 Composition API 實際位置。\nsetup 函式可以回傳一個物件，物件中的內容都將暴露給元件的其餘部分（計算屬性、方法、生命週期鉤子等等）以及元件的模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;script\u0026gt;\rexport default {\rsetup() {\rconst msg = \u0026#39;hello!\u0026#39;;\rconst handler = () =\u0026gt; {\ralert(msg);\r};\rreturn { msg, handler };\r},\r};\r\u0026lt;/script\u0026gt;\r\u0026lt;template\u0026gt; \u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;{{ msg }}\u0026lt;/p\u0026gt;\r\u0026lt;button @click=\u0026#34;handler\u0026#34;\u0026gt;click\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r  CodePen Demo：Vue 3.0 - setup 選項\nComposition API 可以選擇想要暴露的 property，不同於 Options API 全部都暴露給實體。另外，還可以透過解構重新命名，避免命名衝突的發生。\n建立響應式資料 在 Vue 3 中，可以透過 reactive 方法建立響應式物件，或者透過 ref 方法建立響應式變數。\n1. Reactive reactive() 接受一個普通物件作為參數，回傳一個響應式的物件狀態。該響應式轉換是「深度轉換」，會影響巢狀物件傳遞的所有 property。\n Vue 3 的響應式的物件是基於 ES6 的 Proxy 實現。而 Vue 2 是透過 ES5 的 Object.defineProperty() 實現。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \u0026lt;script\u0026gt;\rimport { reactive } from \u0026#39;vue\u0026#39;;\rexport default {\rsetup() {\rconst data = reactive({\rmsg: \u0026#39;hello!\u0026#39;,\r});\rconst handler = () =\u0026gt; {\ralert(data.msg);\r};\rreturn { data, handler };\r},\r};\r\u0026lt;/script\u0026gt;\r\u0026lt;template\u0026gt; \u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;{{ msg }}\u0026lt;/p\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;msg\u0026#34;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;button @click=\u0026#34;handler\u0026#34;\u0026gt;click\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r  CodePen Demo：Vue 3.0 - reactive 響應式物件\n reactive() 相當於 Vue 2.6 新增的 Vue.observable() API，為避免與 RxJS 中的 observables 混淆因此對其重新命名。\n 另外，data 選項回傳一個物件時，在內部也是透過 reactive() 使其成為響應式物件的。\n2. Ref ref() 接受一個任何型別的參數，回傳一個響應式且可變的 Ref 物件。Ref 物件只包含一個名為 value 的屬性。\n 若傳入物件型別，內部會呼叫 reactive() 將其轉成響應式物件。\n 從 setup 回傳的 Ref 物件在模板中訪問時是被自動解開的，因此不需要在模板中使用 .value。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  \u0026lt;script\u0026gt;\rimport { ref } from \u0026#39;vue\u0026#39;;\rexport default {\rsetup() {\rconst msg = ref(\u0026#39;hello!\u0026#39;);\rconst handler = () =\u0026gt; {\ralert(msg.value); // 透過 .value 訪問值\r };\rreturn { msg, handler };\r},\r};\r\u0026lt;/script\u0026gt;\r\u0026lt;template\u0026gt; \u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;{{ msg }}\u0026lt;/p\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;msg\u0026#34;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;button @click=\u0026#34;handler\u0026#34;\u0026gt;click\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r  CodePen Demo：Vue 3.0 - 帶 ref 的響應式變數\n3. Ref 自動解構 如果將 Ref 物件分配給響應式物件 的 property 時，Ref 物件會自動解構。\n1 2 3 4 5 6 7 8 9 10 11  import { ref, reactive } from \u0026#39;vue\u0026#39;;\rconst count = ref(1);\rconst data = reactive({});\rdata.count = count;\rconsole.log(data.count); // 1\r\rconst obj = ref({});\robj.value.count = count;\rconsole.log(obj.value.count); // 1\r  但要注意，只有物件會解構 Ref 物件，陣列不會。陣列給值仍然需要加 .value。\n1 2 3 4 5 6 7 8  import { ref, reactive } from \u0026#39;vue\u0026#39;;\rconst arr = ref([]);\rarr.value[0] = count;\rconsole.log(arr.value[0]); // Ref{}\rconsole.log(arr.value[0].value); // 1\rarr.value[1] = count.value;\rconsole.log(arr.value[1]); // 1\r  CodePen Demo：Vue 3.0 - 自動解構\n4. Reactive vs Ref 基本型別，肯定只能使用 ref() 宣告，那麼複雜型別呢？究竟是要使用 ref() 還是 reactive()？\n有些人認為複雜型別就用 reactive() 就好了啊，少一層 .value 多方便。但當你遇到需要清空物件時，你無法直接指定空物件，這時你只能改用 ref() 宣告。\n 為了風格統一，我個人是建議全部使用 ref() 宣告響應式資料。不過如果你有其他看法，可以留言討論。\n setup 參數 執行 setup 函式時，元件實體尚未被建立，在 setup 函式內的 this 不是實體的引用，若要訪問 props、attrs、slots、emit 可以透過 setup 函式提供的兩個參數來訪問：\n props context  1. Props props 為響應式物件，可以用來在 setup 函式中取得父元件傳遞的 prop。\n1 2 3 4 5 6 7  export default {\rprops: [\u0026#39;msg\u0026#39;],\rsetup(props) {\rconsole.log(props.msg);\r},\r// ...\r};\r  響應式物件無法直接使用 ES6 的解構，會直接失去響應式特性。因此 Vue 3.x 提供了 toRefs 方法，它會將響應式物件轉成普通物件並將每個 property 轉成指向原始物件相應 property 的 Ref 物件。\n1 2 3 4 5 6 7 8 9 10  import { toRef } from \u0026#39;vue\u0026#39;;\rexport default {\rprops: [\u0026#39;msg\u0026#39;, \u0026#39;name\u0026#39;],\rsetup(props) {\rconst { name, msg } = toRefs(props);\rconsole.log(name.value, msg.value);\r},\r// ...\r};\r  CodePen Demo：Vue 3.x - toRefs\n如果 prop 是可選的，那麼傳入的 props 中可能會沒有該 prop，toRefs() 不會為不存在的 prop 建立一個 Ref 物件，這種情況下，可以改使用 toRef 方法處理。\ntoRef() 與 ref() 雖然都是用建立響應式資料，但 ref 會複製一份新的資料，而 toRef() 會保持對其源 property 的響應式連接。即使源 property 不存在，toRef() 也會回傳一個可用的 Ref 物件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import { toRef } from \u0026#39;vue\u0026#39;;\rexport default {\rprops: {\rmsg: {\rtype: String,\rdefault: \u0026#39;Hi!\u0026#39;,\r},\r},\rsetup(props) {\rconst msg = toRef(props, \u0026#39;msg\u0026#39;);\rconsole.log(msg.value);\r},\r// ...\r};\r  CodePen Demo：Vue 3.x - toRef\n2. Context context 是一個普通的物件，它暴露三個元件的 property：\n attrs Attribute slots 插槽 emit 觸發事件  context 不是響應式物件，可以安全地使用 ES6 解構：\n1 2 3 4 5  export default {\rsetup(props, { attrs, slots, emit }) {\r// ...\r },\r};\r  注意，attrs 和 slots 是有狀態的物件，會隨元件本身的更新而更新，要避免對它們進行解構。\n計算 \u0026amp; 監聽 1. computed 基本用法 computed 方法接受一個 getter 函式，會回傳一個唯讀的響應式 Ref 物件。\n1 2 3 4 5 6 7 8  import { ref, computed } from \u0026#39;vue\u0026#39;;\rconst count = ref(1);\rconst plusOne = computed(() =\u0026gt; count.value + 1);\rconsole.log(plusOne.value); // 2\r\rplusOne.value++; // 錯誤\r  CodePen Demo：Vue 3.0 - computed\nsetter 或者，使用具有 get 和 set 函式的物件，並回傳一個可寫的響應式 Ref 物件。\n1 2 3 4 5 6 7 8 9 10 11 12  import { computed } from \u0026#39;vue\u0026#39;;\rconst count = ref(1);\rconst plusOne = computed({\rget: () =\u0026gt; count.value + 1,\rset: (newVal) =\u0026gt; {\rcount.value = newVal - 1;\r},\r});\rplusOne.value = 1;\rconsole.log(count.value); // 0\r  CodePen Demo：Vue 3.0 - computed - setter 應用\n2. watch watch API 與實體方法 $watch 完全等效。\n1  watch(source, callback, [options])\r  基本用法 資料源可以是一個 getter 函式或 Ref 物件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import { watch } form \u0026#39;vue\u0026#39;;\r// 監聽一個 getter 函式\rconst state = reactive({ count: 0 });\rwatch(\r() =\u0026gt; state.count,\r(newVal, oldVal) =\u0026gt; {\r// ...\r },\r);\r// 監聽一個 ref\rconst count = ref(0);\rwatch(count, (newVal, oldVal) =\u0026gt; {\r// ...\r});\r  第一種用法可以監聽響應式物件的 property，不需要監聽整個物件。\nCodePen Demo：Vue 3.0 - watch\n監聽多個資料源 還可以使用陣列同時監聽多個資料源：\n1 2 3 4 5 6 7 8  import { watch } form \u0026#39;vue\u0026#39;;\rconst foo = ref(\u0026#39;\u0026#39;);\rconst bar = ref(\u0026#39;\u0026#39;);\rwatch([foo, bar], ([newFoo, newBar], [oldFoo, oldBar]) =\u0026gt; {\r// ...\r});\r  選項  deep：深度監聽物件或陣列。 immediate：立即觸發 callback。 flush：控制 callback 的時間。  'pre'：預設值，渲染被呼叫 'post'：渲染後呼叫 'sync'：一旦值發生改變，callback 將同步呼叫。    3. watchEffect watchEffect 是 Vue 3.x 新增的，比起 watch 它不需要指定監聽資料源，會自動收集依賴。watchEffect 初始化會執行一次用以收集依賴。\n1 2 3 4 5  const count = ref(0);\rwatchEffect(() =\u0026gt; {\rconsole.log(count.value);\r});\r  watchEffect 會回傳一個 WachStopHandle 函式，用來停止 watchEffect。\n1 2 3 4 5  const stop = watchEffect(() =\u0026gt; {\r// ...\r});\rstop();\r  生命週期鉤子 在 setup 函式中執行的程式，等同在 beforeCreate 和 created 階段執行，直接寫在 setup 函式內即可，其它生命週期鉤子需要透過 on 前綴的方法訪問。\n   Options API Hook inside setup     beforeCreate - - -   created - - -   beforeMount onBeforeMount   mounted onMounted   beforeUpdate onBeforeUpdate   updated onUpdated   beforeUnmount onBeforeUnmount   unmounted onUnmounted   errorCaptured onErrorCaptured   renderTracked onRenderTracked   renderTriggered onRenderTriggered    生命週期函式接收一個 callback 作為參數，當鉤子被元件呼叫時，callback 就會被執行。\n1 2 3 4 5 6 7 8 9 10  import { onMounted } from \u0026#39;vue\u0026#39;;\rexport default {\rsetup() {\r// mounted\r onMounted(() =\u0026gt; {\r// ...\r });\r},\r};\r  Provide / Inject 在 Composition API 中使用 provide/inject。\n1. Provide 在 setup() 中使用 provide 時，需要使用到 provide 方法。\nprovide() 接受兩個參數，用來定義要傳遞的資料：\n name 定義名稱（字串） value 定義值  1 2 3 4 5 6 7  import { provide } from \u0026#39;vue\u0026#39;;\rexport default {\rsetup() {\rprovide(\u0026#39;count\u0026#39;, 1);\r},\r};\r  2. Inject 在 setup() 中使用 inject 時，需要使用到 inject 方法。\nprovide() 接受兩個參數，回傳注入的資料：\n name 資料名稱（字串） value 預設值（可選）  1 2 3 4 5 6 7 8  import { inject } from \u0026#39;vue\u0026#39;;\rexport default {\rsetup() {\rconst count = inject(\u0026#39;count\u0026#39;, 0);\rreturn { count };\r},\r};\r  3. 響應性 provide/inject 綁定的值預設並不是響應式的。我們可以通過傳遞響應式資料來處理 provide/inject 之間的響應性。\n可以使用 reactive 傳遞響應式物件，或者使用 ref 傳遞 Ref 物件。\n1 2 3 4 5 6 7 8  import { ref, provide } from \u0026#39;vue\u0026#39;;\rexport default {\rsetup() {\rconst count = ref(1);\rprovide(\u0026#39;count\u0026#39;, count);\r},\r};\r  4. 操作響應式 provide/inject 不像 Vuex 一樣可以追蹤狀態改變，如果資料狀態操作分散在多個後代元件中，會很難維護。\n 因此，建議盡可能在定義 provide 的元件上操作 響應式的 provide/inject 資料。\n 若一定要在注入資料的元件內操作。這種情況下，建議多定義一個負責操作的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13  import { ref, provide } from \u0026#39;vue\u0026#39;;\rexport default {\rsetup() {\rconst count = ref(1);\rconst addCount = ()=\u0026gt; {\rcount.value += 1;\r};\rprovide(\u0026#39;count\u0026#39;, count);\rprovide(\u0026#39;addCount\u0026#39;, addCount);\r},\r};\r  1 2 3 4 5 6 7 8 9  import { inject } from \u0026#39;vue\u0026#39;;\rexport default {\rsetup() {\rconst count = inject(\u0026#39;count\u0026#39;, 0);\rconst addCount = inject(\u0026#39;addCount\u0026#39;);\rreturn { count, addCount };\r},\r};\r  如果要確保 provide 傳遞的資料不被後代元件更改，可以使用 readonly 或者 computed 方法建立唯讀資料。\n模板引用 1. Composition API 在 Composition API 中，只需要使用 ref() 宣告一個與 ref attribute 相同名稱的變數、內容值為 null，並將它回傳，即可獲取 DOM。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  import { ref, onMounted } from \u0026#39;vue\u0026#39;; export default {\rsetup() {\rconst input = ref(null);\ronMounted(()=\u0026gt;{\rconst dom = input.value;\rdom.focus();\r});\rreturn { input };\r},\r};\r  CodePen Demo：Vue 3.x - Composition API 模板引用\n2. v-for 的處理  v-for 模板引用 Vue 2.x 與 Vue 3.x 的差異可以參考 模板指令：v-for 中的 Ref 陣列。\n Composition API：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  \u0026lt;template\u0026gt; \u0026lt;div v-for=\u0026#34;n of nums\u0026#34; :ref=\u0026#34;setDoms\u0026#34;\u0026gt;{{ n }}\u0026lt;/div\u0026gt;\r\u0026lt;button type=\u0026#34;button\u0026#34; @click=\u0026#34;nums.push(nums.length + 1)\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rconsole.clear();\rimport { ref, onMounted, onBeforeUpdate, onUpdated } from \u0026#39;vue\u0026#39;\rexport default {\rsetup() {\rconst nums = ref([1, 2, 3]);\rconst doms = ref([]);\rconst setDoms = (el) =\u0026gt; {\rif (el) {\rdoms.value.push(el);\r}\r};\ronMounted(() =\u0026gt; {\rconsole.log(doms.value);\r});\ronBeforeUpdate(() =\u0026gt; {\rdoms.value = [];\r});\ronUpdated(() =\u0026gt; {\rconsole.log(doms.value);\r});\rreturn { nums, setDoms };\r},\r};\r\u0026lt;/script\u0026gt;\r  CodePen Demo：Vue 3.0 - 模板引用 v-for 的處理\n邏輯拆分 Composition API 最主要的目的就是將邏輯功能拆分出來，並在入口函式 setup 中組合使用。\n舉個例子，下面為一個簡單的 TodoAdd 元件，用來新增 TodoList 資料狀態。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // TodoAdd.vue\rimport { ref } from \u0026#39;vue\u0026#39;;\rexport default {\remits: [\u0026#39;addTodo\u0026#39;],\rsetup(props, { emit }) {\rconst content = ref(\u0026#39;\u0026#39;);\rfunction emitAddTodo() {\rconst todo = {\rid: new Date().getTime(),\rcontent: content.value,\risCompleted: false,\r};\rif (content.value) {\remit(\u0026#39;addTodo\u0026#39;, todo);\r}\rcontent.value = \u0026#39;\u0026#39;;\r}\rreturn { content, emitAddTodo };\r},\r};\r  1. 簡易拆分 將程式碼根據邏輯功能抽離成函式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // TodoAdd.vue\rimport { ref } from \u0026#39;vue\u0026#39;;\rexport default {\remits: [\u0026#39;addTodo\u0026#39;],\rsetup(props, { emit }) {\rconst { content, emitAddTodo } = useEmitAddTodo(emit);\rreturn { content, emitAddTodo };\r},\r};\rfunction useEmitAddTodo(emit) {\rconst content = ref(\u0026#39;\u0026#39;);\rfunction emitAddTodo() {\rconst todo = {\rid: new Date().getTime(),\rcontent: content.value,\risCompleted: false,\r};\rif (content.value) {\remit(\u0026#39;addTodo\u0026#39;, todo);\r}\rcontent.value = \u0026#39;\u0026#39;;\r}\rreturn { content,emitAddTodo };\r}\r  2. 抽離成模組 也可將程式碼抽離成模組，讓其他元件使用。\n建立一個 composables 資料夾，用來放置功能程式碼。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // addTodo.js\r\rimport { ref } from \u0026#39;vue\u0026#39;;\rconst addTodo = function(emit) {\rconst content = ref(\u0026#39;\u0026#39;);\rfunction emitAddTodo() {\rconst todo = {\rid: new Date().getTime(),\rcontent: content.value,\risCompleted: false,\r};\rif (content.value) {\remit(\u0026#39;addTodo\u0026#39;, todo);\r}\rcontent.value = \u0026#39;\u0026#39;;\r}\rreturn { content, emitAddTodo };\r};\rexport default addTodo;\r  在元件中引用：\n1 2 3 4 5 6 7 8 9 10  // TodoAdd.vue\rimport addTodo from \u0026#39;@/composables/useTodo.js\u0026#39;;\rexport default {\remits: [\u0026#39;addTodo\u0026#39;],\rsetup(props, { emit }) {\rconst { content, emitAddTodo } = addTodo(emit);\rreturn { content, emitAddTodo };\r},\r};\r  VueUse：Vue Composition API 的實用工具集合 1. 簡介  VueUse\nVueUse 是一個 Vue Composition API 的實用工具集合。\n 本文撰寫時，github 上已擁有 3.7k 以上的 star。\n特點：\n 互動式的 Docs 和 Demos。 Vue 2 和 Vue 3 都支持。 tree shaking 結構，只會打包引入的程式碼。 使用 TypeScript 編寫，帶有 TS 檔案。 可通過 CDN 使用。 可配置事件過濾器和目標。 支持各種套件，例如 Router、Firebase、RxJS 等。  2. 安裝 CDN：\n1 2 3  \u0026lt;!-- shared 一定要在前--\u0026gt;\r\u0026lt;script src=\u0026#34;https://unpkg.com/@vueuse/shared\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script src=\u0026#34;https://unpkg.com/@vueuse/core\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r  使用 window.VueUse：\n1 2 3 4 5 6 7 8 9 10  const { useMouse } = VueUse;\rconst app = Vue.createApp({\rsetup() {\r// tracks mouse position\r const { x, y } = useMouse();\rreturn { x, y };\r},\r});\rapp.mount(\u0026#39;#app\u0026#39;);\r  CodePen Demo：VueUse Demo - Vue3\n安裝：\n# npm\rnpm i @vueuse/core\r# yarn\ryarn add @vueuse/core\r從 @vueuse/core 引入：\n1 2 3 4 5 6 7 8 9 10  import { useMouse } from \u0026#39;@vueuse/core\u0026#39;;\rexport default {\rname: \u0026#39;App\u0026#39;,\rsetup() {\r// tracks mouse position\r const { x, y } = useMouse();\rreturn { x, y };\r},\r};\r  3. 核心功能  VueUse - Core Functions\n官方文件有完整說明與範例。\n  Animation 動畫 Browser 瀏覽器 Component 元件 Formatters 格式化 Misc 其他 Sensors 感測器 State 狀態 Utilities 實用工具 Watch 監聽 ","description":"Composition API 是 Vue 3 的最大特點，為 Vue 元件的另一種編寫方式。","id":3,"section":"posts","tags":["Vue3","Composition API","Vue 3 全新功能"],"title":"Vue 3 - Composition API","uri":"https://chupai.github.io/posts/2104/compositionapi/"},{"content":" JavaScript筆記 目錄\n \r2021.03.31 更新\r Date 物件 JavaScript 沒有日期資料型別，但它有內建物件 Date 物件，可以用來處理日期與時間。Date 物件是以世界標準時間（UTC） 1970 年 1 月 1 日為零點，範圍為前後各 1 億天（+-100,000,000），單位為毫秒（ms）。\nDate 物件只能由 new Date() 作為建構器來產生，不帶參數使用將會建立當前時間的 Date 物件：\n1  const date = new Date();   Date 實體求值時，與其他物件預設呼叫 valueOf 方法不同，它預設會呼叫 toString 方法，因此求值時會回傳完整日期時間格式的字串：\n1 2 3 4 5 6 7  // 承接上段程式碼  console.log(date); // 等同於 console.log(date.toString()); // \u0026#34;Sun Mar 28 2021 14:12:01 GMT+0800 (台北標準時間)\u0026#34;   若是作為普通函式直接呼叫 Date，會回傳完整日期時間格式的字串，而非 Date 物件，無法使用 Date 物件方法：\n1 2  console.log(Date()); // \u0026#34;Sun Mar 28 2021 14:12:01 GMT+0800 (台北標準時間)\u0026#34;   CodePen Demo：JavaScript 日期時間 - Date 物件\n基礎概念 1. 時間標準  GTM（Greenwich Mean Time）格林威治標準時間，已經被原子鐘報時的世界協調時間（UTC）所取代。 UTC（Coordinated Universal Time）世界協調時間，是最主要的世界時間標準。 TAI（International Atomic Time）國際原子時，是根據以下秒的定義的一種國際參照時標。  由於地球自轉是稍微不規則的（緩慢減速），因此格林威治標準時間已經被原子鐘報時的世界協調時間所取代。但 GMT 和 UTC 在一般使用的情況下（不需要非常精確的情況）並沒有差異，所以通常將 GMT 和 UTC 視為等同，舉例來說：台灣時區可以標示為 GMT+8 或 UTC+8 。\n2. 時區 時區 是地球上的區域使用同一個時間定義。\n 時差，世界各國位於地球不同位置上，因此不同國家，特別是東西跨度大的國家日出、日落時間必定有所偏差。這些偏差就是所謂的時差。 偏移（offset），指的是某地區與 GTM/UTC 偏移的時間，例如 +08:00 表示該地區的時間比 GTM/UTC 快了 8 小時。 理論時區，指的是以被 15 整除的經線為中心，向東西兩側延伸 7.5°，即每 15° 劃分一個時區。 法定時區，指的是為了避開國界線，有的時區的形狀並不規則，而且比較大的國家以國家內部行政分界線為時區界線，這是實際時區。 夏令時間（Daylight Saving Time, DST），指的是一種在夏季將時間調快一小時的做法。  建立 Date 物件 new Date() 語法基本為四種形式的參數：\n 空值（不帶參數） 毫秒 日期時間字串 時間單位  1 2 3 4  new Date(); new Date(milliseconds); new Date(dateString); new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);   1. 不帶參數 new Date() 不帶參數，表示當前日期時間的 Date 物件。\n1 2 3  const now = new Date(); console.log(now); // \u0026#34;Sun Mar 28 2021 17:50:30 GMT+0800 (台北標準時間)\u0026#34;   2. 毫秒 new Date(milliseconds)，milliseconds 表示從 1970-01-01 00:00:00 UTC+0 開始所經過的毫秒數。\n1 2 3  const date = new Date(0); console.log(date); // \u0026#34;Thu Jan 01 1970 08:00:00 GMT+0800 (台北標準時間)\u0026#34;   經過一百天：\n1 2 3 4 5  const dayms = 24 * 60 * 60 * 1000; const d100 = new Date(dayms * 100); console.log(d100); // \u0026#34;Sat Apr 11 1970 08:00:00 GMT+0800 (台北標準時間)\u0026#34;   3. 日期時間字串 new Date(datestring)，datestring 表示一個日期或時間格式的字串，該參數會通過 Date.parse 算法解析字串。\n日期時間格式字串定義（ISO8601）：\nYYYY-MM-DDTHH:mm:ss.sssZ  日期 YYYY-MM-DD：年-月-日 字串 T：是一個分隔符號 時間 HH:mm:ss.sss：小時:分鐘:秒.毫秒 時區：UTC+8 使用 +08:00 表示，若時區為 UTC+0 可使用 Z 表示。  1 2 3 4 5 6 7  const d1 = new Date(\u0026#39;2021-03-28T10:30:55.000Z\u0026#39;); console.log(d1); // \u0026#34;Sun Mar 28 2021 18:30:55 GMT+0800 (台北標準時間)\u0026#34;  const d2 = new Date(\u0026#39;2021-03-28T10:30:55.000+08:00\u0026#39;); console.log(d2); // \u0026#34;Sun Mar 28 2021 10:30:55 GMT+0800 (台北標準時間)\u0026#34;   :::warning\n若輸入非標準日期字串，會根據各家瀏覽器的實現方式，而有不同的結果。詳細可以參考 MDN 說明。\n:::\n:::warning\n另外要注意，Date 物件在建立時，會將日期時間轉成本地時區（作業系統設定的時區）輸出，並不支持指定時區輸出。\n:::\n4. 時間單位 new Date(year, month, [date, hours, minutes, seconds, ms])\n 必要參數：年、月  年（必須是四位數） 月 （0 ~ 11）   選擇性的參數：日、時、分、秒、毫秒  日（預設為 1） 時、分、秒、毫秒（預設為 0）    預設的時區為本地時區（作業系統設定的時區）：\n1 2 3  const d2021 = new Date(2021, 0); console.log(d2021); // \u0026#34;Fri Jan 01 2021 00:00:00 GMT+0800 (台北標準時間)\u0026#34;   如果超出正確範圍內的數字會自動轉換成對應時間：\n1 2 3  const date = new Date(2021, 12); console.log(date); // \u0026#34;Sat Jan 01 2022 00:00:00 GMT+0800 (台北標準時間)\u0026#34;   獲取 \u0026amp; 設定 1. 獲取 從 Date 物件取的相對應的時間數值（number），可以使用 Date 提供的方法：\n getFullYear()：年份（四位數） getMonth()：月份從 0 到 11 getDate()：當月的日期，從 1 到 31 getHours()：時 getMinutes()：分 getSeconds()：秒 getMilliseconds()：毫秒 getDay()：獲取一週中的第幾天，0 到 6（起始為星期日）  以上所有的方法回傳的訊息都是基於當地時區的。\n1 2 3 4 5 6 7 8 9 10 11 12  function getDate(date) { return { year: date.getFullYear(), month: date.getMonth(), date: date.getDate(), hour: date.getHours(), min: date.getMinutes(), sec: date.getSeconds(), msec: date.getMilliseconds(), day: date.getDay(), }; }   如果要獲取標準時間，則可以使用對應的 UTC 版本，例如 getUTCFullYear()、getUTCMonth() 等等。\n2. 設定 以下方法可以設置時間訊息：\n setFullYear(year [, month, date]) setMonth(month [, date]) setDate(date) setHours(hour [, min, sec, ms]) setMinutes(min [, sec, ms]) setSeconds(sec [, ms]) setMilliseconds(ms)  以上方法會回傳改變後的時間戳，另外，也都有對應的 UTC 版本，例如 setUTCHours()。\n3. 結合使用 兩者方法結合使用，可以得到相對時間：\n1 2 3 4 5 6 7 8 9 10  const date = new Date(); // 將日期向後推1000天 date.setDate(date.getDate() + 1000); // 將時間設為6小時後 date.setHours(date.getHours() + 6); // 將年份設為去年 date.setFullYear(date.getFullYear() - 1);   時間戳（Timestamp） 時間戳（Timestamp）指的是從 1970-1-1 00:00:00 UTC+0 開始的毫秒數。\n1. 靜態方法 Date 的靜態方法：\n Date.now()：回傳當前時間的數值時間戳。 Date.parse()：解析日期或時間格式的字串，回傳該時間的數值時間戳（由於瀏覽器之間的不同與差異，不建議使用）。 Date.UTC()：需要傳入與建構器相同的參數（即年月日等等參數），回傳該時間的數值時間戳。  1 2 3 4 5 6 7  const ms = Date.now(); console.log(ms); // 1616939369617  const date = new Date(ms); console.log(date); // \u0026#34;Sun Mar 28 2021 21:49:29 GMT+0800 (台北標準時間)\u0026#34;   1 2 3 4 5 6 7 8 9 10  const ms = Date.UTC(2021, 0); console.log(ms); // 1609459200000  const date = new Date(ms); console.log(date); // \u0026#34;Fri Jan 01 2021 08:00:00 GMT+0800 (台北標準時間)\u0026#34;  console.log(new Date(2021, 0)); // \u0026#34;Fri Jan 01 2021 00:00:00 GMT+0800 (台北標準時間)\u0026#34;   :::warning\n輸入的參數會視為世界標準時間，而非本地時間，與建構器不同。\n:::\n2. 時間戳轉換 Date 物件轉時間戳的方法：\n getTime()：回傳日期的時間戳。  1 2 3 4 5 6 7 8 9  const time = new Date(2021, 0); console.log(time.getTime()); // 1609430400000  // 等同 console.log(time.valueOf()); // 1609430400000 console.log(Number(time)); // 1609430400000   如果將 Date 物件轉成數值（呼叫 valueOf()），相當於 getTime() 方法。\n1. Unix 時間戳 一般來說，後端給的時間會是以秒為單位的 Unix 時間戳，但 JavaScript 的時間戳單位為毫秒。\n如果我們有一個 Unix 時間戳，可以透過乘 1000 取得 Date 物件：\n1 2 3 4  const unixtimestamp = 1609430400; const date = new Date(unixtimestamp * 1000); console.log(date); // \u0026#34;Fri Jan 01 2021 00:00:00 GMT+0800 (台北標準時間)\u0026#34;   反之，如果要將時間戳轉 Unix 時間戳 就是除 1000：\n1 2 3 4  const timestamp = Date.now(); const unixtimestamp = Math.floor(timestamp / 1000); console.log(unixtimestamp); // 1616940562   運算 如果對 Date 物件進行減法運算，會自動轉換成對應的毫秒數：\n1 2 3 4  const d1 = new Date(2021, 2, 1); const d2 = new Date(2021, 3, 1); console.log(d2 - d1); // 2678400000   若是加法運算則是字串連接：\n1 2 3 4  // 承接上段程式碼  console.log(d2 + d1); // \u0026#34;Thu Apr 01 2021 00:00:00 GMT+0800 (台北標準時間)Mon Mar 01 2021 00:00:00 GMT+0800 (台北標準時間)\u0026#34;   因此我們可以先將時間轉換成成毫秒，再進行運算：\n1 2 3 4 5 6 7 8 9 10 11  const sec = 1000; const min = sec * 60; const hour = min * 60; let date = new Date(2021, 0, 2); console.log(date); // \u0026#34;Sat Jan 02 2021 00:00:00 GMT+0800 (台北標準時間)\u0026#34;  date = new Date(date - hour * 10); console.log(date); // \u0026#34;Fri Jan 01 2021 14:00:00 GMT+0800 (台北標準時間)\u0026#34;   減法運算可以直接相減，但加法運算必須使用 getTime() 轉毫秒再運算：\n1 2 3 4 5  // 承接上段程式碼  date = new Date(date.getTime() + hour * 10); console.log(date); // \u0026#34;Sat Jan 02 2021 00:00:00 GMT+0800 (台北標準時間)\u0026#34;   轉換格式 1. 基本格式字串  toString()：回傳完整的日期時間字串。 toUTCString()：回傳 UTC 格式字串。 toISOString()：回傳 ISO8601 格式字串。 toJSON()：與 toISOString() 回傳結果相同。 toDateString()：回傳日期字串，不含小時、分和秒。 toTimeString()：回傳時間字串，不含年月日。  1 2 3 4 5 6 7 8 9 10 11 12 13 14  const date = new Date(2021, 0, 1); console.log(date.toString()); // \u0026#34;Fri Jan 01 2021 00:00:00 GMT+0800 (台北標準時間)\u0026#34; console.log(date.toUTCString()); // \u0026#34;Thu, 31 Dec 2020 16:00:00 GMT\u0026#34; console.log(date.toISOString()); // \u0026#34;2020-12-31T16:00:00.000Z\u0026#34; console.log(date.toJSON()); // \u0026#34;2020-12-31T16:00:00.000Z console.log(date.toDateString()); // \u0026#34;Fri Jan 01 2021\u0026#34; console.log(date.toTimeString()); // \u0026#34;00:00:00 GMT+0800 (台北標準時間)\u0026#34;   2. 本地格式字串 本地格式字串，會因不同語言而有不同的輸出格式：\n toLocaleString()：完整的日期時間字串。 toLocaleDateString()：日期，不含小時、分和秒。 toLocaleTimeString()：時間，不含年月日。  1 2 3 4 5 6 7 8  const date = new Date(2021, 0, 1); console.log(date.toLocaleString()); // \u0026#34;2021/1/1 上午12:00:00\u0026#34; console.log(date.toLocaleDateString()); // \u0026#34;2021/1/1\u0026#34; console.log(date.toLocaleTimeString()); // \u0026#34;上午12:00:00\u0026#34;   3. 本地格式參數 上述三個本地格式字串方法都有兩個可選的參數：\n1 2 3  date.toLocaleString([locales[, options]]); date.toLocaleDateString([locales[, options]]); date.toLocaleTimeString([locales[, options]]);    locales：字串，指定所用語言。值可參考 地區設定 - 列表，中文為 \u0026quot;zh\u0026quot;、台灣為 \u0026quot;zh-TW\u0026quot;。 options：選項物件，設定格式化規則。   詳細用法可以參考 Natively Format JavaScript Dates and Times 文章。\n 第三方函式庫 1. Moment.js Moment.js 是處理 JavaScript 日期時間熱門函式庫。\n不過，官方已宣佈停止開發，進入維護狀態，官方公告。\n官方總結了兩大問題：\n Moment 物件是可變物件； 體積過大。  替代方案：\n 使用 Date 物件 + Intl API 即可。 改用 Day.js 函式庫，體積小、API 設計與 Moment.js 相同。  2. Day.js Day.js 函式庫是 Moment.js 輕量化替代方案，API 設計與 Moment.js 相同。\nDay.js 沒有對 Date.prototype 做任何修改，而是對 Date 物件做了一層封裝。Day.js 物件是不可變的，所有的 API 操作都將回傳一個全新的實體，避免修改到原始資料。\nDay.js 1. 解析 呼叫 dayjs()，建立 Day.js 物件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 當前時間 dayjs(); // 等同 dayjs(new Date()), dayjs(undefined)  // ISO 8601 格式字串 dayjs(\u0026#39;2018-04-04T16:00:00.000Z\u0026#39;); // 時間戳 dayjs(1318781876406); // Unix 時間戳 dayjs.unix(1318781876); // Date 物件 dayjs(new Date(2018, 8, 18)); // 複製 使用 clone()，或傳入 Day.js 物件 const d1 = dayjs(); const d2 = d1.clone(); const d3 = dayjs(d1); // 驗證是否為有校時間，回傳 boolean dayjs().isValid();   2. 獲取 \u0026amp; 設置 不傳參數為 getter、傳參數為 setter，取得的值為本地時間：\n1 2  const date = dayjs(0).hour(12); console.log(date.hour()); // 12    millisecond() 毫秒 second() 秒 minute() 分鐘 hour() 小時（0 ~ 23 超過會進位到天數） date() 日期（1 ~ 31 超過會進位到月份） day() 星期（0 ~ 6 超過會進位到下週） month() 月份（0 ~ 11 超過會進位到年份） year() 年份  另外，還有 get 和 set 方法，可傳入單位字串：\n   單位字串 縮寫 說明     date D 月份裡的日期   day d 星期幾（0 ~ 6）   month M 月份（0 ~ 11）   year y 年份   hour h 小時   minute m 分鐘   second s 秒    millisecond ms 毫秒    1 2  const date = dayjs(0).set(\u0026#39;year\u0026#39;, 2021); console.log(date.get(\u0026#39;year\u0026#39;)); // 2021   3. 操作 Day.js 支持像這樣的鏈式呼叫一些方法來操作 Day.js 物件。\n加減操作：\n add() subtract()     單位字串 縮寫 說明     day d 星期幾（0 ~ 6）   week w 周   month M 月份（0 ~ 11）   year y 年份   hour h 小時   minute m 分鐘   second s 秒    millisecond ms 毫秒    1 2 3  const date = dayjs(0).add(1, \u0026#39;day\u0026#39;); console.log(date.$d); // \u0026#34;Fri Jan 02 1970 08:00:00 GMT+0800 (台北標準時間)\u0026#34;   時間開頭、末尾操作：\n startOf() endOf()     單位字串 縮寫 說明     year y 今年一月一日零時   month M 本月一日零時   week w 當周第一日零時   day d 當日零時   date d 當日零時   hour h 當前時間零分零秒零毫秒   minute m 當前時間零秒零毫秒   second s 當前時間零毫秒    末尾則相反。\n1 2 3 4 5 6 7 8  const date = dayjs(); console.log(date.$d); // \u0026#34;Mon Mar 29 2021 23:49:30 GMT+0800 (台北標準時間)\u0026#34;  console.log(date.startOf(\u0026#39;month\u0026#39;).$d); // \u0026#34;Mon Mar 01 2021 00:00:00 GMT+0800 (台北標準時間)\u0026#34; console.log(date.endOf(\u0026#39;month\u0026#39;).$d); // \u0026#34;Wed Mar 31 2021 23:59:59 GMT+0800 (台北標準時間)\u0026#34;   4. 顯示 呈現 Day.js 物件的方法。\n格式化 format()：\n   佔位符號 輸出 說明     YY 18 兩位數的年份   YYYY 2018 四位數的年份   M 1-12 月份，從 1 開始   MM 01-12 月份，兩位數   MMM Jan-Dec 縮寫的月份名稱   MMMM January-December 完整的月份名稱   D 1-31 月份裡的一天   DD 01-31 月份裡的一天，兩位數   d 0-6 一週中的一天，星期天是 0   dd Su-Sa 最簡寫的星期幾   ddd Sun-Sat 簡寫的星期幾   dddd Sunday-Saturday 星期幾   H 0-23 小時   HH 00-23 小時，兩位數   h 1-12 小時, 12 小時制   hh 01-12 小時, 12 小時制，兩位數   m 0-59 分鐘   mm 00-59 分鐘，兩位數   s 0-59 秒   ss 00-59 秒 兩位數   SSS 000-999 毫秒 三位數   Z +05:00 UTC 的偏移量，±HH:mm   ZZ +0500 UTC 的偏移量，±HHmm   A AM PM    a am pm     1 2 3 4 5 6 7 8  const date = dayjs(); console.log(date.$d); // \u0026#34;Tue Mar 30 2021 00:14:21 GMT+0800 (台北標準時間)\u0026#34;  console.log(date.format(\u0026#39;YYYY/MM/DD HH:mm\u0026#39;)); // \u0026#34;2021/03/30 00:14\u0026#34; console.log(date.format(\u0026#39;YY-M-D dddd\u0026#39;)); // \u0026#34;21-3-30 Tuesday\u0026#34;   時間差 diff()：\n1 2 3  const date1 = dayjs(\u0026#39;2019-01-25\u0026#39;); const date2 = dayjs(\u0026#39;2018-06-05\u0026#39;); console.log(date1.diff(date2)); // 20217600000   預設單位是毫秒，第二個參數可更改單位（預設取整數），第三參數可以取得浮點數：\n1 2 3 4  // 承接上段程式碼  console.log(date1.diff(date2, \u0026#39;month\u0026#39;)); // 7 console.log(date1.diff(date2, \u0026#39;month\u0026#39;, true)); // 7.645161290322581   取得實體時間戳：\n1 2 3 4 5  const t1 = dayjs(\u0026#39;2019-01-25\u0026#39;).valueOf(); const t2 = +dayjs(\u0026#39;2019-01-25\u0026#39;); console.log(t1); // 1548345600000 console.log(t2); // 1548345600000   取得實體 Unix 時間戳：\n1 2  const t = dayjs(\u0026#39;2019-01-25\u0026#39;).unix(); console.log(t); // 1548345600   取得當月份天數：\n1  dayjs().daysInMonth();   取得原生 Date 物件：\n1  dayjs().toDate();   取得日期時間字串：\n1 2 3 4 5 6  // 完整格式 dayjs().toString(); // ISO 8601 格式 dayjs().toJSON(); dayjs().toISOString();   5. 查詢 Day.js 物件的查詢方法。\n比較：\n 是否在之前 isBefore() 是否在之後 isAfter() 使否相同 isSame()  回傳 Boolean，第二參數可選，指定比較單位。\n1 2 3 4 5 6 7 8 9 10  const date1 = dayjs(\u0026#39;2021-01-01\u0026#39;); const date2 = dayjs(\u0026#39;2021-08-01\u0026#39;); console.log(date1.isBefore(date2)); // true console.log(date1.isAfter(date2)); // false console.log(date1.isSame(date2)); // false  console.log(date1.isBefore(date2, \u0026#39;year\u0026#39;)); // false console.log(date1.isAfter(date2, \u0026#39;year\u0026#39;)); // false console.log(date1.isSame(date2, \u0026#39;year\u0026#39;)); // true   dayjs.isDayjs() 可以判斷是否為 Day.js 物件：\n1 2 3 4  dayjs.isDayjs(dayjs()); // 等同使用 instanceof dayjs() instanceof dayjs;   6. 國際化 i18n Day.js 完美支持國際化，但需要加載，支持語言列表可以參考 locale 資料夾。\n 詳細可以參考 官方文件 說明。\n","description":"JavaScript 沒有日期資料型態，但是它有提供 Date 物件。","id":4,"section":"posts","tags":["JavaScript","日期時間","Date 物件","Day.js"],"title":"日期時間","uri":"https://chupai.github.io/posts/200516_js_date/"},{"content":"\r 本篇為官方文件 Migration from Vue 2 筆記。\n  全域 API 模板指令 元件 \u0026amp; 渲染函數 自定義元素 其他小改變 移除 API  按鍵修飾符號  不再支持使用數字（keyCode）作為 v-on 修飾符號 不再支持 config.keyCodes  1. 2.x 語法 在 Vue 2.x 可以使用鍵盤事件的 keyCode 作為修飾符號：\n1 2  \u0026lt;!-- Vue 2.x --\u0026gt;\r\u0026lt;input v-on:keyup.13=\u0026#34;submit\u0026#34;\u0026gt;\r  另外可透過全域 config.keyCodes 物件，自定義按鍵修飾符號別名。\n1 2 3 4  // Vue 2.x Vue.config.keyCodes = {\rf1: 112\r}\r  2. 3.x 更新 本來就不建議繼續使用鍵盤事件的 keyCode 屬性，因為該用法已經被廢棄，雖然目前因為舊程式碼仍保留支援，但為了未來瀏覽器，盡可能不使用它。\n因此 Vue 在 3.x 版本移除了對它支持，包括 config.keyCodes 也已棄用。\n與 Vue 2.x 相同，使用鍵盤事件的 key 屬性作為飾符號即可：\n1 2 3 4 5  \u0026lt;!-- Vue 3.x --\u0026gt;\r\u0026lt;input v-on:keyup.delete=\u0026#34;confirmDelete\u0026#34; /\u0026gt;\r\u0026lt;!-- 若遇到 PageDown 這類名稱，轉成 kebab-case --\u0026gt;\r\u0026lt;input v-on:keyup.page-down=\u0026#34;onPageDown\u0026#34;\u0026gt;\r  事件 API Vue 2.x 實體方法事件 API 中的 $on、$off 和 $once 已被移除，只剩 $emit 到保留。\n在 Vue 3.x 須改用使用實現了事件觸發 API 的第三方函式庫來取代現有的 event hub，例如 mitt 或 tiny-emitter。\n過濾器 從 Vue 3.0 開始，過濾器（Filter）已刪除，建議改用 method 或 computed 替代。\n內聯模板 Attribute Vue 3.x 將不再支持 內聯模板 功能。我個人是沒用過，詳細說明請參考 官方文件。\n不過，inline-templat 會讓模板的作用域變得更加難以理解，因此在 Vue 2.x 本來就不是最優先的選擇。\n$children $children 實體屬性可以用來訪問當前所有子元件實體，但已從 Vue 3.0 中移除，可以使用 $refs 替代。\n","description":"Vue2.x 與 Vue3.x 差異 - 移除 API","id":5,"section":"posts","tags":["Vue3","Vue2.x 與 Vue3.x 差異"],"title":"移除 API","uri":"https://chupai.github.io/posts/2103/removedapi/"},{"content":"\r 本篇為官方文件 Migration from Vue 2 筆記。\n  全域 API 模板指令 元件 \u0026amp; 渲染函數 自定義元素 其他小改變 移除 API  生命週期  destroyed 生命週期選項被重命名為 unmounted； beforeDestroy 生命週期選項被重命名為 beforeUnmount。  另外，$destroy 實體方法已從 Vue 3.0 中移除。\n在 prop 的預設函式中訪問 this Vue 3.x 的 prop 預設值的工廠函式不再有訪問 this 的權限。\n替代方案：\n 把元件接收到的原始 prop 作為參數傳遞給預設函式； inject API 可以在預設函式中使用。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // Vue 3.x\r\rimport { inject } from \u0026#39;vue\u0026#39;;\rexport default {\rprops: {\rtheme: {\rdefault(props) {\r// props 是傳遞給元件的原始值。\r // 在任何型別/預設強制轉換之前\r // 也可以使用 `inject` 來訪問注入的 property\r return inject(\u0026#39;theme\u0026#39;, \u0026#39;default-theme\u0026#39;);\r},\r},\r},\r};\r  自定義指令 Vue 3.x 對自定義指令的生命週期鉤子重新命名，與元件生命週期保持一致。\n1. 2.x 語法 鉤子函式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // Vue 2.x\rconst MyDirective = {\rbind(el, binding, vnode) {\r// 指令第一次綁定到元素時呼叫\r },\rinserted(el, binding, vnode) {\r// 被綁定元素插入父節點時呼叫\r },\rupdate(el, binding, vnode, oldVnode) {\r// 所在元件的 VNode 更新時呼叫\r },\rcomponentUpdated(el, binding, vnode, oldVnode) {\r// 指令所在元件的 VNode 及其子 VNode 全部更新後呼叫\r },\runbind(el, binding, vnode) {\r// 指令與元素解除綁定時呼叫\r },\r});\r  2. 3.x 語法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // Vue 3.x\rconst MyDirective = {\rcreated(el, binding, vnode) {\r// Vue 3.x 新增\r // 在綁定元素的 attribute 或事件監聽器被應用之前呼叫\r },\rbeforeMount(el, binding, vnode) {\r// 替代 bind()\r // 當指令第一次綁定到元素並且在掛載父元件之前呼叫\r },\rmounted(el, binding, vnode) {\r// inserted\r // 綁定元素的父元件被掛載時呼叫\r },\rbeforeUpdate(el, binding, vnode, prevNode) {\r// Vue 3.x 新增  // 在包含元件的 VNode 更新之前呼叫\r },\rupdated(el, binding, vnode, prevNode) {\r// 替代 update(), componentUpdated()  // 在包含元件的 VNode 及其子元件的 VNode 更新之後呼叫\r },\rbeforeUnmount(el, binding, vnode) {\r// Vue 3.x 新增  // 在綁定元素的父元件卸載之前呼叫\r },\runmounted(el, binding, vnode) {\r// 替代 unmounted()\r // 卸載綁定元素的父元件時呼叫\r },\r};\r  3. 鉤子函式參數  綁定元素的實體 instance 從 Vue 2.x 的 vnode 移到了 binding 中； Vue 3.x 移除 binding 中的 name、expression； Vue 3.x 的 binding 新增了 dir，為一個物件，註冊指令時的物件選項。 Vue 2.x 的 oldVnode 改成了 prevNnode。  Data 選項 data 選項不再接收純 object 形式，而需要使用 function 型式。\n1. 2.x 語法 在 Vue 2.x 時，根實體上的 data 選項可以是純 object 形式：\n1 2 3 4 5  // Vue2.x\r\rconst vm = new Vue({\rdata: {},\r});\r  元件的 data 選項則必須是 function 形式。\n2. 3.x 語法只支持 function 形式 Vue 3.x 的 data 選項統一使用 function 形式。\n1 2 3 4 5 6  // Vue 3.x\rconst app = new Vue({\rdata() {\rreturn {};\r},\r});\r  3. Mixin 合併行為變更 若元件使用 mixin 或 extends，彼此的 data 選項會進行合併，Vue 2.x 是深拷貝合併，但 Vue 3.x 只進行 淺拷貝合併。\n舉例來說：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  const Mixin = {\rdata() {\rreturn {\ruser: {\rname: \u0026#39;Jack\u0026#39;,\rid: 1,\r},\r};\r},\r};\rconst CompA = {\rmixins: [Mixin],\rdata() {\rreturn {\ruser: {\rid: 2,\r},\r};\r},\r};\r  Vue 2.x 生成 $data：\n1 2 3 4 5 6  {\ruser: {\rid: 2,\rname: \u0026#39;Jack\u0026#39;,\r},\r}\r  而 Vue 3.x 將會是：\n1 2 3 4 5  {\ruser: {\rid: 2,\r},\r}\r  因為 mixin 的深度合併非常隱式，這讓程式碼邏輯難以理解。\nattribute 強制行為 這是一個底層的內部 API 更改，不會影響大多數開發者。以下指說明重點差異，詳細說明請參考 官方文件。\r  Vue 3.x 對於 contenteditable、draggable、spellcheck 等 enumerated attribute 不再有特殊處理，將它們視為普通的 non-boolean attribute。 對於 non-boolean attribute 的值，若為 false 將不再刪除 attribute，它會被設置成字串 'false'。  如果要移除 attribute 則需要使用 null 或者 undefined 顯式刪除。       綁定值 Vue 2.x non-boolean Vue 2.x enumerated Vue 3.x non-boolean Vue 3.x enumerated       null removed \u0026quot;false\u0026quot; removed removed     undefined removed removed removed removed     true \u0026quot;true\u0026quot; \u0026quot;true\u0026quot; \u0026quot;true\u0026quot; \u0026quot;true\u0026quot;     false removed \u0026quot;false\u0026quot; \u0026quot;false\u0026quot; \u0026quot;false\u0026quot;     \u0026quot;\u0026quot; \u0026quot;\u0026quot; \u0026quot;true\u0026quot; \u0026quot;\u0026quot; \u0026quot;\u0026quot;     \u0026quot;true\u0026quot; \u0026quot;true\u0026quot; \u0026quot;true\u0026quot; \u0026quot;true\u0026quot; \u0026quot;true\u0026quot;     \u0026quot;false\u0026quot; \u0026quot;false\u0026quot; \u0026quot;false\u0026quot; \u0026quot;false\u0026quot; \u0026quot;false\u0026quot;     \u0026quot;foo\u0026quot; \u0026quot;foo\u0026quot; \u0026quot;true\u0026quot; \u0026quot;foo\u0026quot; \u0026quot;foo\u0026quot;     0 \u0026quot;1\u0026quot; \u0026quot;true\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot;     1 \u0026quot;0\u0026quot; \u0026quot;true\u0026quot; \u0026quot;0\u0026quot; \u0026quot;0\u0026quot;      Transition  Transition 的部分 class 名稱更改。 \u0026lt;TransitionGroup\u0026gt; 不再預設渲染包裹元素。  1. 部分 class 名稱更改 為了更加明確易讀，Vue 3.x 對初始狀態重命名：\n v-enter 修改為 v-enter-from v-leave 修改為 v-leave-from  對於 \u0026lt;transition\u0026gt; 元件相關屬性名稱也發生了變化：\n leave-class 已經被重命名為 leave-from-class enter-class 已經被重命名為 enter-from-class  2. \u0026lt;TransitionGroup\u0026gt; \u0026lt;transition-group\u0026gt; 不再預設渲染根元素，但仍然可以用 tag prop 建立根元素。\nVue 2.x 中，\u0026lt;transition-group\u0026gt; 與自定義元件一樣，需要一個根元素，預設為 \u0026lt;span\u0026gt;，可以透過 tag prop 更改：\n1 2 3 4 5 6  \u0026lt;!-- Vue 2.x --\u0026gt;\r\u0026lt;transition-group tag=\u0026#34;ul\u0026#34;\u0026gt;\r\u0026lt;li v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item\u0026#34;\u0026gt;\r{{ item }}\r\u0026lt;/li\u0026gt;\r\u0026lt;/transition-group\u0026gt;\r  Vue 3.x 有了 片段（Fragments），元件不再需要根節點，因此 \u0026lt;transition-group\u0026gt; 也不再預設渲染根節點。但仍然能透過 tag prop 添加。\nWatch on Arrays Vue 3.x 監聽陣列現在必須開啟 deep 選項。\n1. 2.x 行為 監聽的 deep 選項在 Vue 2.x 只用於處理物件的深度監聽，對於陣列監聽並不需要特別設置 deep: true。\nCodePen Demo：Vue 2.x - Watch on Arrays\n2. 3.x 更新 Vue 3.x 則統一監聽物件處理，包括陣列也需設置 deep: true。\n1 2 3 4 5 6 7 8 9  // Vue 3.x\rwatch: {\rarr: {\rdeep: true,\rhandler() {\rthis.count += 1;\r},\r},\r}\r  CodePen Demo：Vue 3.x - Watch on Arrays\n\u0026lt;template\u0026gt; 相關 沒有特殊指令的標記（v-if/else-if/else、v-for 或 v-slot）的 \u0026lt;template\u0026gt; 現在被視為普通元素，並將生成原生的 \u0026lt;template\u0026gt; 元素，而不是渲染其內部內容。\n","description":"Vue2.x 與 Vue3.x 差異 - 其他小改變","id":6,"section":"posts","tags":["Vue3","Vue2.x 與 Vue3.x 差異"],"title":"其他小改變","uri":"https://chupai.github.io/posts/2103/other/"},{"content":"\r 本篇為官方文件 Migration from Vue 2 筆記。\n  全域 API 模板指令 元件 \u0026amp; 渲染函數 自定義元素 其他小改變 移除 API  自定義元素 若想要添加在 Vue 外部定義的自定義元素（例如 Web Components API），需要將其設為白名單，否則會拋出警告。\n以下將以 \u0026lt;plastic-button\u0026gt;\u0026lt;/plastic-button\u0026gt; 模板為例。\n1. 2.x 語法 在 Vue 2.x 中，自定義元素白名單是透過 Vue.config.ignoredElements 設置：\n1 2  // Vue 2.x\rVue.config.ignoredElements = [\u0026#39;plastic-button\u0026#39;];\r  2. 3.x 語法 在 Vue 3.x 自定義元素白名單現在在模板編譯期間執行，因此改透過 vue-loader 的 compilerOptions 選項傳遞。\nwebpack 中設置：\n1 2 3 4 5 6 7 8 9 10 11 12 13  // in webpack config\rrules: [\r{\rtest: /\\.vue$/,\ruse: \u0026#39;vue-loader\u0026#39;,\roptions: {\rcompilerOptions: {\risCustomElement: tag =\u0026gt; tag === \u0026#39;plastic-button\u0026#39;\r}\r}\r}\r// ...\r]\r  使用動態模板編譯，透過 app.config.isCustomElement 傳遞：\n1 2 3  // Vue 3.x\rconst app = Vue.createApp({});\rapp.config.isCustomElement = tag =\u0026gt; tag === \u0026#39;plastic-button\u0026#39;;\r  使用 is 定義 另一種將自定義元素用作自定義內置模板的方法是向內置元素添加 is attribute：\n1 2  \u0026lt;!-- Vue 3.x --\u0026gt;\r\u0026lt;button is=\u0026#34;plastic-button\u0026#34;\u0026gt;點擊我!\u0026lt;/button\u0026gt;\r  is 的行為 Vue 2.x 與 Vue 3.x 並不相同，原本的行為到了 Vue 3.x 只保留對於 \u0026lt;component\u0026gt; tag 上使用，其餘元素要透過 v-is 指令。\nv-is 指令  本節僅影響直接在頁面的 HTML 中寫入 Vue 模板的情況。詳細問題情況可以參考 Vue2.x - 解析 DOM 模板時的注意事項。\n 1. 2.x 語法 在 Vue 2.x 中，可以使用使用 is prop 來解決：\n1 2 3 4  \u0026lt;!-- Vue 2.x --\u0026gt;\r\u0026lt;table\u0026gt;\r\u0026lt;tr is=\u0026#34;blog-post-row\u0026#34;\u0026gt;\u0026lt;/tr\u0026gt;\r\u0026lt;/table\u0026gt;\r  2. 3.x 語法 隨著 is attribute 的行為變化，Vue 3.x 引入了一個新的指令 v-is，用於解決這些情況：\n1 2 3 4  \u0026lt;!-- Vue 3.x --\u0026gt;\r\u0026lt;table\u0026gt;\r\u0026lt;tr v-is=\u0026#34;\u0026#39;blog-post-row\u0026#39;\u0026#34;\u0026gt;\u0026lt;/tr\u0026gt;\r\u0026lt;/table\u0026gt;\r  v-is 類似於 Vue 2.x 的 :is 動態綁定，因此元件名稱記得使用字串。\r","description":"Vue2.x 與 Vue3.x 差異 - 自定義元素","id":7,"section":"posts","tags":["Vue3","Vue2.x 與 Vue3.x 差異"],"title":"自定義元素","uri":"https://chupai.github.io/posts/2103/customelements/"},{"content":"\r 本篇為官方文件 Migration from Vue 2 筆記。\n  全域 API 模板指令 元件 \u0026amp; 渲染函數 自定義元素 其他小改變 移除 API  函數式元件 Functional Component 函數式元件 基本上就是一個無狀態（沒響應式資料，無實體 this）、不屬於任何生命週期的一種元件。\n在 Vue 2.x 中，主要有兩種作用：\n 作為性能優化，因為初始化速度比有狀態元件快 回傳多個根節點  然而，在 Vue 3.x 中，有狀態元件的性能已經提高到可以忽略不計的程度，再加上有狀態元件也包含回傳多個根節點的能力。\n因此，函數式元件在 Vue 3.x 唯一的用處就是建立簡單元件。\n1. 2.x 語法 使用渲染函數 render，需要設置 functional 選項：\n1 2 3 4 5 6 7 8 9 10  // Vue 2.x Vue.component(\u0026#39;dynamic-heading\u0026#39;, {\rfunctional: true,\rprops: {\r// ...\r },\rrender(h, context) {\r// ...\r },\r};\r  若使用單檔案元件 .vue 的模板，需要再 \u0026lt;template\u0026gt; 內加上 functional：\n1 2 3 4  \u0026lt;!-- Vue 2.x --\u0026gt;\r\u0026lt;template functional\u0026gt;\r\u0026lt;!-- ... --\u0026gt;\r\u0026lt;/template\u0026gt;\r  2. 3.x 語法 在 Vue 3 中，所有函數式元件都是使用普通函式建立的，也就是說，不需要定義 functional: true 選項了。\n1 2 3 4 5 6 7 8  // Vue 3.x\rimport { h } from \u0026#39;vue\u0026#39;;\rconst DynamicHeading = (props, context) =\u0026gt; {\r// ...\r};\rexport default DynamicHeading;\r  渲染函數 Render Functions 渲染函數 的變動，不影響使用 \u0026lt;template\u0026gt; 的開發者。\n h 從 Vue 2.x 的參數傳遞，改為全域導入。 渲染函數參數的更動，使狀態元件和函數式元件之間更加一致。 vnode 現在有一個扁平的 prop 結構。  1. 參數 在 2.x 中，render 函式將自動接收 h 函式作為參數（h 為 createElement 的常規別名）：\n1 2 3 4 5 6  // Vue 2.x\rexport default {\rrender(h) {\r// ...\r },\r};\r  在 3.x 中，h 現在是全域導入，而不是作為參數自動傳遞。\n1 2 3 4 5 6 7 8  // Vue 3.x\rimport { h } from \u0026#39;vue\u0026#39;;\rexport default {\rrender() {\r// ...\r },\r};\r  render 函式不再接收任何參數。\n2. VNode Props 結構 1 2 3 4 5 6 7 8 9  // 2.x\r{\rclass: [\u0026#39;button\u0026#39;, \u0026#39;is-outlined\u0026#39;],\rstyle: { color: \u0026#39;#34495E\u0026#39; },\rattrs: { id: \u0026#39;submit\u0026#39; },\rdomProps: { innerHTML: \u0026#39;\u0026#39; },\ron: { click: submitForm },\rkey: \u0026#39;submit-button\u0026#39;\r}\r  1 2 3 4 5 6 7 8 9 10  // 3.x 語法\r{\rclass: [\u0026#39;button\u0026#39;, \u0026#39;is-outlined\u0026#39;],\rstyle: { color: \u0026#39;#34495E\u0026#39; },\rid: \u0026#39;submit\u0026#39;,\rinnerHTML: \u0026#39;\u0026#39;,\ronClick: submitForm,\rkey: \u0026#39;submit-button\u0026#39;\r}\r  非同步元件 Async Components  新的 defineAsyncComponent 輔助方法，用於顯式地定義非同步元件。 component 選項重命名為 loader。 Loader 函式本身不再接收 resolve 和 reject 參數，且必須回傳一個 Promise。  1. 2.x 語法 在 Vue 2.x 中，非同步元件是透過動態導入某個元件檔案來定義的：\n1 2  // Vue 2.x\rconst asyncPage = () =\u0026gt; import(\u0026#39;./components/NextPage.vue\u0026#39;);\r  帶有選項的高階語法：\n1 2 3 4 5 6 7 8  // Vue 2.x\rconst asyncPage = {\rcomponent: () =\u0026gt; import(\u0026#39;./components/NextPage.vue\u0026#39;),\rdelay: 200,\rtimeout: 3000,\rerror: ErrorComponent,\rloading: LoadingComponent,\r};\r  2. 3.x 語法 在 Vue 3.x，由於函數式元件被定義為純函式，因此非同步元件需要透過 defineAsyncComponent 輔助方法顯式地定義：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // Vue 3.x\rimport { defineAsyncComponent } from \u0026#39;vue\u0026#39;;\r// 不帶選項的非同步元件\rconst asyncPage = defineAsyncComponent(() =\u0026gt; import(\u0026#39;./components/NextPage.vue\u0026#39;));\r// 帶選項的非同步元件\rconst asyncPageWithOptions = defineAsyncComponent({\rloader: () =\u0026gt; import(\u0026#39;./components/NextPage.vue\u0026#39;),\rdelay: 200,\rtimeout: 3000,\rerrorComponent: ErrorComponent,\rloadingComponent: LoadingComponent,\r});\r  另外，component 選項被重新命名為 loader，且不再接收 resolve 和 reject 參數，必須始終回傳 Promise：\n1 2 3 4 5 6 7 8 9 10 11 12  // 2.x const oldAsyncComponent = (resolve, reject) =\u0026gt; {\r/* ... */\r};\r// 3.x const asyncComponent = defineAsyncComponent(\r() =\u0026gt;\rnew Promise((resolve, reject) =\u0026gt; {\r/* ... */\r}),\r);\r  emits 選項 1. 自定義事件 在 Vue 3.x 中，元件的自定義事件 $emit 必須在 emits 選項中宣告：\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;!-- Vue 3.x --\u0026gt;\r\u0026lt;template\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;{{ text }}\u0026lt;/p\u0026gt;\r\u0026lt;button v-on:click=\u0026#34;$emit(\u0026#39;accepted\u0026#39;)\u0026#34;\u0026gt;OK\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rprops: [\u0026#39;text\u0026#39;],\remits: [\u0026#39;accepted\u0026#39;],\r};\r\u0026lt;/script\u0026gt;\r  因此 Vue 3.x 移除了 .native 修飾符號，任何未在 emits 選項中宣告的 event，將被自動加到 $attrs。而 attrs 預設情況下是綁定到根元件的。\n2. 驗證拋出的事件 與 prop 型別驗證類似，如果使用物件語法定義 event，可以用來驗證。\n將為 event 分配一個函式，該函式接收傳遞給 $emit 呼叫的參數，並回傳一個布林值以指示 event 是否有效。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // Vue 3.x\rapp.component(\u0026#39;CustomForm\u0026#39;, {\remits: {\r// 沒有驗證\r click: null,\r// 驗證submit 事件\r submit: ({ email, password }) =\u0026gt; {\rif (email \u0026amp;\u0026amp; password) {\rreturn true;\r} else {\rconsole.warn(\u0026#39;Invalid submit event payload!\u0026#39;);\rreturn false;\r}\r},\r},\rmethods: {\rsubmitForm() {\rthis.$emit(\u0026#39;submit\u0026#39;, { email, password });\r},\r},\r});\r  ","description":"Vue2.x 與 Vue3.x 差異 - 元件 \u0026 渲染函數","id":8,"section":"posts","tags":["Vue3","Vue2.x 與 Vue3.x 差異"],"title":"元件 \u0026 渲染函數","uri":"https://chupai.github.io/posts/2103/componentsrenderfunction/"},{"content":"\r 本篇為官方文件 Migration from Vue 2 筆記。\n  全域 API 模板指令 元件 \u0026amp; 渲染函數 自定義元素 其他小改變 移除 API  元件上的 v-model 指令 Vue 3.x 語法變化概述：\n 用於自定義元件時，v-model prop 和 event 預設名稱已更改：  prop：value -\u0026gt; modelValue； event：input -\u0026gt; update:modelValue。   v-bind 的 .sync 修飾符號和元件的 model 選項已移除，使用 v-model 搭配參數即可替代。 現在可以在同一個元件上使用多個 v-model 進行雙向綁定。 現在可以自定義 v-model 修飾符號。  1. 2.x 語法 在 Vue 2.x 的元件上使用 v-model 等同綁定 value prop 和 input 事件：\n1 2 3 4 5 6 7  \u0026lt;!-- Vue 2.x --\u0026gt;\r\u0026lt;my-component v-model=\u0026#34;pageTitle\u0026#34;\u0026gt;\u0026lt;/my-component\u0026gt;\r\u0026lt;!-- 是以下的簡寫: --\u0026gt;\r\u0026lt;my-component\r:value=\u0026#34;pageTitle\u0026#34;\r@input=\u0026#34;pageTitle = $event\u0026#34;\u0026gt;\u0026lt;/my-component\u0026gt;\r  若不希望使用預設的 value 和 input 事件，可以使用 model 選項來設定 prop 和 event 名稱，避免不同的元件上的語意衝突。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // Vue 2.x Vue.component(\u0026#39;base-checkbox\u0026#39;, {\rmodel: {\rprop: \u0026#39;checked\u0026#39;,\revent: \u0026#39;change\u0026#39;,\r},\rprops: {\rchecked: Boolean,\r},\rtemplate: `\r\u0026lt;input\rtype=\u0026#34;checkbox\u0026#34;\rv-bind:checked=\u0026#34;checked\u0026#34;\rv-on:change=\u0026#34;$emit(\u0026#39;change\u0026#39;, $event.target.checked)\u0026#34;\r\u0026gt;\r`,\r});\r  如果不只一個 prop 需要雙向綁定，就需要借助另一個與 v-model 非常相似的 v-bind.sync。詳細說明可以參考 Vue2.x - sync 修飾符號。\n2. 3.x 語法 由於 v-bind.sync 與 v-model 過於相似，Vue 3.x 將兩者結合，移除了 v-bind 的 sync 修飾符號，現在可以使用多個 v-model 指令。\n元件 v-model 指令中的 prop 和 event 預設名稱也已更改，避免與需要用到 value prop 的標籤衝突：\n prop：value -\u0026gt; modelValue； event：input -\u0026gt; update:modelValue。  1 2 3 4 5 6 7  \u0026lt;!-- Vue 3.x --\u0026gt;\r\u0026lt;my-component v-model=\u0026#34;pageTitle\u0026#34;\u0026gt;\u0026lt;/my-component\u0026gt;\r\u0026lt;!-- 是以下的簡寫: --\u0026gt;\r\u0026lt;my-component :modelValue=\u0026#34;pageTitle\u0026#34;\r@update:modelValue=\u0026#34;pageTitle = $event\u0026#34;\u0026gt;\u0026lt;/my-component\u0026gt;\r  但要注意的是，Vue 3.x 新增了 emits 選項，除了 prop 需要宣告還有 event。\n若要修改預設名稱，將不再使用 model 選項，而是將一個參數傳遞給 model：\n1 2 3 4 5 6 7  \u0026lt;!-- Vue 3.x --\u0026gt;\r\u0026lt;my-component v-model:title=\u0026#34;pageTitle\u0026#34;\u0026gt;\u0026lt;/my-component\u0026gt;\r\u0026lt;!-- 是以下的簡寫: --\u0026gt;\r\u0026lt;my-component :title=\u0026#34;pageTitle\u0026#34;\r@update:title=\u0026#34;pageTitle = $event\u0026#34;\u0026gt;\u0026lt;/my-component\u0026gt;\r  CodePen Demo：Vue 3.x - v-model 參數\n使用多個 v-model 指令：\n1 2 3 4 5 6 7 8 9 10  \u0026lt;!-- Vue 3.x --\u0026gt;\r\u0026lt;my-component v-model:title=\u0026#34;pageTitle\u0026#34; v-model:content=\u0026#34;pageContent\u0026#34;\u0026gt;\u0026lt;/my-component\u0026gt;\r\u0026lt;!-- 是以下的簡寫： --\u0026gt;\r\u0026lt;my-component :title=\u0026#34;pageTitle\u0026#34;\r:content=\u0026#34;pageContent\u0026#34;\r@update:title=\u0026#34;pageTitle = $event\u0026#34;\r@update:content=\u0026#34;pageContent = $event\u0026#34;\r\u0026gt;\u0026lt;/my-component\u0026gt;\r  在 Vue 3.x 除了可以使用內建修飾符號，還可以自定義修飾符號。\n添加到元件 v-model 的修飾符號會透過 modelModifiers prop 提供給元件。modelModifiers prop 預設為空物件，當 v-model 使用自定義修飾符號時，modelModifiers 會包含自定義修飾符號名稱屬性，舉例來說 v-model.capitalize=\u0026quot;\u0026quot; 就會是 { capitalize: true }。\n接著我們就可以在事件處理函式中檢查是否有使用自定義修飾符號。\nCodePen Demo：Vue 3.x - v-model 修飾符號\n對於帶參數的 v-model，自定義修飾符號生成的 prop 將會是 arg + \u0026quot;Modifiers\u0026quot;，例如 v-model:description.capitalize=\u0026quot;\u0026quot;，生成 prop 名稱為 descriptionModifiers。\nkey attribute  對於 v-if/v-else/v-else-if 的各分支項 key 將不再是必須的，因為現在 Vue 會自動生成唯一的 key。  如果你手動提供 key，那麼每個分支必須使用唯一的 key。你不能通過故意使用相同的 key 來強制重用分支。   \u0026lt;template v-for\u0026gt; 的 key 應該設置在 \u0026lt;template\u0026gt; 標籤上（而不是設置在它的子節點上）。  1. 條件分支 在 Vue 2.x 時，當我們使用 v-if 相關指令時，會需要使用 key，來獨立 DOM 狀態。\n1 2 3  \u0026lt;!-- Vue 2.x --\u0026gt;\r\u0026lt;div v-if=\u0026#34;condition\u0026#34; key=\u0026#34;yes\u0026#34;\u0026gt;Yes\u0026lt;/div\u0026gt;\r\u0026lt;div v-else key=\u0026#34;no\u0026#34;\u0026gt;No\u0026lt;/div\u0026gt;\r  而 Vue 3.x 則會自動生成唯一的 key：\n1 2 3  \u0026lt;!-- Vue 3.x --\u0026gt;\r\u0026lt;div v-if=\u0026#34;condition\u0026#34;\u0026gt;Yes\u0026lt;/div\u0026gt;\r\u0026lt;div v-else\u0026gt;No\u0026lt;/div\u0026gt;\r  因此不建議再手動提供 key，若你手動提供，變得每個分支都需要設置 key。\n2. \u0026lt;template\u0026gt; 結合 v-for 指令 在 Vue 2.x 中 \u0026lt;template\u0026gt; 標籤不能擁有 key。不過你可以為其每個子節點分別設置 key。\n1 2 3 4 5  \u0026lt;!-- Vue 2.x --\u0026gt;\r\u0026lt;template v-for=\u0026#34;item in list\u0026#34;\u0026gt;\r\u0026lt;div :key=\u0026#34;item.id\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt;\r\u0026lt;span :key=\u0026#34;item.id\u0026#34;\u0026gt;...\u0026lt;/span\u0026gt;\r\u0026lt;/template\u0026gt;\r  在 Vue 3.x 中 key 則應該被設置在 \u0026lt;template\u0026gt; 標籤上。\n1 2 3 4 5  \u0026lt;!-- Vue 3.x --\u0026gt;\r\u0026lt;template v-for=\u0026#34;item in list\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt;\r\u0026lt;div\u0026gt;...\u0026lt;/div\u0026gt;\r\u0026lt;span\u0026gt;...\u0026lt;/span\u0026gt;\r\u0026lt;/template\u0026gt;\r  v-if 與 v-for 的優先級對比 1. 2.x 語法 2.x 版本中在一個元素上同時使用 v-if 和 v-for 時，v-for 會優先作用。\n2. 3.x 語法 3.x 版本中，則剛好相反，v-if 總是優先於 v-for 生效。\n不過本來就不建議同時使用這兩個指令，因此沒啥影響。\nv-bind 合併行為 v-bind 的綁定順序會影響渲染結果。\n1. 2.x 語法 在 2.x 版本中，如果一個元素同時定義了 v-bind=\u0026quot;object\u0026quot; 語法和相同的 property，那麼這個單獨的 property 一定會覆蓋 object 中的綁定。\n1 2 3 4 5  \u0026lt;!-- Vue 2.x --\u0026gt;\r\u0026lt;!-- template --\u0026gt;\r\u0026lt;div id=\u0026#34;red\u0026#34; v-bind=\u0026#34;{ id: \u0026#39;blue\u0026#39; }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;!-- result --\u0026gt;\r\u0026lt;div id=\u0026#34;red\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r  2. 3.x 語法 在 3.x 版本中，宣告綁定的順序會決定如何合併：\n1 2 3 4 5 6 7 8 9 10  \u0026lt;!-- Vue 3.x --\u0026gt;\r\u0026lt;!-- template --\u0026gt;\r\u0026lt;div id=\u0026#34;red\u0026#34; v-bind=\u0026#34;{ id: \u0026#39;blue\u0026#39; }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;!-- result --\u0026gt;\r\u0026lt;div id=\u0026#34;blue\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;!-- template --\u0026gt;\r\u0026lt;div v-bind=\u0026#34;{ id: \u0026#39;blue\u0026#39; }\u0026#34; id=\u0026#34;red\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;!-- result --\u0026gt;\r\u0026lt;div id=\u0026#34;red\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r  移除 v-on.native 修飾符號 1. 2.x 語法 想要在子元件的根元素上監聽原生 DOM 事件可以使用 v-on 指令的 .native 修飾符號，否則預設情況下只有通過 this.$emit 觸發。\n1 2  \u0026lt;!-- Vue 2.x --\u0026gt;\r\u0026lt;my-component @click.native=\u0026#34;clickHandler\u0026#34;\u0026gt;\u0026lt;/my-component\u0026gt;\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // Vue 2.x\rVue.component(\u0026#39;MyComponent\u0026#39;, {\rtemplate: `\r\u0026lt;button\u0026gt;click\u0026lt;/button\u0026gt;\r`,\r});\rconst vm = new Vue({\rel: \u0026#39;#app\u0026#39;,\rmethods: {\rclickHandler() {\ralert(\u0026#39;onclick\u0026#39;);\r},\r},\r});\r  CodePen Demo：Vue 2.x - native 修飾符號\n2. 3.x 語法 在 3.x 版本中，已移除 v-on 指令的 .native 修飾符號。\n因為 3.x 版本新增了 emits 選項，只有在 emits 選項中定義的事件會做為自訂義事件，而未定義的事件則會作為原生事件添加到子元件的根元素中。\n1 2  \u0026lt;!-- Vue 2.x --\u0026gt;\r\u0026lt;my-component v-on:click=\u0026#34;clickHandler\u0026#34;\u0026gt;\u0026lt;/my-component\u0026gt;\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // Vue 3.x\rconst app = Vue.createApp({\rmethods: {\rclickHandler() {\ralert(\u0026#39;onclick\u0026#39;);\r},\r},\r});\rapp.component(\u0026#39;MyComponent\u0026#39;, {\rtemplate: `\r\u0026lt;button\u0026gt;click\u0026lt;/button\u0026gt;\r`,\r});\rapp.mount(\u0026#39;#app\u0026#39;);\r  CodePen Demo：Vue 3.x - 原生事件\nv-for 中的 Ref 陣列 v-for 中的 ref 不再註冊 ref 陣列。\n1. ref ref 可以用來取得 DOM 元素，也就是將元素註冊在 $refs 物件。詳細可以參考 Vue2.x API ref。\n若是在使用 v-for 指令元素上使用 ref，將會建立包含所有元素的陣列。但當使用巢狀 v-for 時，$refs 的結構就會變得相當不直覺，元素陣列是分開的：\n\u0026lt;!-- Vue 2.x --\u0026gt;\r\u0026lt;div v-for=\u0026quot;x of 3\u0026quot; ref=\u0026quot;xDoms\u0026quot;\u0026gt;\r\u0026lt;div v-for=\u0026quot;y of 3\u0026quot; ref=\u0026quot;yDoms\u0026quot;\u0026gt;{{ x * y }}\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\rCodePen Demo：Vue2.x - 巢狀 ref\n2. 3.x 語法 因此 Vue 3.x 將不再自動建立陣列，需要搭配 v-bind 指令將 ref 綁定到一個更靈活的函式上。\n\u0026lt;!-- Vue 3.x --\u0026gt;\r\u0026lt;div v-for=\u0026quot;n of 10\u0026quot; :ref=\u0026quot;setDoms\u0026quot;\u0026gt;n\u0026lt;/div\u0026gt;\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // Vue 3.x\rdata() {\rreturn {\rdoms: [],\r};\r},\rmethods: {\rsetDoms(el) {\rif (el) {\rthis.doms.push(el);\r}\r},\r},\rmounted() {\rconsole.log(this.doms);\r},\r  我們可以透過該函式將取得的元素迭代放置在一個陣列或物件中。\nCodePen Demo：Vue3.x - ref\n如果 v-for 的元素是動態的，要確保在每次更新之前重置容器：\n1 2 3  beforeUpdate() {\rthis.doms = [];\r}\r  CodePen Demo：Vue3.x - ref 更新\n","description":"Vue2.x 與 Vue3.x 差異 - 模板指令","id":9,"section":"posts","tags":["Vue3","Vue2.x 與 Vue3.x 差異"],"title":"模板指令","uri":"https://chupai.github.io/posts/2103/templatedirectives/"},{"content":"\r 本篇為官方文件 Migration from Vue 2 筆記。\n  全域 API 模板指令 元件 \u0026amp; 渲染函數 自定義元素 其他小改變 移除 API  全域 API Vue 2.x 的全域 Vue API 已更改為使用 應用程式實體（application instance）。\n1. 2.x 語法 Vue 2.x 是透過 Vue 函式建立一個新的 Vue 實體：\n1 2 3 4  // Vue 2.x\rconst vm = new Vue({\r// 選項\r});\r  並且有許多 全域 API 和 全域配置 可以全域改變 Vue 的行為。例如，全域註冊：\n1 2 3  // Vue 2.x\rVue.component(\u0026#39;my-component\u0026#39;, MyComponent);\rVue.directive(\u0026#39;my-directive\u0026#39;, myDirective);\r  2. 全域 API 遇到的問題 Vue 2.x 這種宣告方式雖然方便，但也會導致一些問題。從技術上來說，Vue 2.x 並沒有「app」的概念（app 要互相獨立），只是透過 new Vue() 建立根 Vue 實體。當我們從 Vue 函式建立複數根實體，所有根實體將會共享全域環境配置。\n3. createApp 為了避免上述問題，在 Vue 3.x 引入了 createApp，用來取代 new Vue()。\n呼叫 createApp 函式回傳一個應用實體：\n1 2 3 4  // Vue 3.x\rconst app = Vue.createApp({\r// 選項\r});\r  原本的全域 API 操作改在應用實體上操作：\n1 2 3 4  // Vue 3.x\rconst app = Vue.createApp({});\rapp.component(\u0026#39;my-component\u0026#39;, MyComponent);\rapp.directive(\u0026#39;my-directive\u0026#39;, myDirective);\r  應用實體大多數方法都會回傳自己，方便使用鏈式呼叫其它方法：\n1 2 3 4  // Vue 3.x\rconst app = Vue.createApp({})\r.component(\u0026#39;my-component\u0026#39;, MyComponent)\r.directive(\u0026#39;my-directive\u0026#39;, myDirective);\r  對應表：\n   2.x 全域 API 3.x 應用實體 API (app)     Vue.config app.config   Vue.config.productionTip 移除   Vue.config.ignoredElements app.config.isCustomElement   Vue.component app.component   Vue.directive app.directive   Vue.mixin app.mixin   Vue.use app.use   Vue.prototype app.config.globalProperties    其他不會全域改變行為的全域 API 都通過 exports 導出，呼叫時需要手動導入，下節會提到。\n4. 掛載 在 Vue 2.x 中，我們會使用 el 選項作用為掛載 Vue 實體與 DOM 元素的關係。\n1 2 3 4  // Vue 2.x\rconst vm = new Vue({\rel: \u0026#39;#app\u0026#39;,\r});\r  或者透過 $mount() 進行手動掛載。\n1 2 3 4  // Vue 2.x\rconst vm = new Vue({});\rvm.$mount(\u0026#39;#app\u0026#39;);\r  而 Vue 3.x 沒有 el 選項，而是透過 mount 函式手動掛載根節點：\n1 2 3 4 5 6  // Vue 3.x\rconst app = Vue.createApp({\r// 選項\r});\rconst vm = app.mount(\u0026#39;#app\u0026#39;);\r  mount 函式與大多數應用方法不同，回傳的是根元件實體，而非應用實體本身。\n全域 API Treeshaking Vue 3.x 對部分全域 API 實現了 tree-shakable 功能的支持。\n Tree shaking 是一個用於描述移除 JavaScript 上下文中的未引用程式碼（dead-code）行為的術語。它依賴於 ES2015 中的 import 和 export 語句，用來檢測程式碼模組是否被導出、導入，且被 JavaScript 檔案使用。\n 1. 2.x 語法 在 Vue 2.x 我們使用全域 API 並不需要手動導入，例如 Vue.nextTick：\n1 2 3 4 5 6  // Vue 2.x\rimport Vue from \u0026#39;vue\u0026#39;;\rVue.nextTick(() =\u0026gt; {\r// something DOM-related\r});\r  也就是說，有很多我們沒用到的全域 API 都會被一同打包，造成專案存在多餘的程式碼。\n2. 3.0 語法 在 Vue 3.x 中，為了能支持 tree-shakable 功能，對全域和內部 API 都經過了重構，明確表示只能透過 ES Modules 構建的命名導出進行訪問。\n1 2 3 4 5 6  // Vue 3.x\rimport { nextTick } from \u0026#39;vue\u0026#39;;\rnextTick(() =\u0026gt; {\r// something DOM-related\r});\r  3. 受影響的 API Vue 2.x 中的這些全域 API 受此更改的影響：\n Vue.nextTick Vue.observable（用 Vue.reactive 替換） Vue.version Vue.compile（僅全構建） Vue.set（僅兼容構建） Vue.delete（僅兼容構建）  4. 內部 API 除了全域 API，Vue3.0 許多內部元件、幫助器也支持 tree-shaking。\n","description":"Vue2.x 與 Vue3.x 差異 - 全域 API。","id":10,"section":"posts","tags":["Vue3","Vue2.x 與 Vue3.x 差異"],"title":"全域 API","uri":"https://chupai.github.io/posts/2103/globalapi/"},{"content":" JavaScript筆記 目錄\n \rJavaScrit 註解 1. 格式 JavaScrit 中的註解有兩種格式。\n單行註解：\n1  // Hello\r  多行註解：\n1 2 3 4  /*\rHello\rHi\r*/\r  2. 為什麼要加註解？ 除非你的記得你幾個月前寫的程式，或能立刻明白他人寫的程式，否則良好的註解是必須的。\n註解功能：\n 阻止程式碼執行。 用於說明程式碼，提升可讀性，方便專案管理、交接，提升協作效率。  3. 不必要的註解  只對商業邏輯複雜的部分撰寫註解 不要在程式碼中保留被註解掉的程式碼 不要留有日誌式的註解 避免位置標明   無瑕的程式碼 JavaScript - 註解（Comments）\n 註解應用 1. 特殊標記註解 1 2 3 4 5 6  // TODO: 功能未完成\r// FIXME: 程式碼須修復\r// XXX: 實現方式待確認\r// NOTE: 功能說明\r// HACK: 程式碼還有優化空間\r// BUG: 程式碼有 BUG\r  2. JSDoc JSDoc 是最通用的 JavaScript 註解規範，透過特定格式的註解，可以快速建立 API 文件。\n型別檢查  動態型別一時爽，程式碼重構火葬場\n 由於 Javascript 是動態型別語言，變數型別的寬容使得程式撰寫上有不錯的靈活性，但是當專案變得龐大時，反而會使開發成本提高。\n使用 TypeScript 能有效解決動態型別的缺點，但考慮到學習成本與舊專案的重構，可試試 VSCode 中基於 TypeScript 提供對於 JSDoc 支持，實現智能型別檢查。\n1. 開啟型別檢查 最簡單的方法就是在 .js 檔案開頭新增 @ts-check：\n1 2  // @ts-check\r\r  那麼 VSCode 就會根據註解檢查型別。\n如果不想每隻 .js 檔案都加上 @ts-check，可以開啟 VSCode 全域型別檢查：\n1 2 3  {\r\u0026#34;js/ts.implicitProjectConfig.checkJs\u0026#34;: true\r}\r  預設的情況下是關閉的：\n如果型別檢查為開啟，則可以使用 @ts-nocheck 忽略某隻檔案的類型檢查：\n1 2  // @ts-nocheck\r\r  2. jsconfig.json 除了啟用 VSCode 的設定來開啟型別檢查，也可以在專案根目錄下新增 jsconfig.json 設定檔：\n1 2 3 4 5  {\r\u0026#34;compilerOptions\u0026#34;: {\r\u0026#34;checkJs\u0026#34;: true\r}\r}\r  jsconfig.json 會覆蓋 Implicit Project Config: Check JS 設定。\n預設會全域檢查所有 .js 檔案，可以使用 exclude 或 include 選項，設定要排除或包含的資料夾：\n1 2 3 4 5 6 7  {\r\u0026#34;compilerOptions\u0026#34;: {\r\u0026#34;checkJs\u0026#34;: true\r},\r\u0026#34;exclude\u0026#34;: [\u0026#34;node_modules\u0026#34;, \u0026#34;dist\u0026#34;],\r\u0026#34;include\u0026#34;: [\u0026#34;src/**/*\u0026#34;]\r}\r   Visual Studio Code - jsconfig.json\nTypeScript - What is a tsconfig.json\n 3. 支持的 JSDoc 標籤 TypeScript 只支持了部分 JSDoc 標籤。\n當前所支持的標籤如下：\n @type @param (or @arg or @argument) @returns (or @return) @typedef @callback @template @class (or @constructor) @this @extends (or @augments) @enum   JSDoc Reference\n中文翻譯\n 3. 簡單範例 JSDoc 註解格式必須以 /** 為開頭才能被識別（例如 /*、/*** 不會被解析為 JSDoc 註解）：\n1  /** */\r  舉例來說，我們定義一個 count 變數：\n1  let count;\r  我們可以指定任何型別的值給它，但如果希望它只接受數字型別，可以加上 JSDoc 註解：\n1 2  /** @type {number} */\rlet count;\r  若指定非數字型別的值，VSCode 將會跳出錯誤提示：\n可以在註解第一行加上說明：\n1 2 3 4 5  /**\r* 計數變數\r* @type {number}\r* */\rlet count;\r  如果想要忽略類型錯誤可以使用 @ts-ignore。\nJSDoc 標籤 1. @type @type 可以用來標明變數型別。\n基本用法：\n1 2 3 4 5 6 7 8 9 10 11  /** @type {string} */\rlet str;\rstr = \u0026#39;Hello!\u0026#39;;\r/** @type {Date} */\rlet now;\rnow = new Date();\r/** @type {HTMLElement} */\rlet dom;\rdom = document.querySelector(\u0026#39;body\u0026#39;);\r  複合型別：\n1 2 3 4  /** @type {string|boolean} */\rlet x;\rx = \u0026#39;123\u0026#39;;\rx = true;\r  指定陣列元素的型別：\n1 2 3  /** @type {number[]} */\rconst ns = [];\r[].push(1);\r  也可以寫成 Array.\u0026lt;number\u0026gt;、Array\u0026lt;number\u0026gt;：\n1 2 3 4 5  /** @type {Array.\u0026lt;number\u0026gt;} */\rconst ns = [];\r/** @type {Array\u0026lt;number\u0026gt;} */\rconst ns2 = [];\r  物件字面值：\n1 2 3 4 5  /**\r* @type {{ a: string, b: number }}\r*/\rlet obj;\robj = { a: \u0026#39;123\u0026#39;, b: 123 };\r  指定 map-like 和 array-like 的物件：\n1 2 3 4 5 6 7  /**\r* @type {Object.\u0026lt;string, number\u0026gt;}\r*/\rlet stringToNumber;\r/** @type {Object.\u0026lt;number, object\u0026gt;} */\rlet arrayLike;\r  預設就是 any 任意型別：\n1 2  /** @type {any} */\rlet x;\r  * 和 ? 等同 any：\n1 2 3 4 5  /** @type {*} - can be \u0026#39;any\u0026#39; type*/\rlet y;\r/** @type {?} - unknown type*/\rlet z;\r  函式型別：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /**\r* @type {function(number): number} Closure syntax\r*/\rlet foo;\rfoo = function (a) {\rreturn a * a;\r};\r/** * @type {(a: number) =\u0026gt; number} Typescript syntax\r*/\rlet boo;\rboo = function (a) {\rreturn a * a;\r};\r  2. @param（synonyms: @arg or @argument） @param 語法和 @type 基本上相同，但用於標明函式參數，所以多了參數名稱。\n1 2 3 4 5 6 7 8  /**\r* The square of a number\r* @param {number} number - 輸入數字\r* @return {number}\r*/\rfunction square(number) {\rreturn number * number;\r}\r  函式如果有回傳值，則可以使用 @returns（@return） 標明。\n有屬性的參數，使用物件字面值不易描述屬性：\n1 2 3 4 5 6  /**\r* @param {{ name: string, age: number }} person\r*/\rfunction foo(person) {\rconsole.log(person.name, person.age);\r}\r  可以使用以下寫法：\n1 2 3 4 5 6 7 8  /**\r* @param {Object} person - 某人\r* @param {string} person.name - 某人的名字\r* @param {number} person.age - 某人的年齡\r*/\rfunction foo(person) {\rconsole.log(person.name, person.age);\r}\r  使用 ES6 參數解構，使用適當的參數名稱即可：\n1 2 3 4 5 6 7 8  /**\r* @param {Object} person - 某人\r* @param {string} person.name - 名字\r* @param {number} person.age - 年齡\r*/\rfunction foo({ name, age }) {\rconsole.log(name, age);\r}\r  可選參數表示方式：\n1 2 3 4 5 6  /**\r* @param {string=} p1 - 可選參數（Closure語法）\r* @param {string} [p2] - 可選參數（JSDoc語法）\r* @param {string} [p3 = \u0026#39;test\u0026#39;] - 有預設值的可選參數（JSDoc語法）\r*/\rfunction foo(p1, p2, p3 = \u0026#39;test\u0026#39;) {}\r  3. @typedef @typedef 可以用來宣告複雜型別，也就是自訂義一個類型，再使用 @type 標記來引用。\n描述一個物件型別：\n1 2 3 4 5 6 7 8 9 10  /**\r* @typedef {Object} SpecialType - creates a new type named \u0026#39;SpecialType\u0026#39;\r* @property {string} prop1 - a string property\r* @property {number} prop2 - a number property\r* @prop {number} [prop3] - an optional number property of SpecialType\r*/\r/** @type {SpecialType} */\rlet obj;\robj = { prop1: \u0026#39;123\u0026#39;, prop2: 123 };\r  4. @callback @callback 與 @typedef 相似，但描述的是一個函式：\n1 2 3 4 5 6 7 8 9 10  /**\r* @callback Predicate\r* @param {string} data\r* @returns {boolean}\r*/\r/** @type {Predicate} */\rconst foo = function (str) {\rreturn !(str.length % 2);\r};\r  5. @class（synonyms: @constructor） @class 可以標明函式為一個建構函式（Constructor）。\n1 2 3 4 5 6 7  /**\r* Creates a new Person.\r* @class\r*/\rfunction Person() {}\rconst p = new Person();\r  不過 ES6 有了 class 後，就沒必要使用 @class 了。\n1 2 3 4 5 6  class Person {\r/**\r* Creates a new Person.\r*/\rconstructor() {}\r}\r  6. @this @this 可以明確標示 this 關鍵字在這裡指的是什麼。\n例如建構函式的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13  /**\r* @class\r*/\rfunction Person() {\rthis.name = \u0026#39;\u0026#39;;\r}\r/**\r* @this {Person} - Person 實體\r*/\rPerson.prototype.setName = function (name) {\rthis.name = name;\r};\r  或監聽器處理函式：\n1 2 3 4 5 6 7  /**\r* @param {Event} event - 事件物件\r* @this {HTMLElement} - 監聽器綁定元素\r*/\rfunction clickHandler(event) {\r// ...\r}\r  7. @extends（synonyms: @augments） 如果使用 extends 關鍵字來擴展一個現有的類別的時候，可以使用 @extends 標示。\n1 2 3 4 5 6 7 8  /** 佇列 */\rclass Queue {}\r/**\r* 優先佇列\r* @extends Queue\r*/\rclass PriorityQueue extends Queue {}\r  8. @enum @enum 標籤描述一個靜態屬性值的全部相同的集合，簡單來說就是一個物件內的屬性皆為相同型別，且不允許新增額外屬性。\n1 2 3 4 5 6  /** @enum {number} */\rconst JSDocState = {\rBeginningOfLine: 0,\rSawAsterisk: 1,\rSavingComments: 2,\r};\r  9. @template @templete 非 JSDoc 標準，只在 google closure compiler 中有提及，可以用來宣告 泛用型別（Generic Type），是 TypeScript 中的型別。\n泛用型別（Generic Type） 目的在於成員之間提供有意義的約束，這些成員可以是類別的實體、類別的方法、函式參數、函式回傳值。\n1 2 3 4 5 6 7 8  /**\r* @template T\r* @param {T} x\r* @return {T}\r*/\rfunction foo(x) {\rreturn x;\r}\r  關於 泛用型別（Generic Type） 我自己也不是很了解，有空在補充。\n註解相關 VSCode 套件  koroFileHeader，在 VSCode 中用於生成檔案頭部註解和函式註解的套件。  文件頭部新增註解：Ctrl + Alt + t 光標處添加函式註解：Ctrl + Alt + t   Todo Tree，特殊註解高光亮。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 配置\r\u0026#34;todo-tree.general.tags\u0026#34;: [\u0026#34;TODO:\u0026#34;, \u0026#34;FIXME:\u0026#34;],\r\u0026#34;todo-tree.highlights.defaultHighlight\u0026#34;: {\r\u0026#34;gutterIcon\u0026#34;: true,\r\u0026#34;foreground\u0026#34;: \u0026#34;#fff\u0026#34;,\r\u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;,\r\u0026#34;opacity\u0026#34;: 50\r},\r\u0026#34;todo-tree.highlights.customHighlight\u0026#34;: {\r\u0026#34;TODO:\u0026#34;: {\r\u0026#34;background\u0026#34;: \u0026#34;#ffbd2a\u0026#34;,\r\u0026#34;iconColour\u0026#34;: \u0026#34;#ffbd2a\u0026#34;\r},\r\u0026#34;FIXME:\u0026#34;: {\r\u0026#34;background\u0026#34;: \u0026#34;#f06292\u0026#34;,\r\u0026#34;iconColour\u0026#34;: \u0026#34;#f06292\u0026#34;,\r\u0026#34;icon\u0026#34;: \u0026#34;flame\u0026#34;\r}\r}\r  參考文獻  可不可以不要寫糙 code系列 第 8 篇 - 不必要的註解 编写高质量可维护的代码：一目了然的注释 導入 TypeScript 應考慮之效益與成本 為你的 JavaScript 項目添加智能提示和類型檢查 [Vuex]在 Vscode 中不使用 Typescript 也能讓 Vuex 讀懂變數的類型 JSDoc中文文档(@use JSDoc) 基于TypeScript的JSDoc注释 @ts-check 立即上手，JSDoc 添加类型 如何使用 JSDoc 保證你的 Javascript 型別安全性 TS in JS 实践指北 [Web翻译]从JavaScript生成TypeScript定义文件 [译] 讨论 JS ⚡：文档 使用 JSDoc 标注类型 利用 VSCode、JSDoc、d.ts 让你的代码更健壮 ES6写JSDoc的一些经验和实例 震驚！JavaScript 竟然可以類型推斷！ \u0026ldquo;無 Typescript\u0026rdquo; 編程 JSDoc support in JavaScript JSDoc支持_TypeScript筆記19 Typescript 初心者手札系列 第 3 篇 - TypeScript 編譯設定 - tsconfig.json vscode中的 jsconfig.json 為什麼世界需要Typescript系列 第 7 篇 - 泛型 - 07 你不知道的 TypeScript 泛型（萬字長文，建議收藏） TypeScript系列（四）泛型 ","description":"剪貼簿複製操作。","id":11,"section":"posts","tags":["JavaScript","註解","JSDoc","型別檢查"],"title":"JavaScript 註解 \u0026 型別檢查","uri":"https://chupai.github.io/posts/2102/comments/"},{"content":" JavaScript筆記 目錄\n \r前言 在瀏覽器中，將資料複製到剪貼簿的方法有三種：\n Document.execCommand() 的 copy 指令 Clipboard API  ClipboardEvent 的 copy、paste 事件  遠古時期還有使用 Flash 來操作剪貼簿，這裡就不討論了。\nDocument.execCommand() Document.execCommand() 的 copy 指令能將選取到的內容複製到剪貼簿。\n1. 複製操作 執行 document.execCommand('copy') 就可以將當前選取範圍複製到剪貼簿。\n1 2 3 4 5  const btnCopy = document.querySelector(\u0026#39;.btnCopy\u0026#39;);\rbtnCopy.addEventListener(\u0026#39;click\u0026#39;, function() {\rdocument.execCommand(\u0026#39;copy\u0026#39;);\r});\r  若要顯示當前選取內容值，可以使用 window.getSelection() 表示當前使用者選取的範圍或光標當前位置，回傳 Selection 物件，並使用 + '' 或 toString() 轉字串。\n1 2 3 4 5 6 7  const btnCopy = document.querySelector(\u0026#39;.btnCopy\u0026#39;);\rbtnCopy.addEventListener(\u0026#39;click\u0026#39;, function() {\rdocument.execCommand(\u0026#39;copy\u0026#39;);\rconst selection = window.getSelection();\ralert(selection.toString());\r});\r  See the Pen document.execCommand - 複製選取內容 by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r2. 複製輸入框內容 document.execCommand('copy') 的缺點就是只能複製選取的內容，如果我們要複製 \u0026lt;textarea\u0026gt; 或 \u0026lt;input type=\u0026quot;text\u0026quot;\u0026gt; 的內容值，可以使用 select() 選取內容值，再執行 document.execCommand('copy')。\n1 2 3 4 5 6 7  const btnCopy = document.querySelector(\u0026#39;.btnCopy\u0026#39;);\rbtnCopy.addEventListener(\u0026#39;click\u0026#39;, function() {\rconst inputText = document.querySelector(\u0026#39;.inputText\u0026#39;);\rinputText.select();\rdocument.execCommand(\u0026#39;copy\u0026#39;);\r});\r  See the Pen document.execCommand - 複製輸入框內容 by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r若 select() 在 iOS 無反應，使用 setSelectionRange 即可：\n1 2  inputText.select();\rinputText.setSelectionRange(0, element.value.length);\r   input.select() does not work on iOS\n 3. 複製指定元素文字 如果我們要複製某一個元素的文字內容，就需要建立選取範圍。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const btnCopy = document.querySelector(\u0026#39;.btnCopy\u0026#39;);\rbtnCopy.addEventListener(\u0026#39;click\u0026#39;, function() {\r// 建立 Range 物件\r const range = document.createRange();\r// 將指定元素內容加到 Range 中\r const texts = document.querySelector(\u0026#39;.texts\u0026#39;);\rrange.selectNode(texts);\r// 取得 Selection 物件\r const selection = window.getSelection();\r// 先清空當前選取範圍\r selection.removeAllRanges();\r// 加入 Range  selection.addRange(range);\rdocument.execCommand(\u0026#39;copy\u0026#39;);\rselection.removeAllRanges();\r});\r  See the Pen document.execCommand - 複製指定元素文字 by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r4. 複製任意內容 如果要將任意內容複製到剪貼簿，需要先建立 \u0026lt;textarea\u0026gt; 元素，並將指定內容設為 value，再插入 DOM 樹中，呼叫 select() 與執行複製，最後刪除 \u0026lt;textarea\u0026gt; 元素。\n1 2 3 4 5 6 7 8 9 10 11  const btnCopy = document.querySelector(\u0026#39;.btnCopy\u0026#39;);\rbtnCopy.addEventListener(\u0026#39;click\u0026#39;, function() {\rconst value = \u0026#39;hello!\u0026#39;;\rconst el = document.createElement(\u0026#39;textarea\u0026#39;);\rel.value = value;\rdocument.body.appendChild(el);\rel.select();\rdocument.execCommand(\u0026#39;copy\u0026#39;);\rdocument.body.removeChild(el);\r});\r  See the Pen document.execCommand - 複製任意內容 by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r優缺點 優點：\n 基本上支援所有主流瀏覽器。  Document API: execCommand: copy - Can I use\n缺點：\n 只能複製選取中的內容，複製任意內容需要建立臨時的 \u0026lt;textarea\u0026gt; 可能導致畫面閃爍，而且還會取消使用者當前選取的內容。 同步操作，若複製大量資料，可能導致頁面卡頓。  Clipboard API Clipboard API 是新一代的剪貼簿操作方法，被設計用來取代 document.execCommand()，能直接訪問剪貼簿，為非同步操作，所有操作方法都會回傳 Promise 物件。\n1. Clipboard 物件 navigator.clipboard 會回傳 Clipboard 物件，所有操作都是透過它進行。\n1  const cb = navigator.clipboard;\r  若 navigator.clipboard 回傳 undefined，表示當前瀏覽器不支援。\n2. 安全和權限 直接訪問剪貼簿的操作其實並不安全，因此 Clipboard API 僅支持通過 HTTPS 提供的頁面（開發環境 localhost 例外），且必須使用者授權才能訪問。\n若是在 \u0026lt;iframe\u0026gt; 中運行，父頁面必須授予 clipboard-read（讀權限） 或 clipboard-write（寫權限）。\n1  \u0026lt;iframe allow=\u0026#34;clipboard-read; clipboard-write\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt;\r   另外，我們可以使用 Permissions API 的 Permissions.query() 查看是否有權訪問剪貼簿。\n3. 操作方法  readText()：讀取剪貼簿純文字內容。 writeText()：對剪貼簿寫入純文字內容。 read()：讀取剪貼簿複合內容。 write()：對剪貼簿寫入複合內容。  以上方法皆會回傳一個 Promise 物件，讀取方法有結果值可以接收，若使用者拒絕授權，會拋出 NotAllowedError。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 讀\rnavigator.clipboard.readText()\r.then((text) =\u0026gt; {\rconsole.log(text);\r})\r.catch((err) =\u0026gt; {\rconsole.error(err);\r});\r// 寫\r\rconst text = \u0026#39;Hello!\u0026#39;;\rnavigator.clipboard.writeText(text)\r.then(() =\u0026gt; {\rconsole.log(\u0026#39;內容已複製\u0026#39;);\r})\r.catch((err) =\u0026gt; {\rconsole.error(err);\r});\r  也可以使用 async/await 語法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  async function readFromClipboard() {\rtry {\rconst text = await navigator.clipboard.readText();\rconsole.log(text);\r} catch (error) {\rconsole.error(error);\r}\r}\rasync function writeToClipboard(text) {\rtry {\rawait navigator.clipboard.writeText(text);\rconsole.log(\u0026#39;內容已複製\u0026#39;);\r} catch (error) {\rconsole.error(error);\r}\r}\r  優缺點 優點：\n 操作簡單，能直接訪問剪貼簿，不需要像 document.execCommand('copy') 需要有選取範圍才能使用。 非同步操作。  缺點：\n 需要使用者授權。 瀏覽器支援度不佳。  Clipboard API: readText- Can I use\nClipboard API: writeText- Can I use\nClipboard API: read- Can I use\nClipboard API: write- Can I use\nClipboardEvent ClipboardEvent 介面描述了與修改剪貼簿相關的事件。當使用者執行剪貼簿相關的操作，我們可以透過監聽 cut 、copy 和 paste，攔截事件以進行操作。\ncut 、copy 和 paste 這些事件僅在當前頁面上操作時觸發。\n這些事件的 event 物件中的 clipboardData 屬性 ，有三個方法可以使用：\n clearData()：清除剪貼簿資料，可指定資料類型，若不指定則清除全部。 getData()：取得剪貼簿資料，需要指定資料類型。 setData()：修改剪貼簿資料，需要指定資料類型。  1. 複製操作 當我們執行複製操作時，可以監聽 copy 事件，將指定內容放入剪貼簿。\n1 2 3 4  document.addEventListener(\u0026#39;copy\u0026#39;, function(event) {\revent.preventDefault();\revent.clipboardData.setData(\u0026#39;text/plain\u0026#39;, \u0026#39;Hello!\u0026#39;);\r});\r  我們有時候複製某些網站的內容時，會自動加上版權出處：\n1 2 3 4 5 6 7  document.addEventListener(\u0026#39;copy\u0026#39;, function(event) {\rconst text = window.getSelection().toString();\rif (text.length \u0026gt; 15) {\revent.preventDefault();\revent.clipboardData.setData(\u0026#39;text/plain\u0026#39;, \u0026#39;來源：竹白記事本\\n\u0026#39; + text);\r}\r});\r  See the Pen copy 事件 by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\rClipboard.js Clipboard.js 是一個將文字複製到剪貼簿的 JavaScript 函式庫，操作簡單、輕量、不依賴其他框架，依賴 Selection API 和 execCommand API 支持主流瀏覽器。\n安裝：\n# NPM 管理\rnpm install clipboard --save\r# 引入 CDN\rhttps://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js\r1. 基本用法 建立實體，傳入要綁定的元素：\n1  const clipboard = new ClipboardJS(\u0026#39;.btn\u0026#39;);\r  可以是 DOM 選擇器 或 HTML 元素 或 HTML 元素陣列。\n首先，若要複製當前的內容，可以使用 data-clipboard-text 設定內容值：　1  \u0026lt;button class=\u0026#34;btn\u0026#34; data-clipboard-text=\u0026#34;hello!\u0026#34;\u0026gt;copy\u0026lt;/button\u0026gt;\r  See the Pen Clipboard.js - 基本用法 by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r如果要從其他元素取值，可以透過 data-clipboard-target 指定目標元素：\n1 2  \u0026lt;input id=\u0026#34;foo\u0026#34; type=\u0026#34;text\u0026#34; value=\u0026#34;https://chupai.github.io/\u0026#34;\u0026gt;\r\u0026lt;button class=\u0026#34;btn\u0026#34; data-clipboard-target=\u0026#34;#foo\u0026#34;\u0026gt;copy\u0026lt;/button\u0026gt;   目標為 \u0026lt;input\u0026gt; 或 \u0026lt;textarea\u0026gt; 可以複製內容值，若是 其他元素，例如 \u0026lt;div\u0026gt; 則複製元素中的文字。\nSee the Pen Clipboard.js - 從其他元素取值 by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r預設操作為 copy 複製，使用 data-clipboard-action 可以設置 cut 剪下。\n1 2  \u0026lt;input id=\u0026#34;foo\u0026#34; type=\u0026#34;text\u0026#34; value=\u0026#34;https://chupai.github.io/\u0026#34;\u0026gt;\r\u0026lt;button class=\u0026#34;btn\u0026#34; data-clipboard-target=\u0026#34;#foo\u0026#34; data-clipboard-action=\u0026#34;cut\u0026#34;\u0026gt;cut\u0026lt;/button\u0026gt;\r  但只對 \u0026lt;input\u0026gt; 和 \u0026lt;textarea\u0026gt; 有作用。\nSee the Pen Clipboard.js - cut by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r2. 事件處理 如果想要在剪貼簿操作完成後執行其他操作，可以使用 success 或 error 自定義事件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  const clipboard = new ClipboardJS(\u0026#39;.btn\u0026#39;);\rclipboard.on(\u0026#39;success\u0026#39;, function(e) {\rconsole.info(\u0026#39;Action:\u0026#39;, e.action);\rconsole.info(\u0026#39;Text:\u0026#39;, e.text);\rconsole.info(\u0026#39;Trigger:\u0026#39;, e.trigger);\re.clearSelection();\r});\rclipboard.on(\u0026#39;error\u0026#39;, function(e) {\rconsole.error(\u0026#39;Action:\u0026#39;, e.action);\rconsole.error(\u0026#39;Trigger:\u0026#39;, e.trigger);\r});\r  3. 進階用法 若不希望修改 HTML 程式碼（也就是使用 data-），建立實體時，還可以傳入一個選項物件。\ntarget 選項為一個函式，需要回傳一個 Node，作為目標元素：\n1 2 3 4 5 6  const clipboard = new ClipboardJS(\u0026#39;.btn\u0026#39;, {\rtarget(trigger) {\r// trigger 參數為觸發元素 Node\r return document.querySelector(\u0026#39;#foo\u0026#39;);\r}\r});\r  See the Pen Clipboard.js - 進階用法 by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\rtext 選項為一個函式，需要回傳一個字串，作為複製內容：\n1 2 3 4 5 6  const clipboard = new ClipboardJS(\u0026#39;.btn\u0026#39;, {\rtext(trigger) {\r// trigger 參數為觸發元素 Node\r return \u0026#39;Hello!\u0026#39;;\r}\r});\r  See the Pen Clipboard.js - 進階用法 text by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\rcontainer 選項能傳入獲得焦點的元素：\n1 2 3  const clipboard = new ClipboardJS(\u0026#39;.btn\u0026#39;, {\rcontainer: document.getElementById(\u0026#39;modal\u0026#39;),\r});\r  4. 清除 若使用 SPA 單頁應用程式，想更精確管理 DOM 生命週期，想清除事件、實體，可以使用 destroy()。\n1 2  const clipboard = new ClipboardJS(\u0026#39;.btn\u0026#39;);\rclipboard.destroy();\r  參考文獻  Async Clipboard API: Accessing the clipboard using JavaScript Cut, Copy and Paste in JavaScript with the Clipboard API A better way to copy text to Clipboard in JavaScript 關於 Clipboard API 主流瀏覽器支援程度分析 Async Clipboard API：異步剪貼板 API 剪贴板操作 Clipboard API 教程 前端操作剪切板不完全指北 知乎上複製回答，剪貼板裡自動加上版權出處的技術js如何實現？ clipboard.js 的源碼分析 clipboard.js 核心代碼解析 ","description":"剪貼簿複製操作。","id":12,"section":"posts","tags":["JavaScript","剪貼簿"],"title":"JavaScript 剪貼簿複製操作","uri":"https://chupai.github.io/posts/2101/clipboard/"},{"content":"\r前言 建構網頁佈局是製作網站的基礎，早期排版是許多開發者的惡夢，但隨著 Flex 如毒品般的出現，用過就回不去了。許多前端框架使用 Flex 實現 Grid system，例如 Bootstrap。但基於 Flex 的 Grid system 靈活度有時候還是不太夠，而且遇到雙向排版時，會使用大量的巢狀結構。\nCSS Grid 的出現，可以說是 CSS 真正的 Grid system，為目前 CSS 唯一的二維佈局。\n瀏覽器支援 主流瀏覽基本上都支持，詳細支援情況可以查閱 can I use 。\n基本概念  網格容器 Grid container，網格系統的外層框架。 網格項目 Grid item，網格容器下的直接子元素。 網格線 Grid line，組成網格的分割線。 網格軌道 Grid track，兩條網格線之間的區域，稱為網格欄 Grid column 或網格列 Grid row。 網格單元格 Grid cell，網格的最小的面積單位。 網格區塊 Grid area，由四條網格線所組成的矩形區域。  建立容器 使用 CSS Grid 的必要屬性。\n1  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r  1 2 3  .container {\rdisplay: grid | inline-grid;\r}\r  宣告以後，該元素會變成 grid container，所有直接子元素會變成 grid item。\n畫格子 接下來我們來畫格子，也就是定義出基礎的 grid cell，我們可以使用 grid-template-rows 和 grid-template-columns 來放置網格內的 grid line，這樣就產生垂直與水平的 grid track，也就是欄與列，兩者交叉就會形成一格一格的 grid cell。\n1 2 3 4 5 6 7  .container {\rgrid-template-rows: \u0026lt;track-size\u0026gt;...;\rgrid-template-columns: \u0026lt;track-size\u0026gt;...;\r/* 簡寫 rows / columns */\rgrid-template: \u0026lt;track-size\u0026gt;... / \u0026lt;track-size\u0026gt;...;\r}\r  track-size 指的是 grid line 之間的距離，也就是 grid track 的尺寸。\n舉例來說：\n1 2 3 4  .container {\rgrid-template-rows: 120px 180px;\rgrid-template-columns: 120px 120px 60px;\r}\r  上面程式碼的效果如下，2 列 3 欄會形成 6 格 grid cell：\n我們可以開啟 Chrome Devtool 查看：\n接著放入 grid item：\n1 2 3 4  .item {\rborder-radius: 12px;\rborder: 2px solid #222;\r}\r  1 2 3 4 5 6 7 8  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt;\r\u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r  預設的情況下，grid item 會各佔一格 grid cell。\nSee the Pen CSS Grid - 畫格子 by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r1. fr 單位 如果 grid container 有定義寬高：\n1 2 3 4 5  .container {\rwidth: 300px;\rheight: 300px;\rdisplay: grid;\r}\r  我們可以使用 CSS Grid 專用單位 fr（fraction） 依照比例分配剩餘空間：\n1 2 3 4  .container {\rgrid-template-rows: 100px 1fr;\rgrid-template-columns: 1fr 3fr;\r}\r  使用 % 需要手動計算，而 fr 只需要設置幾等份就好，非常方便。\nSee the Pen CSS Grid - fr 單位 by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r2. repeat() 函式 若尺寸值相同，可以使用 repeat() 表示重複的值：\n1 2 3 4 5  .container {\rgrid-template-rows: repeat(3, 1fr);\r/* 等同 */\rgrid-template-rows: 1fr 1fr 1fr;\r}\r  1 2 3 4 5  .container {\rgrid-template-rows: 10px repeat(3, 1fr) 10px;\r/* 等同 */\rgrid-template-rows: 10px 1fr 1fr 1fr 10px;\r}\r  1 2 3 4 5  .container {\rgrid-template-rows: repeat(3, 1fr 2fr);\r/* 等同 */\rgrid-template-rows: 1fr 2fr 1fr 2fr 1fr 2fr;\r}\r  1 2 3 4 5  .container {\rgrid-template-rows: repeat(2, 1fr) 10px repeat(2, 2fr);\r/* 等同 */\rgrid-template-rows: 1fr 1fr 10px 2fr 2fr;\r}\r  3. 最大最小值 如果我們的 grid container 會隨著視窗做變化，當你使用 fr 或 auto 作為 track-size 大小時，要避免 grid track 太大或太小，可以使用 minmax() 函式可以定義最小最大值，。\n舉例來說，欄寬最小值 auto、最大值不超過 150px：\n1 2 3 4 5 6  .container {\rwidth: 100%;\rdisplay: grid;\rgrid-template-rows: 60px;\rgrid-template-columns: minmax(auto, 150px) 100px 50px;\r}\r  See the Pen CSS Grid - minmax by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r4. auto-fill、auto-fit 使用 repeat() 時，若不知道要重複的數量，可以用 auto-fill 或 auto-fit 自動將 grid track 填滿容器。\n兩者差異在於，auto-fit 沒有用到的 grid track 會被設為 0px。\n1 2 3  \u0026lt;div class=\u0026#34;container auto-fill\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026#34;container auto-fit\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14  .container {\rbackground: #eee;\rwidth: 200px;\rdisplay: grid;\rgrid-template-rows: repeat(4, 50px);\r}\r.auto-fill {\rgrid-template-columns: repeat(auto-fill, 50px);\r}\r.auto-fit {\rgrid-template-columns: repeat(auto-fit, 50px);\r}\r  接下來我們放入 grid item，兩者基本上沒什麼差別。\nSee the Pen CSS Grid - auto-fill、auto-fit by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r但如果我們將欄的 track-size 改成 minmax(50px, 1fr) 就會有明顯的差異。\nSee the Pen CSS Grid - auto-fill、auto-fit 差異 by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r放置網格項目 預設的情況下，grid item 各佔一格 grid cell。不過我們能分別定義 grid item 要佔的空間，也就是 grid area。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  .item {\rgrid-row-start: \u0026lt;name\u0026gt;;\rgrid-row-end: \u0026lt;name\u0026gt;;\rgrid-column-start: \u0026lt;name\u0026gt;;\rgrid-column-end: \u0026lt;name\u0026gt;;\r/* 簡寫 start / end */\rgrid-row: \u0026lt;name\u0026gt; / \u0026lt;name\u0026gt;;\rgrid-column: \u0026lt;name\u0026gt; / \u0026lt;name\u0026gt;;\r/* 簡寫 row start / column start / row end / column end*/\rgrid-area: \u0026lt;name\u0026gt; / \u0026lt;name\u0026gt; / \u0026lt;name\u0026gt; / \u0026lt;name\u0026gt;;\r}\r  start 與 end 分別表示 起始 與 結束 的grid line。\nGrid line 是有名稱的，預設為數字編號，由左至右（由上至下）為正值，由右至左（由下至上）則為負值。\n舉例來說：\n1 2 3 4 5 6  .item {\rgrid-row-start: 2;\rgrid-row-end: 5;\rgrid-column-start: 2;\rgrid-column-end: 4;\r}\r  See the Pen CSS Grid - 格線 by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r1. 跨度 span 除了指定 grid line 名稱，也可以使用 跨度 span \u0026lt;number\u0026gt; 表示要跨幾格 grid cell。\n舉例來說，從第 5 條水平線往上跨 2 格、從第 2 條垂直線往左跨 3 格：\n1 2 3 4 5 6  .item {\rgrid-row-start: span 2;\rgrid-row-end: 5;\rgrid-column-start: 2;\rgrid-column-end: span 3;\r}\r  See the Pen CSS Grid - 欄位數 by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r2. 自訂義名稱 除了預設編號，grid line 能使用自訂義名稱：\n1 2 3 4 5 6 7  .container {\rgrid-template-rows: [name] \u0026lt;track-size\u0026gt; [name]...;\rgrid-template-columns: [name] \u0026lt;track-size\u0026gt; [name]...;\r/* 簡寫 rows / columns */\rgrid-template: [name] \u0026lt;track-size\u0026gt; [name]... / [name] \u0026lt;track-size\u0026gt; [name]...;\r}\r  舉例來說：\n1 2 3 4 5 6 7 8 9  .container {\rgrid-template-rows: [y1] 1fr [y2] 1fr [y3] 1fr [y4] 1fr [y5] 1fr [y6];\rgrid-template-columns: [x1] 1fr [x2] 1fr [x3] 1fr [x4] 1fr [x5] 1fr [x6];\r}\r.item {\rgrid-row: y1 / y4;\rgrid-column: x1 / x5;\r}\r  See the Pen CSS Grid - 自訂義名稱 by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r3. 順序 當我們手動放置 grid item 時，它們的 grid area 可能會有重疊的部分，若要改變顯示順序，可以使用 z-index 分層或 order 排序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  .item-1 {\rbackground: rgba(255, 0, 0, 0.8);\rgrid-row: 1/ 4;\rgrid-column: 1 / 5;\rz-index: 2;\r}\r.item-2 {\rbackground: rgba(0, 255, 0, 0.8);\rgrid-row: 3 / 5;\rgrid-column: 2 / 6;\rz-index: 3;\r}\r.item-3 {\rbackground: rgba(0, 0, 255, 0.8);\rgrid-row: 2 / 6;\rgrid-column: 1 / 3;\rz-index: 1;\r}\r  See the Pen CSS Grid - 自訂義名稱 by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r4. auto 預設的情況下，grid item 各佔一格 grid cell，因為 grid-area 的預設值為 auto，grid item 會被以預設跨度 1 自動放置。\nauto 會自動尋找下一條可用的 grid line，如果要將 grid item 自動跨 2 欄 grid item 不重疊，只需要設置 grid-column-end：\n1 2 3 4  .item {\rgrid-column-start: auto: /* 預設值 auto */\rgrid-column-end: span 2;\r}\r  See the Pen CSS Grid - auto by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r5. 區塊 我們還可以使用 grid-template-areas 定義 grid area，再利用 grid-area 對應到相對的名稱。\n1 2 3  .container {\rgrid-template-areas: \u0026lt;string\u0026gt;;\r}\r  每個字串都代表一列，使用要定義的 grid area 名稱圍成矩形，沒有要使用到的 grid cell 可以使用任何字元跳過。\n舉例來說：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  .container {\r/* ... */\rgrid-template-areas:\r\u0026#39;xx xx . . .\u0026#39;\r\u0026#39;xx xx . yy yy\u0026#39;\r\u0026#39;. . . yy yy\u0026#39; \u0026#39;zz zz . yy yy\u0026#39;\r\u0026#39;zz zz . . .\u0026#39;;\r}\r.item-1 {\rgrid-area: x;\r}\r.item-2 {\rgrid-area: y;\r}\r.item-3 {\rgrid-area: z;\r}\r  注意，定義 grid area 只能是矩形的範圍，非矩形為無效宣告。\nSee the Pen CSS Grid - 命名 by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r間距 Grid area 之間的 間距（gutter）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  .container {\r/* 標準 */\rrow-gap: \u0026lt;line-size\u0026gt;;\rcolumn-gap: \u0026lt;line-size\u0026gt;;\r/* 簡寫 row column */\rgap: line-size\u0026gt; | \u0026lt;line-size\u0026gt; \u0026lt;line-size\u0026gt;;\r/* 舊語法 */\rgrid-row-gap: \u0026lt;line-size\u0026gt;;\rgrid-column-gap: \u0026lt;line-size\u0026gt;;\r/* 簡寫 row column */\rgrid-gap: \u0026lt;line-size\u0026gt; | \u0026lt;line-size\u0026gt; \u0026lt;line-size\u0026gt;;\r}\r  line-size 只能使用長度值或百分比。\nSee the Pen CSS Grid - 間距 by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r對齊 1. content 當網格環境小於 grid content 時，可以使用以下屬性對齊。\njustify-content 水平對齊、align-content 垂直對齊：\n start：靠左對齊。 end：靠右對齊。 center：靠中間對齊 stretch：依照比例拉寬到滿版。 space-around：在各格線間放入多餘的空白，包含開頭和結尾。 space-between：只在各格線間放入多餘的空白。 space-evenly：效果同 space-around 但開頭和結尾的空白較多。  place-content 是兩者的簡寫，align-content 為第一個值、justify-content 為第二值，若兩者相等，可以只設置一個值。\n1 2 3 4 5 6 7 8 9 10 11  .container {\rwidth: 300px;\rheight: 300px;\rdisplay: grid;\rgrid-template-rows: 50px 50px 50px;\rgrid-template-columns: 50px 50px 50px;\rjustify-content: space-between;\ralign-content: space-between;\r}\r  See the Pen CSS Grid - 定位模式 content by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r2. items 預設的情況下，我們的 grid item 大小會等於 grid area。但如果 grid item 有定義尺寸，小於 grid area 時，可以使用以下屬性對齊。\njustify-items 水平對齊、align-items 垂直對齊：\n start：靠左對齊。 end：靠右對齊。 center：靠中間對齊 stretch：依照比例拉寬到滿版。  place-items 則是兩者的簡寫，align-items 為第一個值、justify-items 為第二值，若兩者相等，可以只設置一個值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  .container {\rwidth: 300px;\rheight: 300px;\rdisplay: grid;\rgrid-template-rows: 100px 100px 100px;\rgrid-template-columns: 100px 100px 100px;\rjustify-items: center;\ralign-items: center;\r}\r.item {\rwidth: 50px;\rheight: 50px;\r}\r  See the Pen CSS Grid - 定位模式 items by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r3. self 如果你的 grid item 要單獨對齊，可以在 grid item 中使用以下屬性對齊。\njustify-self 水平對齊、align-self 垂直對齊：\n start：靠左對齊。 end：靠右對齊。 center：靠中間對齊 stretch：依照比例拉寬到滿版。  place-self 則是兩者的簡寫，align-self 為第一個值、justify-self 為第二值，若兩者相等，可以只設置一個值。\n隱式網格 在 grid cell 有限的情況下，如果 grid item 過多，就會自動增加 grid track，也就是 隱式網格。\n1. 隱式網格的大小 隱式網格的 grid track 預測為自動大小，但可以透過 grid-auto-rows 和 grid-auto-columns 定義。\n1 2 3 4  .container{\rgrid-auto-rows: \u0026lt;track-size\u0026gt; ...;\rgrid-auto-columns: \u0026lt;track-size\u0026gt; ...;\r}\r  舉例來說，我們只定義 2 欄 1 列：\n1 2 3 4 5 6  .container {\rgrid-template-rows: 60px;\rgrid-template-columns: repeat(2, 60px);\rgrid-auto-rows: 120px;\r}\r  如果我們放置 4 個 grid track，會自動新增第 2 列 grid track。\nSee the Pen CSS Grid - 隱式 by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r網格流向 預設的情況下，網格流向為 row，也就是 grid item 自動放置時，會水平往右排列。\n我們可以使用 grid-auto-flow 改變網格的流向：\n1 2 3  .container {\rgrid-auto-flow: row | column | row dense | column dense;\r}\r  舉例來說，將流向改成 column 垂直向下：\n1 2 3 4 5 6  .container {\rdisplay: grid;\rgrid-template-rows: repeat(3, 60px);\rgrid-template-columns: repeat(3, 60px);\rgrid-auto-flow: column;\r}\r  See the Pen CSS Grid - 流向 by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r若加上 dense，會嘗試將 grid track 填滿，因此可能會改變 grid item 順序，要特別留意。\n1 2 3 4 5 6  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt;\r\u0026lt;div class=\u0026#34;item item-2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026#34;item item-2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026#34;item item-1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026#34;item item-1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14  .container {\rdisplay: grid;\rgrid-template-rows: repeat(3, 60px);\rgrid-template-columns: repeat(3, 60px);\rgrid-auto-flow: row dense;\r}\r.item-1 {\rgrid-column-end: span 1;\r}\r.item-2 {\rgrid-column-end: span 2;\r}\r  預設的情況下，第 1 列會有空隙，但使用 row dense 後，會將後面較小的 item-1 往前填滿。\nSee the Pen CSS Grid - 流向 dense by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r佈局範例 1. 聖杯佈局 1 2 3 4 5 6 7  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt;\r\u0026lt;header\u0026gt;Header\u0026lt;/header\u0026gt;\r\u0026lt;aside\u0026gt;Aside\u0026lt;/aside\u0026gt;\r\u0026lt;main\u0026gt;Main\u0026lt;/main\u0026gt;\r\u0026lt;aside\u0026gt;Aside\u0026lt;/aside\u0026gt;\r\u0026lt;footer\u0026gt;Footer\u0026lt;/footer\u0026gt;\r\u0026lt;/div\u0026gt;\r  1 2 3 4 5 6 7 8 9 10 11  .container {\rwidth: 100%;\rmin-width: 600px;\rdisplay: grid;\rgrid-template-columns: 100px auto 100px;\rgap: 10px;\r}\rheader, footer {\rgrid-column: 1 / 4;\r}\r  See the Pen CSS Grid - 聖杯佈局 by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r移動端響應式佈局，可以加上媒體查詢：\n1 2 3 4 5  @media all and (max-width: 700px) {\raside, main {\rgrid-column: 1 / 4;\r}\r}\r  See the Pen CSS Grid - 聖杯佈局 響應式 by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r\r2. 960 grid system See the Pen CSS Grid - 960 grid system by CHUPAIWANG\r(@CHUPAIWANG) on CodePen.\r","description":"CSS Grid","id":13,"section":"posts","tags":["CSS Grid","CSS排版"],"title":"CSS Grid","uri":"https://chupai.github.io/posts/2101/css_grid/"},{"content":"Vue CLI 安裝 Tailwind CSS v2.0。\n\r簡介  Tailwind CSS\n Tailwind CSS 是一個 Utility CSS 框架。\n如果你有用過 Bootstrap，一定有用過它的通用類別，而 Tailwind 就是 100% 的通用類別不含 UI 元件，你可以更加輕鬆的客製化自己的元件。\n Tailwind 的實際案例，可以參考 Built with Tailwind。 更多關於 Tailwind 的資源，可以參考 Awesome Tailwind CSS。  2020.11.19 Tailwind 升級到了 v2.0，詳細的更新內容可以參考 Tailwind CSS v2.0。\n安裝 Tailwind 是 PostCSS 的套件，但不一定要使用 PostCSS 作為預處理器才能使用 Tailwind。如果只是簡單的專案或是體驗 Tailwind，可以使用 Tailwind CLI 來編譯 Tailwind CSS。\n詳細的安裝流程，這裡就不多加說明，可以參考 官方文件。\nVue CLI Vue CLI 內部本來就使用了 PostCSS 預設開啟 Autoprefixer，你只要安裝 Tailwind 和新增 postcss.config.js、tailwind.config.js 設定檔就可以使用了。\n但是 v2.0 版本的 Tailwind 依賴於 PostCSS 8。而 Vue CLI 目前使用的是 PostCSS 7，因此執行後會現下列錯誤訊息：\nError: PostCSS plugin tailwindcss requires PostCSS 8.\r 解決辦法就是，重新安裝官方提供的 PostCSS 7 兼容版本：\nnpm uninstall tailwindcss\rnpm install tailwindcss@npm:@tailwindcss/postcss7-compat\r你若是還有安裝使用其他 PostCSS 套件，最新版已經支援 PostCSS 8，記得降版本。\n","description":"Vue CLI 安裝 Tailwind CSS v2.0。","id":14,"section":"posts","tags":["Vue","TailwindCSS"],"title":"Vue CLI 安裝 TailwindCSS v2.0","uri":"https://chupai.github.io/posts/2011/tailwindcss/"},{"content":"Vue Router篇\n\r 這週是六角鼠年鐵人賽最後一週，Vue 筆記的第五篇。\n 竹白的 Vue 記事本 目錄\n Vue - Router篇：\n Vue Router - 基礎 Vue Router - 動態路由匹配 Vue Router - 巢狀路由 Vue Router - 程式控制 Vue Router - 命名路由 \u0026amp; 命名視圖 Vue Router - 重新導向 \u0026amp; 别名 Vue Router - 路由元件傳遞 Vue Router - 導航守衛 Vue Router - 權限控制 Vue Router - 滾動行為 Vue Router - 模組化管理  四十週連續不中斷的六角鼠年鐵人賽終於完賽了 😂，不過 Vue 筆記會繼續更新。\n","description":"Vue Router篇。","id":15,"section":"posts","tags":["Vue","w3HexSchool"],"title":"Vue - Router","uri":"https://chupai.github.io/posts/2011/vue_vuex/"},{"content":" 竹白的 Vue 記事本 目錄\n \r基本結構 路由配置基本結構：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  import Vue from \u0026#39;vue\u0026#39;; import VueRouter from \u0026#39;vue-router\u0026#39;; import Home from \u0026#39;../views/Home.vue\u0026#39;; Vue.use(VueRouter); // 定義路由 const routes = [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;Home\u0026#39;, component: Home, }, { // ...  }, ]; // 設定 const router = new VueRouter({ mode: \u0026#39;history\u0026#39;, routes, scrollBehavior(to, from, savedPosition) { if (savedPosition) { return savedPosition; } else { return { x: 0, y: 0 }; } }, }); // 守衛 router.beforeEach((to, from, next) =\u0026gt; { next(); }); export default router;   模組化管理 如果專案越來越複雜，路由隨之變得越多，就需要將路由拆分，方便管理維護。\n結構：\n/router ├── index.js # 配置檔 ├── common.js # 通用路由 | └── /modules ├── index.js ├── home.js ├── user.js ├── ... 通用路由：\n1 2 3 4 5 6 7 8 9 10 11 12  // common.js  export default [ { path: \u0026#39;/\u0026#39;, redirect: \u0026#39;/index\u0026#39;, }, { path: \u0026#39;*\u0026#39;, redirect: \u0026#39;/404\u0026#39;, }, ];   路由模組：\n1 2 3 4 5 6 7 8 9 10 11  // user.js  import User from \u0026#39;../../views/User.vue\u0026#39;; export default [ { path: \u0026#39;/user\u0026#39;, name: \u0026#39;user\u0026#39;, component: User, }, ];   使用 ES6 展開運算子整合到配置檔：\n1 2 3 4 5 6 7 8 9 10 11 12 13  // ...  import home from \u0026#39;./modules/home\u0026#39;; import user from \u0026#39;./modules/user\u0026#39;; import error from \u0026#39;./modules/error\u0026#39;; import common from \u0026#39;./modules/common\u0026#39;; const routes = [ ...home, ...user, ...error, ...common, ];   延遲加載 當我們專案到達一定程度時，打包後的 JavaScript bundle 會變得非常大，一次性加載，可能會花費較長時間，影響使用者體驗。\n大多數情況下，使用者訪問網站時。並不需要立即從 JavaScript bundle 中取得全部的程式碼。\n因此我們可以使用延遲加載拆分 bundle。webpack 在打包的過程中，非同步引入的資源會被打進單獨的 chunk 檔案，在需要執行該檔案時才會加載。\n原本的寫法：\n1  import Foo from \u0026#39;./Foo.vue\u0026#39;;   改用延遲加載寫法：\n1  const Foo = () =\u0026gt; import(\u0026#39;./Foo.vue\u0026#39;);   如果路由使用到多個元件，可以使用特殊的特殊的註釋語法\n命名 chunk 將它們打包載同一個 chunk 中：\n1 2 3  const Foo = () =\u0026gt; import(/* webpackChunkName: \u0026#34;group-foo\u0026#34; */ \u0026#39;./Foo.vue\u0026#39;); const Bar = () =\u0026gt; import(/* webpackChunkName: \u0026#34;group-foo\u0026#34; */ \u0026#39;./Bar.vue\u0026#39;); const Baz = () =\u0026gt; import(/* webpackChunkName: \u0026#34;group-foo\u0026#34; */ \u0026#39;./Baz.vue\u0026#39;);   ","description":"模組化管理。","id":16,"section":"posts","tags":["Vue","Vue Router"],"title":"Vue Router - 模組化管理","uri":"https://chupai.github.io/posts/vue/router/module/"},{"content":" 竹白的 Vue 記事本 目錄\n \r這個功能只在支持 history.pushState 的瀏覽器中可用。\r 1 2 3 4 5 6  const router = new VueRouter({ routes: [...], scrollBehavior(to, from, savedPosition) { // return {}  }, });   scrollBehavio 方法接收參數為：\n to：即將要進入的目標路由物件。 from：當前導航正要離開的路由物件。 savedPosition：這個參數只有當 popstate 導航（透過瀏覽器的前進、後退按鈕觸發）時才可用。  這個方法需要回傳一個滾動位置物件，有兩種格式：\n { x: number, y: number } { selector: string, offset? : { x: number, y: number }}（offset 只在 2.6.0+ 支持）  如果回傳一個 falsy 值或空物件，則不會發生滾動。\n對於所有路由導航，簡單地讓頁面滾動到頂部：\n1 2 3  scrollBehavior(to, from, savedPosition) { return { x: 0, y: 0}; }   若是透過瀏覽器的前進、後退按鈕切換路由時，可以使用 savedPosition 取得上次位置：\n1 2 3 4 5 6 7  scrollBehavior(to, from, savedPosition) { if (savedPosition) { return savedPosition; } else { return { x: 0, y: 0}; } }   若希望路由切換時，讓頁面滾動到指定位置，可以利用 hash，模擬「滾動到錨點」的行為：\n\u0026lt;router-link :to=\u0026quot;{name: 'nav', hash: '#nav'}\u0026quot;\u0026gt;nav\u0026lt;/router-link\u0026gt; 1 2 3 4 5  scrollBehavior(to, from, savedPosition) { if (to.hash) { return { selector: to.hash }; } }   若是希望滾動位置可以預留空間，可以加上 offset 屬性：\n1 2 3 4 5 6 7 8  scrollBehavior(to, from, savedPosition) { if (to.hash) { return { selector: to.hash, offset: { x: 0, y: 100 }, }; } }   非同步滾動 2.8.0 新增了非同步滾動，可以回傳一個 Promise 來處理\n1 2 3 4 5 6 7  scrollBehavior(to, from, savedPosition) { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve({ x: 0, y: 0 }); }, 500); }); },   ","description":"滾動行為。","id":17,"section":"posts","tags":["Vue","Vue Router"],"title":"Vue Router - 滾動行為","uri":"https://chupai.github.io/posts/vue/router/scroll/"},{"content":" 竹白的 Vue 記事本 目錄\n \rMeta Fields 如果你的頁面需要通過會員登入驗證才能訪問，或者是不同角色（例如：訪客、會員、管理員）的權限判斷，定義路由時，可以設置一個 meta 選項，用來儲存一些識別用資料。\n舉例來說，路由 /user 需要通過驗證才能訪問。\n如果直接在 beforeEach 全域前置守衛中用路徑判斷：\n1 2 3 4 5 6 7  beforeEach((to, from, next)=\u0026gt; { if (to.path=\u0026#34;/user\u0026#34; \u0026amp;\u0026amp; !isAuthenticated) { next({ name: \u0026#39;Login\u0026#39; }); } else { next(); } });   這樣會遇到一些問題：\n /user 下的子路由無法檢查； 其它路由也需要通過驗證時，判斷寫起來很麻煩。  我們可以在 /user 路由定義一個 meta：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  const router = new VueRouter({ routes: [ { path: \u0026#39;/\u0026#39;, component: Home, }, { path: \u0026#39;/login\u0026#39;, name: \u0026#39;Login\u0026#39; component: Login, }, { path: \u0026#39;/user\u0026#39;, component: User, meta: { requiresAuth: true, } } ] });   這樣我們就只需要訪問路由物件的 meta 是否有我們定義屬性，用它來判斷是否需要驗證：\n1 2 3 4 5 6 7  beforeEach((to, from, next)=\u0026gt; { if (to.meta.requiresAuth \u0026amp;\u0026amp; !isAuthenticated) { next({ name: \u0026#39;Login\u0026#39; }); } else { next(); } });   isAuthenticated 為驗證狀態，通常會透過 Vuex 全域管理控制。使用者輸入帳號密碼通過後端伺服器驗證之後，後端會回傳一個 token，前端可以透過 localStorage 或 cookie 將它緩存，接下來只需要驗證是否存在、過期、正確性。\r 如果有子路由，你又不想為每個子路由都重複設置 meta，可以使用 $route.matched 路由紀錄來判斷：\n1 2 3 4 5 6 7  router.beforeEach((to, from, next) =\u0026gt; { if (to.matched.some((record) =\u0026gt; record.meta.requiresAuth) \u0026amp;\u0026amp; !isAuthenticated) { next({ name: \u0026#39;Login\u0026#39; }); } else { next(); } });   matched 為陣列，裡面包含匹配成功的路由紀錄，因此使用 some() 遍歷檢查是否需要驗證。\nCodePen Demo：Vue 2.x - Meta Fields 簡易範例\nAddRoutes 上面的作法是前端寫好所有路由，後端在回傳當前使用者的權限，根據預先定義好的路由規則進行驗證。\n權限控制的另一種作法就是，一開始前端規劃的路由都是不需要驗證的，而需要驗證路由的則是從後端取得後，以動態添加的方式加載到路由實體中。\naddRoutes 動態添加更多的路由規則：\n1  router.addRoutes(routes: Array\u0026lt;RouteConfig\u0026gt;)   參數必須是一個符合 routes 選項要求的陣列。\n","description":"權限控制。","id":18,"section":"posts","tags":["Vue","Vue Router"],"title":"Vue Router - 權限控制","uri":"https://chupai.github.io/posts/vue/router/accesscontrol/"},{"content":" 竹白的 Vue 記事本 目錄\n \r什麼是導航守衛 導航 指的是路由的改變。路由路徑是能任意輸入的，當我們需要判斷權限或登錄狀態來決定使用者使否能訪問路由時，就會用到 導航守衛（Navigation Guards），在路由發生變化時，做出相對應的處理。\n簡單來說，就是在路由改變的過程中，會有一些函式鉤子可以讓我們用來處理一些事情。\n完整的導航解析流程 先來看官方提供的導航解析流程：\n 導航被觸發。 在失活的元件裡呼叫 beforeRouteLeave 守衛。 呼叫全域的 beforeEach 守衛。 在重用的元件裡呼叫 beforeRouteUpdate 守衛（2.2+）。 在路由配置裡呼叫 beforeEnter。 解析非同步路由元件。 在被激活的元件裡呼叫 beforeRouteEnter。 呼叫全域的 beforeResolve 守衛（2.5+）。 導航被確認。 呼叫全域的 afterEach 鉤子。 觸發 DOM 更新。 呼叫 beforeRouteEnter 守衛中傳給 next 的回呼函式，創建好的元件實例會作為回呼函式的參數傳入。  導航守衛可以分成三種類型：\n 全域守衛 路由獨享守衛 元件內守衛  全域守衛 全域守衛會監測所有路由，按順序分為：\n beforeEach beforeResolve afterEach  1. 前置守衛 全域前置守衛會在跳轉前觸發，常用於登入驗證。\n使用 router 物件的 beforeEach 方法註冊：\n1 2 3 4 5 6 7  // router.js  const router = new VueRouter({ ... }); router.beforeEach((to, from, next) =\u0026gt; { // ... });   回呼函式接收的三個參數分別為：\n to：即將要進入的目標路由物件。 from：當前導航正要離開的路由物件。 next：為一個函式，用來交出控制權或者中斷導航。  next 函式會根據傳入的參數而有不同的行為：\n next()：不傳入參數，會進入下一個守衛。如果全部鉤子都執行完，導航狀態就是 confirmed（確認的）。 next(false)：中斷當前導航。 next('/') 或 next({ path: '/' })：跳轉至指定路由。 next(error)：如果傳入一個 Error 實體，導航會被終止且該錯誤會被傳遞給 router.onError()。  :::warning\nnext 函式一定要呼叫，因為守衛式非同步解析執行，此時導航在所有守衛 resolve 完之前一直處於 等待中。但要注意，只能呼叫一次。\n:::\n2. 解析守衛 在 2.5.0 之後的版本，可以用 router.beforeResolve 註冊一個解析守衛\n1 2 3  router.beforeResolve((to, from, next) =\u0026gt; { // ... });   用法基本上與 beforeEach 相同，區別在於被呼叫的時間點：一樣是在跳轉前觸發，但會在 beforeEnter 呼叫之後，也就是 所有元件內守衛和非同步路由元件被解析之後 才呼叫。\n3. 後置鉤子 afterEach 會在導航被確認後觸發，所以稱為 後置鉤子 而不是守衛。\n1 2 3  router.afterEach((to, from) =\u0026gt; { // ... });   它沒有 next 參數可用，因此不會改變導航本身。\n路由獨享的守衛 如果你不想全域設置守衛，可以單獨在指定路由上設置守衛。\n定義 beforeEnter 守衛：\n1 2 3 4 5 6 7 8 9 10 11  const router = new VueRouter({ routes: [ { path: \u0026#39;/foo\u0026#39;, component: Foo, beforeEnter: (to, from, next) =\u0026gt; { // ...  }, }, ], });   參數與 beforeEach 相同。\n元件內的守衛 在元件內也可直接定義以下路由導航守衛：\n beforeRouteEnter beforeRouteUpdate beforeRouteLeave  1 2 3 4 5 6 7 8 9 10 11 12  const Foo = { template: `...`, beforeRouteEnter (to, from, next) { // ...  }, beforeRouteUpdate (to, from, next) { // ...  }, beforeRouteLeave (to, from, next) { // ...  } }   1. beforeRouteEnter beforeRouteEnter 守衛內 不能 使用 this 獲取元件實體，因為它是在導航 confirm（確認）前被呼叫，新元件還尚未建立。\n不過，我們可以透過傳遞一個回呼函式給 next 來訪問元件實體：\n1 2 3 4 5  beforeRouteEnter (to, from, next) { next(vm =\u0026gt; { // 透過 vm 訪問元件實體  }) }   :::warning\nbeforeRouteEnter 是唯一支持 next 傳遞回呼函式的守衛。對於 beforeRouteUpdate 和  beforeRouteLeave 來說，已經透過 this 取得元件實體，所以沒必要。\n:::\n2. beforeRouteUpdate beforeRouteUpdate 會在當前路由改變，但是該元件被覆用時呼叫。\n舉例來說，對於一個帶有動態參數的路徑 /foo/:id，在 /foo/1 和 /foo/2 之間跳轉的時候，由於會渲染同樣的 Foo 元件，因此元件實體會被覆用。這個情況下的變化，就會觸發 Foo 元件的 beforeRouteUpdate。\n通常用於父路由監聽子路由的變化。\n3. beforeRouteLeave beforeRouteLeave 會在導航離開該元件的對應路由時呼叫。\n通常用於以下情況：假設當前路由為一個修改頁面，當使用者還未保存就突然離開，我們可以透過 next(false) 來取消。\n1 2 3 4 5 6 7 8 9 10 11  beforeRouteLeave (to, from, next) { if (this.isConfirmed) { next(); } else { if (confirm(\u0026#39;還未保存，確定要離開嗎\u0026#39;)) { next(); } else { next(false); } } }   ","description":"導航守衛。","id":19,"section":"posts","tags":["Vue","Vue Router"],"title":"Vue Router - 導航守衛","uri":"https://chupai.github.io/posts/vue/router/navigationguards/"},{"content":" 竹白的 Vue 記事本 目錄\n \r路由元件傳遞 如果我們直接在元件內使用 $router 會使之與其對應路由形成高度耦合，那麼該元件就只能用於特定的 URL 上使用，限制了其靈活性。\n舉例來說，如果直接在元件內透過 $router 取得路徑參數：\n1 2 3 4 5 6 7 8 9  // component const User = { template: \u0026#39;\u0026lt;div\u0026gt;User {{ $route.params.id }}\u0026lt;/div\u0026gt;\u0026#39;, }; // router const router = new VueRouter({ routes: [{ path: \u0026#39;/user/:id\u0026#39;, component: User }], });   那麼這個 User 元件就只能用於特定路徑參數的 URL。\nProps 我們可以改用 props 傳入路徑參數。\n如果 props 選項被設置為 true，$route.params 將會被設置為元件的屬性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // component const User = { props: [\u0026#39;id\u0026#39;], template: \u0026#39;\u0026lt;div\u0026gt;User {{ id }}\u0026lt;/div\u0026gt;\u0026#39;, }; // router const router = new VueRouter({ routes: [ { path: \u0026#39;/user/:id\u0026#39;, component: User, props: true }, ], });   這樣子我的元件的 id 就不一定只能透過 $router 取得。\nCodePen Demo：Vue 2.x - 路由元件傳遞 props\n如果使用命名視圖，會對應到多個元件，因此需要分別設置：\n1 2 3 4 5 6 7 8 9  const router = new VueRouter({ routes: [ { path: \u0026#39;/user/:id\u0026#39;, components: { default: User, sidebar: Sidebar }, props: { default: true, sidebar: false }, }, ], });   1. 物件模式 除了上述的布林模式，我們也可以傳遞物件，它會被按原樣設置為元件屬性。當 props 是靜態的時候有用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // component const Foo = { props: [\u0026#39;boo\u0026#39;], template: \u0026#39;\u0026lt;div\u0026gt;{{ boo }}\u0026lt;/div\u0026gt;\u0026#39;, }; // router const router = new VueRouter({ routes: [ { path: \u0026#39;/foo\u0026#39;, component: Foo, props: { boo: \u0026#39;boo\u0026#39; }, }, ], });   CodePen Demo：Vue 2.x - 路由元件傳遞 props 物件模式\n2. 函式模式 如果使用函式模式，我們可以透過參數取得 route 物件：\n1 2 3 4 5 6 7 8 9 10 11  const router = new VueRouter({ routes: [ { path: \u0026#39;/user/:id\u0026#39;, component: User, props: (route) =\u0026gt; ({ id: route.params.id, }), }, ], });   CodePen Demo：Vue 2.x - 路由元件傳遞 props 函式模式\n","description":"路由元件傳遞。","id":20,"section":"posts","tags":["Vue","Vue Router"],"title":"Vue Router - 路由元件傳遞","uri":"https://chupai.github.io/posts/vue/router/passingprops/"},{"content":" 竹白的 Vue 記事本 目錄\n \r重新導向 重新導向之前有稍微提到，也就是將當前路由轉向其它指定路徑路由。\n設置 redirect 選項，當我們訪問 /a 時，URL 將會被替換成 /b，然後匹配路由也為 /b：\n1 2 3 4 5 6 7 8 9 10  const routes = [ { path: \u0026#39;/a\u0026#39;, redirect: \u0026#39;/b\u0026#39;, }, { path: \u0026#39;/b\u0026#39;, // ...  }, ];   簡單來說就是 /a 會被重新導向至 /b。\nCodePen Demo：Vue 2.x - 重新導向\n除了字串路徑，也可以傳遞路徑物件：\n1  redirect: { name: \u0026#39;foo\u0026#39; }   或者是函式：\n1 2 3 4  redirect: to =\u0026gt; { // 方法接收 目標路由 作為參數  // return 重定向的 字串路徑/路徑物件 }   别名 使用 alias 別名是做什麼用的呢？\n當我們訪問 /b 時，路徑會保持 /b 但，路由匹配則為 /a。\n1 2 3 4 5 6 7  const routes = [ { path: \u0026#39;/a\u0026#39;, alias: \u0026#39;/b\u0026#39;, // ...  }, ];   這個功能讓你可以自由地將 UI 結構映射到任意的 URL，而不是受限於配置的巢狀路由結構。\nCodePen Demo：Vue 2.x - 别名\n","description":"重新導向 \u0026 別名。","id":21,"section":"posts","tags":["Vue","Vue Router"],"title":"Vue Router - 重新導向 \u0026 別名","uri":"https://chupai.github.io/posts/vue/router/redirectalias/"},{"content":" 竹白的 Vue 記事本 目錄\n \r命名路由 定義路由還可以使用 name 屬性來設置名稱：\n1 2 3 4 5 6 7  routes: [ { path: \u0026#39;/user/:id\u0026#39;, name: \u0026#39;user\u0026#39;, component: User } ]   to 特性使用 v-bind 來綁定一個物件傳入路由名稱和動態路由參數：\n1  \u0026lt;router-link :to=\u0026#34;{ name: \u0026#39;user\u0026#39;, params: { id: \u0026#39;foo\u0026#39; } }\u0026#34;\u0026gt;User\u0026lt;/router-link\u0026gt;   當路徑比較複雜的時候，使用命名路由代替，會是一個選擇。但要注意，path 和 name 不可以混用，path 會被無視。\nCodePen Demo：Vue 2.x - 命名路由\n命名視圖 假設要同一個頁面載入兩個以上的視圖，就需要替 \u0026lt;router-view\u0026gt; 元件命名。\n1 2 3  \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;router-view name=\u0026#34;a\u0026#34;\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;router-view name=\u0026#34;b\u0026#34;\u0026gt;\u0026lt;/router-view\u0026gt;   多個視圖就需要多個元件，因此路由設置需要改用 components：\n1 2 3 4 5 6 7 8 9 10  routes: [ { path: \u0026#39;/\u0026#39;, components: { default: Foo, a: Bar, b: Baz, } }, ]   \u0026lt;router-view\u0026gt; 沒命名預設為 default，如果具名會渲染相對設定元件。\nCodePen Demo：Vue 2.x - 命名視圖\n","description":"程式控制。","id":22,"section":"posts","tags":["Vue","Vue Router"],"title":"Vue Router - 命名路由 \u0026 命名視圖","uri":"https://chupai.github.io/posts/vue/router/named/"},{"content":" 竹白的 Vue 記事本 目錄\n \rpush 方法 除了使用 \u0026lt;router-link\u0026gt; 創建 a 標籤來定義導航連結，還可以使用路由的實體方法來實作。\n1  router.push(location, onComplete?, onAbort?);   當你點擊 \u0026lt;router-link\u0026gt; 時，push 方法會在內部呼叫，所以 \u0026lt;router-link :to=\u0026quot;...\u0026quot;\u0026gt; 等同於呼叫 router.push(...)。\nlocation 參數可以是字串或物件：\n1 2 3 4 5 6 7 8 9 10 11  // 字串 router.push(\u0026#39;home\u0026#39;); // 物件 router.push({ path: \u0026#39;home\u0026#39; }); // 命名的路由 router.push({ name: \u0026#39;user\u0026#39;, params: { userId: \u0026#39;123\u0026#39; } }); // 帶查詢參數，變成 /register?plan=private router.push({ path: \u0026#39;register\u0026#39;, query: { plan: \u0026#39;private\u0026#39; } });   如果提供了 path，params 會被忽略。建議改用以下作法：\n1 2 3 4 5  // -\u0026gt; /user/123  const userId = \u0026#39;123\u0026#39;; router.push({ name: \u0026#39;user\u0026#39;, params: { userId } }); router.push({ path: `/user/${userId}` });   同樣的規則也適用於 \u0026lt;router-link\u0026gt; 元件的 to 特性。\n更多關於 命名的路由 之後會說明。\n1. 可選參數 另外兩個可選參數為回呼函式：\n onComplete：導航成功完成（在所有的異步鉤子被解析之後）時進行呼叫。 onAbort：導航終止（導航到相同的路由、或在當前導航完成之前導航到另一個不同的路由）時進行呼叫。  在 3.1.0+ 之後，如果省略兩個可選參數，會回傳 Promise 物件，可以使用以下作法：\n1  router.push(location).then(onComplete).catch(onAbort);   replace 方法 replace 方法基本上與 push 方法 相同，唯一差異在於它不會向 history 添加新記錄。\n等同 \u0026lt;router-link\u0026gt; 設置 replace 特性。\ngo 方法 go 方法的參數為整數，意思是在 history 記錄中向前或者後退多少步。\n1  router.go(n);   舉例來說：\n1 2 3 4 5 6 7 8 9 10 11 12  // 在瀏覽器記錄中前進一步，等同於 history.forward() router.go(1); // 後退一步記錄，等同於 history.back() router.go(-1); // 前進 3 步記錄 router.go(3); // 如果 history 記錄不夠用，默默地失敗 router.go(-100); router.go(100);   導航失敗 1 2  \u0026lt;router-link to=\u0026#34;/about\u0026#34;\u0026gt;About\u0026lt;/router-link\u0026gt; \u0026lt;button @click=\u0026#34;$router.push(\u0026#39;/about\u0026#39;)\u0026#34;\u0026gt;About\u0026lt;/button\u0026gt;   這裡要注意，若我們當前路徑與目標路徑相同，使用 \u0026lt;router-link\u0026gt; 的並不會拋出錯誤，而使用程式控制的會拋出錯誤。\nCodePen Demo：Vue 2.x - 導航失敗\n要如何處理，可以參考官方文件說明 Navigation Failures。\n","description":"程式控制。","id":23,"section":"posts","tags":["Vue","Vue Router"],"title":"Vue Router - 程式控制","uri":"https://chupai.github.io/posts/vue/router/programmaticnavigation/"},{"content":" 竹白的 Vue 記事本 目錄\n \r巢狀路由 多層巢狀範例：\n/user/foo/profile /user/foo/posts +------------------+ +-----------------+ | User | | User | | +--------------+ | | +-------------+ | | | Profile | | +------------\u0026gt; | | Posts | | | | | | | | | | | +--------------+ | | +-------------+ | +------------------+ +-----------------+ 在巢狀的出口中渲染元件，需要在路由配置中使用 children 屬性，接受一個 RouteConfig 陣列。：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  { path: \u0026#39;/user/:id\u0026#39;, component: User, children: [ { path: \u0026#39;profile\u0026#39;, component: UserpProfile, }, { path: \u0026#39;posts\u0026#39;, component: UserPosts, }, ], }   注意，巢狀時 path 不帶 /，否則會被當作根路徑。\n子路由會被渲染在元件中的 \u0026lt;router-view\u0026gt; 位置：\n1 2 3 4 5 6 7 8  const User = { template: ` \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;User\u0026lt;/h1\u0026gt; \u0026lt;router-view /\u0026gt; \u0026lt;/div\u0026gt; `, };   如果希望 /user/foo 有預設子路由，可以提供一個空路徑：\n1 2 3 4 5 6 7  children: [ { path: \u0026#39;\u0026#39;, component: UserHome }, // ... ],   或者，你希望預設是子路由中的其中一個，可以使用 redirect 轉向：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  { path: \u0026#39;/user/:id\u0026#39;, component: User, redirect: \u0026#39;/user/:id/profile\u0026#39;, children: [ { path: \u0026#39;profile\u0026#39;, component: UserProfile, }, { path: \u0026#39;posts\u0026#39;, component: UserPosts, }, ], }   CodePen Demo：Vue 2.x - 巢狀路由\n","description":"巢狀路由。","id":24,"section":"posts","tags":["Vue","Vue Router"],"title":"Vue Router - 巢狀路由","uri":"https://chupai.github.io/posts/vue/router/nestedroutes/"},{"content":" 竹白的 Vue 記事本 目錄\n \r動態路由 動態路由是指在 URL 路徑中含有動態參數的路由。例如有一個 User 元件，對於所有 ID 各不相同的用戶，都要使用這個元件來渲染。那麼路徑就會是 /user/1、/user/2、/user/3 等等。\n1. 路徑參數 params 一個 路徑參數 使用冒號 : 標記：\n1 2 3 4 5 6  routes: [ { path: \u0026#39;/user/:id\u0026#39;, // 動態路徑參數 以冒號開頭  component: User }, ]   這樣，任何匹配 /user/:id 的路徑都會渲染出 User 元件。\n路由物件 this.$route 中的 params 屬性表示當前動態路徑參數值。\nCodePen Demo：Vue 2.x - 動態路由 路徑參數\n2. 多段路徑參數 你可以在一個路由中設置多段 路徑參數，對應的值都會設置到 params 屬性中。例如：\n模式： /user/:id /user/:username/post/:post_id 匹配路徑： /user/evan /user/evan/post/123 params 物件： { username: 'evan' } { username: 'evan', post_id: '123' } 響應路由參數的變化 當使用路由參數時，元件會重複利用，這意味著元件的生命週期鉤子不會再被呼叫。\n因此，若元件想對路由參數的變化作出響應的話，可以使用 watch 監聽：\n1 2 3 4 5 6 7 8  const User = { template: \u0026#39;...\u0026#39;, watch: { $route(to, from) { // 對路由變化作出響應...  }, }, };   或者使用 beforeRouteUpdate() 導航守衛：\n1 2 3 4 5 6 7  const User = { template: \u0026#39;...\u0026#39;, beforeRouteUpdate(to, from, next) { // react to route changes...  // don\u0026#39;t forget to call next()  }, };   就算是分開定義路由，如果使用相同元件，一樣會重複使用元件，例如：\n1 2 3 4 5 6 7 8  { path: \u0026#39;/user/1\u0026#39;, component: User }, { path: \u0026#39;/user/2\u0026#39;, component: User }   捕獲所有路由或 404 Not found 路由 通用符號 * 可以捕獲所有路由路徑，通常用於例外處理。\n當路徑不存在時，可以渲染一個錯誤警告，告知使用者當前網址不存在：\n1 2 3 4  { path: \u0026#39;*\u0026#39;, component: Error, }   但是這樣子不存在的路徑會保留，因此你可以使用 redirect 轉向 /404：\n1 2 3 4 5 6 7 8  { path: \u0026#39;/404\u0026#39;, component: Error, }, { path: \u0026#39;*\u0026#39;, redirect: \u0026#39;/404\u0026#39;, }   當使用通用符號路由時，請確保路由的順序是正確的，也就是說含有通用符號的路由應該放在最後。\n1. pathMatch 參數 使用一個通用符號時，$route.params 內會自動添加一個名為 pathMatch 參數。包含了 URL 通過通用符號被匹配的部分。\n1 2 3 4 5 6 7  // { path: \u0026#39;/user-*\u0026#39; } this.$router.push(\u0026#39;/user-admin\u0026#39;); this.$route.params.pathMatch; // \u0026#39;admin\u0026#39;  // { path: \u0026#39;*\u0026#39; } this.$router.push(\u0026#39;/non-existing\u0026#39;); this.$route.params.pathMatch; // \u0026#39;/non-existing\u0026#39;   高級匹配模式 Vue Router 使用 path-to-regexp 作為路徑匹配引擎，所以可以使用 正則表達式 支持很多高級的匹配模式。\n官方文件範例\n1. 可選路由參數 ? 等同於 {0,1} 表示零個或一個，也就是可選。\n無論是否添加路由參數都對應的同一個元件：\n1  { path: \u0026#39;/optional-params/:foo?\u0026#39; }   1 2  \u0026lt;router-link to=\u0026#34;/optional-params\u0026#34;\u0026gt;\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/optional-params/foo\u0026#34;\u0026gt;\u0026lt;/router-link\u0026gt;   可以在元件內使用 v-if 搭配 $route.params 渲染不同的內容。\n2. 精確匹配參數 使用正則規則驗證，只有符合的格式才會跳轉。\n舉例來說，必須是正整數：\n1  { path: \u0026#39;/params-with-regex/:id(\\\\d+)\u0026#39; }   1  \u0026lt;router-link to=\u0026#34;/params-with-regex/123\u0026#34;\u0026gt;\u0026lt;/router-link\u0026gt;   \\d 等同[0-9] 匹配 0 到 9 之間的任一數字、+ 等同於 {1,} 表示至一個以上。\n純數字的驗證通常用於分頁。另外，精確匹配還可以用來驗證手機、信箱等等資料格式的參數，符合的才允許跳轉。\n3. 匹配任意路徑 之前提過的 * 通用符號，匹配任意路徑。\n1  { path: \u0026#39;/asterisk/*\u0026#39; }   1 2  \u0026lt;router-link to=\u0026#34;/asterisk/foo\u0026#34;\u0026gt;\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/asterisk/foo/bar\u0026#34;\u0026gt;\u0026lt;/router-link\u0026gt;   4. 部分可選參數 結合可選路由參數和精確匹配參數：\n1  { path: \u0026#39;/optional-group/(foo/)?bar\u0026#39; }   1 2  \u0026lt;router-link to=\u0026#34;/optional-group/bar\u0026#34;\u0026gt;\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/optional-group/foo/bar\u0026#34;\u0026gt;\u0026lt;/router-link\u0026gt;   匹配優先級 有時候，同一個路徑可以匹配多個路由，此時，匹配的優先級就按照路由的定義順序：誰先定義的，誰的優先級就最高。\n","description":"動態路由是指在 URL 路徑中含有動態參數的路由。","id":25,"section":"posts","tags":["Vue","Vue Router"],"title":"Vue Router - 動態路由匹配","uri":"https://chupai.github.io/posts/vue/router/dynamicroutematching/"},{"content":" 竹白的 Vue 記事本 目錄\n \r前端路由概述  前端路由為 單頁應用（SPA） 的基礎標配。\n 路由這個概念來自後端伺服器，透過不同的路徑，回傳不同的網頁內容，每次請求都會刷新頁面，因此會不定時間的空白畫面。\n隨著 AJAX 技術的盛行，資料請求不再需要刷新頁面，開始有前後端分離的開發模式，前端只需要接收後端傳遞的資料，再將內容渲染出來。各種 MVVM 框架的興起，前端發展逐漸走向 SPA，由於只有單一個 html，一但加載完成，並不會因為使用者的操作而重新載入或跳轉，取而代之的是利用 JS 動態切換不同的元件，改變 URL 但頁面整體不刷新。\n前端路由是 URL 與畫面之間的關係，有兩種實現方式 history 和 hash，詳細可以參考這篇文章：Web 前端路由原理解析和实现。\nVue Router  Vue Router\n Vue Router 是 Vue.js 官方的路由管理器。頁面的路徑改變就是元件的切換。\n1. CDN 1  \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.4.5/vue-router.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   2. Vue CLI 專案 安裝：\n1  npm install vue-router --save   配置檔：\n Vue CLI3 為 router.js Vue CLI4 為 /router/index.js  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  import Vue from \u0026#39;vue\u0026#39;; import Router from \u0026#39;vue-router\u0026#39;; import Home from \u0026#39;./views/Home.vue\u0026#39;; Vue.use(Router); export default new Router({ routes: [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;home\u0026#39;, component: Home, }, { path: \u0026#39;/about\u0026#39;, name: \u0026#39;about\u0026#39;, component: () =\u0026gt; // 路由懶加載 lazy-loading  import(\u0026#39;./views/About.vue\u0026#39;), }, ], });   將 router 掛載到 Vue 實體：\n1 2 3 4 5 6 7 8 9 10  import Vue from \u0026#39;vue\u0026#39;; import App from \u0026#39;./App.vue\u0026#39;; import router from \u0026#39;./router\u0026#39;; // 引入配置檔  Vue.config.productionTip = false; new Vue({ router, // 載入  render: h =\u0026gt; h(App), }).$mount(\u0026#39;#app\u0026#39;);   基本範例 1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.4.5/vue-router.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;!-- 導航元件 --\u0026gt; \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt;Home\u0026lt;/router-link\u0026gt; | \u0026lt;router-link to=\u0026#34;/about\u0026#34;\u0026gt;About\u0026lt;/router-link\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;p\u0026gt;path: {{ $route.fullPath }}\u0026lt;/p\u0026gt; \u0026lt;!-- 路由配置元件 --\u0026gt; \u0026lt;router-view /\u0026gt; \u0026lt;/div\u0026gt;   \u0026lt;router-link\u0026gt; 與 \u0026lt;router-view\u0026gt; 為 Vue Router 提供的元件：\n \u0026lt;router-link\u0026gt; 預設為 \u0026lt;a\u0026gt;，透過 to 特性用於指定跳轉的連結； 而 \u0026lt;router-view\u0026gt; 是負責掛載路由匹配到畫面的元件。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 路由元件 const Home = { template: \u0026#39;\u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;Home\u0026lt;/h1\u0026gt;\u0026lt;/div\u0026gt;\u0026#39; }; const About = { template: \u0026#39;\u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;About\u0026lt;/h1\u0026gt;\u0026lt;/div\u0026gt;\u0026#39; }; // 配置路由 const routes = [ { path: \u0026#39;/\u0026#39;, component: Home }, { path: \u0026#39;/about\u0026#39;, component: About }, ]; // 建立 router 實體，並傳 routes 配置 const router = new VueRouter({ routes }); // 建立實體 + 掛載 router const vm = new Vue({ el: \u0026#39;#app\u0026#39;, router, });   CodePen Demo：Vue 2.x - Vue Router 基本範例\n配置路由 配置路由映射，元件和路徑映射的關係。\nroutes 為一個陣列，僅能接受 RouteConfig 設定資料物件，這個物件本身包含了以下基本屬性：\n path：對應的虛擬路徑，從 base 開始算。 component：路由配置的 Vue 元件。  1 2 3 4 5 6 7 8 9 10  const routes = [ { path: \u0026#39;/\u0026#39;, component: Home }, { path: \u0026#39;/about\u0026#39;, component: About }, ];   其他屬性之後會慢慢提到。\n路由連結 1. router-link 元件 \u0026lt;router-link\u0026gt; 元件，預設會解析成 HTML 的 \u0026lt;a\u0026gt; 標籤，有兩個屬性可設定：\n tag：指定標籤。 to：導向的路徑字串。  1 2  \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt;Home\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/about\u0026#34;\u0026gt;About\u0026lt;/router-link\u0026gt;   to 除了接受路徑字串，也可以使用 v-bind 來綁定一個物件。點擊 \u0026lt;router-link\u0026gt; 會在內部呼叫路由實體 push 方法，更多詳細用法會在 程式控制 說明。\n2. active 樣式 對應的路由匹配成功時，\u0026lt;router-link\u0026gt; 會自動添加一個 active-class 類別。\n可以使用 .router-link-active 來定義樣式：\n1 2 3  .router-link-active { /* style */ }   或是透過 active-class 特性，各別引入自定義類別名稱：\n1  \u0026lt;router-link to=\u0026#34;/\u0026#34; active-class=\u0026#34;is-active\u0026#34;\u0026gt;Home\u0026lt;/router-link\u0026gt;   1 2 3  .is-active { /* style */ }   如果不想要各別引入自定義類別名稱，可以設置 Router 的linkActiveClass 選項：\n1 2 3 4 5  // router.js export default new Router({ linkActiveClass: \u0026#39;is-active\u0026#39;, // 預設值 \u0026#39;router-link-active\u0026#39;  // ... });   2. 精確匹配模式 要注意，當前路由的所有父級都會添加 active-class，舉例：/about 就包含 / 也添加 active-class。\n而精確匹配的 \u0026lt;router-link\u0026gt; 還會添加一個 exact-active-class，用法與 active-class 相同，Router 選項為 linkExactActiveClass（預設值 'router-link-exact-active'）。\n你可以改用 .router-link-exact-active 來定義 active 樣式，就可以避免父級也套用 active 樣式。\n或者使用 exact 精確匹配模式：\n1  \u0026lt;router-link to=\u0026#34;/\u0026#34; exact\u0026gt;Home\u0026lt;/router-link\u0026gt;   使用精確匹配模式，只有路由完全匹配時才會添加 active-class。\nCodePen Demo：Vue 2.x - Vue Router active class\n路由渲染 \u0026lt;router-view\u0026gt; 路由配置元件，會渲染當前路徑指定的元件。如果要設置複數 \u0026lt;router-view\u0026gt;，有 name 特性可以設置名稱。\n因為它也是個元件，所以可以配合 \u0026lt;transition\u0026gt; 和 \u0026lt;keep-alive\u0026gt; 使用。\n路由實體 \u0026amp; 路由物件 1. 路由實體 在 Vue 實體內，可以透過 $router 獲取路由實體，我們能透過它來呼叫路由方法。\n2. 路由物件 另外，還可以透過 $route 獲取當前的路由資訊，包含了當前 URL 解析得到的資訊。\n這個物件 唯讀，可用於監聽變化。部分屬性之後會提到，詳細屬性可以先參考 文件 API。\n","description":"Vue Router 是 Vue.js 官方的路由管理器。頁面的路徑改變就是元件的切換。","id":26,"section":"posts","tags":["Vue","Vue Router"],"title":"Vue Router - 基礎","uri":"https://chupai.github.io/posts/vue/router/base/"},{"content":"Vue Vuex篇\n\r 這週是六角鼠年鐵人賽第三十九週，Vue 筆記的第四篇。\n 竹白的 Vue 記事本 目錄\n Vue - Vuex篇：\n Vuex - 起手式 Vuex - 核心概念 Vuex - Module Vuex - 注意事項 ","description":"Vue Vuex篇。","id":27,"section":"posts","tags":["Vue","w3HexSchool"],"title":"Vue - Vuex","uri":"https://chupai.github.io/posts/2010/vue_vuex/"},{"content":" 竹白的 Vue 記事本 目錄\n \r專案結構 Vuex 並不限制程式碼結構，只需要遵守以下幾點規則：\n 應用層級的狀態應該集中到單個 store 物件中。 提交 mutation 是唯一更改狀態的唯一方法，且必須是同步操作。 非同步操作應該封裝到 action 中。  1. 基本結構 單一個 store.js 檔案：\n1 2 3 4 5 6 7 8 9 10 11 12  import Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ strict: process.env.NODE_ENV !== \u0026#39;production\u0026#39;, state: {}, mutations: {}, actions: {}, getters: {}, });   2. 資料夾管理 /store ├── index.js ├── actions.js ├── mutations.js ├── ... └── /modules ├── moduleA.js └── moduleB.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // index.js  import Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; import mutations from \u0026#39;./mutations\u0026#39;; import actions from \u0026#39;./actions\u0026#39;; import getters from \u0026#39;./getters\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ state: {}, mutations, actions, getters, modules: { moduleA, moduleB, } });   官方提供範例：shopping-cart\n模組部分也可以使用資料夾拆分的更細去管理。\n嚴格模式 一邊的情況下，進行以下非法操作：使用非 mutation 修改狀態與使用 mutation 進行非同步更新狀態，並不會拋出錯誤，但在 devtool 中無法正確捕捉到狀態。\n因此我們可以開啟 嚴格模式：\n1 2 3 4  const store = new Vuex.Store({ strict: true, // ... });   這樣當我們進行非法操作時，變會拋出錯誤訊息提示，保證所有狀態能夠被 devtool 追蹤。\n1. 環境 但有一點必須注意，因為嚴格模式會深度監測狀態樹，所以在 發布環境 下避免使用，避免不必要的性能損失。\n因此我們可以使用 環境變數 來處理：\n1 2 3  const store = new Vuex.Store({ strict: process.env.NODE_ENV !== \u0026#39;production\u0026#39;, });   v-model 如果我們要將取回來的狀態使用 v-model 綁定，就會遇到 v-model 綁定計算屬性的問題。計算屬性預設無法回寫（會跳出警告），再加上會直接違反 Vuex 直接修改狀態的規則。\n因此我們需要用到計算屬性的 setter：\n1 2 3 4 5 6 7 8 9 10 11 12  // Component.vue  computed: { message: { get() { return this.$store.state.message; }, set(value) { this.$store.commit(\u0026#39;updateMessage\u0026#39;, value); }, }, }   1 2 3 4 5 6 7 8 9 10  // store.js  state: { message: \u0026#39;\u0026#39;, }, mutations: { updateMessage(state, message) { state.message = message; } }   CodePen Demo：Vue 2.x -Vuex v-model\n解決狀態丟失的問題 套件：\n vuex-persist vuex-along ","description":"Vuex 注意事項。","id":28,"section":"posts","tags":["Vue","Vuex"],"title":"Vuex - 注意事項","uri":"https://chupai.github.io/posts/vue/vuex/warning/"},{"content":" 竹白的 Vue 記事本 目錄\n \r模組化 如果所有狀態資料都集中在一個比較大的物件，會遇到一個問題：當應用變得非常複雜時，store 物件就有可能變得相當難以維護。\n為了解決以上問題，Vuex 允許我們將 store 分割成模組（module）。\n分割 每個模組就是一個小型的 store，擁有自己的 state、mutations、actions、getters、甚至是巢狀子模組。\n兩種模組結構參考：\n1 2 3 4 5 6 7 8 9 10 11  // moduleA.js  export default { namespaced: true, state: () =\u0026gt; ({ a1: \u0026#39;aaa\u0026#39;, }), mutations: {}, actions: {}, getters: {}, };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // moduleB.js  const state = () =\u0026gt; ({ b1: \u0026#39;bbb\u0026#39;, }); const getters = {}; const actions = {}; const mutations = {}; export default { state, getters, actions, mutations, };   為了避免模組重用時，狀態物件通過引用被共享，所以會使用函式型式來宣告模組的狀態。\n引入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // store.js  import Vuex from \u0026#39;vuex\u0026#39;; import moduleA from \u0026#39;./modules/modulesA\u0026#39;; import moduleB from \u0026#39;./modules/modulesB\u0026#39;; export default new Vuex.Store({ state: {}, mutations: {}, actions: {}, modules: { moduleA: moduleA, moduleB: moduleB, // 或是使用簡寫  // moduleA,  // moduleB,  }, });   1. 取得模組狀態 模組的的 state 物件將被儲存在 moduleA、 moduleB 中：\n1 2  store.state.moduleA; // { \u0026#34;a1\u0026#34;: \u0026#39;aaa\u0026#39; } store.state.moduleB; // { \u0026#34;b1\u0026#34;: \u0026#39;bbb\u0026#39; }   CodePen Demo：Vue 2.x -Vuex Module\n模組的區域狀態 對於模組內的 mutation、getter、action，透過參數取得的狀態為模組內部的區域狀態。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const moduleA = { state: () =\u0026gt; ({ text: \u0026#39;區域\u0026#39; }), mutations: { print(state) { console.log(state.text); }, }, }; const store = new Vuex.Store({ state: { text: \u0026#39;全域\u0026#39;, }, modules: { a: moduleA, }, });   1  store.commit(\u0026#39;print\u0026#39;); // \u0026#39;區域\u0026#39;   CodePen Demo：Vue 2.x -Vuex Module 區域狀態\n若要取的根  state，getter 函式可以使用第三個參數 rootState，action 函式也可以透過 context.rootState 取得：\n1 2 3 4 5 6 7 8 9 10 11 12 13  const moduleA = { // ...  getters: { foo(state, getters, rootState) { // ...  }, }, actions: { boo({ rootState }) { // ...  }, }, }   另外，還有 rootGetters 可以取得根 getters。\n命名空間 從上面可知，預設情況下模組內的 action、mutation 和 getter 是註冊在全域空間下。如果全域、區域有相同的名稱的函式都會執行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  const moduleA = { state: () =\u0026gt; ({ text: \u0026#39;區域\u0026#39; }), mutations: { print(state) { console.log(state.text); }, }, }; const store = new Vuex.Store({ state: { text: \u0026#39;全域\u0026#39;, }, mutations: { print(state) { console.log(state.text); }, }, modules: { a: moduleA, }, });   1 2 3  store.commit(\u0026#39;print\u0026#39;); // \u0026#39;全域\u0026#39; // \u0026#39;區域\u0026#39;   CodePen Demo：Vue 2.x -Vuex Module 相同名稱\n因此，如果你希望模組具有更高度的封裝性，只讓它們在內部有作用，可以設置 namespaced: true 使其成為帶命名空間的模組。\n1 2 3 4  const moduleA = { namespaced: true, // ... };   啟用命名空間後，如果要呼叫模組內的 mutation 就需要加上路徑：\n1 2 3 4 5 6  store.commit(\u0026#39;moduleA/print\u0026#39;); // \u0026#39;區域\u0026#39;  // 呼叫相同名稱的全域 mutation 也不會觸發模組內的函式 store.commit(\u0026#39;print\u0026#39;); // \u0026#39;全域\u0026#39;   getter 和 action 也一樣要加上路徑：\n1 2 3 4  // getter store.getters[\u0026#39;moduleA/xxxx\u0026#39;]; // action store.dispatch(\u0026#39;moduleA/xxxx\u0026#39;);   CodePen Demo：Vue 2.x -Vuex Module 命名空間\n1. 訪問全域內容 使用命名空間後，在模組內呼叫的 mutation 和 action 都會是區域的。但如果我們要在模組內操作全域的 mutation 和 action 該怎麼做呢？\n你可以將 { root: true } 作為 dispatch 或 commit 方法的第三參數傳入：\n1 2  dispatch(\u0026#39;someOtherAction\u0026#39;, null, { root: true }); commit(\u0026#39;someMutation\u0026#39;, null, { root: true });   CodePen Demo：Vue 2.x -Vuex Module 訪問全域內容\n2. 在命名空間的模組下全域註冊 若你希望在命名空間的模組上，某個函式全域註冊，你可以使用物件的形式定義，並加上 root: true\n1 2 3 4 5 6 7 8 9 10 11  const moduleA = { namespaced: true, actions: { foo: { root: true, handler (context, payload) { // ...  }, } }, };   3. 輔助函式 如果要使用輔助函式引入模組的內容，寫起來會有點繁瑣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // Component.vue  computed: { ...mapState({ a1: (state) =\u0026gt; state.moduleA.a1, a2: (state) =\u0026gt; state.moduleA.a2, }) }, methods: { ...mapActions({ foo: \u0026#39;moduleA/foo\u0026#39;, boo: \u0026#39;moduleA/boo\u0026#39;, }), }   CodePen Demo：Vue 2.x -Vuex Module 輔助函式\n你可以將模組的空間名稱作為第一個參數傳入輔助函式，這樣所有綁定會自動將該模組作為上下文，這樣就能使用陣列型式映射內容，簡化上述繁瑣的程式碼：\n1 2 3 4 5 6 7 8  // Component.vue  computed: { ... mapState(\u0026#39;moduleA\u0026#39;, [\u0026#39;a1\u0026#39;, \u0026#39;a2\u0026#39;]), }, methods: { ... mapActions(\u0026#39;moduleA\u0026#39;, [\u0026#39;foo\u0026#39;, \u0026#39;boo\u0026#39;]), }   CodePen Demo：Vue 2.x -Vuex Module 輔助函式 - 模組命名參數\n或者透過 createNamespacedHelpers 建立基於模組命名空間的輔助函式：\n1 2 3 4 5 6 7 8 9 10 11 12  // Component.vue import { createNamespacedHelpers } from \u0026#39;vuex\u0026#39;; const { mapState, mapActions } = createNamespacedHelpers(\u0026#39;moduleA\u0026#39;); export default { computed: { ... mapState([\u0026#39;a1\u0026#39;, \u0026#39;a2\u0026#39;]), }, methods: { ... mapActions([\u0026#39;foo\u0026#39;, \u0026#39;boo\u0026#39;]), } }   CodePen Demo：Vue 2.x -Vuex Module 輔助函式 - createNamespacedHelpers\n","description":"Vuex 模組化。","id":29,"section":"posts","tags":["Vue","Vuex"],"title":"Vuex - Module","uri":"https://chupai.github.io/posts/vue/vuex/module/"},{"content":" 竹白的 Vue 記事本 目錄\n \r核心概念 一般元件上，我們會用 data 儲存狀態資料、用 method 操作狀態資料，還會用 computed 衍生狀態資料。\n而在 Vuex 則是透過以下選項來管理狀態資料：\n State：儲存狀態資料，類似全域的 data。 Mutations：更新態的方法，只能同步操作。 Actions：進行非同步狀態更新操作，類似全域的 method。 Getters：衍生狀態資料，類似全域的 computed。  State State 就是用來存放共享狀態資料的倉庫。\n定義 state ：\n1 2 3 4 5  // store.js  state: { count: 0, }   與 data 一樣需要遵守 Vue 的響應規則。\n1. 訪問狀態 在元件內，我們可以透過 $store（Store 實體）訪問到這個 state 物件。\n1  $store.state   通常會使用計算屬性回傳狀態：\n1 2 3 4 5 6 7  // Component.vue  computed: { count() { return this.$store.state.count; }, }   CodePen Demo：Vue 2.x - Vuex State\n注意，state 物件，只能透過 Mutations 更新。\r 2. 多個狀態 當一個元件需要獲取多個狀態時候，將這些狀態都宣告為計算屬性會有些重複和冗餘。因此我們可以使用 mapState 輔助函式 ，取得多個 state 裡面的狀態資料。\n假設 state 物件內有多筆狀態資料：\n1 2 3 4 5 6  // store.js  state: { count: 0, total: 0, }   首先我們必須在元件中引入 mapState 輔助函式：\n1 2 3  // Component.vue  import { mapState } from \u0026#39;vuex\u0026#39;;   mapState 輔助函式可以傳入物件或陣列。如果傳入一個物件有三種寫法：\n 箭頭函式，可以使程式碼更簡潔。 字串，等同使用箭頭函式。 如果要使用 this 獲取區域狀態，需要改用一般的函式。  1 2 3 4 5 6 7 8 9 10 11 12  // Component.vue  computed: mapState({ // 箭頭函式  count: state =\u0026gt; state.count, // 字串  total: \u0026#39;total\u0026#39;, // 一般的函式  countPlusLocalState(state) { return state.count + this.localCount; }, })   當映射的計算屬性的名稱與 state 名稱相同時，我們也可以給 mapState 輔助函式傳一個字串陣列。\n1 2 3  // Component.vue  computed: mapState([\u0026#39;count\u0026#39;, \u0026#39;total\u0026#39;]),   3. 區域狀態 使用 Vuex 並不意味著你需要將所有的狀態放入 Vuex。如果有些狀態嚴格屬於單個元件，最好還是作為元件的區域狀態。\n另外，如果我們有區域計算屬性要用，可以使用 ... 展開運算子將 mapState 輔助函式合併：\n1 2 3 4 5 6 7 8 9  // Component.vue  computed: { localComputed () { // ...  }, // 展開回傳的物件，將它混入到 computed 物件中  ...mapState([\u0026#39;count\u0026#39;, \u0026#39;total\u0026#39;]) }   CodePen Demo：Vue 2.x - Vuex mapState \nMutations 前面有提到，state 狀態不能直接改變。\n舉例來說：\n1  \u0026lt;button @click=\u0026#34;$store.state.count += 1\u0026#34;\u0026gt;++\u0026lt;/button\u0026gt;   雖然這樣不會拋出錯誤，也不會跳出警告，但這是錯誤的非法操作。\n如果想要狀態非 mutation 函式引起的更新拋出錯誤，可以使用 嚴格模式。\r 我們只能透過 Vuex 中的 mutation 來更新 state。雖然這種操作較繁瑣，但可以集中監控狀態的變化，避免不可預期情況發生。\n定義 mutation：\n1 2 3 4 5 6 7  // store.js  mutations: { increment(state) { state.count += 1; // 變更狀態  } }   1. 提交 Mutation mutation 類似事件監聽器，無法直接呼叫，我們必須透過 store.commit 方法來呼叫。\n1 2 3 4 5 6 7  // Component.vue  methods: { increment() { this.$store.commit(\u0026#39;increment\u0026#39;); }, }   CodePen Demo：Vue 2.x -Vuex Mutations\n2. Payload 可以向 store.commit 傳入額外的參數，即 mutation 的第二個參數 payload：\n1 2 3 4 5 6 7  // store.js  mutations: { increment(state, n) { state.count += n } }   1  $store.commit(\u0026#39;increment\u0026#39;, 10);   在大多數情況下，payload 應該是一個物件，這樣可以包含多個字段並且記錄的 mutation 會更易讀：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // store  mutations: { increment(state, payload) { state.count += payload.amount; } } // 或是使用解構賦值 mutations: { increment(state, { amount }) { state.count += amount; } }   1  $store.commit(\u0026#39;increment\u0026#39;, {amount: 10});   CodePen Demo：Vue 2.x -Vuex Mutations Payload\n3. 物件風格的提交方式 提交 mutation 的另一種方式是直接使用包含 type 屬性的物件：\n1 2 3 4  $store.commit({ type: \u0026#39;increment\u0026#39;, amount: 10 });   4. mapMutations mutation 一樣有 mapMutations 輔助函式可以使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // Component.vue  import { mapMutations } from \u0026#39;vuex\u0026#39;; // 物件 methods: { ...mapMutations({ increment: \u0026#39;increment\u0026#39;, }), } // 陣列 methods: { ...mapMutations([\u0026#39;increment\u0026#39;]), }   mapMutations 輔助函式也支持 payload，只需要在呼叫的地方傳入參數，會自動傳遞：\n1  \u0026lt;button @click=\u0026#34;decrement(10)\u0026#34;\u0026gt;++\u0026lt;/button\u0026gt;   CodePen Demo：Vue 2.x -Vuex mapMutations\n5. 使用常數替代 Mutation 類型 當 Vuex 管理的狀態越多，我們就會需要用到大量的 mutation 去更新，你不可能記住全部，因此可能會反覆查看。\n為了解決上述問題，使用常數替代 mutation 類型事最常見的方案之一，可以使 mutation 更容易識別。\n1 2 3  // mutation-types.js export const EDIT_TASK = \u0026#39;EDIT_TASK\u0026#39;; ...   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // store.js  import Vuex from \u0026#39;vuex\u0026#39;; import { EDIT_TASK } from \u0026#39;./mutation-types\u0026#39;; export default new Vuex.Store({ state: { task: \u0026#39;\u0026#39;; }, mutations: { [EDIT_TASK](state, { value }) { state.task = value; }, }, });   1 2 3 4 5 6 7 8 9 10  // Component.vue  import { EDIT_TASK } from \u0026#39;../mutation-types\u0026#39;; // ... methods: { [EDIT_TASK]() { this.$store.commit(EDIT_TASK, {}); }, }   若要一次性導入，可以改成：\n1 2 3 4  import * as types from \u0026#39;./mutation-types\u0026#39;; // mutations　... [types.EDIT_TASK](state) {}   6. 響應規則 之前提到，store 與 data 一樣需要遵守 Vue 的響應規則。\n因此物件新增屬性時，需要使用 Vue.set() 來處理：\n1 2 3 4 5 6 7 8 9 10 11 12  // store.js import Vue from \u0026#39;vue\u0026#39;; // ... state: { obj: {}; }, mutations: { ADD_OBJ(state, { prop, value }) { Vue.set(state.obj, prop, value); } }   或者運用展開運算子替換舊物件：\n1 2 3 4 5  mutations: { ADD_OBJ(state, { value }) { state.obj = { ...state.obj, newProp: \u0026#39;value\u0026#39; }; } }   陣列修改也一樣，也需要使用 Vue.set() 來處理：\n1 2 3 4 5 6 7 8  state: { list: [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;], }, mutations: { EDIT_LIST(state, { index, value }) { Vue.set(state.list, index, value); } }   詳細可以參考 深入響應式原理。\n7. 非同步處理 當我們使用 mutation 更新狀態時，必須是同步處理，否則 devtool 工具將無法追蹤到狀態的改變。\nActions 如果我們要非同步處理狀態資料，就無法直接使用 mutation，而必須透過 action 間接的提交 mutation 來變更狀態資料。\n定義一個簡單的非同步處理操作的 action：\n1 2 3 4 5 6 7 8 9  // store.js  actions: { incrementAsync(context) { setTimeout(() =\u0026gt; { context.commit(\u0026#39;increment\u0026#39;); }, 1000); } }   actions 函式接受一個與 store 實體具有相同方法和屬性的 context 物件，包含以下屬性：\n1 2 3 4 5 6 7 8  { state, // 等同於 store.state，若在模組中則為區域狀態  rootState, // 等同於 store.state，只存在於模組中  commit, // 等同於 store.commit  dispatch, // 等同於 store.dispatch  getters, // 等同於 store.getters  rootGetters // 等同於 store.getters，只存在於模組中 }   因此我們可以用來呼叫 context.commit 提交一個 mutation，或者透過 context.state 和 context.getters 來獲取 state 和 getters 物件。\n可以使用 ES6 解構賦值來簡化程式碼：\n1 2 3 4 5 6 7 8 9  // store.js  actions: { incrementAsync({ commit }) { setTimeout(() =\u0026gt; { commit(\u0026#39;increment\u0026#39;); }, 1000); }, }   1. 調度 Action action 是透過 store.dispatch 方法來呼叫：\n1 2 3 4 5 6 7  // Component.vue  methods: { incrementAsync() { this.$store.dispatch(\u0026#39;incrementAsync\u0026#39;); }, }   CodePen Demo：Vue 2.x -Vuex Actions\naction 同樣有 payload 參數和物件風格，也有 mapActions 輔助函式可以使用，用法與 mutation 差不多，這裡就不多加說明。\n2. 組合 Action 因為 action 通常用來處理非同步操作，所以我們可以回傳 Promise，用來處理更佳複雜的非同步流程。\n1 2 3 4 5 6 7 8 9 10 11 12  // store.js  actions: { actionA({ commit }) { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { commit(\u0026#39;someMutation\u0026#39;); resolve(); }, 1000); }); }, }   Getters 你可以將 Getters 看成全域的計算屬性。\n有時候我們需要從 State 中衍生一些狀態，例如對陣列過濾，假設有很多元件都會用到，那麼我們就定義 getter，它與計算屬性一樣會緩存結果，只有當它的依賴值發生了改變才會被重新計算。\n1 2 3 4 5 6 7 8 9 10  // store.js  state: { numbers: [1, 2, 3, 4, 5, 6, 7, 8], }, getters: { even(state) { return state.numbers.filter((n) =\u0026gt; n % 2 === 0); }, }   getter 函式的第一個參數為 state 物件，若希望傳入其他 getter，可以使用第二個參數 getters 物件：\n1 2 3 4 5 6 7 8 9 10  // store.js  getters: { even(state) { // ...  }, evenCount(state, getters) { return getters.even.length; }, }   1. 訪問 要在元件中訪問 getter 一樣可以透過 $stroe 實體：\n1 2 3 4 5 6 7  // Component.vue  computed: { even() { return this.$store.getters.even; } }   CodePen Demo：Vuex Getters\n或者使用 mapGetters 輔助函數：\n1 2 3 4 5 6  // Component.vue  import { mapGetters } from \u0026#39;vuex\u0026#39;; //... computed: {...mapGetters([\u0026#39;even\u0026#39;]) },   ","description":"Vuex 核心概念。","id":30,"section":"posts","tags":["Vue","Vuex"],"title":"Vuex - 核心概念","uri":"https://chupai.github.io/posts/vue/vuex/coreconcepts/"},{"content":" 竹白的 Vue 記事本 目錄\n \r什麼是 Vuex 官方說明：\n Vuex 是一個專為 Vue.js 應用程式開發的狀態管理模式。它採用集中式存儲管理應用的所有元件的狀態，並以相應的規則保證狀態以一種可預測的方式發生變化。\n 簡單來說，Vuex 就是一個狀態倉庫，將各個元件公用的狀態放到裡面進行全域統一管理，只要倉庫內的狀態發生變化，引用它的元件都會自動更新。\n為什麼要用 Vuex 1. 元件之間狀態資料傳遞的方式 元件之間的狀態資料傳遞：\n 父元件傳子元件：Props 子元件傳父元件：Events 兄弟元件之間的傳遞：EventBus  但當我們遇到多個元件共享相同狀態資料，或者大範圍的傳遞，狀態資料的傳遞與維護就會變得相當麻煩。\n2. Vuex 用處 Vuex 將元件的共享狀態抽取出來，將狀態變成全域的，方便集中管理。在這種模式下，我們的元件樹構成了一個巨大的「視圖」，不管在樹的哪個位置，任何元件都能獲取狀態或者觸發行為。\n當專案規模到達一定程度時，才適合使用 Vuex，否則可能是繁瑣冗餘的。\r 3. Flux、Redux、MobX Vuex 是 Vue.js 專用的狀態管理模式，其概念是來自 Flux 架構思想，使用類似概念的還有 MobX 和常用於 React.js 的 Redux。\n這裡就不多做說明，有興趣的可以參考以下文章：\n Vuex、Flux、Redux、Redux-saga、Dva、MobX Flux、Redux、Vuex、MobX 總結 - 概念篇  Vue CLI 專案 安裝：\nnpm install vuex --save 導入、建立 store 物件：\n1 2 3 4 5 6 7 8 9 10 11  // store.js import Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ state: {}, mutations: {}, actions: {}, });   當專案更複雜時，通常會改用資料夾結構管理，之後會提到。\n將 store 物件掛載到 Vue 實體：\n1 2 3 4 5 6 7 8 9 10 11  // main.js import Vue from \u0026#39;vue\u0026#39;; import App from \u0026#39;./App.vue\u0026#39;; import store from \u0026#39;./store\u0026#39;; Vue.config.productionTip = false; new Vue({ store, render: h =\u0026gt; h(App), }).$mount(\u0026#39;#app\u0026#39;);   Promise Vuex 依賴 Promise。如果你支持的瀏覽器並沒有實現 Promise（比如 IE），那麼你可以使用一個 polyfill 的庫，例如 es6-promise。\n","description":"Vuex 是一個專為 Vue.js 應用程式開發的狀態管理模式。","id":31,"section":"posts","tags":["Vue","Vuex"],"title":"Vuex - 起手式","uri":"https://chupai.github.io/posts/vue/vuex/introduction/"},{"content":"Vue 元件篇\n\r 這週是六角鼠年鐵人賽第三十八週，Vue 筆記的第三篇。\n 竹白的 Vue 記事本 目錄\n Vue - 指令篇：\n 元件基礎 Prop 自定義事件 Slot 插槽 ","description":"Vue 元件篇。","id":32,"section":"posts","tags":["Vue","w3HexSchool"],"title":"Vue - 元件","uri":"https://chupai.github.io/posts/2010/vue_component/"},{"content":" 竹白的 Vue 記事本 目錄\n \rSlot 插槽 元件就是用來重複使用的，但不可能每次使用都用同樣的模板。而 \u0026lt;slot\u0026gt; 插槽 可以使我們的元件更佳彈性，能從外層將模板放置指定位置上。\n匿名插槽 首先，這是沒有 \u0026lt;slot\u0026gt; 的元件：\n1 2 3 4 5 6 7  Vue.component(\u0026#39;c-demo\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Demo\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `, });   因此如果我們直接在元件 tag 放置內容是沒有意義的。\n1 2 3 4  \u0026lt;c-demo\u0026gt;\u0026lt;p\u0026gt;123\u0026lt;/p\u0026gt;\u0026lt;/c-demo\u0026gt; \u0026lt;!-- 渲染 --\u0026gt; \u0026lt;div\u0026gt;\u0026lt;p\u0026gt;Demo\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;   想要新增的內容並不會被渲染出來。\n這裡要使用插槽，需要在元件模板加上 \u0026lt;slot\u0026gt;：\n1 2 3 4 5 6 7 8  Vue.component(\u0026#39;c-demo\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Demo\u0026lt;/p\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; `, });   1 2 3 4 5 6 7  \u0026lt;c-demo\u0026gt;\u0026lt;p\u0026gt;123\u0026lt;/p\u0026gt;\u0026lt;/c-demo\u0026gt; \u0026lt;!-- 渲染 --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Demo\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;123\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;   原本 \u0026lt;slot\u0026gt; 的位置就會被替換成添加的元素。\nCodePen Demo：Vue 2.x - 匿名插槽\n如果你設置多個 \u0026lt;slot\u0026gt;，內容就會重複：\n1 2 3 4 5 6 7 8 9 10  Vue.component(\u0026#39;c-demo\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Demo\u0026lt;/p\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; `, });   1 2 3 4 5 6 7 8 9  \u0026lt;c-demo\u0026gt;\u0026lt;p\u0026gt;123\u0026lt;/p\u0026gt;\u0026lt;/c-demo\u0026gt; \u0026lt;!-- 渲染 --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Demo\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;123\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;123\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;123\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;   另外，\u0026lt;slot\u0026gt; 內可以加上預設元素：\n1 2 3 4 5 6 7 8 9 10  Vue.component(\u0026#39;c-demo\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Demo\u0026lt;/p\u0026gt; \u0026lt;slot\u0026gt; \u0026lt;p\u0026gt;預設內容\u0026lt;/p\u0026gt; \u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; `, });   如果沒有添加元素，就會顯示預設元素。\n具名插槽 slot 特性語法在 2.6.0 起被廢棄，由 v-slot 指令取代，有興趣可以參考 官方文件。\r 1. 基本範例 如果我們有多個插槽的需求，就需要為每個 \u0026lt;slot\u0026gt; 加上 name 特性，也就是具名插槽：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  Vue.component(\u0026#39;c-demo\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;slot name=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;main\u0026gt; \u0026lt;slot name=\u0026#34;content\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;slot name=\u0026#34;footer\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; `, });   在外層插入元素時，必須在 \u0026lt;template\u0026gt; 元素上使用 v-slot 指令，指定元素插入的位置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u0026lt;c-demo\u0026gt; \u0026lt;template v-slot:title\u0026gt; Title \u0026lt;/template\u0026gt; \u0026lt;template v-slot:content\u0026gt; \u0026lt;p\u0026gt;123456\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:footer\u0026gt; end \u0026lt;/template\u0026gt; \u0026lt;/c-demo\u0026gt; \u0026lt;!-- 渲染 --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Title\u0026lt;/h1\u0026gt; \u0026lt;main\u0026gt; \u0026lt;p\u0026gt;123456\u0026lt;/p\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt;end\u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt;   CodePen Demo：Vue 2.x - 具名插槽\n2. 混用 如果使用具名插槽又使用匿名插槽：\n1 2 3 4 5 6 7 8  Vue.component(\u0026#39;c-demo\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;slot name=\u0026#34;content\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; `, });   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u0026lt;c-demo\u0026gt; \u0026lt;p\u0026gt;111\u0026lt;/p\u0026gt; \u0026lt;template v-slot:content\u0026gt; \u0026lt;p\u0026gt;222\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;p\u0026gt;333\u0026lt;/p\u0026gt; \u0026lt;template\u0026gt; \u0026lt;p\u0026gt;444\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;p\u0026gt;555\u0026lt;/p\u0026gt; \u0026lt;/c-demo\u0026gt; \u0026lt;!-- 渲染 --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;111\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;333\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;444\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;555\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;222\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;   任何沒有被包裹在帶有 v-slot 的 \u0026lt;template\u0026gt; 的內容都會被放進匿名插槽中。\nCodePen Demo：Vue 2.x - Slot 插槽測試\n匿名插槽預設 name 特性名稱為 default，因此如果我們使用 \u0026lt;template v-slot:default\u0026gt; 時，這裡的內容將被放置在匿名插槽中，而且任何沒有被包裹在帶有 v-slot 的 \u0026lt;template\u0026gt; 的內容都將無效：\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;c-demo\u0026gt; \u0026lt;p\u0026gt;1111\u0026lt;/p\u0026gt; \u0026lt;template v-slot:default\u0026gt; \u0026lt;p\u0026gt;222\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template\u0026gt; \u0026lt;p\u0026gt;333\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/c-demo\u0026gt; \u0026lt;!-- 渲染 --\u0026gt; \u0026lt;p\u0026gt;222\u0026lt;/p\u0026gt;   CodePen Demo：Vue 2.x - Slot 插槽測試2\n3. 縮寫 另外 v-slot 指令也有縮寫 #：\n1 2 3 4  \u0026lt;template v-slot:#title\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;!-- 等同 --\u0026gt; \u0026lt;template #title\u0026gt;\u0026lt;/template\u0026gt;   與其他縮寫一樣，只有在有參數時，才能使用。\n作用域插槽 元件 tag 位於父層，如果希望插槽訪問元件的資料，你可以這樣做。\n在設置插槽時，可以綁定 插槽 prop：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  Vue.component(\u0026#39;c-demo\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;slot :obj=\u0026#34;abc\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; `, data() { return { abc: { a: \u0026#39;aaa\u0026#39;, b: \u0026#39;bbb\u0026#39;, }, }; }, });   obj 為我們定義的 插槽 prop，abc 為綁定的資料。\n接下來，我們就能在父層使用 v-slot 指令，可以取得一個物件（可以任意命名），這個物件會包含 \u0026lt;solt\u0026gt; 上所有綁定的 插槽 prop：\n1 2 3 4 5  \u0026lt;c-demo \u0026gt; \u0026lt;template v-slot=\u0026#34;myData\u0026#34;\u0026gt; {{ myData.obj.a }} \u0026lt;/template\u0026gt; \u0026lt;/c-demo\u0026gt;   CodePen Demo：Vue 2.x - 作用域插槽\n但要注意，上面 v-slot=\u0026quot;myData\u0026quot; 屬於匿名插槽的縮寫，當你有使用其它具名插槽時，不能與匿名插槽的縮寫混用，會導致作用域不明確，應該要正確使用原本應該要有的語法 v-slot:default=\u0026quot;myData\u0026quot;。\r 另外，我們還可以解構插槽，例如將上面程式碼改成這樣：\n1 2 3 4 5  \u0026lt;c-demo \u0026gt; \u0026lt;template v-slot=\u0026#34;{ obj }\u0026#34;\u0026gt; {{ obj.a }} \u0026lt;/template\u0026gt; \u0026lt;/c-demo\u0026gt;   甚至可以定義預設值：\n1 2 3 4 5  \u0026lt;c-demo \u0026gt; \u0026lt;template v-slot=\u0026#34;{ obj = { a: \u0026#39;a\u0026#39;} }\u0026#34;\u0026gt; {{ obj.a }} \u0026lt;/template\u0026gt; \u0026lt;/c-demo\u0026gt;   ","description":"Vue 元件 Slot 插槽。","id":33,"section":"posts","tags":["Vue","Vue元件"],"title":"Vue元件 - Slot 插槽","uri":"https://chupai.github.io/posts/vue/component/slot/"},{"content":" 竹白的 Vue 記事本 目錄\n \r自定義事件 在開發元件時，有時候功能還是需要與外層做溝通，但 prop 是單向的。因此 Vue 實體提供了一個 自定義事件 的系統來解決這個問題，使用事件來回應外層資料。\n1. 基本範例 舉個簡單的範例，我們要讓元件 c-button 能夠執行外層的方法。\n首先設定元件會如何觸發監聽方法，在監聽方法內透過 $emit 方法傳入自定義事件名稱。\n1 2 3 4 5 6 7 8  Vue.component(\u0026#39;c-btn\u0026#39;, { methods: { clickHandler() { this.$emit(\u0026#39;my-event\u0026#39;); }, }, template: `\u0026lt;button @click=\u0026#34;clickHandler\u0026#34;\u0026gt;add\u0026lt;/button\u0026gt;`, });   使用 v-on 監聽自定義事件 my-event，並指定要執行事情：\n1 2 3 4  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ counter }}\u0026lt;/p\u0026gt; \u0026lt;c-btn @my-event=\u0026#34;addCounter\u0026#34;\u0026gt;\u0026lt;/c-btn\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11  const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { counter: 0, }, methods: { addCounter() { this.counter += 1; }, }, });   See the Pen Vue 2.x - Emit by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 使用事件拋出一個值 $emit 的第二個參數能夠將值拋出，這個值將會作為第一個參數傳入外層方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  Vue.component(\u0026#39;c-btn\u0026#39;, { methods: { clickHandler() { this.$emit(\u0026#39;my-event\u0026#39;, 3); }, }, template: `\u0026lt;button @click=\u0026#34;clickHandler\u0026#34;\u0026gt;add\u0026lt;/button\u0026gt;`, }); const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { counter: 0, }, methods: { addCounter(val) { this.counter += val; }, }, });   See the Pen Vue 2.x - 拋出一個值 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  自定義事件名稱 不同於元件和 prop，事件名稱無法自動化的大小寫轉換。在 HTML 中使用自定義事件時，需要完全匹配名稱。\n如果觸發一個 camelCase 風格命名的事件：\n1  this.$emit(\u0026#39;myEvent\u0026#39;);   監聽這個名字的 kebab-case 版本是不會有任何效果的：\n1 2  \u0026lt;!-- 沒有效果 --\u0026gt; \u0026lt;c-demo @my-event=\u0026#34;doSomething\u0026#34;\u0026gt;\u0026lt;/c-demo\u0026gt;   官方推薦始終使用 kebab-case 風格命名自定義事件。\n在元件上使用 v-model v-model 可以在表單元素上實現雙向綁定，也可以用在元件上。\n1. 基本範例 請考慮以下情況，假設有一個輸入元件，我們想要實現資料雙向綁定：\n1 2 3 4 5 6 7  Vue.component(\u0026#39;c-demo\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; `, });   你可能需要先用 prop 傳遞給元件，再使用 $emit 拋值給父層：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  Vue.component(\u0026#39;c-demo\u0026#39;, { props: [\u0026#39;inputText\u0026#39;], data() { return { text: this.inputText, }; }, methods: { inputHandler(event) { this.text = event.target.value; this.$emit(\u0026#39;my-event\u0026#39;, this.text); }, }, template: ` \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;text\u0026#34; @input=\u0026#34;inputHandler\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; `, }); const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { text: \u0026#39;hello\u0026#39;, }, methods: { demoHandler(value) { this.text = value; }, }, });   1 2 3 4  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ text }}\u0026lt;/p\u0026gt; \u0026lt;c-demo :input-text=\u0026#34;text\u0026#34; @my-event=\u0026#34;demoHandler\u0026#34;\u0026gt;\u0026lt;/c-demo\u0026gt; \u0026lt;/div\u0026gt;   CodePen Demo：Vue 2.x - 元件雙向綁定\n這樣子的作法非常麻煩且複雜，我們可以改用 v-model 雙向綁定資料：\n1 2 3 4  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ text }}\u0026lt;/p\u0026gt; \u0026lt;c-demo v-model=\u0026#34;text\u0026#34;\u0026gt;\u0026lt;/c-demo\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  Vue.component(\u0026#39;c-demo\u0026#39;, { props: [\u0026#39;value\u0026#39;], template: ` \u0026lt;div\u0026gt; \u0026lt;input :value=\u0026#34;value\u0026#34; @input=\u0026#34;$emit(\u0026#39;input\u0026#39;, $event.target.value)\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; `, }); const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { text: \u0026#39;hello\u0026#39;, }, });   我們需要將 value 特性綁定到一個名叫 value 的 prop 上，並在事件被觸發時，將新的值透過自定義的 input 事件拋出。\nCodePen Demo：Vue 2.x - 在元件上使用 v-model\n2. model 選項 一個元件上的 v-model 預設會利用名為 value 的 prop 和名為 input 的自定義事件。\n除了預設值外，我們可以使用 model 選項來設定 prop 和 event：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  Vue.component(\u0026#39;c-checkbox\u0026#39;, { model: { prop: \u0026#39;checked\u0026#39;, event: \u0026#39;my-event\u0026#39;, }, props: { checked: Boolean, }, template: ` \u0026lt;div\u0026gt; \u0026lt;input :checked=\u0026#34;checked\u0026#34; @change=\u0026#34;$emit(\u0026#39;my-event\u0026#39;, $event.target.checked)\u0026#34; type=\u0026#34;checkbox\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; `, });   CodePen Demo：Vue 2.x - model 選項\n這樣子可以有效避免不同的元件上的語意衝突。\n綁定原生事件 1. 基本範例 在元件 tag 上使用事件綁定，全都屬於自定義事件，因此若要使用原生事件，你可能會這樣做：\n1  \u0026lt;c-button @my-event=\u0026#34;clickHandler\u0026#34;\u0026gt;\u0026lt;/c-button\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14  Vue.component(\u0026#39;c-button\u0026#39;, { template: ` \u0026lt;button @click=\u0026#34;$emit(\u0026#39;my-event\u0026#39;)\u0026#34;\u0026gt;add\u0026lt;/button\u0026gt; `, }); const vm = new Vue({ el: \u0026#39;#app\u0026#39;, methods: { clickHandler() { // ...  }, }, });   這裡我們可以改用事件修飾符號 .native，這樣元件 tag 就能使用元生事件 click，會綁定在根元素上：\n1  \u0026lt;c-button @click.native=\u0026#34;clickHandler\u0026#34;\u0026gt;\u0026lt;/c-button\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12  Vue.component(\u0026#39;c-button\u0026#39;, { template: \u0026#39;\u0026lt;button\u0026gt;add\u0026lt;/button\u0026gt;\u0026#39;, }); const vm = new Vue({ el: \u0026#39;#app\u0026#39;, methods: { clickHandler() { // ...  }, }, });   CodePen Demo：Vue 2.x - 綁定原生事件\n2. 根元素非監聽元素 但是，這種方式只能在用在根元素剛好是要監聽的元素。\n如果我們的元件長這樣：\n1 2 3 4 5 6 7 8  Vue.component(\u0026#39;c-button\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;button\u0026gt;add\u0026lt;/button\u0026gt; \u0026lt;button\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; `, });   就需要用到 Vue 提供的 $listeners 屬性，它是一個物件，裡面包含了作用在這個元件上的所有監聽器（不含使用 .native 的事件）。\n因此我們要先將 inheritAttrs: false，並配合 v-on=\u0026quot;$listeners\u0026quot; 將所有的事件監聽器指向指定的元素。\n1 2 3 4 5 6 7 8 9  Vue.component(\u0026#39;c-button\u0026#39;, { inheritAttrs: false, template: ` \u0026lt;div\u0026gt; \u0026lt;button v-on=\u0026#34;$listeners\u0026#34;\u0026gt;add\u0026lt;/button\u0026gt; \u0026lt;button\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; `, });   1 2 3 4  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ counter }}\u0026lt;/p\u0026gt; \u0026lt;c-button @click=\u0026#34;clickHandler\u0026#34;\u0026gt;\u0026lt;/c-button\u0026gt; \u0026lt;/div\u0026gt;   CodePen Demo：Vue 2.x - 根元素非監聽元素\nv-on=\u0026quot;$listeners\u0026quot; 這裡不能使用縮寫 @，，因為沒綁定事件。\r sync 修飾符號 若希望達到父子元件之間的 prop 進行雙向綁定必須自行實作兩個步驟：\n 從父元件利用 prop 傳值到子元件； 父元件監聽自訂的事件。當子元件發生變更時，使用 $emit('event', value) 將變動通知父元件，並於父元件中自行更改值。  1 2 3 4 5 6 7  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ counter }}\u0026lt;/p\u0026gt; \u0026lt;c-button :counter=\u0026#34;counter\u0026#34; @counter-update=\u0026#34;updateCounter\u0026#34; \u0026gt;\u0026lt;/c-button\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  Vue.component(\u0026#39;CButton\u0026#39;, { props: [\u0026#39;counter\u0026#39;], methods: { clickHandler() { const newCounter = this.counter + 1; this.$emit(\u0026#39;counter-update\u0026#39;, newCounter); }, }, template: \u0026#39;\u0026lt;button @click=\u0026#34;clickHandler\u0026#34;\u0026gt;add\u0026lt;/button\u0026gt;\u0026#39;, }); const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { counter: 0, }, methods: { updateCounter(val) { this.counter = val; }, }, });   CodePen Demo：Vue 2.x - 雙向綁定\nVue 替這種模式提供一個方便的縮寫，即 .sync 修飾符號：\n1 2 3 4  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ counter }}\u0026lt;/p\u0026gt; \u0026lt;c-button :counter.sync=\u0026#34;counter\u0026#34;\u0026gt;\u0026lt;/c-button\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  Vue.component(\u0026#39;CButton\u0026#39;, { props: [\u0026#39;counter\u0026#39;], methods: { clickHandler() { const newCounter = this.counter + 1; this.$emit(\u0026#39;update:counter\u0026#39;, newCounter); }, }, template: \u0026#39;\u0026lt;button @click=\u0026#34;clickHandler\u0026#34;\u0026gt;add\u0026lt;/button\u0026gt;\u0026#39;, }); const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { counter: 0, }, });   使用 update:myPropName 取代外層的更新事件，省略非常多程式碼。\nCodePen Demo：Vue 2.x - .sync 修飾符號\n但這裡要小心，.sync 不能和表達式一起使用，因為你是要雙向綁定資料。\r 另外，如果使用一個物件同時設置多個 prop 時，並且需要雙向綁定，也可以使用 .sync。\nCodePen Demo：Vue 2.x - .sync 修飾符號 - 物件\n如果只有一個 prop 需要雙向綁定，可以選用 v-model，若需要雙向綁定多個 prop 才使用 .sync。\n","description":"Vue 元件自定義事件。","id":34,"section":"posts","tags":["Vue","Vue元件"],"title":"Vue元件 - 自定義事件","uri":"https://chupai.github.io/posts/vue/component/emit/"},{"content":" 竹白的 Vue 記事本 目錄\n \rProp 由於元件與外層（Vue 實體或父元件）屬於不同的實體，因此不能直接在元件上操作外層資料狀態，這時就需要透過 props 選項屬性，將資料從外層傳遞給元件。\n1. 基本範例 假設 Vue 實體有一個資料屬性 url ，要將它傳給 c-img 元件使用。\n1 2 3 4 5 6  const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { url: \u0026#39;https://picsum.photos/200\u0026#39;, }, });   首先，在元件的 props 選項定義一個 prop：\n1 2 3  Vue.component(\u0026#39;c-img\u0026#39;, { props: [\u0026#39;imgUrl\u0026#39;], });   傳遞方式為，在 HTML 上使用自定義特性：\n1  \u0026lt;c-img :img-url=\u0026#34;url\u0026#34;\u0026gt;\u0026lt;/c-img\u0026gt;   這樣我們就能在元件實體上使用這筆資料：\n1 2 3 4  Vue.component(\u0026#39;c-img\u0026#39;, { props: [\u0026#39;imgUrl\u0026#39;], template: \u0026#39;\u0026lt;img :src=\u0026#34;imgUrl\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt;\u0026#39;, });   See the Pen Vue 2.x - 元件 Prop by CHUPAIWANG (@CHUPAIWANG) on CodePen.  Prop 的命名 HTML 中的特性是大小寫不敏感的，因此如果 Prop 的命名是 camelCase，在 HTML 中要轉成 kebab-case。\n1  props: [\u0026#39;imgUrl\u0026#39;]   1  \u0026lt;photo img-url=\u0026#34;https://picsum.photos/200\u0026#34;\u0026gt;\u0026lt;/photo\u0026gt;   但如果是 Prop 的命名是 kebab-case，表達式內要轉成 camelCase：\n1 2  props: [\u0026#39;img-url\u0026#39;], template: \u0026#39;\u0026lt;img :src=\u0026#34;imgUrl\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt;\u0026#39;,   Prop 型別檢查 1. 物件形式 基本範例的 props 選項是以字串陣列的形式定義 prop：\n1  props: [\u0026#39;propA\u0026#39;, \u0026#39;propB\u0026#39;, \u0026#39;propC\u0026#39;]   我們可以可以使用物件形式定義 prop，這樣能夠指定 prop 的型別限制：\n1 2 3 4 5 6  props: { // 基礎的型別檢查  propA: String, // 多個可能的型別  propB: [String, Number], }   這裡的型別不是只有 JS 內建型別的七個型別，而是只要有原生建構函式都可以檢查，例如 Date、Promise 等等。\n若是傳入不符合的型別，開發環境構建版本的 Vue 會在 Console 跳出警告。這在開發第三方元件時非常有用。\n但要注意，null 和 undefined 會符合所有型別查，不會跳出警告。\r 2. Prop 驗證 上面的寫法只能檢查型別，prop 還能使用物件的方式來定義。\n物件規則說明如下：\n type：資料型別，可以是原生建構函式中的一個，或是自定義的建構函式。 default：預設值。 required：該屬性是否為必要。 validator：自定義驗證函式，檢驗屬性資料是否有效。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  props: { // 一定要有值，而且要是字串  propA: { type: String, required: true }, // 帶有預設值  propB: { type: Number, default: 100 }, // 物件或陣列預設值必須從一個工廠函式獲取  propC: { type: Object, default() { return { message: \u0026#39;hello\u0026#39; } } }, // 自定義驗證函式  propD: { validator(value) { // 這個值必須匹配下列字串中的一個  return [\u0026#39;success\u0026#39;, \u0026#39;warning\u0026#39;, \u0026#39;danger\u0026#39;].indexOf(value) !== -1 } } }   prop 驗證會在實體建立前執行，因此 default 和 validator 都不可以使用實體資料狀態（如 data、computed 等）。\r 傳遞靜態或動態資料 prop 可以傳入一個靜態的值，也可以透過 v-bind 動態賦值。\n但要注意，靜態賦值傳入的結果值為字串，如果要傳數值、布林值、陣列、物件等等，需要用到 v-bind 才會是 JS 表達式。\n舉例來說，傳入一個數值：\n1 2 3 4 5  \u0026lt;!-- 靜態 --\u0026gt; \u0026lt;text-component text-content=\u0026#34;42\u0026#34;\u0026gt;\u0026lt;/text-component\u0026gt; \u0026lt;!-- 動態 --\u0026gt; \u0026lt;text-component v-bind:text-content=\u0026#34;42\u0026#34;\u0026gt;\u0026lt;/text-component\u0026gt;   靜態傳入的 42 是字串，不是數值，必須使用 v-bind 動態傳入。\n1. 傳入一個布林值 如果指定一個 prop 是布林值：\n 那麼就算 prop 特性沒給值的情況下，它也會傳 true； 若是沒有設定特性，則會傳 false。  1 2 3  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;c-demo b\u0026gt;\u0026lt;/c-demo\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  Vue.component(\u0026#39;c-demo\u0026#39;, { props: { a: Boolean, b: Boolean, }, created() { console.log(this.a); // false  console.log(this.b); // true  }, }); const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: {}, });   CodePen Demo：Vue 2.x - 傳入一個布林值\n2. 傳入一個物件的所有屬性 如果要傳入一個物件的所有屬性，可以使用不帶參數的 v-bind。\n舉例來說，假設要將一個物件 obj 中的所有屬性，分別傳遞給一個元件，需要在元件 props 定義對應的屬性：\n1 2 3 4 5 6 7 8 9 10  // 外層資料 data: { obj: { aaa: \u0026#39;a\u0026#39;, bbb: \u0026#39;b\u0026#39;, }, } // 元件 prop props: [\u0026#39;aaa\u0026#39;, \u0026#39;bbb\u0026#39;]   並且將對應的物件屬性傳入元件：\n1 2 3  \u0026lt;c-demo v-bind:aaa=\u0026#34;obj.aaa\u0026#34; v-bind:bbb=\u0026#34;obj.bbb\u0026#34;\u0026gt;\u0026lt;/c-demo\u0026gt;   可以使用不帶參數的 v-bind 傳入物件，會自動將物件解構傳入，等同上面傳入操作：\n1  \u0026lt;c-demo v-bind=\u0026#34;obj\u0026#34;\u0026gt;\u0026lt;/c-demo\u0026gt;   CodePen Demo：Vue 2.x - 傳入一個物件的所有屬性\n要注意，v-bind 這裡不能使用縮寫，因為沒綁定特性。\r 單向資料流（One-Way Data Flow） 元件的 prop 是單向綁定的，可由外向內傳遞資料，但不會反過來。主要是為了避免子元件任意更改父級的狀態，從而導致你的應用程式的資料流向難以理解。\n如果直接去改變 prop，開發環境版本的 Vue 會在 Console 跳出警告。\r 若我們有改變資料的需求，就必須使用 data 或 computed 儲存它：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  props: [\u0026#39;initialCounter\u0026#39;], data() { return { counter: this.initialCounter } } // or props: [\u0026#39;size\u0026#39;], computed: { normalizedSize() { return this.size.trim().toLowerCase() } }   如果外層傳入的資料是物件型別（物件、陣列），還是會因為傳址的特性，不小心更動到父級的資料狀態。因此盡量避免傳入物件型別的資料，確保資料的流向。\r 非 Prop 的特性 一個非 prop 的特性，指的是元件未定義的 prop 的定性。\n1. 替換/合併 如果在元件 tag 上使用非 prop 的特性，它將被加到根元素上。\n對於大部分的特性來說，若是元件根元素已經有相同的特性，特性值將會被替換掉：\n1 2 3 4  Vue.component(\u0026#39;c-demo\u0026#39;, { props: [], template: \u0026#39;\u0026lt;div data-text=\u0026#34;5\u0026#34;\u0026gt;demo\u0026lt;/div\u0026gt;\u0026#39; });   1 2 3 4  \u0026lt;c-demo data-text=\u0026#34;10\u0026#34;\u0026gt;\u0026lt;/c-demo\u0026gt; \u0026lt;!-- 將被渲染成 --\u0026gt; \u0026lt;div data-text=\u0026#34;10\u0026#34;\u0026gt;demo\u0026lt;/div\u0026gt;   但對於樣式特性：\n class 會智能的合併，不會出現重複或覆蓋類別； style 也會合併（根元素上的樣式再前），但如果有重複的 CSS 樣式，根元素上的樣式會被覆蓋。  2. 禁用繼承 請考慮以下情況。\n建立一個 checkbox 元件，但根元素通常不會是 \u0026lt;input\u0026gt; 元素。如果在元件 tag 上使用 checked=\u0026quot;checked\u0026quot; 一定無法作用：\n1 2 3 4 5 6 7 8  Vue.component(\u0026#39;c-checkbox\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;checkbox\u0026#34;\u0026gt; \u0026lt;label\u0026gt;要不要\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; `, });   因此，我們要關掉根元素繼承特性，需要在元件選項中設置 inheritAttrs: false：\n1 2 3 4  Vue.component(\u0026#39;c-demo\u0026#39;, { inheritAttrs: false, // ... });   注意 inheritAttrs: false 選項不會影響 style 和 class 的綁定。\r 設置完 inheritAttrs: false 後，要搭配 $attrs 使用，它是一個物件，包含元件 tag 上所有非 Prop 的特性（style 和 class 除外）。\n使用 v-bind 手動將它綁定要作用的元素上：\n1 2 3 4 5 6 7 8 9  Vue.component(\u0026#39;c-checkbox\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;checkbox\u0026#34; v-bind=\u0026#34;$attrs\u0026#34;\u0026gt; \u0026lt;label\u0026gt;要不要\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; `, inheritAttrs: false, });   1 2 3  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;c-checkbox checked=\u0026#34;checked\u0026#34;\u0026gt;\u0026lt;/c-checkbox\u0026gt; \u0026lt;/div\u0026gt;   CodePen Demo：Vue 2.x - 非 Prop 的特性\n注意，checked=\u0026quot;checked\u0026quot; 有時會簡寫成 checked。但關閉繼承後，在 $attrs 物件內 checked 會得到空字串（因為沒給值），也就是說會變成不勾選狀態。因此在使用表單元素相關特性時，要多加留意。\r","description":"Vue 元件的狀態資料傳遞。","id":35,"section":"posts","tags":["Vue","Vue元件"],"title":"Vue元件 - Prop","uri":"https://chupai.github.io/posts/vue/component/prop/"},{"content":" 竹白的 Vue 記事本 目錄\n \r元件 元件的概念就是將整個頁面拆分成一個一個的小區塊，然後像積木一樣把頁面組合起來。\n拆分成元件的優點：\n 只需要維護自己依賴的 CSS、JS； 元件可以進行任意次數的復用； 獨立的 data、computed、watch、methods 等等。  注意事項：\n data 必須使用 function 函式； 需註冊才能使用。  元件中 data 必須是函式的原因是，元件是可以重複利用的，在正常的情況下，它會使用不同的資料。使用函式建構資料，在建立新的元件時，都會回傳一個新的物件。\n註冊 註冊元件的方式有兩種：\n 全域（Global）註冊 區域（Local）註冊  不論全域註冊或是區域註冊，都必須在 Vue 實體之前完成。\n1. 全域註冊 如果有元件共用的需求，我們會使用 Vue.component() 來全域註冊一個元件。\n語法：\n1  Vue.component(id, options);    id：元件名稱 options：選項物件  舉例來說，定義一個名為 c-layout 的元件：\n1 2 3 4 5 6 7 8 9  Vue.component(\u0026#39;c-layout\u0026#39;, { // 注意，元件必須使用 function  data() { return { text: \u0026#39;全域註冊\u0026#39;, }; }, template: \u0026#39;\u0026lt;div\u0026gt;{{ text }}\u0026lt;/div\u0026gt;\u0026#39;, });   全域註冊後，就可以在任何 Vue 實體中使用：\n1 2 3  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;c-layout\u0026gt;\u0026lt;/c-layout\u0026gt; \u0026lt;/div\u0026gt;   1 2 3  const vm = new Vue({ el: \u0026#39;#app\u0026#39;, });   See the Pen Vue 2.x - 元件全域註冊 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 區域註冊 使用全域註冊的缺點是，不論是否有使用到都會載入，因此如果載入大量用不到的元件，對網頁整體來說較不佳，會拖慢載入速度。\n因此可以使用 components 選項來區域註冊元件，這個元件只能註冊的 Vue 實體上使用。\n定義元件的選項物件：\n1 2 3 4 5 6 7 8  const Clayout = { data() { return { text: \u0026#39;區域註冊\u0026#39;, } }, template: \u0026#39;\u0026lt;div\u0026gt;{{ text }}\u0026lt;/div\u0026gt;\u0026#39;, };   在 component 選項中載入：\n1 2 3 4 5 6  const vm = new Vue({ el: \u0026#39;#app\u0026#39;, components: { \u0026#39;c-layout\u0026#39;: Clayout, }, });   See the Pen Vue 2.x - 元件區域註冊 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  命名規則 1. 命名限制 元件的命名限制：\n 不使用非法的 tag 字元； 不與 HTML 元素或 SVG 元素重名； 不使用 Vue 保留的 slot 和 component； 避免與 Vue 內建的 KeepAlive、Transition、TransitionGroup 三個元件重名。  2. kebab-case 命名元件時，可以使用 kebab-case 或 camelCase：\n1 2  // kebab-case Vue.component(\u0026#39;text-component\u0026#39;, {...});   1 2  // camelCase Vue.component(\u0026#39;textComponent\u0026#39;, {...});   但是瀏覽器在解析 HTML tag 時，無大小寫之分，因此在使用元件時，必須要改成 kebab-case：\n1  \u0026lt;text-component\u0026gt;\u0026lt;/text-component\u0026gt;   因此要注意，統一命名寫法別混用，避免重複命名元件。\n:::success\n若是在 .vue 單一元件檔的 \u0026lt;template\u0026gt; 中使用元件，HTML tag 則無大小寫限制。\n:::\n3. 風格指南 在 官方的風格指南 有許多關於元件命名的建議。\nTemplates 1. 建立元件模板 定義元件的 Templates 有兩種作法：\n String Template DOM Template  上面的範例就是使用 String Template，直接利用字串定義元件的 template 選項。但是這個做法的缺點很明顯，假如介面非常複雜，會讓程式變的難以閱讀及維護。\n因此可以改用 DOM Template，主要是透過 \u0026lt;script type=\u0026quot;text/x-template\u0026quot;\u0026gt; 來建立。\n1 2 3 4 5 6 7  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;c-layout\u0026gt;\u0026lt;/c-layout\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/x-template\u0026#34; id=\u0026#34;cLayoutTemplate\u0026#34;\u0026gt; \u0026lt;div\u0026gt;{{text}}\u0026lt;/div\u0026gt; \u0026lt;/script\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const Clayout = { data() { return { text: \u0026#39;DOM Template\u0026#39;, } }, template: \u0026#39;#componentLayoutTemplate\u0026#39;, }; const vm = new Vue({ el: \u0026#39;#app\u0026#39;, components: { \u0026#39;c-layout\u0026#39;: Clayout, }, });   See the Pen Vue 2.x - 建立元件模板 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 解析 DOM 模板的注意事項 在 HTML 中，\u0026lt;ul\u0026gt;、\u0026lt;ol\u0026gt;、\u0026lt;table\u0026gt;、\u0026lt;select\u0026gt; 等 tag 底下不能隨便塞入其他 tag。格式不合法的話，不同瀏覽器會有不同的解析結果，有的會直接刪除或是移到外層。\n請考慮以下程式碼：\n1 2 3 4 5 6 7  Vue.component(\u0026#39;c-layout\u0026#39;, { template: ` \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;TEST\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; `, });   1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;c-layout\u0026gt;\u0026lt;/c-layout\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 渲染成 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;TEST\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;table\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt;   因為我們在 \u0026lt;table\u0026gt; 內放了 \u0026lt;c-layout\u0026gt;，被瀏覽器認為式非法 tag，所以被移到外層。\n因此 Vue 提供了 is 特性的語法，可用來引入元件。\n將上述程式碼改成：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr is=\u0026#34;c-layout\u0026#34;\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 渲染成 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;TEST\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt;   但是如果我們是在以下 Template 來源中使用元件，這條限制是不存在的：\n 字串 單一元件檔.vue \u0026lt;script type=\u0026quot;text/x-template\u0026quot;\u0026gt;  舉例來說：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  Vue.component(\u0026#39;c-layout\u0026#39;, { template: ` \u0026lt;table\u0026gt; \u0026lt;c-layout2\u0026gt;\u0026lt;/c-layout2\u0026gt; \u0026lt;/table\u0026gt; `, }); Vue.component(\u0026#39;c-layout2\u0026#39;, { template: ` \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;TEST\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; `, });   1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;c-layout\u0026gt;\u0026lt;/c-layout\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 渲染成 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;TEST\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt;   3. 外層根元素 Template 一定要有一個外層的根元素（Root element），不然沒辦法知道這個元件的邊界在哪。\n舉例來說，不能將寫成這樣：\n1 2 3 4 5 6 7 8 9  \u0026lt;!-- 錯誤示範1 --\u0026gt; \u0026lt;p\u0026gt;text\u0026lt;/p\u0026gt; \u0026lt;span\u0026gt;123\u0026lt;/span\u0026gt; \u0026lt;!-- 錯誤示範2 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;p\u0026gt;text\u0026lt;/p\u0026gt; \u0026lt;span\u0026gt;123\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt;   以上皆會拋出錯誤。\n必須要有一個根元素將它包起來：\n1 2 3 4  \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;text\u0026lt;/p\u0026gt; \u0026lt;span\u0026gt;123\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt;   動態切換 我們可以透過 \u0026lt;component\u0026gt; 和 is 特性，動態切換不同的元件。\n這裡有三個不同的元件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  Vue.component(\u0026#39;c-aaa\u0026#39;, { template: \u0026#39;\u0026lt;p\u0026gt;component A\u0026lt;/p\u0026gt;\u0026#39;, }); Vue.component(\u0026#39;c-bbb\u0026#39;, { template: \u0026#39;\u0026lt;p\u0026gt;component B\u0026lt;/p\u0026gt;\u0026#39;, }); Vue.component(\u0026#39;c-ccc\u0026#39;, { template: \u0026#39;\u0026lt;p\u0026gt;component C\u0026lt;/p\u0026gt;\u0026#39;, }); const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { current: \u0026#39;c-aaa\u0026#39;, }, });   使用 v-bind:is 來動態切換元件：\n1 2 3 4 5 6  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;current = \u0026#39;c-aaa\u0026#39;\u0026#34;\u0026gt;A\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;current = \u0026#39;c-bbb\u0026#39;\u0026#34;\u0026gt;B\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;current = \u0026#39;c-ccc\u0026#39;\u0026#34;\u0026gt;C\u0026lt;/button\u0026gt; \u0026lt;component\u0026gt; v-bind:is=\u0026#34;current\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/div\u0026gt;   維持元件生命週期 切換元件時，可能會遇到一個問題，Vue 會直接把 DOM 上的元件消滅再重渲染一份。如果你有保留狀態的需求，可以在外層包一層 Vue 內建元件 \u0026lt;keep-alive\u0026gt;。\n請考慮以下程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  Vue.component(\u0026#39;c-counter\u0026#39;, { data() { return { count: 0, }; }, template: ` \u0026lt;div\u0026gt; \u0026lt;button @click=\u0026#34;count += 1\u0026#34;\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;{{ count }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;`, }); const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { show: false, }, });   1 2 3 4  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;show = !show\u0026#34;\u0026gt;show Counter\u0026lt;/button\u0026gt; \u0026lt;c-counter v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/counter\u0026gt; \u0026lt;/div\u0026gt;   v-if 會卸載 DOM 元素，因此如果我們隱藏元件後再打開，計數又會重 0 開始。\n因此我們可以用 \u0026lt;keep-alive\u0026gt; 將元件包起來：\n1 2 3  \u0026lt;keep-alive\u0026gt; \u0026lt;c-counter v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/counter\u0026gt; \u0026lt;/keep-alive\u0026gt;   See the Pen Vue 2.x - 維持元件生命週期 by CHUPAIWANG (@CHUPAIWANG) on CodePen. ","description":"Vue 元件基礎。","id":36,"section":"posts","tags":["Vue","Vue元件"],"title":"Vue元件 - 基礎","uri":"https://chupai.github.io/posts/vue/component/component/"},{"content":"Vue 指令篇\n\r 這週是六角鼠年鐵人賽第三十七週，Vue 筆記的第二篇。\n 竹白的 Vue 記事本 目錄\n Vue - 指令篇：\n 指令概述 特性綁定 條件渲染 \u0026amp; 列表渲染 事件綁定 表單資料的雙向綁定 ","description":"Vue 指令篇。","id":37,"section":"posts","tags":["Vue","w3HexSchool"],"title":"Vue - 指令","uri":"https://chupai.github.io/posts/2010/vue_directives/"},{"content":" 竹白的 Vue 記事本 目錄\n \r表單綁定 在表單元素中，要監聽使用者輸入的資料並更新畫面，需要同時做兩件事。\n請考慮下面程式碼：\n1 2  \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;message\u0026#34; @input=\u0026#34;onInput\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;Message is : {{ message }}\u0026lt;/p\u0026gt;   1 2 3 4 5 6 7 8  data: { message: \u0026#39;\u0026#39; }, methods: { onInput(event) { this.message = event.target.value; } }    將 \u0026lt;input\u0026gt; 的 value 特性綁定 message； 並監聽 \u0026lt;input\u0026gt;，當事件觸發時，更新 message。  Vue 提供了 v-model 語法糖，簡化了上述表單雙向綁定的操作。\n1 2  \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;message\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Message is : {{ message }}\u0026lt;/p\u0026gt;   1 2 3  data: { message: \u0026#39;\u0026#39; }   當輸入文字框內的內容改變時，就會同步更新 message。\nSee the Pen 表單資料的雙向綁定 v-model by CHUPAIWANG (@CHUPAIWANG) on CodePen.  v-model v-model 指令可以在表單元素上進行資料的雙向綁定。\n會根據表單控制類型使用不同的特性並拋出不同的事件：\n text 和 textarea 元素使用 value 特性和 input 事件； checkbox 和 radio 使用 checked 特性和 change 事件； select 將 value 作為 prop 並將 change 作為事件。  另外，所有表單元素只要有綁定 v-model，就會忽略 value、checked、selected 等特性的設定。預設狀態會根據綁定資料的預設值顯示。\n對於需要使用輸入法編輯器（Input Method Editor, IME）的語言（如中文、日文、韓文等），你會發現 v-model 不會在輸入法組合文字過程中得到更新。因為 Vue 有使用 Composition Event 進行處理，你可以在 原始碼 中看到。\r 輸入文字框  \u0026lt;input type=\u0026quot;text\u0026quot;\u0026gt;：單行輸入文字框 \u0026lt;textarea\u0026gt;：多行輸入文字框  單行輸入文字框就如開頭的範例所示，多行輸入文字框則與它一模一樣：\n1 2  \u0026lt;textarea v-model=\u0026#34;message\u0026#34; \u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;p\u0026gt;Message is : {{ message }}\u0026lt;/p\u0026gt;   1 2 3  data: { message: \u0026#39;\u0026#39; }   單選的按鈕欄位 radio radio 只能單選，綁定的資料為字串。\n1 2 3 4 5 6 7 8 9 10  \u0026lt;input id=\u0026#34;a\u0026#34; v-model=\u0026#34;picked\u0026#34; type=\u0026#34;radio\u0026#34; value=\u0026#34;a\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;a\u0026#34;\u0026gt;A\u0026lt;/label\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;input id=\u0026#34;b\u0026#34; v-model=\u0026#34;picked\u0026#34; type=\u0026#34;radio\u0026#34; value=\u0026#34;b\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;b\u0026#34;\u0026gt;B\u0026lt;/label\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;input id=\u0026#34;c\u0026#34; v-model=\u0026#34;picked\u0026#34; type=\u0026#34;radio\u0026#34; value=\u0026#34;c\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;c\u0026#34;\u0026gt;C\u0026lt;/label\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;p\u0026gt;Picked: {{ picked }}\u0026lt;/p\u0026gt;   1 2 3  data: { picked: \u0026#39;a\u0026#39; },   See the Pen 表單資料的雙向綁定 v-model 選項 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  可複選的核取方塊欄 checkbox checkbox 綁定的資料為布林值或陣列。\n1. 布林值 checkbox 單獨使用時，v-model 會綁定一個布林值：\n1 2  \u0026lt;input id=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;checked\u0026#34; type=\u0026#34;checkbox\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;checkbox\u0026#34;\u0026gt;{{ checked }}\u0026lt;/label\u0026gt;   1 2 3  data: { checkbox: true },    當資料預設值為 true 時，checkbox 會是勾選狀態，反之 false 則為未勾選狀態； 當改變 checkbox 勾選狀態時，資料會隨著勾選狀態改變成 true 或 false；  See the Pen 表單資料的雙向綁定 v-model - checkbox by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 陣列 如果是多個 checkbox 複選欄，v-model 要綁定一個陣列：\n1 2 3 4 5 6 7 8  \u0026lt;input id=\u0026#34;jack\u0026#34; v-model=\u0026#34;checkedNames\u0026#34; type=\u0026#34;checkbox\u0026#34; value=\u0026#34;Jack\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;jack\u0026#34;\u0026gt;Jack\u0026lt;/label\u0026gt; \u0026lt;input id=\u0026#34;john\u0026#34; v-model=\u0026#34;checkedNames\u0026#34; type=\u0026#34;checkbox\u0026#34; value=\u0026#34;John\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;john\u0026#34;\u0026gt;John\u0026lt;/label\u0026gt; \u0026lt;input id=\u0026#34;mike\u0026#34; v-model=\u0026#34;checkedNames\u0026#34; type=\u0026#34;checkbox\u0026#34; value=\u0026#34;Mike\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;mike\u0026#34;\u0026gt;Mike\u0026lt;/label\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;p\u0026gt;{{ checkedNames }}\u0026lt;/p\u0026gt;   1 2 3  data: { checkedNames: [], },   勾選時，會根據勾選順序，將該值加入到陣列中。\nSee the Pen 表單資料的雙向綁定 v-model - checkbox by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 值綁定 單獨使用一個 checkbox 時，如果要自定義勾選與未勾選時的資料值，可以用 true-value 及 false-value 特性：\n1 2  \u0026lt;input id=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;checked\u0026#34; type=\u0026#34;checkbox\u0026#34; true-value=\u0026#34;要\u0026#34; false-value=\u0026#34;不要\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;checkbox\u0026#34;\u0026gt;{{ checked }}\u0026lt;/label\u0026gt;   1 2 3  data: { checked: \u0026#39;要\u0026#39;, },   See the Pen 表單資料的雙向綁定 v-model 動態資料綁定 - checkbox by CHUPAIWANG (@CHUPAIWANG) on CodePen.  如果要用來提交表單，請改用單選的按鈕。因為這裡的 true-value 和 false-value 特性並不會影響 value 特性。\r 下拉選單 select 1. 單選 使用下拉選單 \u0026lt;select\u0026gt; 時，v-model 是綁定字串：\n1 2 3 4 5 6 7  \u0026lt;select v-model=\u0026#34;selected\u0026#34;\u0026gt; \u0026lt;option disabled value=\u0026#34;\u0026#34;\u0026gt;Please select one\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;A\u0026#34;\u0026gt;A\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;B\u0026#34;\u0026gt;B\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;C\u0026#34;\u0026gt;C\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;span\u0026gt;Selected: {{ selected }}\u0026lt;/span\u0026gt;   1 2 3  data: { selected: \u0026#39;\u0026#39; },    有設定 value 特性，資料會存入 value 值； 若是沒有，會將內容當作成 value 值存入。但是不建議這麼做。  See the Pen 表單資料的雙向綁定 v-model 下拉選單-單選 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  如果 v-model 綁定資料的預設值未能匹配任何選項，\u0026lt;select\u0026gt; 將被渲染為未選中狀態。在 iOS 中，這會使用戶無法選擇第一個選項。因為這樣的情況下，iOS 不會觸發 change 事件。因此，推薦像上面範例一樣，提供一個值為空的禁用選項。\n2. 複選 下拉選單加上 multiple 特性會變成可以複選，會改成綁定陣列：\n1 2 3 4 5 6 7 8  \u0026lt;select v-model=\u0026#34;selected\u0026#34; multiple\u0026gt; \u0026lt;option\u0026gt;A\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;B\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;C\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;D\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;br\u0026gt; \u0026lt;span\u0026gt;Selected: {{ selected }}\u0026lt;/span\u0026gt;   1 2 3  data: { selected: [], },   See the Pen 表單資料的雙向綁定 v-model 下拉選單-複選 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  修飾符  .lazy：將預設的 input 事件改為監聽 change 事件。 .number：輸入字串轉為有效的數字。 .trim：輸入首尾空格過濾。  1. lazy 使用者每次輸入就會觸發 input 事件，若不希望資料更新次數這麼頻繁，可以使用 .lazy 將監聽改成 change 事件。\n1  \u0026lt;input type=\u0026#34;text\u0026#34; v-model.lazy=\u0026#34;message\u0026#34;\u0026gt;   改成這樣子，只有離開輸入框的焦點時，資料才會更新，顯示資料將不會是及時的。\nSee the Pen 表單資料的雙向綁定 v-model - lazy by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. number 使用輸入框取得的值都是字串，就是使用 number 類型的輸入框也一樣，這麼一來，取得資料後還需要將值轉成數值型別才能做數值操作。\n因此我們可以使用 .number 讓 Vue 幫我們轉型：\n1 2 3 4 5  \u0026lt;input type=\u0026#34;number\u0026#34; v-model.number=\u0026#34;number1\u0026#34;\u0026gt; ＋ \u0026lt;input type=\u0026#34;number\u0026#34; v-model.number=\u0026#34;number2\u0026#34;\u0026gt; ＝ {{ sum }}   1 2 3 4 5 6 7 8 9  data: { number1: 0, number2: 1, }, computed: { sum() { return this.number1 + this.number2; } }   See the Pen 表單資料的雙向綁定 v-model - number by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. trim 使用 .trim 字串會執行 trim()，自動過濾首尾空白字元。\n","description":"Vue 表單資料的雙向綁定。","id":38,"section":"posts","tags":["Vue","Vue指令"],"title":"表單資料的雙向綁定","uri":"https://chupai.github.io/posts/vue/directives/vmodel/"},{"content":" 竹白的 Vue 記事本 目錄\n \r事件綁定 事件是 JavaScript 操作網頁最重要的部分。在 Vue 主要是透過 v-on 指令來對需要監聽的 DOM 進行事件綁定，因為比較常用到，可以使用「@」來縮寫。\n1 2 3 4 5  \u0026lt;!-- 語法 --\u0026gt; \u0026lt;button v-on:event=\u0026#34;expression\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;!-- 縮寫 --\u0026gt; \u0026lt;button @event=\u0026#34;expression\u0026#34;\u0026gt;\u0026lt;/button\u0026gt;    event：事件名稱。 expression：表達式，預期值為。  Inline Statement Function Object    1. 行內敍述 範例，一個按鈕綁定 click：\n1 2  \u0026lt;button v-on:click=\u0026#34;count += 1\u0026#34;\u0026gt;點我+1\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;{{ count }}\u0026lt;/p\u0026gt;   1 2 3  data: { count: 0, },   See the Pen v-on 行內敍述 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 綁定事件處理函式 行內敍述只能用於簡單事件處理，因為你不可能將所有邏輯複雜的程式碼都寫在 v-on 指令中，或者遇到需要重複執行的情況。因此可以將事件處理函式用 method 宣告，並透過 v-on 綁定。\n1 2  \u0026lt;button v-on:click=\u0026#34;addCount\u0026#34;\u0026gt;點我+1\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;{{ count }}\u0026lt;/p\u0026gt;   1 2 3 4 5 6 7 8  data: { count: 0, }, methods: { addCount() { this.count += 1; }, }   See the Pen v-on 事件處理函式 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 傳遞參數 如果要在事件中傳遞參數，可以在行內敍述中直接呼叫事件處理函式：\n1 2  \u0026lt;button v-on:click=\u0026#34;addCount(3)\u0026#34;\u0026gt;點我\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;{{ count }}\u0026lt;/p\u0026gt;   1 2 3 4 5 6 7 8  data: { count: 0, }, methods: { addCount(i) { this.count += i; }, }   See the Pen v-on 在事件中傳遞參數 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  4. 綁定多個事件 綁定多個事件，可以重複使用 v-on 指令：\n1 2 3 4 5 6 7 8 9 10 11  data: { doWhat: \u0026#39;\u0026#39; }, methods: { showUp(event) { this.doWhat = `up ${event.target.tagName}`; }, showDown(event) { this.doWhat = `down ${event.target.tagName}`; } }   1 2 3 4 5 6  \u0026lt;button v-on:mousedown=\u0026#34;showDown\u0026#34; v-on:mouseup=\u0026#34;showUp\u0026#34;\u0026gt; click me \u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;{{ doWhat }}\u0026lt;/p\u0026gt;   或是使用物件綁定事件的方式：\n1 2  \u0026lt;button v-on=\u0026#34;{ mousedown: showDown, mouseup: showUp }\u0026#34;\u0026gt;click me\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;{{ doWhat }}\u0026lt;/p\u0026gt;   使用物件綁定事件的方式，有以下幾點要注意：\n 指令沒參數，不能使用簡寫 @； 也無法使用修飾符號； 函式無法傳參數。  CodePen Demo：Vue2.x - v-on 物件綁定事件\n4. 事件物件 如果要獲取 event 物件，可以使用特殊變數 $event：\n1  \u0026lt;button v-on:click=\u0026#34;alert($event.target)\u0026#34;\u0026gt;event\u0026lt;/button\u0026gt;   使用 v-on 綁定方法，預設會傳入一個參數 event 事件物件：\n1  \u0026lt;button v-on:click=\u0026#34;addCount\u0026#34;\u0026gt;event\u0026lt;/button\u0026gt;   1 2 3 4 5 6  methods: { addCount(event) { this.count += 1; alert(event.target); }, }   但是，直接呼叫事件處理函式，要訪問 event 物件，要自己將 $event 傳入：\n1 2  \u0026lt;button v-on:click=\u0026#34;addCount(3, $event)\u0026#34;\u0026gt;點我\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;{{ count }}\u0026lt;/p\u0026gt;   1 2 3 4 5 6 7 8 9  data: { count: 0, }, methods: { addCount(i, event) { this.count += i; alert(event.target); }, }   事件行為修飾符號 1. 通用修飾符號  .stop：呼叫 event.stopPropagation()，停止事件的繼續傳遞。 .prevent：呼叫 event.preventDefault()，停止事件預設行為。 .self：只有當事件是從監聽器所綁定的元素本身（非子元素）才呼叫事件處理函式，簡單來說就是事件處於目標階段才會呼叫事件處理函式。 .capture：事件監聽器使用補獲模式。 .once：該事件處理函式指被呼叫一次（還能被用到自定義的元件事件上）。 .passive：與 .prevent 剛好相反，表示事件處理函式永遠不會呼叫 preventDefault()（所以別與 .prevent 共用）。 .native：監聽根元素的原生事件（在元件上使用 v-on 只會監聽自定義事件，如果要監聽監聽根元素的原生事件時，就可以使用）。  使用 .stop 等同：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // 使用 .stop 等同 doThis(event) { event.stopPropagation(); } // 使用 .prevent 等同 doThis(event) { event.preventDefault(); } // 使用 .self 等同 doThis(event) { if(!event.target === event.currentTarget) { return } // or  if(!event.eventPhase === 2) { return } }   .capture、.once、.passive 分別對應到 addEventListener() 的 options 選項參數。.native 會在元件用到。\n一個指令可以加上複數修飾符號，但順序會影響執行的結果。\r 舉例來說，v-on:click.prevent.self 會阻止所有的點擊，而 v-on:click.self.prevent 只會阻止對元素自身的點擊。\n2. 鍵盤事件修飾符號 鍵盤事件 kepdown 與 keyup 可以使用鍵盤事件修飾符號。\n原本需要使用鍵盤事件的 key 屬性來判斷是否按下 Enter 鍵來執行處理函式：\n1 2 3 4  submit(event) { if(event.key !=== \u0026#39;Enter\u0026#39;) {return} //... }   現在只需要使用修飾符號：\n1  \u0026lt;div v-on:keyup.enter=\u0026#34;submit\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   原則上，所有 key 值 都有對應的修飾符號，若遇到 PageDown 這類名稱，需轉成 kebab-case 來使用：\n1  \u0026lt;input v-on:keyup.page-down=\u0026#34;onPageDown\u0026#34;\u0026gt;   2.1 keyCode 鍵盤事件的 keyCode 屬性用法已經被廢棄了，雖然目前因為舊程式碼仍保留支援，但為了未來瀏覽器，盡可能不使用它。\r 使用 keyCode 修飾符號：\n1  \u0026lt;input v-on:keyup.13=\u0026#34;submit\u0026#34;\u0026gt;   為了在必要的情況下支持舊瀏覽器，Vue 提供了絕大多數常用的按鍵別名：\n .enter Enter 鍵 .tab Tab 鍵 .delete（包含 Backspace 鍵、Delete 鍵） .esc ESC 鍵 .space 空白鍵 .up 方向鍵上 .down 方向鍵下 .left 方向鍵左 .right 方向鍵右  舉例來說，IE9 上面的某些按鍵 key 值會跟別人不同，因此使用上面按鍵的別名會是首要選擇。\n另外可透過全域 config.keyCodes 物件，自定義按鍵修飾符號別名。\n3. 系統鍵修飾符號 系統鍵修飾符號不只鍵盤事件能用，包含了滑鼠事件：\n .ctrl（MAC 沒有） .alt .shift .meta（MAC 的 command 鍵 ⌘，Windows 則對應到 win 鍵 ⊞）  1 2 3 4 5  \u0026lt;!-- Alt + C --\u0026gt; \u0026lt;input v-on:keyup.alt.67=\u0026#34;clear\u0026#34;\u0026gt; \u0026lt;!-- Ctrl + Click --\u0026gt; \u0026lt;div v-on:click.ctrl=\u0026#34;doSomething\u0026#34;\u0026gt;Do something\u0026lt;/div\u0026gt;   請注意，系統鍵修飾符號和 keyup 事件一起使用時，系統鍵修飾符號必須處於按下狀態。也就是說，只有按住系統鍵修飾符號情況下釋放其他按鍵才能觸發。若想要單獨使用系統鍵和 keyup 事件，請改用 keyCode 對應的修飾符號，以 keyup.ctrl 來說，就是改用 keyup.17。\r 3.1 精確判斷 .exact 修飾符號允許你控制由精確的系統修飾符號組合觸發的事件。\n1 2 3 4 5 6 7 8  \u0026lt;!-- 即使 Alt 或 Shift 被一同按下時也會觸發 --\u0026gt; \u0026lt;button @click.ctrl=\u0026#34;onClick\u0026#34;\u0026gt;A\u0026lt;/button\u0026gt; \u0026lt;!-- 有且只有 Ctrl 單獨被按下的時候才觸發 --\u0026gt; \u0026lt;button @click.ctrl.exact=\u0026#34;onCtrlClick\u0026#34;\u0026gt;A\u0026lt;/button\u0026gt; \u0026lt;!-- 沒有任何系統修飾符號被按下的時候才觸發 --\u0026gt; \u0026lt;button @click.exact=\u0026#34;onClick\u0026#34;\u0026gt;A\u0026lt;/button\u0026gt;   4. 滑鼠按鍵修飾符號：  .left：只當點擊滑鼠左鍵時觸發。 .right：只當點擊滑鼠右鍵時觸發。 .middle：只當點擊滑鼠中鍵時觸發。  右鍵會跳出選單，可以搭配 .prevent 修飾符號。\n視窗監聽 若是要監聽 window 物件，就沒辦法使用 v-on 指令了。\n這時事件監聽就需要用到生命週期 mounted、beforeDestroy 鉤子。\n在 mounted 鉤子上進行監聽：\n1 2 3 4 5 6 7 8  mounted() { window.addEventListener(\u0026#39;resize\u0026#39;, this.resizeHandler); }, methods: { resizeHandler(event) { // do something  }, },   但是這樣子的作法，若生命週期結束實體銷毀時，它並不會自動移除事件監聽，因此需要在 beforeDestroy 鉤子手動移除監聽：\n1 2 3  beforeDestroy() { window.removeEventListener(\u0026#39;resize\u0026#39;, this.resizeHandler); },   事件委派 事件委派（Event Delegation） 或稱 事件委託、事件代理，是一種減少事件監聽的優化方式。利用了事件冒泡，將事件綁定在父元素上，再判斷當前觸發事件的元素是否是我們要的元素。\n那麼在 Vue 中，使用 v-for 時，每個元素綁定事件時，是否有需要使用 事件委派 呢？\n直接說結論：\n 原則上沒必要使用，因為效能影響極小； 除非要渲染數千甚至上萬的元素，才會嘗試使用事件委派。  詳細可以參考 第 94 題：vue 在 v-for 時給每項元素綁定事件需要用事件代理嗎？為什麼？\n","description":"Vue 事件綁定。","id":39,"section":"posts","tags":["Vue","Vue指令"],"title":"事件綁定","uri":"https://chupai.github.io/posts/vue/directives/von/"},{"content":" 竹白的 Vue 記事本 目錄\n \r條件渲染 1. v-if v-if 指令的表達式預期值為 any，若表達式結果為 truthy 值則顯示該元素。\n舉例來說，若希望某區塊在特定條件下才出現：\n1  \u0026lt;div v-if=\u0026#34;type === \u0026#39;A\u0026#39;\u0026#34;\u0026gt;A Content\u0026lt;/div\u0026gt;   1 2 3  data: { type: \u0026#39;A\u0026#39;, }   如果 type 是 A 字串，type === 'A' 會是 true，那結果會是 truthy 值，則顯示這個元素，反之如果 type 不等於 A 字串，則不顯示元素。\n若要連續判斷，可以使用 v-else-if：\n1 2  \u0026lt;div v-if=\u0026#34;type === \u0026#39;A\u0026#39;\u0026#34;\u0026gt;A Content\u0026lt;/div\u0026gt; \u0026lt;div v-else-if=\u0026#34;type === \u0026#39;B\u0026#39;\u0026#34;\u0026gt;B Content\u0026lt;/div\u0026gt;   另外可以搭配 v-else，若結果為 falsy 值則顯示另一個元素：\n1 2 3  \u0026lt;div v-if=\u0026#34;type === \u0026#39;A\u0026#39;\u0026#34;\u0026gt;A Content\u0026lt;/div\u0026gt; \u0026lt;div v-else-if=\u0026#34;type === \u0026#39;B\u0026#39;\u0026#34;\u0026gt;B Content\u0026lt;/div\u0026gt; \u0026lt;div v-else\u0026gt;No Content\u0026lt;/div\u0026gt;   要注意：\n v-else-if 的元素必須緊跟在帶 v-if 的元素的後面； v-else 的元素必須緊跟在帶 v-if 或者 v-else-if 的元素的後面，否則它將不會被識別。  不過，如果是純文字的輸出，容器元素相同，盡量別將複雜的邏輯判斷寫在 HTML 上面。\n可以改用以下方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  const dataMapping = { A: \u0026#39;A Content\u0026#39;, B: \u0026#39;B Content\u0026#39;, }; // vm 略 ... data: { type: \u0026#39;A\u0026#39;, }, computed: { content() { return dataMapping[this.type] || \u0026#39;No Content\u0026#39;; }, }   1  \u0026lt;div\u0026gt;{{ content }}\u0026lt;/div\u0026gt;   2. 切換多個元素 如果要切換多個元素，可使用 \u0026lt;template\u0026gt;，當做不可見的包裹元素。\n1 2 3 4 5 6 7 8 9 10  \u0026lt;template v-if=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Title\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Paragraph 1\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Paragraph 2\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- HTML 將被渲染成 --\u0026gt; \u0026lt;h1\u0026gt;Title\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Paragraph 1\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Paragraph 2\u0026lt;/p\u0026gt;   最終的渲染結果將不包含 \u0026lt;template\u0026gt; 元素。\n3. v-show v-show 一樣是用於條件顯示元素的指令，但不同是 v-show 的元素始終會被渲染並保留在 DOM 中，而是透過切換元素的 CSS display 屬性。\n兩者的比較：\n v-if 是真正的條件渲染，會確保在切換過程中條件塊內的事件監聽器和子元件適當地被銷毀和重建； v-if 是惰性的，如果在初始渲染時條件為 false，則什麼也不做，直到條件第一次變為 true，才會開始渲染條件塊； 相比之下 v-show 不論條件為何都渲染，而是進行 CSS display 屬性切換； v-show 不支持 \u0026lt;template\u0026gt; 元素，也不支持 v-else； v-if 比起 v-show 切換時的開銷更高，因此需要非常頻繁地切換，則使用 v-show 較佳。  列表渲染 v-for 用於多次渲染元素，必須使用 alias in expression 特定語法。\n也可以用 of 替代 in 作為分隔符號，兩者沒有差異，但 of 它更接近 JavaScript 迭代器的語法。\n1. 陣列 使用 v-for 迭代陣列中的元素。\n1  \u0026lt;div v-for=\u0026#34;(item, index) in array\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;    array：陣列。 item：陣列元素。 index：索引。 只使用第一個參數時，不需要括號。  直接看範例，假設我們要建立一組列表：\n1 2 3 4 5 6 7 8  data: { list: [ \u0026#39;HTML\u0026#39;, \u0026#39;CSS\u0026#39;, \u0026#39;JavaScript\u0026#39;, \u0026#39;Vue.js\u0026#39;, ], }   1 2 3 4 5 6 7 8 9 10 11  \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in list\u0026#34;\u0026gt;{{ item }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;!-- HTML 將被渲染成 --\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;HTML\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;CSS\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;JavaScript\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Vue.js\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;   如果要使用第二個參數 index（索引值），需加上括號：\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item, index) in array\u0026#34;\u0026gt; {{ index + \u0026#39;. \u0026#39; + item }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;!-- HTML 將被渲染成 --\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;0. HTML\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;1. CSS\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;2. JavaScript\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;3. Vue.js\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;   See the Pen v-for 列表 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 物件 v-for 也可以用來遍歷一個物件的屬性。\n1  \u0026lt;div v-for=\u0026#34;(value, name, index) in object\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;    object：物件。 value：鍵名。 name：鍵值。 index：遍歷順序。 只使用第一個參數時，不需要括號。  在遍歷一個物件時，會按 Object.keys() 的結果遍歷，但是不能保證它的結果在不同瀏覽器上的 JavaScript 引擎下都一致。\n1 2 3 4 5 6 7  data: { object: { name: \u0026#39;Peter\u0026#39;, age: \u0026#39;29\u0026#39;, sex: \u0026#39;male\u0026#39;, }, }   1 2 3 4 5  \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(value, name, index) in object\u0026#34;\u0026gt; {{ index }}. {{ name }}: {{ value }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;   See the Pen v-for 物件 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 整數 v-for 也可以接受整數。\n1  \u0026lt;span v-for=\u0026#34;index in number\u0026#34;\u0026gt;{{ n }}\u0026lt;/span\u0026gt;    number：正整數 index：起始從 1 開始，至 number  舉例來說：\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;div\u0026gt; \u0026lt;span v-for=\u0026#34;n in 5\u0026#34;\u0026gt;{{ n }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- HTML 將被渲染成 --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;2\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;3\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;4\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;5\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt;   印出九九乘法表：\n1 2 3 4 5 6 7 8 9  \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;x in 9\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;y in 9\u0026#34;\u0026gt; {{ x + 1 }} × {{ y }} ＝ {{ (x + 1) * y }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;   4. 重複多個元素 類似於 v-if 提到的用法，如果要重複渲染多個元素，可使用 \u0026lt;template\u0026gt;，當做不可見的包裹元素。\n1 2 3 4  \u0026lt;template v-for=\u0026#34;item in items\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;{{ item.title }}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;{{ item.content }}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt;   同時使用 v-if 和 v-for 1. 如果同時使用 當 v-if 與 v-for 一起使用時，v-for 具有比 v-if 更高的優先級。v-if 會隨著 v-for 重覆執行數次。\n1 2 3  data: { array: [1, 3, 0, 4, 5, 0, 2] },   只渲染值為 true 的成員：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in array\u0026#34; v-if=\u0026#34;item\u0026#34;\u0026gt; {{ item }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;!-- HTML 將被渲染成 --\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;3\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;4\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;5\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;2\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;   但要注意，v-for 的個數範圍判斷條件成立後，才會輪到 v-if 來判斷顯示與否。請考慮以下範例：\n1 2 3 4  \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in array\u0026#34; v-if=\u0026#34;array.length !== 0\u0026#34;\u0026gt;{{ item }}\u0026lt;/li\u0026gt; \u0026lt;p v-else\u0026gt;Nothing could show.\u0026lt;/p\u0026gt; \u0026lt;/ul\u0026gt;   1 2 3  data: { array: [] }   目前 array 是空陣列，沒有任何項目可顯示，當 v-for 在判斷 item in array 時，發現條件不成立，因此就不會就不去做 v-if 和 v-else 判斷，會導致 Nothing could show. 不會出現。\n可以將程式改成這樣：\n1 2 3 4  \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in array\u0026#34;\u0026gt;{{ item }}\u0026lt;/li\u0026gt; \u0026lt;p v-if=\u0026#34;array.length !== 0\u0026#34;\u0026gt;Nothing could show.\u0026lt;/p\u0026gt; \u0026lt;/ul\u0026gt;   2. 避免同時使用 上面操作只會出現在範例說明，官方風格指南 明確表示：避免 v-if 和 v-for 用在同一個元素上。\r 假設為了過濾一個列表中的項目：\n1 2 3 4 5 6 7 8 9  \u0026lt;!-- .html --\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;user in users\u0026#34; v-if=\u0026#34;user.isActive\u0026#34; \u0026gt; {{ user.name }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;   1 2 3 4 5 6 7  data: { users: [ { name: \u0026#39;A\u0026#39;, isActive: true }, { name: \u0026#39;B\u0026#39;, isActive: true }, { name: \u0026#39;C\u0026#39;, isActive: false }, { name: \u0026#39;D\u0026#39;, isActive: true }, ],   此寫法會經過以下運算:\n1 2 3 4 5  this.users.map(function (user) { if (user.isActive) { return user.name } })   由此可知，哪怕只需要渲染出一小部分 user 的元素，也得每次重新渲染時遍歷整個 users 列表，不論 isActive 狀態是否發生變化。\n因此我們可以將上述程式碼稍作修改，將 users 替換為一個計算屬性：\n1 2 3 4 5 6 7  computed: { activeUsers() { return this.users.filter(function (user) { return user.isActive }) } }   1 2 3 4 5  \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;user in activeUsers\u0026#34;\u0026gt; {{ user.name }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;   程式碼改成這樣有以下優點：\n 過濾後的列表 activeUsers，只會在 users 陣列發生相關變化時才被重新運算，過濾更高效； 在渲染的時候，只遍歷篩選後的 user，渲染更高效； 解耦渲染層的邏輯，可維護性（對邏輯的更改和擴展）更強。  key 屬性 1. 沒 key 會遇到的情況 請考慮以下程式碼：\n1 2 3 4 5 6 7 8 9  \u0026lt;div v-if=\u0026#34;show\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Username\u0026lt;/label\u0026gt; \u0026lt;input placeholder=\u0026#34;username\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div v-else\u0026gt; \u0026lt;label\u0026gt;Email\u0026lt;/label\u0026gt; \u0026lt;input placeholder=\u0026#34;email\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;show = !show\u0026#34;\u0026gt;change\u0026lt;/button\u0026gt;   1 2 3  data: { show: true, }   你可以試著在輸入框輸入，接著按切換按鈕，你會發現你輸入的值並不會消失，這表示它們共用同一個元素。\nSee the Pen key 屬性 v-if by CHUPAIWANG (@CHUPAIWANG) on CodePen.  因此你需要加上替它們加上 key 屬性，使這兩個元素完全獨立，每次切換時輸入框才會重新渲染。\n原因等等下面會說明，繼續看另一段程式碼：\n1 2 3 4 5 6  \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in arrayData\u0026#34;\u0026gt; {{ item.name }} \u0026lt;input type=\u0026#34;checkbox\u0026#34;\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;button @click=\u0026#34;arrayData.reverse()\u0026#34;\u0026gt;反轉陣列\u0026lt;/button\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  data: { arrayData: [ { id: 1, name: \u0026#34;test1\u0026#34;, }, { id: 2, name: \u0026#34;test2\u0026#34;, }, { id: 3, name: \u0026#34;test3\u0026#34;, }, { id: 4, name: \u0026#34;test4\u0026#34;, }, ], }   當你點選 checkbox 後，再點選反轉陣列的按鈕，你可觀察到，checkbox 並不會隨著資料變換而跟著改變。\nSee the Pen v-for by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. key 的作用 上面情況的原因是 Vue 在切換畫面時，並不會完全置換元素，會使用一種最大限度減少動態元素並且儘可能的嘗試修復/再利用相同類型元素的算法。但是 不適用 於需依賴子元件狀態、臨時 DOM 狀態的列表渲染輸出（例如，表單輸入）。\n為了解決這個問題，可以使用 Vue 提供的 key 屬性，key 的作用是給予一個節點唯一的身份識別，有相同父元素的子元素必須有獨特的 key。這樣它可以前後對比，算出哪些節點是要重複使用或者調整順序。\n1  \u0026lt;li v-for=\u0026#34;item in arrayData\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt;   See the Pen v-for key by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2.2.0+ 的版本，當在元件上使用 v-for 時，key 屬性現在是必須的。\r 2. 避免使用 index 作為 key 值 在 v-for 指令上，避免使用 index 當作 key 值。\n請考慮以下程式碼：\n1 2 3 4 5 6 7  \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item, index) in arrayData\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt; {{ item.name }} \u0026lt;input type=\u0026#34;checkbox\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;del(index)\u0026#34;\u0026gt;del\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;button @click=\u0026#34;arrayData.reverse()\u0026#34;\u0026gt;反轉陣列\u0026lt;/button\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  data: { arrayData: [ { id: 1, name: \u0026#34;test1\u0026#34;, }, { id: 2, name: \u0026#34;test2\u0026#34;, }, { id: 3, name: \u0026#34;test3\u0026#34;, }, { id: 4, name: \u0026#34;test4\u0026#34;, }, ], }, methods: { del(index) { this.arrayData.splice(index, 1); }, }   See the Pen v-for key=\u0026quot;index\u0026quot; by CHUPAIWANG (@CHUPAIWANG) on CodePen.  刪除前：\n   key index name id     0 0 test1 1   1 1 test2 2   2 2 test3 3   3 3 test4 4    假設刪除 test2 後：\n   key index name id     0 0 test1 1   1 1 test3 3   2 2 test4 4    因為刪除了 test2 導致 index 發生變化，而 key 因為綁定 index 而導致 test3 與 test4 被重新渲染。而且 key = 2 的 checkbox 狀態會變成 text3 的。\n另外官方文件也標示，key 值不可以是物件或陣列，必須是字串或數值。\r 3. 其他用途 key 屬性也可以用於強制替換元素/元件而不是重複使用它。如果遇到以下場景會非常用：\n 完整地觸發元件的生命週期鉤子 觸發轉場  舉例來說：\n1 2 3 4  \u0026lt;transition\u0026gt; \u0026lt;div v-if=\u0026#34;toggle\u0026#34; :key=\u0026#34;1\u0026#34;\u0026gt;Hello\u0026lt;/div\u0026gt; \u0026lt;div v-else key=\u0026#34;2\u0026#34;\u0026gt;Goodbye\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   當 切換 toggle 時，它也是切換 \u0026lt;div\u0026gt;，如果你想用上 enter/leave animations 時，即節點插入和刪除的時候的動畫時就要打破這個復用。\n","description":"Vue 條件渲染 \u0026 列表渲染。","id":40,"section":"posts","tags":["Vue","Vue指令"],"title":"條件渲染 \u0026 列表渲染","uri":"https://chupai.github.io/posts/vue/directives/vifvfor/"},{"content":" 竹白的 Vue 記事本 目錄\n \r特性綁定 HTML 元素標籤的特性（attribute）無法使用 Mustache 語法與 vue 實體綁定，因此需要使用 v-bind 指令來綁定元素與 vue 實體的關係。因為常用到，所以有縮寫「:」。\n物件的 property 和 HTML attribute 中文都稱作「屬性」。筆記中會以「特性」表示 HTML attribute 來區分兩者。\r 1. 基本語法 v-bind 語法：\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;!-- 語法 --\u0026gt; \u0026lt;div :v-bind:attribute=\u0026#34;expression\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 簡寫 --\u0026gt; \u0026lt;div :attribute=\u0026#34;expression\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 動態特性名（2.6.0 新增）： --\u0026gt; \u0026lt;!-- 語法 --\u0026gt; \u0026lt;div :v-bind:[attribute]=\u0026#34;expression\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 簡寫 --\u0026gt; \u0026lt;div :[attribute]=\u0026#34;expression\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;    attribute：要綁定的特性名稱。 expression：預期值為 any（任何 type）。 2.6 版後新增了特性名稱加上方括號，也能是表達式。  舉例來說，動態地新增一個圖片連結：\n1 2 3  data: { imgSrc: \u0026#39;https://picsum.photos/200/200\u0026#39; }   1  \u0026lt;img v-bind:src=\u0026#34;imgSrc\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt;   當 imgSrc 內容發生變化，顯示圖片就會更新。\n2. 樣式綁定 操作元素的 class 列表和 style 行內樣式是資料綁定的常見需求，因為都是特性所以可以使用 v-bind 來處理。\n雖然透過表達式計算出字串結果即可，但字串拼接麻煩且易錯，因此 Vue 對它們做了專門增強的功能，也就是表達式的結果值除了字串還可以是陣列或物件。\n如果是其他特性，預期值傳入陣列或物件，會被強制轉型成字串。\nclass 綁定 1. 物件語法 傳一個物件，以動態地切換 class。\n1  \u0026lt;div v-bind:class=\u0026#34;{ className: boolean }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;    className：類別名稱。 boolean：布林值，切換類別。  它能與普通的 class 特性共存。\n範例：\n1 2 3 4 5 6 7 8 9 10  /* 先定義 css */ .box { width: 100px; height: 100px; background: #222; } .red { background: red; }   1 2 3  data: { isRed: true, }   1 2 3 4  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-bind:class=\u0026#34;{ red: isRed }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;button v-on:click=\u0026#34;isRed =!isRed\u0026#34;\u0026gt;點擊\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt;   如果 isActive 的值變成 false，.red 類別就會被移除，反之 isActive 的值 true 就會新增 .red 類別。\nSee the Pen v-bind class by CHUPAIWANG (@CHUPAIWANG) on CodePen.  這裡注意的是，因為物件鍵名（key name）無法用 -，需要加上 '' 單引號，明確的用字串當作鍵名。\r 舉例來說，.box-red 這個類別名稱，需要加上單引號，明確的用字串當作鍵名。\n1  \u0026lt;div class=\u0026#34;box\u0026#34; v-bind:class=\u0026#34;{ \u0026#39;box-red\u0026#39;: isActive }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   綁定的物件不一定要定義在模板中：\n1  \u0026lt;div class=\u0026#34;box\u0026#34; v-bind:class=\u0026#34;classObject\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   1 2 3 4 5  data: { classObject: { \u0026#39;box-red\u0026#39;: false, }, }   但這樣我們變成需要操作 classObject['box-red'] 這個屬性。\n因此建議使用一個回傳物件的 computed 計算屬性，將這個物件包裝起來，方便管理維護。\n1 2 3 4 5 6 7 8  data: { isRed: true, }, computed: { classObject() { return { \u0026#39;box-red\u0026#39;: this.isRed, } }, }   2. 陣列語法 傳給 v-bind:class 一組陣列，以應用一個 class 列表。\n1 2 3 4  \u0026lt;div v-bind:class=\u0026#34;[ \u0026#39;className1\u0026#39;, \u0026#39;className2\u0026#39; ]\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- HTML 將被渲染成 --\u0026gt; \u0026lt;div class=\u0026#34;className1 className2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   結合 checkbox + v-model：\nSee the Pen v-bind:class 陣列語法 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  另外，陣列中也可以用物件語法：\n1  \u0026lt;div v-bind:class=\u0026#34;[{ className1: true }, \u0026#39;className2\u0026#39;]\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   style 綁定 1. 物件語法 直接舉例說明：\n1  \u0026lt;div v-bind:style=\u0026#34;{ backgroundColor: \u0026#39;#ddd\u0026#39;, width: \u0026#39;100px\u0026#39;, height: \u0026#39;100px\u0026#39; }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   語法雖然看起來像 CSS 樣式，但它其實是 JS 物件，因此要注意：\n CSS 屬性名，有兩種寫法：  駝峰式（camelCase），backgroundColor 短橫線分隔（kebab-case），'background-color'（需要明確的用字串當作鍵名，因武要加上單引號）   值（沒有預設單位，因此有單位的需使用字串）  多重值：\n1  \u0026lt;div v-bind:style=\u0026#34;{ display: [\u0026#39;-webkit-box\u0026#39;, \u0026#39;-ms-flexbox\u0026#39;, \u0026#39;flex\u0026#39;] }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   會渲染陣列中最後一個被瀏覽器支持的值。\n2. 陣列語法 我們可以用陣列語法，將多個樣式物件應用在同一個元素上：\n1  \u0026lt;div v-bind:style=\u0026#34;[baseStyles, bgStyles]\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   1 2 3 4 5 6 7  data: { baseStyles: { width: \u0026#39;100px\u0026#39;, height: \u0026#39;100px\u0026#39; }, bgStyles: { \u0026#39;background-color\u0026#39;: \u0026#39;#ddd\u0026#39;}, }   重複特性 1. 一般特性 如果使用 v-bind 和未使用 v-bind 特性重複，後寫的會將先寫覆蓋：\n1 2 3 4  data: { google: \u0026#39;https://www.google.com/\u0026#39;, yahoo: \u0026#39;https://tw.yahoo.com/\u0026#39;, }   1 2 3 4 5 6  \u0026lt;a href=\u0026#34;https://www.google.com/\u0026#34; v-bind:href=\u0026#34;yahoo\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;1\u0026lt;/a\u0026gt; \u0026lt;a v-bind:href=\u0026#34;yahoo\u0026#34; href=\u0026#34;https://www.google.com/\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;2\u0026lt;/a\u0026gt; \u0026lt;!-- HTML 將被渲染成 --\u0026gt; \u0026lt;a href=\u0026#34;https://tw.yahoo.com/\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;1\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;https://www.google.com/\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;2\u0026lt;/a\u0026gt;   2. 樣式綁定 但樣式綁定 class 和 style 會將兩者合併，互相不干擾。\n上面範例已經用過了：\n1 2 3 4  \u0026lt;div class=\u0026#34;box\u0026#34; v-bind:class=\u0026#34;{ red: isRed }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- HTML 將被渲染成 --\u0026gt; \u0026lt;div class=\u0026#34;box red\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   但是如果出現重複類別，要特別注意：\n1 2 3 4  \u0026lt;div class=\u0026#34;box red\u0026#34; v-bind:class=\u0026#34;{ red: isRed }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- HTML 將被渲染成 --\u0026gt; \u0026lt;div class=\u0026#34;box red red\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   將會出現兩個相同的類別，我們只能控制使用 v-bind 的類別。\n若是 style 出現相同 CSS 樣式，v-bind 會覆蓋原本的樣式：\n1 2 3 4 5 6  \u0026lt;div class=\u0026#34;box\u0026#34; :style=\u0026#34;{ backgroundColor: \u0026#39;blue\u0026#39; }\u0026#34; style=\u0026#34;background-color: red;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; style=\u0026#34;background-color: red;\u0026#34; :style=\u0026#34;{ backgroundColor: \u0026#39;blue\u0026#39; }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- HTML 將被渲染成 --\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; style=\u0026#34;background-color: blue;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; style=\u0026#34;background-color: blue;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   另外還有使用陣列語法的重複，若物件有相同 CSS 樣式：\n1 2 3 4  data: { red: { backgroundColor: \u0026#39;red\u0026#39; }, blue: { backgroundColor: \u0026#39;blue\u0026#39; }, }   1 2 3 4 5 6  \u0026lt;div class=\u0026#34;box\u0026#34; :style=\u0026#34;[blue, red]\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; :style=\u0026#34;[red, blue]\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- HTML 將被渲染成 --\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; style=\u0026#34;background-color: red;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; style=\u0026#34;background-color: blue;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   後者會覆蓋前者。\n","description":"Vue 特性綁定。","id":41,"section":"posts","tags":["Vue","Vue指令"],"title":"v-bind 特性綁定","uri":"https://chupai.github.io/posts/vue/directives/vbind/"},{"content":" 竹白的 Vue 記事本 目錄\n \r指令（Directives） 在 Vue 中有提供一些帶有前綴 v- 的指令（Directives），主要用於 HTML 元素標籤中。每個指令都會有一個 預期值，指的是想綁定的值，為 JavaScript 表達式（v-for 是例外情況），我們可以直接在 HTML 上去綁定我們需要做的事情。\n參數（Arguments） 一些指令能夠接收一個「參數」，在指令名稱之後以冒號表示，例如 v-bind、v-on 等：\n v-bind 接收的參數為 HTML 特性 v-on 接收的參數為 DOM 事件  1 2 3  \u0026lt;a v-bind:href=\u0026#34;url\u0026#34;\u0026gt;...\u0026lt;/a\u0026gt; \u0026lt;a v-on:click=\u0026#34;doSomething\u0026#34;\u0026gt;...\u0026lt;/a\u0026gt;   動態參數（Dynamic Arguments） 如果我們想在 v-bind or v-on 中使用動態參數，在 2.6.0 版之前，只能使用物件的語法：\n1 2 3  \u0026lt;a v-bind=\u0026#34;{ [attributeName]: url }\u0026#34;\u0026gt; ... \u0026lt;/a\u0026gt; \u0026lt;a v-on=\u0026#34;{ [eventName]: doSomething }\u0026#34;\u0026gt; ... \u0026lt;/a\u0026gt;   但這種做法有幾種缺點：\n vue-template-compier 生成了低效的程式碼 v-slot 沒有類似的使用物件的語法  Vue 在 2.6.0 版後，新增了動態參數的新語法，可以使用方括號 [] 將參數用表達式表示：\n1 2 3  \u0026lt;a v-bind:[attributeName]=\u0026#34;url\u0026#34;\u0026gt; ... \u0026lt;/a\u0026gt; \u0026lt;a v-on:[eventName]=\u0026#34;doSomething\u0026#34;\u0026gt; ... \u0026lt;/a\u0026gt;   動態參數表達式有一些限制，因為某些字元，如空格和引號，放在 HTML attribute 名裡是無效的。\n修飾符號（Modifiers） 修飾符號（modifier）是以 . 指名的特殊後綴，用於指出一個指令應該以特殊方式綁定。\n舉例來說，.prevent 修飾符號，可對 v-on 觸發的事件函式呼叫 event.preventDefault()：\n1  \u0026lt;form v-on:submit.prevent=\u0026#34;onSubmit\u0026#34;\u0026gt;...\u0026lt;/form\u0026gt;   每個指令都有自己的修飾符號，會在之後詳細說明。\n縮寫 v-bind 和 v-on 這兩個最常用的指令，Vue 提供了縮寫。\n1 2 3 4 5  \u0026lt;!-- 完整語法 --\u0026gt; \u0026lt;a v-bind:href=\u0026#34;url\u0026#34;\u0026gt;...\u0026lt;/a\u0026gt; \u0026lt;!-- 縮寫 --\u0026gt; \u0026lt;a :href=\u0026#34;url\u0026#34;\u0026gt;...\u0026lt;/a\u0026gt;   1 2 3 4 5  \u0026lt;!-- 完整語法 --\u0026gt; \u0026lt;a v-on:click=\u0026#34;doSomething\u0026#34;\u0026gt;...\u0026lt;/a\u0026gt; \u0026lt;!-- 縮寫 --\u0026gt; \u0026lt;a @click=\u0026#34;doSomething\u0026#34;\u0026gt;...\u0026lt;/a\u0026gt;   在某些情況下，可能不需要使用參數，但是要注意，沒參數無法使用縮寫，只能使用完整語法。\r","description":"Vue 指令概述。","id":42,"section":"posts","tags":["Vue","Vue指令"],"title":"Vue 指令概述","uri":"https://chupai.github.io/posts/vue/directives/directives/"},{"content":"Vue 基礎篇\n\r 這週是六角鼠年鐵人賽第三十六週，剩沒幾週了，最近花了點時重新將之前的 Vue 2.x 筆記整理過，作為最後幾週的結尾，之後要來看 Vue 3 啦。\n 竹白的 Vue 記事本 目錄\n Vue - 基礎：\n Vue 實體 資料 \u0026amp; 方法 資料渲染 資料計算 \u0026amp; 資料監聽 Vue 生命週期 資料無法響應  題外話，話說銀角獎的獎牌已經收到啦，感謝六角學院 😀。但有點小失望啦，當初說好的講座呢！😂\n","description":"Vue 基礎篇。","id":43,"section":"posts","tags":["Vue","w3HexSchool"],"title":"Vue - 基礎","uri":"https://chupai.github.io/posts/2010/vue_base/"},{"content":" 竹白的 Vue 記事本 目錄\n Vue 資料無法響應的情況。\n\r對於物件 Vue 建立實體時，會對 data 物件中的所有屬性加入到 Vue 的 響應式系統 中，從而讓 data 的屬性能夠響應式更新。\n但是 Vue 不能檢測到物件的新增或刪除。\n舉例來說，我們如果想要在 Vue 實體初始化後新增 count 資料屬性：\n1 2 3 4 5 6 7  const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: {}, created() { this.count = 0; } });   count 雖然有被新增，但無法畫面無法隨著資料改變響應。\n新增一個按鈕來改變 count 的值來驗證：\n1 2 3 4  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ count }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;count += 1; alert(count)\u0026#34;\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt;   CodePen Demo：Vue2.x - 資料無法響應 - 對於物件\nVue 不允許動態添加根級別的屬性，所以一般情況下，我們不會這樣新增資料屬性，一定是預先定義資料屬性。\n但是，如果資料屬性為物件，就有可能會發生以下情況。\n我們在進行開發的過程中，不可能每次都預先定義好物件內的所有屬性。舉例來說，我們透過 AJAX 取得資料，但如果該資料沒有前端畫面要的屬性，就需要自己新增屬性。\n這時就必須使用到 $set()，來確保這個新屬性同樣是響應式的。\n1 2 3 4 5 6 7 8 9 10 11 12 13  const vm = new Vue({ data: { use: {}, }, created() { // 取得資料  this.use = { name: \u0026#39;Peter\u0026#39;, }; // 新增屬性  this.$set(this.use, \u0026#39;follow\u0026#39;, false); }, });   $set() 語法：\n1  vm.$set(target, propertyName/index, value)   對於陣列 1. 可觀察到的陣列方法 Vue 有重新對以下陣列方法進行包裝，因此可以觀察到使用以下方法的變化：\n push() pop() shift() unshift() splice() sort() reverse()  2. 無法響應式變化 Vue 不能檢測以下陣列的變動：\n 利用索引設置一個修改或新增元素。 修改陣列長度。  舉例來說，我們將陣列的第一個元素值替換掉：\n1 2  \u0026lt;button @click=\u0026#34;changeValue(array)\u0026#34;\u0026gt;change\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;{{ array }}\u0026lt;/p\u0026gt;   1 2 3 4 5 6 7 8  data: { array: [0, 1, 2] }, methods: { changeValue(arr) { arr[0] = \u0026#39;zero\u0026#39;; }, },   執行後，你會發現畫面沒有變動。\n改用 $set(array, index, value) 即可觸發狀態更新：\n1 2 3 4 5  methods: { changeValue(arr) { this.$set(arr, 0 , \u0026#39;zero\u0026#39;); }, },   或者使用 splice 方法來修改或新增元素：\n1  arr.splice(0, 1, \u0026#39;zero\u0026#39;);   CodePen Demo：Vue2.x - 資料無法響應 - 對於陣列\n","description":"Vue 資料無法響應的情況。","id":44,"section":"posts","tags":["Vue"],"title":"資料無法響應","uri":"https://chupai.github.io/posts/vue/base/norespond/"},{"content":" 竹白的 Vue 記事本 目錄\n Vue 的實體（Instance）是 Vue.js 的核心，每個 Vue App 都是從建立實體開始。\n\r生命週期（Life Cycle） 生命週期簡單來說就是「從 Vue 實體建立到銷毀的過程」。\n可以分為 4 個階段：\n 初始化 模板編譯 掛載 銷毀  在這些過程中，還會呼叫 生命週期鉤子（Hook），我們可以在這些鉤子上做額外的處理。\n生命週期鉤子的觸發時間點：\n beforeCreate：實體剛被建立，資料觀測和事件綁定都尚未初始化。 created：實體已建立，資料觀測和事件綁定初始化完成。 beforeMount：已經完成了模板的編譯，但尚未掛載。 mounted：實體掛載完成，el 的目標 DOM 被 $el 所替換。 beforeUpdate：資料更新時，重新渲染 DOM 之前。 updated：DOM 重新渲染後。 beforeDestroy：實體銷毀前，此時實體依然可以使用。 destroyed：實體銷毀後。  初始化階段 new Vue() 到 created 鉤子之間的階段叫做初始化階段，主要目的為初始化一些屬性、事件以及響應式資料等等。\n1. beforeCreate 鉤子 beforeCreate 鉤子是 new Vue() 之後觸發的第一個鉤子：\n 這個階段元素尚未被掛載； 資料尚未被建立，data、computed、methods、watch 等等皆無法取得。  2. created 鉤子 created 鉤子，Vue 實體已建立完成：\n 這個階段元素一樣尚未被掛載； data、computed、 methods、watch 等等已可取得。  資料操作至少要等到 created 階段，因此通常我們用 AJAX 取得資料操作會在這裡執行，但不建議過多的請求，避免網頁無畫面的時間過長，可以考慮在 mounted 階段做出讀取畫面再打操作。\n模板編譯階段 created 鉤子到 beforeMount 鉤子之間的階段叫做模板編譯階段，主要目的為將模板編譯為 render 函式。\n會先判斷是否有指定 el 選項：\n 有，繼續往下執行。 沒有，會停止生命週期，直到呼叫 vm.$mount(el) 才會進行下一步。  接下來繼續判斷是否指定 template 選項：\n 有，就直接將模板編譯為 render 函式。 沒有，則使用 el 進行編譯。  1. beforeMount 鉤子 beforeMount 鉤子發生在執行掛載之前，虛擬 DOM 已經建立完成，即將開始渲染。\n掛載階段 beforeMount 鉤子到 mounted 鉤子之間為掛載階段，這個階段 Vue 會將虛擬 DOM 掛載到頁面上。\n掛載後，Vue 會持續追蹤資料變化，當資料發生改變會重新渲染畫面。\n1. mounted 鉤子 mounted 鉤子會在開始掛載時呼叫：\n 可以對 DOM 進行操作，例如使用 $refs； 但 mounted 不會保證所有的子元件也都一起被掛載，如果你希望等到全部渲染完畢，可以用 $nextTick 來確保。  2. beforeUpdate beforeUpdate 鉤子會在資料發生改變時呼叫，資料雖然已經更新，但畫面還是舊資料：\n 適合在更新之前訪問現有的 DOM，手動移除已添加的事件監聽器。  3. updated updated 鉤子會在畫面更新後呼叫：\n 可以執行依賴於 DOM 的操作，但跟 mounted 一樣，不保證所有的子元件都更新完畢，可使用 $nextTick 來確保； 避免在此更改資料狀態，可能會造成死循環，應該使用 watch 屬性來處理。  銷毀階段 Vue 在呼叫 $destroy() 後，生命週期就會進入銷毀階段，將解除實體的所有綁定、所有事件監聽移除、子元件實體也會被銷毀。\n1. beforeDestroy beforeDestroy 鉤子會在銷毀之前呼叫：\n 實體仍然可用； 一般會在這做一些提示、重置操作。  2. destroyed destroyed 鉤子會在銷毀後呼叫，此時已經無法操作實體了。\nkeep-alive 專屬生命週期  activated：元件激活時呼叫。 deactivated：元件被銷毀時呼叫。 ","description":"生命週期簡單來說就是「從 Vue 實體建立到銷毀的過程」。","id":45,"section":"posts","tags":["Vue","Vue生命週期"],"title":"Vue 生命週期","uri":"https://chupai.github.io/posts/vue/base/lifecycle/"},{"content":" 竹白的 Vue 記事本 目錄\n \rComputed 計算 在專案開發中，資料往往需要經過一些處理，Vue 提供了 computed 選項，用來減輕模板上的資料處理，方便重複利用及維護。\n1. computed 以反轉字串為例：\n1 2 3  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ message.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;) }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;   若是在 Mustache 中寫一些簡單運算還能馬上理解。但像上面寫一長串程式碼，我們可能無法立刻理解它的邏輯。\n因此，我們可以使用計算屬性，將程式碼改寫成這樣：\n1 2 3  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ reversedMessage }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11  const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { message: \u0026#39;Hello Vue.js!\u0026#39;, }, computed: { reversedMessage() { return this.message.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;); }, }, });   這樣不但方便重複使用與維護，也能馬上明白這段程式碼的意思。\nSee the Pen Vue 2.x - Computed by CHUPAIWANG (@CHUPAIWANG) on CodePen.  另外要注意，因為 Vue 會將 computed 整合到實體中，因此不要與 data、methods 重複宣告。\r 2. 與 method 的差異 雖然使用 method 一樣可以達到同樣的效果：\n1 2 3  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ reversedMessage() }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5  methods: { reversedMessage() { return this.message.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;); }, }   但計算屬性會將結果緩存，只在相關響應式依賴發生改變時它們才會重新計算。另外計算屬性沒辦法傳入參數。\n響應式依賴發生改變是什麼意思呢？就是只有在計算屬性中使用被加到響應式系統的資料發生改變，計算屬性才會重新計算。\n舉例來說，Date.now() 並不是響應式依賴，所以並不會重新計算。：\n1 2 3 4 5  computed: { now: function () { return Date.now() } }   還有一點要注意，計算屬性要有使用才會計算，並不是依賴發生改變就重新計算。舉例來說，我們沒有在畫面上使用到 c1：\n1 2 3 4 5 6 7 8 9 10 11 12  const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { message: \u0026#39;Hello\u0026#39;, }, computed: { c1() { console.log(\u0026#39;c1\u0026#39;); return this.message + 1 }, }, });   1  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   我們在 Console 中改變 message 的值，並不會印出 'c1'，也就是說 c1 並沒有被呼叫：\n1 2  // Console vm.message = \u0026#39;Hi!\u0026#39;;   但是如果你有使用 Vue.js devtools，它會全部呼叫一次才能顯示值給你，因此就算沒到使用也會呼叫。\n回到剛提到的 method，我們從以下程式碼，就可以觀察到兩者的差異：\n1 2 3 4 5 6 7 8  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ rmComputed }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ rmComputed }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ rmComputed }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ rmMethods() }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ rmMethods() }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ rmMethods() }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { message: \u0026#39;Hello Vue.js!\u0026#39;, }, computed: { rmComputed() { console.log(\u0026#39;computed\u0026#39;); return this.message.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;); }, }, methods: { rmMethods() { console.log(\u0026#39;methods\u0026#39;); return this.message.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;); }, }, });   // Console 'computed' 'methods' 'methods' 'methods' 我們在模板中重複訪問，你可以發現 rmComputed 只執行一次，而 rmMethods 會執行三次。\n因為，只要跟 rmComputed 有關的 message 不變，就不會重新計算，會從緩存取得結果值。\n3. setter 計算屬性函式型式預設為 getter，也可以改寫成物件型式新增一個 setter，當計算屬性被回寫 setter 就會被呼叫。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  const vm = new Vue({ computed: { a: { get() { return 10; }, set(newVal) { console.log(\u0026#39;123\u0026#39;); }, }, }, }); vm.a = 0; // \u0026#39;123\u0026#39; ( a 被改變，所以執行 console.log(\u0026#39;123\u0026#39;)   注意，只有使用 setter 時，才可以回寫計算屬性。否則開發環境版本的 Vue 會在 Console 跳出警告。\r 我們來看一個匯率轉換的應用：\n1 2 3 4 5 6 7 8 9  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;假設 1 美元 = 29.8 台幣\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;美元 \u0026lt;input v-model.number=\u0026#34;usd\u0026#34; type=\u0026#34;number\u0026#34; /\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;新台幣 \u0026lt;input v-model.number=\u0026#34;twd\u0026#34; type=\u0026#34;number\u0026#34; /\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { usd: 1, }, computed: { twd: { get() { return this.usd * 29.8; }, set(newVal) { this.usd = newVal / 29.8; }, }, }, });   當 twd 變化，就會呼叫 setter 改變 usd 的值。\nSee the Pen Vue2.x - 匯率轉換 computed by CHUPAIWANG (@CHUPAIWANG) on CodePen.  4. 總結 計算屬性的應用：\n 分離邏輯 緩存結果 雙向綁定（setter 應用）  Watch 監聽 Vue 提供了一種更通用的方式來觀察和響應 Vue 實體上的資料變動，那就是 watch 選項。\n1. watch 監聽資料，當資料發生改變，我們就做某件事：\n1 2 3 4 5 6 7 8 9 10 11 12  const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { message: \u0026#39;\u0026#39;, count: 0, }, watch: { message() { this.count += 1; }, }, });   1 2 3 4  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;message\u0026#34; \u0026gt; \u0026lt;p\u0026gt;{{ count }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;   當 message 發生變化，就計數。\nSee the Pen Vue 2.x - Watch by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 參數 當監聽的資料發生變化，這個監聽函式會傳入兩個參數，分別為 newVal 與 oldVal，變化後的新值、變化前的舊值。\n1 2 3 4 5  watch: { message(newVal, oldVal) { // do Something  }, }   See the Pen Vue 2.x - Watch : newVal, oldVal by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. immediate 監聽屬性除了函式，也可以寫成物件型式：\n1 2 3 4 5 6 7  watch: { message: { handler(newVal, oldVal) { // do Something  }, }, }   物件型式有兩個選項可以設定，分別為 immediate 與 deep。\n資料若沒變動，就不會觸發監聽函式，若希望資料初始值也會執行 watch 的動作，我們可以將 immediate 設為 true。\n直接看應用範例，UNIX timestamp 格式轉換：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { date: new Date().toLocaleDateString(), timestamp: null, }, watch: { date: { immediate: true, handler() { this.timestamp = this.turnTimestamp(this.date); }, }, }, methods: { turnTimestamp(date) { const timestamp = Math.floor(new Date(date) / 1000); return timestamp; }, }, });   1 2 3 4 5  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;date\u0026#34; v-model=\u0026#34;date\u0026#34; \u0026gt; \u0026lt;p\u0026gt;Date: {{ date }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;UNIX timestamp: {{ timestamp }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;   如果沒使用 immediate: true，就需要在 created 鉤子上初始化 timestamp：\n1 2 3  created() { this.timestamp = this.turnTimestamp(this.date); }   See the Pen Vue 2.x - Watch : immediate by CHUPAIWANG (@CHUPAIWANG) on CodePen.  4. 深度監聽 如果 data 是物件，要監聽裡面的屬性變化，該怎麼做呢？\n物件型式的另一個選項為 deep 深度監聽，設為 true 即可，只要其中一個屬性值發生變化，就會執行指定動作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  data:{ object: { a: \u0026#39;\u0026#39;, b: \u0026#39;\u0026#39;, } }, watch: { object: { deep: true, handler() { // do Something  }, }, }   5. 總結 任何可以使用 computed 的功能，都能使用 watch 完成，因此很容自造成濫用 watch。\n簡單的區分使用場景：\n 簡單且單純的資料操作並用於畫面上，盡量使用 computed； 如果需觸發行為再使用 watch。  非同步操作就只能使用 watch。\n","description":"資料計算 與 資料監聽。","id":46,"section":"posts","tags":["Vue","computed","watch"],"title":"計算 \u0026 監聽","uri":"https://chupai.github.io/posts/vue/base/computedwatch/"},{"content":" 竹白的 Vue 記事本 目錄\n \r資料綁定 Vue 作為資料驅動畫面的框架，首先必須要了解如何將資料在畫面中展示出來。\n傳統 Web 是透過後端的樣板引擎來進行資料與畫面的渲染，會導致前後端語法交雜在一起（前端 HTML 文件包含了後端樣板引擎的語法），而且渲染後要再次修改畫面，就只能透過獲取 DOM 的方法進行修改，來保持畫面與資料的一致。\nVue 的核心是一個響應式的資料綁定系統，建立綁定後，DOM 將和資料保持同步，這樣就不需要手動維護 DOM，使程式碼能夠更加簡潔易懂，提升效率。\n文字 Text 最基礎的形式就是文字，使用雙大括號 {{}}（Mustache 語法）。\n語法範例：\n1 2 3  data: { message: \u0026#39;Hello Vue.js!\u0026#39;, }   1 2 3 4  \u0026lt;p\u0026gt;{{ message }}\u0026lt;/p\u0026gt; \u0026lt;!-- HTML 將被渲染成 --\u0026gt; \u0026lt;p\u0026gt;Hello Vue.js!\u0026lt;/p\u0026gt;   Mustache 語法中的變數會去 Vue 實體中找。\n文字除了使用 Mustache 語法，v-text 指令也可以渲染文字：\n1 2 3 4  \u0026lt;p v-text=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!-- 等同 --\u0026gt; \u0026lt;p\u0026gt;{{ message }}\u0026lt;/p\u0026gt;   差異在於，使用 v-text 會取代原本元素的內容，而使用 Mustache 語法可以合併內容：\n1 2 3 4  \u0026lt;p\u0026gt;message：{{ message }}\u0026lt;/p\u0026gt; \u0026lt;!-- 等同 --\u0026gt; \u0026lt;p\u0026gt;message：Hello Vue.js!\u0026lt;/p\u0026gt;   若同時使用，Mustache 語法會被 v-text 取代。\nv-once 如果元素上所綁定的資料只需要渲染一次，之後不會在更新它，可以使用 v-once 指令，助於優化更新性能：\n1  \u0026lt;p v-once\u0026gt;Message: {{ message }}\u0026lt;/p\u0026gt;   CodePen Demo：Vue 2.x - v-once\n可用於低開銷的靜態元件上。\nHTML 標籤 如果要將資料渲染成 HTML 標籤，就需要使用 v-html 指令。\n1 2 3 4  \u0026lt;p v-html=\u0026#34;\u0026#39;\u0026lt;span\u0026gt;123\u0026lt;/span\u0026gt;\u0026#39;\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!-- HTML 將被渲染成 --\u0026gt; \u0026lt;p\u0026gt;\u0026lt;span\u0026gt;123\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt;   使用 v-html 的元素，若有內容會被取代掉：\n1 2 3 4  \u0026lt;p v-html=\u0026#34;\u0026#39;\u0026lt;span\u0026gt;123\u0026lt;/span\u0026gt;\u0026#39;\u0026#34;\u0026gt;某段內容\u0026lt;/p\u0026gt; \u0026lt;!-- HTML 將被渲染成 --\u0026gt; \u0026lt;p\u0026gt;\u0026lt;span\u0026gt;123\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt;   不過 v-html 可以不使用，盡可能不使用。\nAttributes Mustache 語法不能作用在 HTML atributes 上，這時可以使用 v-bind 指令：\n1  \u0026lt;div v-bind:id=\u0026#34;dynamicId\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   更詳細的說明會在特性綁定介紹。\nJavaScript Expressions Vue.js 提供了完全的 JavaScript Expressions（表達式）支持。\n舉例來說：\n1 2 3 4 5 6  \u0026lt;p\u0026gt;{{ 1 + 1 }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ \u0026#39;Hello\u0026#39;.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;) }}\u0026lt;/p\u0026gt; \u0026lt;!-- HTML 將被渲染成 --\u0026gt; \u0026lt;p\u0026gt;{{ 2 }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;olleH\u0026lt;/p\u0026gt;   但要注意的是，只支持表達式，並不支持語句，舉例來說：\n1 2 3  \u0026lt;p\u0026gt;{{ var a = 1 }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ if (ok) { return message } }}\u0026lt;/p\u0026gt;   以上皆會拋出錯誤。條件判斷，可以改用三元運算子。\n另外還有一點，除了某些 白名單中 中的全域變數外，不能使用其他自定義的全域變數。\n也就是說，我們能直接使用 Date：\n1 2 3 4  \u0026lt;p\u0026gt;版權所有 {{ \u0026#39;© \u0026#39; + new Date().getFullYear() }}\u0026lt;/p\u0026gt; \u0026lt;!-- HTML 將被渲染成 --\u0026gt; \u0026lt;p\u0026gt;版權所有 © 2020\u0026lt;/p\u0026gt;   是因為 Date 物件有在白名單內。\n若是第三方函式庫（例如 jQuery 的 $），或是自訂義全域物件，就無法在 Mustache 語法中使用。\n","description":"Vue 作為資料驅動畫面的框架，首先必須要了解如何將資料在畫面中展示出來。","id":47,"section":"posts","tags":["Vue"],"title":"資料渲染","uri":"https://chupai.github.io/posts/vue/base/datarender/"},{"content":" 竹白的 Vue 記事本 目錄\n Vue 的資料與方法。\n\rData 資料 資料 data 選項是用來儲存 Vue 實體的資料/狀態。接受一個物件或是 function 形式的物件（元件限制）。\n1. data 當一個 Vue 實體被建立時，它會將 data 物件中的所有屬性加入到 Vue 的 響應式系統 中，從而讓 data 的屬性能夠響應式更新。\n舉例來說，我們定義個資料屬性 message：\n1 2 3 4 5 6  const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { message: \u0026#39;Hello Vue.js!\u0026#39;, }, });   這個資料屬性就可以在實體對應的 Vue App 中進行使用。\n我們能用 Vue 的模板語法 Mustache 將資料呈現在畫面上：\n1 2 3  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ message }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;   若資料屬性的值發生改變時，畫面將會產生「響應」，即匹配更新為新的值。\n例如，新增一個用來改變 message 值的按鈕：\n1  \u0026lt;button @click=\u0026#34;message = \u0026#39;Hi!\u0026#39;\u0026#34;\u0026gt;Change\u0026lt;/button\u0026gt;   See the Pen Vue 2.x - Data by CHUPAIWANG (@CHUPAIWANG) on CodePen.  但是，只有當實體被建立時，就已經存在於 data 中的屬性才是響應式的，這部分我們會在 資料無法響應 中說明。\r 2. 訪問資料 Vue 實體建立之後，我們可以使用 $data 來訪問資料物件。\n另外 Vue 實體也代理了 data 物件上所有的屬性，因此訪問 vm.message 等同訪問 vm.$data.message。\n1 2  // Console vm.message === vm.$data.message; // true   3. Object.freeze() Vue 會遍歷 data 中的所有屬性，並使用 Object.defineProperty 將屬性做 getter、setter 改造，以便監控狀態的更新（響應式更新）。\n1 2 3 4 5 6 7  const data = { message: \u0026#39;Hello Vue.js!\u0026#39; }; const vm = new Vue({ data, }); conosle.log(data);   我們印出來觀察，就會發現資料物件已經不是原來的普通物件：\n若是使用 Object.freeze() 將物件凍結，這會阻止 Vue 修改屬性，也就說它將不會響應式更新。\n這有什麼好處？若今天有一筆資料，只是純展示用的，根本不需要對它進行監聽，這時就可以使用 Object.freeze() 來提升性能。另一種做法是，將這筆資料放進 computed 屬性中，因為 computed 屬性只有依賴的響應式屬性變化才會重新計算。\n有人會問，為什不直接放在全域呢？因為放在全域就不能用於模板語法上了。\n4. 內建屬性 Vue 內建的實體屬性與方法。它們都有前綴 $ 以便與用戶定義的屬性區分開來。\n因此在 data 資料物件內，以 _ 或 $ 開頭的屬性不會被 Vue 實體代理，因為它們可能衝突。\n 實體屬性 實體方法 / 資料 實體方法 / 事件 實體方法 / 生命週期  Methods 方法 methods 選項，就是用來存放函式的，也就是方法，和一般的函式沒有區別。\n1. methods 定義方法：\n1 2 3 4 5 6 7 8 9 10 11 12  const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { a: 1, b: 2, }, methods: { add() { return this.a + this.b; }, }, });   這裡的 this 自動綁定為 Vue 實體（也就是 vm），因此可以透過 this 取得 data 資料物件內的屬性。\n我們也可以直接在 Mustache 語法中呼叫方法：\n1 2 3  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ add() }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;   雖然在 Mustache 語法中使用方法，也會根據依賴的響應式屬性變化重新計算，但它沒有緩存，所以重複使用會重複計算。\nCodePen Demo：Vue 2.x - Methods\nmethods 基本上沒什麼特別的，唯一要注意的，就是不要使用箭頭函式（arrow function）定義方法，因為會改變 this 的指向。\r 更多關於 methods 應用，會在事件綁定中提到。\n2. 訪問方法 methods 中的方法將被混入到 Vue 實體中，可以直接訪問這些方法：\n1  vm.add();   所以我們要在另一個方法中呼叫其他方法，也是使用 this。\n1 2 3 4 5 6 7 8  methods: { foo() { // ...  }, boo() { this.foo(); }, }   ","description":"Vue 的資料與方法。","id":48,"section":"posts","tags":["Vue"],"title":"資料 \u0026 方法","uri":"https://chupai.github.io/posts/vue/base/datamethods/"},{"content":" 竹白的 Vue 記事本 目錄\n Vue 的實體（Instance）是 Vue.js 的核心，每個 Vue App 都是從建立實體開始。\n\r建立 Vue 實體 Vue 實體是透過 Vue Constructor（建構式）所產生，在實體化時，可傳入一個選項物件（Options）。\n1 2 3  const vm = new Vue({ // options });   儲存 Vue 實體的變數名稱常見的縮寫有 vm（ViewModel 視圖模型）和 app（application 應用程式）。\n若之後沒有要操作這個實體的狀態，可以不指定變數直接使用。\n選項 傳入 Vue 實體的選項物件包含這個 Vue 實體需要用到的屬性，例如：\n el：用來掛載 Vue 實體元素 data：要綁定的資料/狀態 methods：定義在 Vue 實體內使用的方法（函式） watch：用來觀察 Vue 實體內資料的變動 props：元件接收外部資料的屬性 等等\u0026hellip;  掛載 DOM 元素 el 屬性為 element 縮寫，作用為掛載 Vue 實體與 DOM 元素的關係（此元素為根元素），是 Vue App 的作用範圍。\n1  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   1 2 3  const vm = new Vue({ el: \u0026#39;#app\u0026#39;, });   el 類型為 string 或 Element，也就是 CSS 選擇器或 DOM 物件。\nel 只在用 new 創建實體時生效。在實體掛載後，元素可以用 vm.$el 訪問。\n1 2  // Console vm.$el; // \u0026lt;div id=\u0026#39;app\u0026#39;\u0026gt;\u0026lt;/div\u0026gt;   除了透過選項物件 el 屬性掛載 DOM 外，我們還能透過 $mount() 進行手動掛載。\n1 2 3  const vm = new Vue({}); vm.$mount(\u0026#39;#app\u0026#39;);   CodePen Demo：Vue 2.x - Instance\n","description":"Vue 的實體（Instance）是 Vue.js 的核心，每個 Vue App 都是從建立實體開始。","id":49,"section":"posts","tags":["Vue","Vue實體"],"title":"Vue 實體","uri":"https://chupai.github.io/posts/vue/base/instance/"},{"content":"Vue 免費學習資源\n官方  教程 風格指南  電子書  Learning Vue.js eBook 重新認識 Vue.js Vue.js 技術揭秘 深入理解Vue.js實戰 你也許不知道的 Vuejs  字典  Vue3+ \u0026amp; Vue-CLI3+ 开发生态圈资讯  影片 Alex 宅幹嘛：\n Vue.js 手牽手，一起嗑光全家桶 Re Vue 重頭說起 第一季 Re Vue 重頭說起 第二季  跟山地人学前端：\n Vue.js自学系列教程 跟山地人学Vue CLI系列教程 跟山地人学Vue Router系列教程 跟山地人学Vuex系列教程 跟山地人实战Vue系列教程 ","description":"Vue 免費學習資源","id":50,"section":"posts","tags":["Vue","免費學習資源"],"title":"Vue 免費學習資源","uri":"https://chupai.github.io/posts/vue/freelearn/"},{"content":"目前筆記以 Vue 2 為主，之後會新增 Vue 3。\n\r學習  免費學習資源  基礎  Vue 實體 資料 \u0026amp; 方法 資料渲染 資料計算 \u0026amp; 資料監聽 Vue 生命週期 資料無法響應  指令 Directives  指令概述 特性綁定 條件渲染 \u0026amp; 列表渲染 事件綁定 表單資料的雙向綁定  元件 Component  元件基礎 Prop 自定義事件 Slot 插槽  重用 轉場 \u0026amp; 動畫 Vue Router  Vue Router - 基礎 Vue Router - 動態路由匹配 Vue Router - 巢狀路由 Vue Router - 程式控制 Vue Router - 命名路由 \u0026amp; 命名視圖 Vue Router - 重新導向 \u0026amp; 别名 Vue Router - 路由元件傳遞 Vue Router - 導航守衛 Vue Router - 權限控制 Vue Router - 滾動行為 Vue Router - 模組化管理  Vue 專案化 Vuex  Vuex - 起手式 Vuex - 核心概念 Vuex - Module Vuex - 注意事項  Vue 套件 Vue UI 風格","description":"竹白的 Vue 記事本 目錄","id":51,"section":"posts","tags":["Vue"],"title":"竹白的 Vue 記事本 目錄","uri":"https://chupai.github.io/posts/vue/menu/"},{"content":"這週是六角鼠年鐵人賽第三十五週。\n\r何謂回溯法 回溯法（Backtracking）是暴力搜尋法（窮舉搜尋、枚舉法）中的一種。用試錯的思想，在分步解決問題的過程中，當探索到某一步時，發現原先選擇並不能得到有效的正確的解答的時候，就退回一步甚至是上幾步的計算重新選擇。\n可以分為兩個概念：\n 枚舉 enumerate：每一步列出所有可能的下一步一一測試。 剪枝 pruning：遇到不符合條件的下一步便省略，不再繼續枚舉。  全排列 用 全排列（Permutations） 來理解回溯法。\n問題：用程式列出所有由 1、2、3 構成的 不重複序列。\n首先使用巢狀迴圈枚舉所有可能：\n1 2 3 4 5 6 7 8 9  const res = []; for (let i = 1; i \u0026lt;= 3; i +=1) { for (let j = 1; j \u0026lt;= 3; j +=1) { for (let k = 1; k \u0026lt;= 3; k +=1) { res.push([i, j , k]); } } }   共會有 27 種組合，包含了不符合條件的。\n檢查約束條件（不重複），過濾重複的組合：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const res = []; for (let i = 1; i \u0026lt;= 3; i += 1) { for (let j = 1; j \u0026lt;= 3; j += 1) { for (let k = 1; k \u0026lt;= 3; k += 1) { if (i === j || i === k || j === k) {continue;} res.push([i, j, k]); } } } console.log(res); // [ [ 1, 2, 3 ], // [ 1, 3, 2 ], // [ 2, 1, 3 ], // [ 2, 3, 1 ], // [ 3, 1, 2 ], // [ 3, 2, 1 ] ]   求得六組解。\n但是我們如果最後一層才做檢查，會有多餘的檢查，因為當 i === j 時，不論 k 是什麼，都不可能會是我們要的。\n因此我們可以提早檢查，提早結束：\n1 2 3 4 5 6 7 8 9 10 11  const res = []; for (let i = 1; i \u0026lt;= 3; i +=1) { for (let j = 1; j \u0026lt;= 3; j +=1) { if (i === ｊ) {continue;} for (let k = 1; k \u0026lt;= 3; k +=1) { if (i === k || ｉ === k) {continue;} res.push([i, j, k]); } } }   不過使用巢狀迴圈會有一個問題，你無法調整深度，假設數字增加，就會造成迴圈有非常多層，另一種情況是你根本不知道會有幾層。\n所以通常回溯法會使用遞迴方法來實作，在反覆重複上述的步驟後可能出現兩種情況：\n 找到一個可能存在的正確的答案； 在嘗試了所有可能的分步方法後宣告該問題沒有答案。  遞迴可以再改寫成迭代的方式（堆疊/佇列 + 迴圈）。\n將問題用樹狀結構表示：\ngraph TB; 0[\u0026quot;[]\u0026quot;] --\u0026gt; 1[\u0026quot;[1]\u0026quot;] \u0026amp; 2[\u0026quot;[2]\u0026quot;] \u0026amp; 3[\u0026quot;[3]\u0026quot;]; 1[\u0026quot;[1]\u0026quot;] --\u0026gt; 4[\u0026quot;[1, 2]\u0026quot;] \u0026amp; 5[\u0026quot;[1, 3]\u0026quot;]; 2[\u0026quot;[2]\u0026quot;] --\u0026gt; 6[\u0026quot;[2, 1]\u0026quot;] \u0026amp; 7[\u0026quot;[2, 3]\u0026quot;]; 3[\u0026quot;[3]\u0026quot;] --\u0026gt; 8[\u0026quot;[3, 1]\u0026quot;] \u0026amp; 9[\u0026quot;[3, 2]\u0026quot;]; 4[\u0026quot;[1, 2]\u0026quot;] --\u0026gt; 10[\u0026quot;[1, 2, 3]\u0026quot;] 5[\u0026quot;[1, 3]\u0026quot;] --\u0026gt; 11[\u0026quot;[1, 3, 2]\u0026quot;] 6[\u0026quot;[2, 1]\u0026quot;] --\u0026gt; 12[\u0026quot;[2, 1, 3]\u0026quot;] 7[\u0026quot;[2, 3]\u0026quot;] --\u0026gt; 13[\u0026quot;[2, 3, 1]\u0026quot;] 8[\u0026quot;[3, 1]\u0026quot;] --\u0026gt; 14[\u0026quot;[3, 1, 2]\u0026quot;] 9[\u0026quot;[3, 2]\u0026quot;] --\u0026gt; 15[\u0026quot;[3, 2, 1]\u0026quot;] 因為有約束條件（不重複），在這棵樹上我們有做剪枝，剪去一些不會產生正確解的選擇（分支）。\n求解過程其實就是深度優先搜尋。\n從 [] 出發：\n 首先選擇 1，path = [1]； 因為有約束條件，所以跳過 1 選擇 2，path =[1, 2]； 繼續往下層，因為有約束條件，所以跳過 1, 2 選擇 3，path = [1, 2, 3] 求得解所以回到 [1, 2]； 沒 nums 可選了，所以繼續退回上層 [1]； 接下來就是重複相同操作。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  function permute(nums) { const res = []; const used = {}; // 判斷數字是否使用過  dfs([]); // path 當前路徑  function dfs(path) { if (path.length === nums.length) { res.push([...path]); // 傳拷貝  return; // 回上層  } for (const num of nums) { if (used[num]) {}; // 約束條件  path.push(num); used[num] = true; dfs(path); // 繼續下層  path.pop(); // 恢復路徑  used[num] = false; } } return res; } console.log(permute([1, 2, 3])); // [ [ 1, 2, 3 ], // [ 1, 3, 2 ], // [ 2, 1, 3 ], // [ 2, 3, 1 ], // [ 3, 1, 2 ], // [ 3, 2, 1 ] ]   可以輸入其他不重複的數列，求其全排列。\n","description":"回溯法（Backtracking）是暴力搜尋法中的一種。","id":52,"section":"posts","tags":["回溯法","w3HexSchool"],"title":"JavaScript 學演算法（二十五）- 回溯法","uri":"https://chupai.github.io/posts/2009/backtracking/"},{"content":"這週是六角鼠年鐵人賽第三十四週。\n\r前言 在 Vue 文件的 表單輸入綁定 中有提到這一段：\n 對於需要使用輸入法 (如中文、日文、韓文等) 的語言，你會發現 v-model 不會在輸入法組合文字過程中得到更新。如果你也想處理這個過程，請使用 input 事件。\n See the Pen v-model by CHUPAIWANG (@CHUPAIWANG) on CodePen.  這是因為 Vue 有使用到 CompositionEvent，你可以在 v-model 的 原始碼 中看到。\n另外，在 Element UI 的 Input 元件 原始碼，你可以看到它的身影\nCompositionEvent 簡介 CompositionEvent 複合事件，是用來處理輸入法編輯器（Input Method Editor, IME）的事件，從 DOM Level 3 之後才新增的。\n在使用輸入法編輯器時，會根據輸入狀態觸發下事件：\n compositonstart：開始拼字時觸發。 compositionupdate：選字時觸發。 compositionend：拼字完成時觸發。  CompositionEvent 會在 keydown 事件之後被觸發。\n假設我們不使用 v-model 來雙向綁定輸入框：\n1 2 3  \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;text\u0026#34; @input=\u0026#34;inputHandler\u0026#34;\u0026gt; \u0026lt;p\u0026gt;內容： {{ text }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;字數： {{ text.length }}\u0026lt;/p\u0026gt;   1 2 3 4 5 6 7 8  data: { text: \u0026#39;\u0026#39;, }, methods: { inputHandler(event) { this.text = event.target.value; }, }   你就會發現，當你使用注音選字時，會觸發更新：\nSee the Pen DEMO by CHUPAIWANG (@CHUPAIWANG) on CodePen.  新增一個 isComposing 狀態來判斷輸入法是否在使用中：\n1 2 3 4  data: { text: \u0026#39;\u0026#39;, isComposing: false, }   接著，我們要監聽 compositonstart 和 compositionend 事件：\n1 2 3 4 5 6 7 8 9  \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;text\u0026#34; @input=\u0026#34;inputHandler\u0026#34; @compositionstart=\u0026#34;isComposing = true\u0026#34; @compositionend=\u0026#34;handleCompositionEnd\u0026#34; \u0026gt; \u0026lt;p\u0026gt;內容： {{ text }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;字數： {{ text.length }}\u0026lt;/p\u0026gt;    當 compositionstart 觸發，isComposing 設為 true； 當 compositionend 觸發，isComposing 設為 false 並呼叫 inputHandler。  1 2 3 4 5 6 7 8 9 10 11 12  methods: { inputHandler(event) { if (this.isComposing) { return; } this.text = event.target.value; }, handleCompositionEnd(event) { if (this.isComposing) { this.isComposing = false; this.inputHandler(event); } } }   See the Pen CompositionEvent DEMO by CHUPAIWANG (@CHUPAIWANG) on CodePen.  isComposing 事件屬性 另外，KeyboardEvent 和 InputEvent 有 KeyboardEvent.isComposing、 InputEvent.isComposing。isComposing 屬性在 compositonstart 和 compositionend 之間其值為 true。\n但是 Safari（WebKit）瀏覽器不支援。\n應用 使用 CompositionEvent 來判斷輸入法狀態，可以有效避免 input 監聽事件在拼字時一直觸發。\n也可以在用在使用 Enter 鍵送出資料時的優化。舉例來說，在某些瀏覽器下，如果使用 @keyup.enter=\u0026quot;submit\u0026quot; 送出資料，當我們在選字時所按下 Enter 鍵，就會觸發事件：\n因此我們可以加上輸入法狀態判斷避免誤觸：\n1 2 3 4 5 6 7 8 9  \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;text\u0026#34; @keyup.enter=\u0026#34;submit\u0026#34; @compositionstart=\u0026#34;isComposing = true\u0026#34; @compositionend=\u0026#34;isComposing = false\u0026#34; \u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item of list\u0026#34;\u0026gt;{{ item }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;   1 2 3 4 5 6 7 8 9 10 11  data: { text: \u0026#39;\u0026#39;, list: [], isComposing: false, }, methods: { submit(event) { if (this.isComposing) { return } this.list.push(this.text); } }   CodePen Demo\n等同：\n1 2 3 4 5 6 7  \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;text\u0026#34; @keyup.enter=\u0026#34;submit\u0026#34; \u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item of list\u0026#34;\u0026gt;{{ item }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;   1 2 3 4 5 6 7 8 9 10  data: { text: \u0026#39;\u0026#39;, list: [], }, methods: { submit(event) { if (event.isComposing) { return } this.list.push(this.text); } }   但是 isComposing 事件屬性 Safari（WebKit）瀏覽器不支援。\n","description":"CompositionEvent 處理輸入法狀態判斷。","id":53,"section":"posts","tags":["CompositionEvent","w3HexSchool"],"title":"CompositionEvent","uri":"https://chupai.github.io/posts/2009/compositionevent/"},{"content":"這週是六角鼠年鐵人賽第三十三週。\n\r何謂貪婪演算法 貪婪演算法（Greedy Algorithm），或稱 貪心演算法，比起動態規劃更為簡單直接。\n1. 演算法思想 貪婪演算法的主軸是反覆執行某個任務，直到求得一組解；每次執行任務時，都是找當下最好的方案。\n也就是說，貪婪演算法並不會考慮到未來，只考慮當下，因此對於某些情況下不一定能求出最佳解。\n2. 適用的情況 由於貪婪演算法的高效性以及其所求得的答案比較接近最佳解，貪婪演算法也可以用作輔助演算法或者直接解決一些要求結果不特別精確的問題。\n零錢問題 給定不同面額的硬幣 coins，和一個總金額 amount，求出最少硬幣的組合數。如果沒有任何一種硬幣組合能組成總金額，回傳 -1。\n1. 貪婪演算法 假設我們的硬幣面額為新台幣常見的 1、5、10、50。\n那麼我們可以使用貪婪演算法的思想，每次兌換優先使用面額較大的硬幣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function coinChange(coins, amount) { let count = 0; let total = 0; for (let i = coins.length; i \u0026gt;= 0; i -= 1) { const coin = coins[i]; while (total + coin \u0026lt;= amount) { count += 1; total += coin; } } return count; } const COINS = [1, 5, 10, 50]; console.log(coinChange(COINS, 90)); // 5 console.log(coinChange(COINS, 40)); // 4 console.log(coinChange(COINS, 15)); // 2   對於新台幣硬幣面額，我們能使用貪婪演算法求出最佳解。\n但是，如果使用其他硬幣面額，就不一定能求出最佳解：\n1 2 3  const COINS = [1, 3, 4]; console.log(coinChange(COINS, 6)); // 3   正確解為 2(3 + 3)。\n2. 動態規劃 改用動態規劃。\n假設硬幣面額為 [1, 3, 4]、總金額為 100。\ndp[i]：表示總金額為 i 的時候最佳解。\n 如果我們拿一枚面額為 1 的硬幣 + 總金額 99 的解為 dp[99] + 1； 如果我們拿一枚面額為 3 的硬幣 + 總金額 97 的解為 dp[97] + 1； 如果我們拿一枚面額為 4 的硬幣 + 總金額 96 的解為 dp[96] + 1。  由此可知，總金額 100 的最佳解為 3 種解法的其中一種，因此我們可以得到：dp[100] = Math.min(dp[99] + 1, dp[97] + 1, dp[96] + 1)。\n推導出：dp[i] = Math.min(dp[i - coins[0]] + 1, dp[i - coins[1]] + 1, ...)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function coinChange(coins, amount) { let dp = new Array(amount + 1).fill(Infinity); dp[0] = 0; for (let coin of coins) { for (let i = coin; i \u0026lt;= amount; i += 1) { dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } return dp[amount] === Infinity ? -1 : dp[amount]; } const COINS = [1, 3, 4]; console.log(coinChange(COINS, 6)); // 2   先建立 amount + 1 陣列（+1 是為了對應總金額），將預設值設為 Infinity（便於與最小值的判斷）。\n接下來遍歷每種面額對應的金額，並判斷是否為最小解。\n","description":"貪婪演算法。","id":54,"section":"posts","tags":["資料結構","貪婪演算法","動態規劃","w3HexSchool"],"title":"JavaScript 學演算法（二十四）- 貪婪演算法","uri":"https://chupai.github.io/posts/2009/greedyalgorithm/"},{"content":"這週是六角鼠年鐵人賽第三十二週。\n\r何謂分治法 分治法（Divide-and-Conquer） 或稱 各個擊破法、切割征服法，是一種演算法思想，而不是用於解決特定問題的演算法。\n設計思想如字面上的意義：將難以直接解決的問題，切分成可簡單處理的小問題，再將小問題的結果合併，即原始問題的答案。\n1. 演算法思想 對於一個規模為 n 的問題，若該問題可以容易地解決（比如說規模 n 較小）則直接解決，否則將其分解為 k 個規模較小的子問題，這些子問題互相獨立且與原問題形式相同，遞迴地解這些子問題，然後將各子問題的解合併得到原問題的解。\n2. 基本流程 分治法在每一層遞迴上都有三個步驟：\n 分解（divide）：將原問題分解為若干個規模較小，相互獨立，與原問題形式相同的子問題； 解決（conquer）：若子問題規模較小且易於解決時，則直接求解。 合併（combine）：將各子問題的解合併，合併後的結果為原問題的解。  3. 適用的情況 分治法所能解決的問題一般具有以下幾個特徵：\n 該問題的規模縮小到一定的程度就可以容易地解決； 該問題可以分解爲若干個規模較小的相同問題，即該問題具有 最佳子結構（Optimal Substructure） 性質； 利用該問題分解出的子問題的解，可以合併爲該問題的解； 該問題所分解出的各個子問題是相互獨立的。  若子問題不是互相獨立的，有互相重疊部分（即下一個子階段的求解是建立在上一個子階段的解的基礎上，進行進一步的求解），如果使用分治法會重複計算重疊的子問題，造成浪費效能。建議改用 動態規劃。\n4. 實作方式 分治法最適合使用遞迴來實作，但遞迴和迭代是一一對應的，分治法只是一種演算法思想，所以使用迭代來實作也沒問題。\n之前提過的 合併排序 和 快速排序 都是使用分治法的經典問題。\n何謂動態規劃 動態規劃（Dynamic programming, DP） 與分治法類似。\n1. 演算法思想 動態規劃也是一種分治思想，同樣是將待求解的問題分解為若干個子問題。但與分治法最大的差別是，動態規劃經分解後得到的子問題往往不是互相獨立的，有互相重疊部分（即下一個子階段的求解是建立在上一個子階段的解的基礎上，進行進一步的求解），因此需要用記憶體儲存解子問題的解，以便下次需要同一個子問題解之時直接使用（避免重複運算）\n2. 基本流程 動態規劃的主要難點在於理論上的設計：\n 定義原問題與子問題的關係，可使用遞迴關係表示； 以自底向上或自頂向下的記憶化方式，儲存子問題的解； 決定如何得到完整的最佳解。  3. 適用的情況 使用動態規劃的問題具有以下性質：\n 最佳子結構（Optimal Substructure）； 無後效性，即子問題的解一旦確定，就不再改變，不受在這之後、包含它的更大的問題的求解決策影響。 子問題重疊的性質。  3. 費氏數列 我們來看費氏數列。\n若使用遞歸實作：\n1 2 3 4 5 6  function fibonacci(n) { if (n \u0026lt; 2) { return n; } return fibonacci(n - 1) + fibonacci(n - 2); }   雖然使用遞歸簡單明瞭，但子問題並不是獨立：\n1 2 3 4 5 6  f(5) = f(4) + f(3); f(4) = f(3) + f(2); f(3) = f(2) + f(1); f(2) = f(1) + f(0); f(1) = 1; f(0) = 0;    求 f(5) 就必須算出 f(4) 和 f(3) 求 f(4) 就必須算出 f(3) 和 f(2) 求 f(3) 就必須算出 f(2) 和 f(1)  很明顯的，子問題重疊，會出現重複計算，因此導致執行效率不佳，當 n 非常大時，直接計算到爆炸，時間複雜度 $O(2^n)$、空間複雜 $O(n)$。\n若我們用變數 dp 將結果儲存，就可以避免重複計算：\n1 2 3 4 5 6 7  function fibonacci(n) { let dp = [0, 1, 1]; for (let i = 3; i \u0026lt;= n; i += 1) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; }   時間複雜度 $O(n)$、空間複雜 $O(n)$。\n優化，只存上一個和當前的值，減少記憶體空間：\n1 2 3 4 5 6 7 8 9 10 11 12  function fibonacci3(n) { if (n === 0) return 0; if (n === 2 || n === 1) return 1; let prev = 1; let curr = 1; for (let i = 3; i \u0026lt;= n; i += 1) { let sum = prev + curr; prev = curr; curr = sum; } return curr; }   時間複雜度 $O(n)$、空間複雜 $O(1)$。\n","description":"分治法、動態規劃。","id":55,"section":"posts","tags":["資料結構","分治法","動態規劃","w3HexSchool"],"title":"JavaScript 學演算法（二十三）- 分治法、動態規劃","uri":"https://chupai.github.io/posts/2009/divide_and_conquer_dp/"},{"content":"這週是六角鼠年鐵人賽第三十一週。這週原本是要說明分治法，但文章還沒整理好😅。\n\r什麼是 Neumorphism Neumorphism 是由「New Skeuomorphism」組合的新名詞，也就是新型態的擬物化風格設計，中文稱作新擬態、同化，也有設計師稱其為 Soft UI（軟UI）。\nNeumorphism 是 2020年最熱門的新風格，它透過燈光的原理，替圖形加上高光和陰影，類似於浮雕的效果，賦予元件真實和立體感。\n此風格源頭為烏克蘭的設計師 Alexander Plyuto，於 2019年底所發表的作品「Skeuomorph Mobile Banking」。\n設計風格發展 1. Skeuomorphism（擬物） Skeuomorphism 風格最早的起源是 2007年 Apple 發布 iOS 1。\nSkeuomorphism 最大特徵就是模擬真實物件的外觀，那個時期幾乎所有 UI 都是 Skeuomorphism。\n2. Flat Design（扁平設計） 接下來，2010 年微軟發布他們首款智慧型手機 Window Phone 中，可以說是首款應用 Flat Design 風格的智慧型裝置。\nFlat Design 最大特徵就是去除陰影、漸層、裝飾、反射光澤等等的模擬 3D 要素，呈現出簡潔的風格。\n直到 2013年 Apple iOS7 捨棄了 Skeuomorphism，也改用更簡潔的 Flat Design。\n從 2014 年開始 Flat Design 風格的 UI 設計開始大流行，形成新一代介面設計的熱潮，不僅僅是 UI 介面，連許多大企業的 LOGO 也都捨棄 Skeuomorphism 改成 Flat Design 風格。\n最有名的例子 Instagram：\n3. Material Design（卡片式設計、實感設計） 但 Flat Design 風格的最大問題就是容易造成審美疲勞，所有資訊沒有分層，直到 2017年 Google 推出了 Material Design，將現實世界中紙張的特性用在虛擬中，利用陰影模擬紙張空間。\n目前主流 UI 設計幾乎是 Flat Design 和 Material Design。\nNeumorphism 特徵 Neumorphism 此風格同時擁有高光和陰影。\n具有以下幾點特徵：\n 元件不漂浮； 元件顏色與背景統一，不能純黑或純白； 利用明的暗陰影產生凹凸感。  扁平、實感、擬物化風格：\nSee the Pen Neumorphism DEMO by Chupai@Design (@chupai) on CodePen.  CSS 樣式 1. 凸 1 2 3 4 5 6 7 8 9  .circle { width: 200px; height: 200px; border-radius: 50%; background: #E6EEF8; box-shadow: -6px -6px 16px rgba(255, 255, 255, 0.8), 6px 6px 16px rgba(0, 0, 0, 0.2); }   See the Pen Neumorphism Concave by Chupai@Design (@chupai) on CodePen.  2. 凹 1 2 3 4 5 6 7 8 9  .circle { width: 200px; height: 200px; border-radius: 50%; background: #E6EEF8; box-shadow: inset -6px -6px 16px rgba(255, 255, 255, 0.8), inset 6px 6px 16px rgba(0, 0, 0, 0.2); }   See the Pen Neumorphism Convex by Chupai@Design (@chupai) on CodePen.  3. 疊加 See the Pen Neumorphism 疊加 by Chupai@Design (@chupai) on CodePen.  4. 總結 分辨光源位置製造凹凸有致的效果，最基本的光源角度為 45度角，也就左上角和右下角，也可以用其他角度。\n背景也可以使用漸層稍作一點點變化，讓元件表面看起來不是平面的，陰影模糊程度可以視想要呈現的材質來決定，較大看起來較柔軟。\n Neumorphism.io\n線上工具\n 範例 See the Pen Neumorphism Text Effect by Chupai@Design (@chupai) on CodePen.  See the Pen Neumorphism UI - Social by Chupai@Design (@chupai) on CodePen.  See the Pen Neumorphism - block by Chupai@Design (@chupai) on CodePen.  See the Pen Neumorphism UI - Login Form by Chupai@Design (@chupai) on CodePen.  總結 在主流 UI 設計幾乎是 Flat Design 風格的情況下，Neumorphism 帶給人新穎、新鮮、未來感，但說實在的，此風格對於視力較差的使用者來說，可辨識非常不友善。因為它的元件顏色與背景相同，基本上是依賴高光和陰影凸顯出元件本身，舉例來說，你的螢幕對比稍微不準確一點，元件會直接與背景融合。\n以上是我的看法，但我不設計師，因此若對此風格有更多興趣，可以參考以下文章：\n Neumorphism（新拟态）UI设计趋势吗？ 新擬物化設計 Neumorphism 讓 UIUX 設計師重新思考的 5 件事 用户界面中的Neumorphism（新拟物风格）设计 为什么2020年初爆火的新拟物化设计，完全无法落地使用？ “热火朝天”的新拟物设计趋势，你需要理性看待 趋势 I 解析新拟态风格最全指南 新擬態——國外設計師分析的全新UI趨勢  另外，最近找到一個基於 Bootstrap 的 Neumorphism UI，可以玩玩看。\n","description":"Neumorphism 是由「New Skeuomorphism」組合的新名詞，也就是新型態的擬物化風格設計。","id":56,"section":"posts","tags":["UI/UX","Neumorphism","Soft UI"],"title":"Neumorphism（Soft UI）","uri":"https://chupai.github.io/posts/2008/neumorphism/"},{"content":"這週是六角鼠年鐵人賽第三十週。\n這幾週會說明演算法的設計：分治法、動態規劃、貪婪法、回溯法、分支定界法，所以我們先來看 遞迴 Recursion。\n\r什麼是遞迴  為了理解遞迴，則必須首先理解遞迴。\n 遞迴（Recursion） 最早是用在數學定義式，稱作 遞迴定義（recursive definitions），使用被定義對象的自身來為其下定義，使用被定義對象的自身來為其下定義。\n簡單來說，就是「自己定義自己」。\n舉例來說，費氏數列（Fibonacci） 或稱 斐波那契數列：由 0 和 1 開始，之後的數是由之前的兩數相加而得出。\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 ... 如果要將數列全部列舉完，基本上不可能，所以數學上就以遞迴來定義：\n $F_0 = 0$（基本條件） $F_1 = 1$（基本條件） 對所有大於 $1$ 的整數 $n$：$F_n = F_{n-1} + F_{n-2}$（遞迴定義）  在程式語言中，將上述概念程式化，是程式流程控制的一種，遞迴程序（recursive procedures），一個函式直接或間接呼叫自身的一種方式。\n簡單來說，就是「自己呼叫自己」。\n遞迴本質上，是一種將一個複雜的問題，拆分成具有相同性質的子問題，而解決問題的方法。\n簡單範例 一個基本的遞迴函式一定要有：\n 終止條件（基本條件） 遞迴條件（呼叫自己的條件）  如果沒有終止條件，就會無限循環直到當掉。\n1. 累加 假設輸入一個正整數 n，求 1 + 2 + \u0026hellip; + n 的總和。\n最簡單的方式，就是用迭代的方式（迴圈），將所有數字累加再一起：\n1 2 3 4 5 6 7  function sum(n) { let result = 0; for (let i = 1; i \u0026lt;= n; i++) { result += i; } return result; }   這個問題可以寫成 $S(n) = n + n - 1 + \u0026hellip; + 1$，也就是\n $S(1) = 1$（基本條件） 對所有大於 1 的整數：$S(n) = n + S(n - 1)$（遞迴定義）  使用遞迴的方式：\n1 2 3 4 5 6  function sum(n) { if (n === 1) { return 1; } return n + sum(n - 1); }   初始（終止）條件為 n === 1，遞迴條件為 n !== 1。\n如果 n = 6，執行過程如下：\n1 2 3 4 5 6 7 8 9 10  sum(5) 5 + sum(4) 4 + sum(3) 3 + sum(2) 2 + sum(1) return 1 return 2 + 1 // 3  return 3 + 3 // 6  return 4 + 6 // 10  return 5 + 10 // 15   2. 階乘 另一個更常見的範例就是正整數的階乘（factorial）。\n定義：\n $0! = 1$ $n! = 1 \\times 2 \\times 3 \u0026hellip;(n - 2) \\times (n - 1) \\times n$ $n! = n \\times(n - 1)!$  1 2 3 4  function factorial(n) { if (n === 0) {return 1;} return n * factorial(n - 1); }   3. 費氏數列 上面提到的費氏數列：\n $F_0 = 0$（基本條件） $F_1 = 1$（基本條件） 對所有大於 $1$ 的整數 $n$：$F_n = F_{n-1} + F_{n-2}$（遞迴定義）  1 2 3 4 5 6  function fibonacci(n) { if (n \u0026lt; 2) { return n; } return fibonacci(n - 1) + fibonacci(n - 2); }   遞迴與迭代 迭代：\n 迴圈結構，是由下而上（Bottom-Up），一步步逼近答案； 用新值覆蓋舊值，直到滿足條件後結束，因為不保存中間值，因此不會消耗很多記憶體空間。  遞迴：\n 選擇結構，是由上而下（Top-Down），慢慢地將問題縮小，來求得答案； 將問題分解成干個子問題，再回頭運算答案，因此會消耗大量記憶體空間，但程式碼簡單明瞭。  遞迴可以改寫成迭代，迭代反之亦然。\n1. 遞迴的優缺點 優點：\n 大問題化為小問題，程式碼簡潔清晰，可讀性佳。  缺點：\n 容易產生 堆疊溢位（stack overflow），因此非必要，不建議使用遞迴； 冗餘計算，若子問題彼此非獨立的，會重複計算。  也就是說，雖然遞迴看起來比較簡潔專業，但並沒有比較快且消耗大量記憶體。\n尾遞迴 呼叫堆疊是有大小的，當過多的函式呼叫導致無法容納這些呼叫的位址，就會發生堆疊溢位。常發生在使用遞迴函式，因此設計函式時，會盡量避免使用遞迴結構，會改用迭代結構。\n但一定要使用遞迴呢？有一個技巧叫做尾遞迴（tail-recursive），可以優化遞迴函式指的是遞迴操作只回傳函式自己。\n不過我沒研究過，因此這裡先不討論，有興趣可以參考以下連結：\n 尾呼叫 - wikipedia 尾遞歸為啥能優化？ - 知乎 Javascript中的尾遞歸及其優化 - 知乎 讓遞迴的Stack永遠不會爆炸的「尾遞迴」真的有那麼神奇嗎 — 尾遞迴篇｜髒桶子 ","description":"為了理解遞迴，則必須首先理解遞迴。","id":57,"section":"posts","tags":["資料結構","遞迴","Recursion","w3HexSchool"],"title":"JavaScript 學演算法（二十二）- 遞迴 Recursion","uri":"https://chupai.github.io/posts/2008/alg_recursion/"},{"content":" 竹白的 JS 學徒特訓班筆記 - 目錄\n 記錄六角學院所開的 JS 學徒特訓班，為期 60天的特訓。\n\r第四十七關 -  題目連結\n 47. 問題 請吸收以下影片列表，以了解 post 的練習，影片內容是使用原生 post 方式，如果您已理解觀念，還請觀看 axios 影片來改寫原生 post 語法，用我們所提供的 API，來註冊一個帳號\n老鳥問題：\n請用此 API，寫三個 AJAX POST API 範例：\n XMLHttpRequest Fetch axios  47. 參考解答 API、要 POST 的資料（JSON 格式）：\n1 2 3 4 5  const url = \u0026#39;https://hexschool-tutorial.herokuapp.com/api/signin\u0026#39;; const sendData = { email: \u0026#39;lovef2e@hexschool.com\u0026#39;, password: \u0026#39;12345678\u0026#39;, };   XHR：\n1 2 3 4 5 6 7 8 9 10 11  const xhr = new XMLHttpRequest(); xhr.open(\u0026#39;POST\u0026#39;, url); xhr.setRequestHeader(\u0026#39;content-type\u0026#39;, \u0026#39;application/json\u0026#39;); xhr.send(JSON.stringify(sendData)); xhr.addEventListener(\u0026#39;load\u0026#39;, function () { if (this.status === 200) { const data = JSON.parse(this.responseText); alert(data.success + \u0026#39;,\u0026#39; + data.message); } });   Fetch：\n1 2 3 4 5 6 7 8 9  fetch(url, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;content-type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify(sendData), }) .then((response) =\u0026gt; response.json()) .then((data) =\u0026gt; { alert(data.success + \u0026#39;,\u0026#39; + data.message); });   1 2 3 4 5 6 7 8 9 10 11 12 13  // Async/Await async function ajax() { const response = await fetch(url, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;content-type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify(sendData), }); const data = await response.json(); alert(data.success + \u0026#39;,\u0026#39; + data.message); } ajax();   jQuery ajax：\n1 2 3  $.post(url, sendData, function (data) { alert(data.success + \u0026#39;,\u0026#39; + data.message); });   axios：\n1 2 3 4  axios.post(url, sendData).then((response) =\u0026gt; { const data = response.data; alert(data.success + \u0026#39;,\u0026#39; + data.message); });   教學、延伸知識連結  竹白記事本 - AJAX 竹白記事本 - JSON 竹白記事本 - XMLHttpRequest 竹白記事本 - Fetch  第四十八關 -  題目連結\n 48. 問題 請做此此影片的小節作業，一個網頁上有兩個面板，分別是\n 註冊面板 登入面板  同時寫一些驗證與使用者體驗功能，例如：\n 帳號密碼不可為空 送出後，欄位進行清空 查詢是否為 Email 格式(非必做) 密碼是否有英數夾雜(非必做)  48. 參考解答 codePen\nSee the Pen POST 練習 by Chupai@Design (@chupai) on CodePen.  第四十九、五十關 - 旅館訂房網  題目連結\n 技術主管終於告訴小杰，他們準備要幫客戶做旅館訂房網的題目，客戶已經有在網站看到一些網站覺得不錯，\n後來技術主管發現，其實那些網站都是 fake API，查到源頭才發現是這個網站，所以客戶要求說，先用這網站所提供的 API 先做出雛形來。\n49.50. 問題 小杰依照文件裡的 API，想要去取得此 API [GET] 取得所有房型，但發現不管怎麼戳也無法取得所有房型資料，\n技術主管只淡淡說了一句：「你送請求時少加 TOKEN 啦！」，就跑去泡咖啡了，這句話究竟是什麼意思呢？\n 任務一：請已經了解這知識的學員，寫篇 hackMD，教導該如何夾帶 token， 任務二：請用 codepen 寫自己的範例，能正確取得 [GET] 取得所有房型，並用 ul、li 來呈現各個「房型名稱」  49. 參考解答 TOKEN 簡單來說，就是你登入帳密（POST）後，伺服器會給你通行證（token），當你要跟伺服器請求資料時（GET），就是用這組通行證來驗證，不需要再次傳送帳號。\nAPI、TOKEN：\n1 2  const url = \u0026#39;https://challenge.thef2e.com/api/thef2e2019/stage6/rooms\u0026#39;; const token = \u0026#39;\u0026#39;;   XHR：\n1 2 3 4 5 6 7 8 9 10 11  const xhr = new XMLHttpRequest(); xhr.open(\u0026#39;GET\u0026#39;, url); xhr.setRequestHeader(\u0026#39;Authorization\u0026#39;, `Bearer ${token}`); xhr.send(null); xhr.addEventListener(\u0026#39;load\u0026#39;, function () { if (this.status === 200) { const data = JSON.parse(this.responseText); console.log(data); } });   Fetch：\n1 2 3 4 5 6 7 8 9 10  fetch(url, { method: \u0026#39;GET\u0026#39;, headers: { Authorization: `Bearer ${token}`, }, }) .then((res) =\u0026gt; res.json()) .then((data) =\u0026gt; { console.log(data); });   jQuery ajax：\n1 2 3 4 5 6 7 8 9 10  $.ajax({ url, type: \u0026#39;GET\u0026#39;, headers: { Authorization: `Bearer ${token}`, }, success(data) { console.log(data); }, });   axios：\n1 2 3 4 5 6 7  axios .get(url, { headers: { Authorization: `Bearer ${token}` }, }) .then((res) =\u0026gt; { console.log(res.data); });   50. 參考解答 渲染：\n1 2 3 4 5 6 7 8 9  function render(data) { const list = document.querySelector(\u0026#39;.list\u0026#39;); data.items.forEach((item)=\u0026gt; { const li = document.createElement(\u0026#39;li\u0026#39;); list.append(li); li.textContent = `Room name: ${item.name}`; }); }   教學、延伸知識連結  是誰在哈囉? 如何搞定 SPA 與 API Server 的登入驗證 [C#][ASP.NET] Web API 開發心得 (7) - 使用 Token 進行 API 授權驗證 你需要瞭解的token，Json web token ","description":"AJAX 47 ~ 50 關","id":58,"section":"posts","tags":["JavaScript","JS 學徒特訓班"],"title":"JS 學徒特訓班 - AJAX 47 ~ 50 關","uri":"https://chupai.github.io/posts/2008/js60_6/"},{"content":" JavaScript筆記 目錄\n AJAX：\n AJAX JSON XMLHttpRequest Fetch  Fetch API 傳統 AJAX 操作是使用 XMLHttpRequest（XHR）物件來實現，而 Fetch API 是近年來被提及將要取代 XMLHttpRequest 的技術新標準，是一個 HTML5 的 API。\n1. 簡介 Fetch 並不是 XMLHttpRequest 的升級版本，不是 jQuery 提供的 $.ajax 語法或 AXIOS 那種原生 XHR 的封裝。它是一個全新的東西，並且基於 Promise 語法結構所設計，可配合使用 Async/Await 語法，使程式更加優雅。\nFetch 的解決了一些 XHR 問題，例如，解決回呼地獄，使用起來更加簡潔、不需要加載函式庫等等。\n常被提及可能取代 XHR，但它也不是完全沒有缺點，沒辦法像 XHR 處理更細節的東西，例如，無法對請求進度、愈時請求做處理，只對網路請求報錯等等。\n2. 範例 取得假資料 JSON，API：\n1  const url = \u0026#39;https://randomuser.me/api/\u0026#39;;   傳統 XMLHttpRequest 需要好幾行的操作：\n1 2 3 4 5 6 7 8 9 10  const xhr = new XMLHttpRequest(); xhr.open(\u0026#39;GET\u0026#39;, url); xhr.send(null); xhr.addEventListener(\u0026#39;load\u0026#39;, function (event) { if (this.status === 200) { const data = JSON.parse(this.responseText); console.log(data); } });   而 Fetch 只需要短短幾行：\n1 2 3  fetch(url) .then((response) =\u0026gt; response.json()) .then((data) =\u0026gt; {console.log(data);});   使用 Async/Await 更直覺：\n1 2 3 4 5 6 7  async function ajax() { const response = await fetch(url); const data = await response.json(); console.log(data); } ajax();   Request 物件 使用 Fetch 最簡單的方式就是透過 fetch()，但再這之前，我們先來理解什麼是 Request 物件，\nRequest 物件代表資源請求，建構式接受一個或兩個參數：\n1  const myRequest = new Request(input, [init]);    input：url，獲取資源的網址； init：一個可選物件，包含希望被包括到請求中的各種自定義選項。  init 物件中選項如下：\n method：指定 HTTP 請求方法，例如 GET、POST、DELETE等等（預設為 GET）。 headers：任何你想加到請求中的 Headers 物件（預設 {} 空物件）。 body：需要發送的內容，如果 method 為 GET 或 HEAD 則不設定。 mode：請求的模式。  cors 允許跨域（預設） no-cors 只允許使用 HEAD、GET、POST 方法 same-origin 只允許同源請求，否則直接報錯 navigate 支持頁面導航   credentials：表示是否發送 cookie。  omit 不發送 cookie same-origin 僅在同源時發送 cookie（預設） include 發送cookie   cache：請求中想要使用處理緩存的策略，預設為default，其他可以參考 cache mode 。 redirect：對重定向處理的模式  manual 需要用戶手動跟隨（預設） follow 跟隨 error 發生錯誤   integrity：包含一個用於驗證資資源完整性的字串。  fetch 方法 fetch 方法有兩種呼叫方式：\n 接受 Request 物件作為參數； 符合建構 Request 物件的參數作為參數。  1 2 3 4 5 6 7  const url = \u0026#39;\u0026#39;; const req = new Request(url, { method: \u0026#39;GET\u0026#39;}); fetch(req); // or fetch(url, { method: \u0026#39;GET\u0026#39;});   fetch() 函式會回傳一個狀態為 fulfilled 的 Promise 物件，resolves 為一個 Response 物件。\n要注意的是，某些錯誤的 HTTP 狀態下如 404、500 等還是會回傳 fulfilled 狀態的 Promise。只有在有網絡錯誤會導致請求不能完成時，才會回傳 rejected 狀態的 Promise，因此需要做封裝處理才能判斷。\n1. POST 範例 GET 因為是預設的請求的模式，所以不一定要設定參數，那麼我來看一下 POST 請求的範例：\n1 2 3 4 5 6 7 8 9 10 11 12  const url = \u0026#39;\u0026#39;; const sendData = {}; fetch(url, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;content-type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify(sendData), }) .then((response) =\u0026gt; response.json()) .then((data) =\u0026gt; { console.log(data); });   Response 物件 Response 物件代表請求的回應。\n1. 屬性 fetch() 只有在有網絡錯誤會導致請求不能完成時，才會回傳 rejected 狀態的 Promise，因此如果要查看 HTTP 錯誤，可以在回傳的 Response 物件中使用以下屬性：\n status：狀態代碼（整數）。 ok：狀態結果（布林值），成功回傳 true（HTTP 狀態碼的範圍在 200-299），失敗回傳 false。  1 2 3 4  fetch(url).then((response) =\u0026gt; { console.log(response.ok); // true  console.log(response.status); // 200 });   Response 的其他屬性可以參考 MDN。\n目前階段還沒辦法取得回應資料，接下會說明。\n2. 方法 Response 物件中的 body 屬性提供了一個 ReadableStream 的實體，這個就是存放回應資料的地方。\n我們可以使用以下 Response 提供的方法來讀取 body 屬性：\n arrayBuffer() blob() json() text() formData()  以上方法回傳一個被解析為對應格式的 Promise 物件。\nbody 屬性只能讀取一次，讀取過後 bodyUsed 屬性會變成 true 表示已讀，若再次呼叫方法讀取 body 屬性就會報錯（TypeError: body stream is locked），若要重複讀取可以使用 clone() 建立一份 Response 的複製物件。\n1 2 3  fetch(url) .then((response) =\u0026gt; response.json()) .then((data) =\u0026gt; {console.log(data);});   ","description":"Fetch 是近年來被提及將要取代 XMLHttpRequest 的技術新標準，是一個 HTML5 的 API。\"","id":59,"section":"posts","tags":["JavaScript","非同步","Fetch","AJAX"],"title":"Fetch","uri":"https://chupai.github.io/posts/2008/js_fetch/"},{"content":" JavaScript筆記 目錄\n AJAX：\n AJAX JSON XMLHttpRequest Fetch  \rXMLHttpRequest 雖然現在很少人會直接使用原生 XMLHttpRequest 物件 來處理 AJAX，但還是需要理解運作原理。\n1. 請求 基本三步驟：\n 建立一個 XMLHttpRequest 物件； 設定請求； 傳送請求。  1 2 3 4 5 6 7 8  // 建立 XMLHttpRequest 物件 const xhr = new XMLHttpRequest(); // 設定請求 xhr.open(\u0026#39;GET\u0026#39;, url, true); // 傳送請求 xhr.send(null);   1.1 open 方法 XMLHttpRequest.open() 可以設定一個請求。\n1  xhr.open(method, url, [async, user, password]);   必要參數：\n method：指定 HTTP 請求方法，例如 GET、POST、DELETE等等。 url：為請求的伺服器網址。  可選參數：\n async：預設為 true 表示要用非同步的方式進行，如果設為 false 則會以同步的方式來發送請求。 user、password：預設為 null，為使用者名稱、密碼，視伺服器有無要求驗證而設置。  1.2 send 方法 XMLHttpRequest.send() 用來對伺服器傳送請求。\n1  xhr.send([body]);   可選參數 body 資料本體，若使用 GET 請求，不帶資料時，可省略不寫或是傳入 null。\n2. 伺服器回應 當瀏覽器從伺服器端接收資料回應後，便會觸發 load 事件，因此可以藉由事件監聽，先判斷回應狀態：\n1 2 3 4 5 6  xhr.addEventListener(\u0026#39;load\u0026#39;, function () { // 分析 HTTP 狀態  if (this.status === 200) { // 處理回應資料  } });   XMLHttpRequest.status 會回傳 XMLHttpRequest 物件目前的狀態碼，可用來確認回應是否成功。\nHTTP 狀態碼：\n 1xx: 資訊回應； 2xx: 成功回應； 3xx: 重定向； 4xx: 用戶端錯誤； 5xx: 伺服器端錯誤； 詳細 HTTP 狀態碼 請參考 MDN。  除了 load 事件外，還有很多事件：\n loadstart：請求開始； progress：請求進度； abort：請求終止； error：發生連接錯誤； load：請求成功完成； timeout：請求超時； loadend：請求結束。  除了監聽 load 事件外，也可以監聽 onreadystatechange 事件。在發一個請求後，如果想追蹤請求當前處於哪種狀態，可以使用 XMLHttpRequest.readyState，查看請求狀態：\n 0：UNSENT 狀態，客戶端已被建立，但 open() 方法尚未被呼叫。 1：OPENED 狀態，open() 方法已被呼叫，但還沒傳送資料。 2：HEADERS_RECEIVED 狀態，send() 方法已被呼叫，而且可取得 header 與狀態。 3：LOADING 狀態，回應資料下載中，此時 responseText 會擁有部分資料。 4：DONE 狀態，完成下載操作。  readyState = 4 就類似 loadend 事件：\n1 2 3 4 5 6  xhr.addEventListener(\u0026#39;onreadystatechange\u0026#39;, function () { // 分析 xhr 狀態  if (this.readyState === 4 \u0026amp;\u0026amp; this.status === 200) { // 處理伺服器端回傳資料的程式碼  } });   3. 處理回應資料 確認伺服器成功回應，接下來就是處理資料。\n共有三種方式，可以獲取請求後的回應資料：\n XMLHttpRequest.response XMLHttpRequest.responseText XMLHttpRequest.responseXML  responseText 回傳 DOMString，responseXML 回傳 HTML 或 XML 的 Document。而 response 回傳的資料類型取決於 XMLHttpRequest.responseType。\n範例，GET 一個 JSON 資料並轉成物件：\n1 2 3 4 5 6 7 8 9 10  const xhr = new XMLHttpRequest(); const url = \u0026#39;\u0026#39;; // API網址 xhr.open(\u0026#39;GET\u0026#39;, url); xhr.send(null); xhr.addEventListener(\u0026#39;load\u0026#39;, function (event) { if (this.status === 200) { const data = JSON.parse(this.responseText); } });   HTTP Header 使用 POST 請求時，send() 傳送資料給伺服器前，還需要使用 XMLHttpRequest.setRequestHeader() 設定內容類型，告知伺服器我們傳遞的資料格式。\n舉例來說，如果我們要傳遞的是 JSON 格式的資料：\n1 2 3 4 5 6 7  const xhr = new XMLHttpRequest(); const url = \u0026#39;\u0026#39;; // API網址 xhr.open(\u0026#39;POST\u0026#39;, url); let sendData = {}; // 要傳遞的資料 xhr.setRequestHeader(\u0026#39;content-type\u0026#39;, \u0026#39;application/json\u0026#39;); xhr.send(JSON.stringify(sendData));   語法：\n1  xhr.setRequestHeader(header, value);    header：表頭名稱。 value：編碼類型。  模擬 HTTP 回應工具 Mocky\nFormData 物件 若使用 FormData 物件從表單獲取資料，可以直接使用 send() 傳送，setRequestHeader() 會自動設置。\n","description":"AJAX 技術在瀏覽器上，會利用 XMLHttpRequest 物件與伺服器進行非同步傳遞。\"","id":60,"section":"posts","tags":["JavaScript","非同步","XMLHttpRequest","AJAX"],"title":"XMLHttpRequest","uri":"https://chupai.github.io/posts/2008/js_xhr/"},{"content":" JavaScript筆記 目錄\n AJAX：\n AJAX JSON XMLHttpRequest Fetch  \r什麼是 JSON JSON 全稱為 Javascript Object Notation，意思就是 JavaScript 物件表示法，是資料交換的格式的一種，副檔名為 .json。\n目前是 AJAX 資料交換最為流行的資料格式。\n1. JSON 與程式設計語言無關 儘管 JSON 是 JavaScript 的一個子集，但 JSON 資料格式與語言無關是獨立於語言的文字格式，目前很多程式語言都支援 JSON 格式資料的生成和解析。\n2. 優點  相容性高； 格式容易瞭解，閱讀及修改方便； 支援許多資料格式； 許多程式都支援函式庫讀取或修改 JSON 資料。  3. 應用 原本 AJAX（Asynchronous JavaScript and XML）技術在 JavaScript 中，主要使用的資料格式是 XML 格式，但 XML 格式很繁瑣，讓使用者撰寫不方便，而且不容易嵌入網頁中進行處理。\n為了讓網頁上的共通程式語言 JavaScript 可以輕易的交換資料，目前 AJAX 交換資料都改用 JSON 格式資料。\n語法 1. JSON 與 JavaScript 物件的差異 JSON 物件基本上就是 JavaScript 物件」，而這敘述在大多數情況下都對。\n但有幾點必須注意：\n 複合類型的值只能為陣列或物件，不能是函式、正規表達式、日期物件等。  物件屬性名稱必須加上雙引號 陣列或物件最後一行不可以有逗號 ,   基本型別值只能有四種：字串、數字、布林值、null，不包含 undefined。  字串必須用 \u0026quot;\u0026quot; 雙引號表示 NaN、Infinity、-Infinity 會被轉成 null   除了物件，陣列也可以是有效的 JSON 物件。  舉例來說，下面是 JavaScript 的物件實字：\n1 2 3 4 5  var obj = { name: \u0026#39;Chupai\u0026#39;, age: 26, childs: [{ name: \u0026#39;Wang\u0026#39;, age: 3 }], };   若使用 JSON 表示，則是如下：\n1 2 3 4 5  { \u0026#34;name\u0026#34;:\u0026#34;Chupai\u0026#34;, \u0026#34;age\u0026#34;:26, \u0026#34;childs\u0026#34;:[{\u0026#34;name\u0026#34;:\u0026#34;Wang\u0026#34;,\u0026#34;age\u0026#34;:3}] }   陣列作為 JSON 格式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  [ { \u0026#34;name\u0026#34;:\u0026#34;Chupai\u0026#34;, \u0026#34;age\u0026#34;:26, \u0026#34;childs\u0026#34;:[ { \u0026#34;name\u0026#34;:\u0026#34;Wang\u0026#34;, \u0026#34;age\u0026#34;:3 } ] }, { \u0026#34;name\u0026#34;:\u0026#34;Mike\u0026#34;, \u0026#34;age\u0026#34;:11, \u0026#34;childs\u0026#34;: null } ]   2. JSON 檢驗、格式化工具  JSON Formatter JSONLint  處理 JSON 資料  JSON.parse() JSON.stringify()  1. 建立 JSON 字串 JSON.stringify() 可以將一個 JavaScript 的值，轉換為一個 JSON 字串。\n語法：\n1  JSON.stringify(value[, replacer [, space]])    value：JavaScript 的值 replacer：  若指定陣列，只會針對該陣列轉換 JSON 字串 若指定函式，這個函式可接受物件的屬性名與值，可以自行決定如何轉換為 JSON 字串   space：美化用，如果是 1 到 10 的數字，會自動換行並以指定數字作為縮排層次，如果指定字元，就會以指定的字元來進行縮排。 回傳值：JSON 字串  字串、數字、布林值、null 會自動轉換成對應的原始值：\n1 2 3 4  console.log(JSON.stringify(\u0026#39;foo\u0026#39;)); // \u0026#34;foo\u0026#34; console.log(JSON.stringify(123)); // \u0026#34;123\u0026#34; console.log(JSON.stringify(true)); // \u0026#34;true\u0026#34; console.log(JSON.stringify(null)); // \u0026#34;null\u0026#34;   undefined、任意的函數以及 symbol 值，會被忽略：\n1 2 3  console.log(JSON.stringify(undefined)); // undefined console.log(JSON.stringify(function () {})); // undefined console.log(JSON.stringify(Symbol(\u0026#39;\u0026#39;))); // undefined   上面的值，如果出現在陣列中會被轉成 null，如果是物件的屬性值該屬性會直接被忽略：\n1 2 3 4 5 6 7 8 9  var arry = [function () {}, undefined, Symbol(\u0026#39;\u0026#39;)]; var obj = { fn: function () {}, un: undefined, sym: Symbol(\u0026#39;\u0026#39;), }; console.log(JSON.stringify(arry)); // \u0026#34;[null,null,null]\u0026#34; console.log(JSON.stringify(obj)); // \u0026#34;{}\u0026#34;   接下來，我們來看 JSON.stringify() 的第二個參數。\n如果是陣列，將會只保留陣列中的屬性：\n1 2 3 4 5 6 7 8  var obj = { a: 1, b: 2, c: 3, d: 4, }; console.log(JSON.stringify(obj, [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;])); // {\u0026#34;a\u0026#34;:1,\u0026#34;b\u0026#34;:2}   作為函式，會有兩個參數，分別是屬性名與屬性值，可以用來控制每個屬性，要回傳的值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  var obj = { a: 1, b: 2, c: 3, d: 4, }; console.log( JSON.stringify(obj, (key, value) =\u0026gt; { if (key === \u0026#39;b\u0026#39;) { return value + 2; } return value; }) ); // {\u0026#34;a\u0026#34;:1,\u0026#34;b\u0026#34;:4,\u0026#34;c\u0026#34;:3,\u0026#34;d\u0026#34;:4}   最後是第三個參數，可用來縮排，如果是 1 到 10 的數字，會自動換行並以指定數字作為縮排層次，如果指定字元，就會以指定的字元來進行縮排：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var obj = { a: 1, b: 2, c: 3, d: 4, }; console.log(JSON.stringify(obj, null, 6)); // { // \u0026#34;a\u0026#34;: 1, // \u0026#34;b\u0026#34;: 2, // \u0026#34;c\u0026#34;: 3, // \u0026#34;d\u0026#34;: 4 // }   2. 解析 JSON 字串 JSON.parse() 可以將一個 JSON 字串轉換成 JavaScript 的值。\n語法：\n1  JSON.parse(text[, reviver])    text：JSON 字串 reviver：函式 回傳值：物件  範例：\n1 2 3 4 5 6 7 8  console.log(JSON.parse(\u0026#39;{}\u0026#39;)); // {} console.log(JSON.parse(\u0026#39;true\u0026#39;)); // true console.log(JSON.parse(\u0026#39;\u0026#34;foo\u0026#34;\u0026#39;)); // \u0026#34;foo\u0026#34; console.log(JSON.parse(\u0026#39;[1, 5, \u0026#34;false\u0026#34;]\u0026#39;)); // [1, 5, \u0026#34;false\u0026#34;] console.log(JSON.parse(\u0026#39;null\u0026#39;)); // null  var json = \u0026#39;{\u0026#34;a\u0026#34;:1,\u0026#34;b\u0026#34;:2,\u0026#34;c\u0026#34;:3,\u0026#34;d\u0026#34;:4}\u0026#39;; console.log(JSON.parse(json)); // {a: 1, b: 2, c: 3, d: 4}   如果解析的字串不是合法的 JSON 格式，會拋出 SyntaxError：\n1 2 3  var json = \u0026#39;{\u0026#34;a\u0026#34;:1,\u0026#34;b\u0026#34;:2,}\u0026#39;; console.log(JSON.parse(json)); // SyntaxError   最後一行多了一個逗號。\n第二個參數為函式，會有兩個參數，分別是屬性名與屬性值，可以用來控制每個屬性，要回傳的值：\n1 2 3 4 5 6 7 8 9 10 11 12  var json = \u0026#39;{\u0026#34;a\u0026#34;:1,\u0026#34;b\u0026#34;:2,\u0026#34;c\u0026#34;:3,\u0026#34;d\u0026#34;:4}\u0026#39;; console.log( JSON.parse(json, (key, value) =\u0026gt; { if (key === \u0026#39;a\u0026#39;) { return value * 10; } return value; }) ); // {a: 10, b: 2, c: 3, d: 4}   如果該函式回傳 undefined，則該屬性將不會加到物件中：\n1 2 3 4 5 6 7 8 9 10 11 12  var json = \u0026#39;{\u0026#34;a\u0026#34;:1,\u0026#34;b\u0026#34;:2,\u0026#34;c\u0026#34;:3,\u0026#34;d\u0026#34;:4}\u0026#39;; console.log( JSON.parse(json, (key, value) =\u0026gt; { if (value \u0026gt; 3) { return undefined; } return value; }) ); // {a: 1, b: 2, c: 3}   ","description":"AJAX 資料交換最為流行的資料格式。\"","id":61,"section":"posts","tags":["JavaScript","JSON","AJAX"],"title":"JSON 格式","uri":"https://chupai.github.io/posts/2008/js_json/"},{"content":" JavaScript筆記 目錄\n AJAX：\n AJAX JSON XMLHttpRequest Fetch  \r什麼是 AJAX？ AJAX 是 Asynchronous JavaScript and XML 的縮寫，中文名稱為「非同步 JavaScript 及 XML」，這個名詞出自 《Ajax: A New Approach to Web Applications》。\n原意指的是透過 JavaScript 的非同步通訊，從服務器獲取 XML 從中提取資料，再更新當前網頁的對應部分，而不用刷新整個網頁。\n但後來，AJAX 這詞成為了 JavaScript 向伺服器發送 HTTP 請求的代名詞。不是指一種單一的技術，而是一種多技術的組合，其內容包含的技術有 HTML 或 XHTML、層疊樣式表、JavaScript、文件物件模型、XML、XSLT 以及最重要的 XMLHttpRequest 物件等等。當這些技術被結合在 AJAX 模型中，Web 應用程式便能快速、即時更動介面及內容，不需要重新讀取整個網頁，讓程式更快回應使用者的操作。\n雖然 X 在 AJAX 中代表 XML，但後來 JSON 格式是最為流行的資料格式。\n傳統網頁載入 傳統網頁載入資料與 AJAX 比較：\n 傳統的⽅式\n是以同步方式傳送請求、等待伺服器回應，在這段期間使用者只能發呆，當資料回應後，會重新載入整個網頁。 AJAX\n可與伺服器進行非同步更新，不需要等待伺服器回應依然可以進行其他操作，也不需要重新載入整個網頁，只更新要更新的部分。  使用 AJAX 的好處  提高可操作性  避免每次傳遞資料造成畫面更新閃動； 伺服器端處理時，使用者仍可操作。   提升效能  只需要更新部分頁面，傳遞資料量可以控制在最小； 不需要等待伺服器處理結束，提升了操作的流暢度。   提升開發產能與應用  只需要用瀏覽器標準技術，就可以架構使用者介面； 不需要特別的外掛。    AJAX 與 XMLHttpRequest AJAX 技術在瀏覽器上，會利用 JavaScript（XMLHttpRequest 物件）與伺服器進行非同步傳遞，並將結果由 DOM 反映至頁面上。\n流程：\n 建立一個 XMLHttpRequest 物件； 定義伺服器傳遞資料的處理流程； 開始非同步處理。  但經過長久的時間，它在使用上產生不少問題，例如：\n XMLHttpRequest 實體肩負著太多任務，例如，請求設置、傳送、回應狀態判斷、事件監聽等等； 每次請求都要新建 XMLHttpRequest 實體，但請求同常通常只會做一次； 由於使用事件監聽獲取回應資料，因此會產生回呼地域的問題。  所以現在很少人會直接使用原生 XMLHttpRequest 物件來處理 AJAX，通常都會用以下方法來實作：\n 使用 jQuery 的 ajax 語法（原生 XHR 的封裝） AXIOS（原生 XHR 的封裝，使用 Promise） Fetch API（HTML5 的 API，使用 Promise）  除了 Fetch API，其他都屬於函式庫，需額外載入。\n什麼是 CORS？ 跨來源資源共用 （Cross-Origin Resource Sharing，CORS）是一種使用額外 HTTP 標頭令目前瀏覽網站的使用者代理取得存取其他來源（網域）伺服器特定資源權限的機制。當使用者代理請求一個不是目前文件來源，例如來自於不同網域（domain）、通訊協定（protocol）或通訊埠（port）的資源時，會建立一個跨來源 HTTP 請求（cross-origin HTTP request）。\n基於安全性考量，程式碼所發出的跨來源 HTTP 請求會受到限制。例如，XMLHttpRequest 及 Fetch 都遵守同源政策（same-origin policy）。這代表網路應用程式所使用的 API 除非使用 CORS 標頭，否則只能請求與應用程式相同網域的 HTTP 資源。\n如果要測試 API 是否開源 可以用 test-cors.org 這個網站。\n更多 CORS 詳細內容，可以參考 CORS 跨來源資源共用｜MDN。\n","description":"AJAX 向伺服器發送 HTTP 請求的代名詞。","id":62,"section":"posts","tags":["JavaScript","非同步","AJAX"],"title":"AJAX","uri":"https://chupai.github.io/posts/2008/js_ajax/"},{"content":" JavaScript筆記 目錄\n 非同步是 JavaScript 最重要的觀念之一。\n 非同步 回呼函式 Promise Async/Await  \r什麼是 Async/Await ES8 新增 的 Async/Await 為 Promise 的語法糖，底層運作還是 Promise。\n1. Async functions 在一個函式前面加上async 關鍵字放：\n1  async function fn() {}   這個函式只會回傳一個 Promise 物件，如果 return 值非 Promise ，會將 return 值作為 resolve() 的參數值。\n1 2 3 4 5 6 7  async function fn() { return 1; } fn().then(console.log); // 1   也就是說 async 確保了函式的回傳值是一個 Promise 物件，也會包裝非 Promise 的值。\n2. Await await 只能用在 Async functions 中。\nawait 可以讓非同步程式在 Async functions 中用起來像是使寫同步程式一樣，依序執行。\n這是一個隨機延遲時間的函式：\n1 2 3 4 5 6 7  function delay(value) { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(value); }, Math.random() * 2000); }); }   如果依序呼叫三個函式，會根據延遲時間回傳，所以順序會不一定：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function delay(value) { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(value); }, Math.random() * 2000); }); } function test() { delay(1).then(console.log); delay(2).then(console.log); delay(3).then(console.log); } test();   使用 Async/Await 就不需要使用 then 方法了，能直接獲得結果值：\n1 2 3 4 5 6 7 8 9 10  async function test() { console.log(await delay(1)); console.log(await delay(2)); console.log(await delay(3)); } test(); // 1 // 2 // 3   每個函式都會依序執行，會等到處理完畢，再執行下一行，就像寫同步的程式一樣。\n錯誤處理 如果要錯誤處理，要使用 try...catch 述句：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  async function fun() { const p = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { const ran = Math.floor(Math.random() * 2); // 模擬可能失敗 0 or 1  if (ran) { resolve(\u0026#39;done!\u0026#39;); } else { reject(new Error(\u0026#39;error!\u0026#39;)); } }, 1000); }); try { const r = await p; console.log(r); } catch (err) { console.log(err); } } fun();   ","description":"Async/Await 為 Promise 的語法糖。","id":63,"section":"posts","tags":["JavaScript","非同步","Promise","Async/Await"],"title":"Async/Await","uri":"https://chupai.github.io/posts/2008/js_async_await/"},{"content":" JavaScript筆記 目錄\n 非同步是 JavaScript 最重要的觀念之一。\n 非同步 回呼函式 Promise Async/Await  \r什麼是 Promise？ Promise 在其他不同語言有很多不同的名稱，例如 Delay、Future。其實 Promise API 已經存在多年，但是直到 ES6 才被標準化和引入。\nPromise 字面意思為「承諾」或「約定」，白話一點的解釋就是「我承諾幫你做某件事，但會不會做到不一定，但最後一定會跟你說有做到或沒做到」。\n當你拿到一個 Promise 的時候，代表在未來中這個 Promise 可能會有三種狀態：\n 未定（pending） 達成（fulfilled） 拒絕（rejected）  狀態只會由 pending 變成 fulfilled 或 rejected。\n接下來可以根據上面這兩種結果，決定下一步要做啥：\n 履行承諾，繼續做預定好的下一件事 毀約後，根據原因去做對應的處理  創建 Promise 物件 要建立一個 Promise 物件實體需要使用 Promise() 建構式：\n1 2 3  new Promise(function(resolve, reject) { // ... });   建構式中接受一個函式作為參數，該函式稱為 executor（執行函式），當 Promise 實體被創建，就會立刻執行 executor 函式。\n這函式又接收兩個參數，分別為 resolve 與 reject，這兩個參數也是函式，皆接收一個參數。\n如果在 executor 函式中：\n 呼叫 resolve(value)  Promise 會從 pending 狀態進入 fulfilled 狀態 如有值傳入，它將成為完成結果   呼叫 reject(reason)  Promise 會從 pending 狀態進入 rejected 狀態 如有值傳入，它將被設為拒絕理由，值通常會是 Error 物件實體，表示拋出訊息   如果都沒呼叫，那 Promise 會一直保持 pending 狀態。  一但進入 fulfilled 或 rejected 狀態，Promise 就不會再接受任何狀態改變，所以重複呼叫 resolve 或 reject 是沒有意義的行為。\nresolve 通常會用在非同步程式中，可以將非同步程式處理的結果傳出去：\n1 2 3  const p = new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; resolve(\u0026#39;done!\u0026#39;), 1000); });   經過一秒，呼叫 resolve 將字串 done! 當作完成結果，也就是 Promise 狀態經過一秒才由 pending 狀態進入 fulfilled 狀態。\n假如非同步程式執行失敗時，就可以利用 reject 獲取錯誤訊息，讓我們模擬一下：\n1 2 3 4 5 6 7 8 9 10  const p = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { const ran = Math.floor(Math.random() * 2); // 模擬可能失敗 0 或 1  if (ran) { resolve(\u0026#39;done!\u0026#39;); } else { reject(new Error(\u0026#39;error!\u0026#39;)); } }, 1000); });   另外，呼叫 resolve 或 reject 並不會終止 executor 函式的執行，後續的程式碼還使會執行：\n1 2 3 4  const p = new Promise((resolve) =\u0026gt; { resolve(\u0026#39;done!\u0026#39;); console.log(123); });   但一般來說，呼叫 resolve 或 reject 以後，Promise 的使命就完成了，後繼操作應該放到 then 方法中，而不應該直接寫在呼叫完 resolve 或 reject 的後方。\n接下來 1. then 方法 接下來，我們來看如何從 Promise 中取出結果值。\nthen 方法是 Promise 中最重要的方法，標準有八成在定義它。\nthen 字面意思為「然後」或「接下來」，也就是 Promise 實體被創建後，可以使用 then 方法分別指定 fulfilled 和 rejected 狀態的回呼函式，來處理回傳值：\n1  p.then(fulfilledCallback[, rejectedCallback]);    fulfilledCallback：當 Promise 為 fulfilled 狀態時被呼叫，接收的參數為 resolve() 回傳的結果。 rejectedCallback（可選）：當 Promise 為 rejected 狀態時被呼叫，接收的參數為 reject() 回傳的失敗訊息。  如果 fulfilledCallback 或 fulfilled 不是函式時，忽略跳過。\nthen 方法雖然是立即執行的，但它裡面的回呼函式會進入到事件佇列中，等待 Promise 改變狀態。如果 Promise 一直是 pending 狀態，也就是一直沒有回應，then 方法中的回呼函式就會一直等待。\n一個簡單的範例，建立一個 delay 函式，回傳 Promise 物件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function delay(time) { return new Promise((resolve) =\u0026gt; { const t = time * 1000; setTimeout(() =\u0026gt; { resolve(`延遲了 ${time}秒`); }, t); }); } delay(2).then((result) =\u0026gt; { console.log(result); }); // (經過2秒 // \u0026#34;延遲了 2 秒\u0026#34;   經過了 2 秒，Promise 由 pending 狀態進入 fulfilled 狀態，就會觸發 then 方法綁定的回呼函式，印出結果。\n如果 Promise 為 rejected 狀態，沒有處理會有 Uncaught 提示，因此如果有呼叫 reject 要加上 rejected 狀態的回呼函式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const p = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { const ran = Math.floor(Math.random() * 2); // 模擬可能失敗  if (ran) { resolve(\u0026#39;done!\u0026#39;); } else { reject(\u0026#39;錯誤\u0026#39;); } }, 1000); }); p.then( (result) =\u0026gt; { console.log(result); }, (error) =\u0026gt; { console.log(error); } );   2. 呼叫順序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const p = new Promise((resolve) =\u0026gt; { console.log(1); resolve(4); console.log(2); }); p.then((v) =\u0026gt; { console.log(3); console.log(v); console.log(5); }); console.log(6); // 1 // 2 // 6 // 3 // 4 // 5    當 Promise 實體被創建，就會立刻執行 executor 函式，所以先印出 1； 就算 resolve 已呼叫，executor 函式並不會終止，所以印出 2； then 方法中的回呼函式一開始就會進入到事件佇列中，當 Promise 狀態改變，並等到同步程式執行完畢，才會開始執行，因此會跳過，所以會先印出 6； Promise 狀態改變了，同步程式執行也完了，因此執行 then 方法中的回呼函式，所以印出 3 4 5。  3. 串連 then 方法，會回傳一個新的 Promise 實體。因此可以用 then() 串連多個 Promise，形成一個 Promise 鏈。\nthen 方法回傳的新 Promise 會有以下幾種情況：\n 回呼函式中，return 非 Promise 的值； 回呼函式中，return Promise； 回呼函式中，因為 throw 述句拋出錯誤； 沒有對應狀態的回呼函式。  我們使用這個函式建立 Promise 來說明：\n1 2 3 4 5 6 7 8 9  function p(n, b) { return new Promise((resolve, reject) =\u0026gt; { if (b) { resolve(n); } else { reject(\u0026#39;erro\u0026#39;); } }); }   參數 n 為結果值、b 用來控制狀態。\n情況一：如果回呼函式中 return 一個非 Promise 的值，則會回傳一個 fulfilled 狀態的新 Promise，並且將 return 值作為 resolve 的參數值。\n1 2 3 4 5 6 7 8 9 10 11 12  // 情況一 p(1, true) .then((result) =\u0026gt; { console.log(result); return 2; }) .then((result) =\u0026gt; { console.log(result); }); // 1 // 2   情況二：如果回呼函式 return 一個 Promise，會回傳與該 Promise 相同狀態、帶相同值的新 Promise。\n1 2 3 4 5 6 7 8 9 10 11  p(1, true) .then((result) =\u0026gt; { console.log(result); return p(2, true); }) .then((result) =\u0026gt; { console.log(result); }); // 1 // 2   情況三：then 方法中回呼函式因為 throw 述句拋出一個錯誤，則會回傳一個 rejected 狀態的 Promise，並且將錯誤訊息作為 reject 的參數值。\n1 2 3 4 5 6 7 8 9  p(1, true) .then((result) =\u0026gt; { throw new Error(\u0026#39;Something failed\u0026#39;); }) .then(null, (error) =\u0026gt; { console.log(error); }); // \u0026#34;Error: Something failed\u0026#34;   情況四：如果 then 方法沒有可以處 Promise 狀態的回呼函式，會回傳與原本相同狀態、帶相同值的新 Promise。\n1 2 3 4 5 6 7 8 9  p(1, false) .then((v) =\u0026gt; { console.log(v); }) .then(null, (error) =\u0026gt; { console.log(error); }); // \u0026#34;erro\u0026#34;   4. catch 方法 catch 方法，其實就是 then(null, rejectedCallback) 或 then(undefined, rejectedCallback) 的簡寫。\n原本是使用 then 方法的兩個回呼函式，分別處理兩個狀態：\n1 2 3 4 5 6 7 8  p.then( (result) =\u0026gt; { console.log(result); }, (error) =\u0026gt; { console.log(error); } );   但建議改用以下方式：\n1 2 3 4 5  p.then((result) =\u0026gt; { console.log(result); }).catch((error) =\u0026gt; { console.log(error); });   這樣不但將兩種狀態處理分開寫，增加可讀性。如果 then() 的回呼函式因為 throw 述句拋出錯誤，catch() 也能捕捉錯誤訊息。\n5. throw 與 reject 在 Promise 建構函式的 executor 函式中，直接使用 throw 述句相當於呼叫 reject 的作用。\n1 2 3 4 5 6 7 8 9 10  const p = new Promise((resolve, reject) =\u0026gt; { throw new Error(\u0026#39;error!\u0026#39;); // 等同  // reject(new Error(\u0026#39;error!\u0026#39;)) }); p.catch((e) =\u0026gt; { console.log(e.message); }); // \u0026#34;error!\u0026#34;   6. finally 方法 在 ES7 新增了 finally 方法，不論 Promise 狀態是 fulfilled 或 rejected 都會執行。\nfinally 方法中的回呼函式不接受任何參數，也就是不會得到任何的回傳值，通常用於最後，用來處理與狀態無關的操作，例如重置、清除、終止。\n原本需要使用 then 方法，將兩個回呼函式設置相同來處理，使用 finally 方法就只需要寫一次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  p.finally(() =\u0026gt; { console.log(\u0026#39;End!\u0026#39;); }); // 等同 p.then( () =\u0026gt; { console.log(\u0026#39;End!\u0026#39;); }, (reason) =\u0026gt; { console.log(\u0026#39;End!\u0026#39;); throw reason; } );   Promise 的靜態方法 1. all 方法 Promise.all 方法用於將多個 Promise，包裝成一個新的 Promise。\n假設有一個延遲計算的函式：\n1 2 3 4 5 6 7 8  function delayAdd(x, y) { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { const r = x + y; resolve(r); }, Math.random() * 2000); }); }   要如何將這三個的結果值相加呢？\n1 2 3  const p1 = delayAdd(1, 2); const p2 = delayAdd(3, 4); const p3 = delayAdd(5, 6);   使用 Promise.all 方法：\n1 2 3 4 5  Promise.all([p1, p2, p3]).then((result) =\u0026gt; { const sum = result.reduce((total, value) =\u0026gt; total + value); console.log(sum); }); // 21   語法說明：\n1  Promise.all(iterable);   iterable：通常會是一個陣列，陣列中的值只會是一般的值或是 Promise 物件。\nPromise.all 方法會將陣列中的值並行運算執行，全部完成後後會回傳一個 finally 狀態的 Promise。\n有幾點要注意：\n 陣列中的索引值與執行順序無關； 陣列中的值如果不是 Promise 物件會自動使用Promise.resolve 方法來轉換； 陣列中只要其中一個 Promise 狀態為 rejected，就會回傳 rejected 狀態的 Promise。  Promise.all 方法最後獲得的 Promise 的結果值會是一個陣列，陣列中的內容為所有 Promise 的結果。\n1 2 3 4 5 6 7 8  const p1 = delayAdd(1, 2); const p2 = delayAdd(3, 4); const p3 = delayAdd(5, 6); Promise.all([p1, p2, p3]).then((result) =\u0026gt; { console.log(result); }); // [3, 7, 11]   2. race 方法 Promise.race 方法的規則與 Promise.all 方法相同，差異在於 Promise.race 回傳的 Promise 的結果只有最快變成 finally 狀態的那個。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function delay(name, time) { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(name); }, time); }); } const p1 = delay(\u0026#39;A\u0026#39;, 2000); const p2 = delay(\u0026#39;B\u0026#39;, 100); const p3 = delay(\u0026#39;C\u0026#39;, 500); Promise.race([p1, p2, p3]).then((result) =\u0026gt; { console.log(result); }); // \u0026#34;B\u0026#34;   如果同時變為 finally 狀態，就會以陣列順序優先者作為回傳值。\n3. resolve 方法 Promise.resolve() 能建立一個 finally 狀態的 Promise 物件，其參數為結果值。\n1  const p = Promise.resolve(1);   等同：\n1 2 3  const p = new Promise((resolve) =\u0026gt; { resolve(1); });   4. reject 方法 Promise.reject() 能建立一個 rejected 狀態的 Promise 物件，其參數為錯誤訊息。\n1  const p = Promise.reject(new Error(\u0026#39;error!\u0026#39;));   等同：\n1 2 3  const p = new Promise((resolve, reject) =\u0026gt; { reject(new Error(\u0026#39;error!\u0026#39;)); });   ","description":"Promise 代表著「承諾」在未來提供任務執行結果。","id":64,"section":"posts","tags":["JavaScript","非同步","Promise"],"title":"Promise","uri":"https://chupai.github.io/posts/2008/js_promise/"},{"content":" JavaScript筆記 目錄\n 非同步是 JavaScript 最重要的觀念之一。\n 非同步 回呼函式 Promise Async/Await  \r什麼是回呼函式 回呼函式（callback function）是指能藉由參數（argument）通往另一個函式的函式。\n簡單來說，就是這個函式做為另一個函式的引數傳入，就稱為「回呼函式」，例如常見的陣列處理方法都有回呼函式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function foo(name) { console.log(name); } function boo(name, callback) { callback(name); } boo(\u0026#39;Peter\u0026#39;, foo); // \u0026#34;Peter\u0026#34;  // 陣列批次處理方法 const arr = [1, 2, 3]; const newArr = arr.map((item) =\u0026gt; item * 2); console.log(newArr); // [2, 4, 6]   這些屬於同步回呼，因為它是立即執行的。\n非同步 而回呼常用來延續非同步行動完成後的程式執行，例如計時器等等。\n1 2 3 4  // 計時器 setTimeout(() =\u0026gt; { console.log(\u0026#39;1\u0026#39;); }, 3000);   1. 回呼中回呼 舉例來說，如果要設定計時器，在它執行完後，在一次呼叫一個計時器。\n錯誤寫法：\n1 2 3 4 5 6 7 8 9 10 11  setTimeout(() =\u0026gt; { console.log(\u0026#39;1\u0026#39;); }, 2000); setTimeout(() =\u0026gt; { console.log(\u0026#39;2\u0026#39;); }, 2000); // 兩秒後 同時印出 // 1 // 2   必須將第二個計時器寫在第一個回呼函式中：\n1 2 3 4 5 6  setTimeout(() =\u0026gt; { console.log(\u0026#39;1\u0026#39;); setTimeout(() =\u0026gt; { console.log(\u0026#39;2\u0026#39;); }, 2000); }, 2000);   2. 回呼地域 非同步程式的回呼對於一個或兩個的簡單巢狀，這樣的呼叫看起來還好。\n但對於一個接一個非同步動作來說，程式碼會變得非常難以維護。舉例來說，這是一個延遲呼叫的函式：\n1 2 3 4 5 6 7 8 9  function delay(n, callback) { setTimeout(() =\u0026gt; { callback(n); }, 2000); } delay(1, (n) =\u0026gt; { console.log(n); });   上面有說過，如果要重複呼叫，就必須要等到上次的呼叫成功時，才能進行下次呼叫：\n1 2 3 4 5 6  delay(1, (n) =\u0026gt; { console.log(n); delay(2, (n) =\u0026gt; { console.log(n); }); });   如果呼叫次非常多，程式碼就會變成這樣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  delay(1, (n) =\u0026gt; { console.log(n); delay(2, (n) =\u0026gt; { console.log(n); delay(3, (n) =\u0026gt; { console.log(n); delay(4, (n) =\u0026gt; { console.log(n); delay(5, (n) =\u0026gt; { console.log(n); delay(6, (n) =\u0026gt; { console.log(n); }); }); }); }); }); });   由上述可知，沒有進一步的非同步需求，回呼函式是直覺而簡單的，但如果需要執行多次非同步程式，就會不利於程式碼的閱讀和維護。\n從 ES6 開始，JavaScript 引入了一些新功能，可以幫助我們不用回呼就能處理非同步程式：\n Promise 物件（ES6） Async/Await 語法（Promise 語法糖 ES8） ","description":"回呼函式（callback function）是指能藉由參數（argument）通往另一個函式的函式。","id":65,"section":"posts","tags":["JavaScript","非同步","回呼函式"],"title":"回呼函式","uri":"https://chupai.github.io/posts/2008/js_callback/"},{"content":" JavaScript筆記 目錄\n 非同步是 JavaScript 最重要的觀念之一。\n 非同步 回呼函式 Promise Async/Await  \r什麼是非同步  Synchronous 同步 Asynchronous 非同步（異步）  同步就是程式碼由上到下依序執行；而非同步則是，不用等待該程式碼執行完畢，就可以往下繼續執行。\n常見的非同步程式：\n 瀏覽器所提供的計時器 setTimeout()、setInterval() DOM 的事件監聽 addEventListener() 網路請求資料 Ajax 呼叫  JavaScript 的非同步處理 首先，JavaScript 是 單線程（single threaded） 的程式語言，也就是一個單執行緒、同步的程式，它逐行執行程式碼，並不會非同步的執行程式。\n那它是如何做到非同步執行呢？\n簡單來說，JS 引擎在運行時，除了一個正在處理事情的主線程外，還有一個用來存放非同步需求的 事件佇列（Event Queue）。當偵測到非同步的需求，就會將它丟進去，等到主線程所有事情處理完畢，就會去 事件佇列 找事做。\nJS 引擎是透過不斷的檢查事件佇列，來確認非同步的程式符合進入主線程的條件，這種檢查機制叫做 事件迴圈（Event Loop）。\n換句話說，當某件事情卡住了，後續的事情都將無法繼續執行。\n非同步的流程控制 如果有多個非同步操作，就存在一個流程控制的問題。\n要如何解決非同步操作的執行順序，有以下幾種方式：\n 回呼函式 Callback（最早期） Promise 物件（ES6） Async/Await 語法（Promise 語法糖 ES8）  首先我們來看一個範例問題：\n1 2 3 4 5 6 7  function square(n) { return n * n; } const result = square(2); console.log(result); // 4    這是個很普通的同步程式，square() 回傳平方結果，然後用 console.log() 印出。\n接下來我們使用 setTimeout() 來模擬，需要經過冗長計算過程或從伺服器取得，而無法立即做運算。\n會遇到的問題：\n1 2 3 4 5 6 7 8 9 10  function delaySquare(n) { let result; setTimeout(() =\u0026gt; { result = n * n; }, 2000); return result; } const result = delaySquare(2); console.log(result); // undefined   很明顯的，我們無法直接回傳非同步程式的運算結果。\n那麼我們要如何解決？\n1. 回呼函式 傳統作法就是新增一個 回呼函式 callback 參數，將結果當作引數傳入：\n1 2 3 4 5 6 7 8 9  function delaySquare(n, callback) { setTimeout(() =\u0026gt; { callback(n * n); }, 2000); } delaySquare(2, (result) =\u0026gt; { console.log(result); });   但是，如果今天我要重複呼叫，就必須要等到上次的呼叫成功時，才能進行下次呼叫，就會產生 Callback Hell（回呼地獄）：\n1 2 3 4 5 6 7 8 9 10 11 12  delaySquare(2, (result) =\u0026gt; { console.log(result); delaySquare(3, (result) =\u0026gt; { console.log(result); delaySquare(4, (result) =\u0026gt; { console.log(result); delaySquare(5, (result) =\u0026gt; { console.log(result); }); }); }); });   由上述可知，沒有進一步的非同步需求，回呼函式是直覺而簡單的，但如果需要執行多次非同步程式，就會不利於程式碼的閱讀和維護。\n從 ES6 開始，JavaScript 引入了一些新功能，可以幫助我們不用回呼就能處理非同步程式：\n Promise 物件（ES6） Async/Await 語法（Promise 語法糖 ES8）  2. Promise 物件 其實 Promise 已經存在多年，但是直到 ES6 才被標準化和引入。\n1 2 3 4 5 6 7 8 9 10 11  function delaySquare(n) { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(n * n); }, 2000); }); } delaySquare(2).then((result) =\u0026gt; { console.log(result); });   Promise 可以讓非同步操作寫起來，就像在寫同步操作的流程：\n1 2 3 4 5 6 7 8 9 10 11 12 13  delaySquare(2) .then((result) =\u0026gt; { console.log(result); return delaySquare(3); }) .then((result) =\u0026gt; { console.log(result); return delaySquare(4); }) .then((result) =\u0026gt; { console.log(result); return delaySquare(5); });   3. Async/Await 語法 Async/Await 其實就是 Promise 的語法糖將其簡化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function delaySquare(n) { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(n * n); }, 2000); }); } async function answer() { const result = await delaySquare(2); console.log(result); const result2 = await delaySquare(3); console.log(result2); const result3 = await delaySquare(4); console.log(result3); const result4 = await delaySquare(5); console.log(result4); } answer();   必須使用 async function 宣告函式，才可以使用 await，而 await 呼叫的函式必須回傳 Promise 物件。\n","description":"非同步是 JavaScript 最重要的觀念之一。","id":66,"section":"posts","tags":["JavaScript","非同步"],"title":"非同步","uri":"https://chupai.github.io/posts/2008/js_asynchronous/"},{"content":" 竹白的 JS 學徒特訓班筆記 - 目錄\n 記錄六角學院所開的 JS 學徒特訓班，為期 60天的特訓。\n\r第四十一關 - new Date() 時間處理  題目連結\n 41. 問題 請觀看以下文章，以了解如何透過 JS 去取得年月日的資料，並用 Slack 回傳你的學習心得，42 關將會出題目來練習。\n JavaScript Date（日期） 对象 JavaScript Date 時間和日期 日期與時間 從零開始的學習 JS 生活-第二十一日  41. 參考解答 竹白記事本 - 日期時間\n教學、延伸知識連結  Date 对象 Natively Format JavaScript Dates and Times moment.js - 關於時間的一切  第四十二關 new Date() 與字串處理  題目連結\n 42. 問題 請用你學會的語法，取出今日時間，並依序組出以下字串。\n假設今天時間為 8/5，則需透過 new Date() 處理後，印出以下資料：\n// 目前時間是 2020/8/5 14:20 // 2020/08/05 // 2020-08-05 // 今天是禮拜五 // 今天是八月五日，時間為 14:20 42. 參考解答 See the Pen 第四十二關 new Date() 與字串處理 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  四十三關 你熟悉 GitHub Pages 嗎？  題目連結\n 43. 問題 請依照技術主管的指示，將網頁放在 GitHub Pages 上的服務\n 在本地端新增一個 index.html，裡面多加上一個 h1 的標籤，裡面寫自己 Slack 的暱稱 觀看此文件，讓自己的網頁上傳到 GitHub Pages 上 在下方列表，張貼自己的 GitHub Pages 網址 接下來我們將會持續用 GitHub Pages 更新網頁  43. 參考解答 略\n四十四關 window.location  題目連結\n 44. 問題 請觀看以下文件，了解 window.location 類別的功能，例如轉址、取得網址參數等等\n Javascript 頁面跳轉、刷新、重定向的幾種方式 用 JavaScript 取得目前網址與其它網址參數簡單語法 JavaScript location Object window 物件的屬性 location JavaScript：回上一頁、各種跳轉頁面方法與 window.location 物件 javascript筆記 - window.location類別 Javascript 刷新頁面的幾種方法  44. 參考解答 竹白記事本 - window.location\n教學、延伸知識連結  Location 對象，URL 對象，URLSearchParams 對象  四十五關、四十六關 window.location  題目連結\n 45. 問題 以下有兩顆按鈕，請使用 JavaScript 語法，操控點擊後，能夠轉址到對應網站去\n1 2  \u0026lt;button class=\u0026#34;google\u0026#34;\u0026gt;連到 Google\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;yahoo\u0026#34;\u0026gt;連到 Yahoo\u0026lt;/button\u0026gt;   45. 參考解答 1 2 3 4 5 6 7  document.querySelector(\u0026#39;.google\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, function () { window.location.href = \u0026#39;https://www.google.com\u0026#39;; }); document.querySelector(\u0026#39;.yahoo\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, function () { window.location.href = \u0026#39;https://tw.yahoo.com\u0026#39;; });   CodePen\n46. 問題 問題一：\n以下有兩顆按鈕，是部落格推薦連結，請抓取 data-id 的值後進行轉址：\n 點擊 Tom 時，網址為 https://www.hexschool.com/?recommend=tom 點擊 John 時，網址為 https://www.hexschool.com/?recommend=John  1 2  \u0026lt;button class=\u0026#34;google\u0026#34; data-id=\u0026#34;tom\u0026#34;\u0026gt;Tom 推薦六角學院\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;yahoo\u0026#34; data-id=\u0026#34;John\u0026#34;\u0026gt;John 推薦六角學院\u0026lt;/button\u0026gt;   問題二：\n如果網址規則是https://www.hexschool.com/?recommend=\u0026quot;值\u0026quot;，該如何取出 recommend 的值？\n例如 https://www.hexschool.com/?recommend=tom，可以透過 JS，精準取出 tom 的值？請提供 JS 寫法。\nPS：Codepen 做法是抓不到值的，需自行開 web server，或到六角官網開啟 console 面板測試\n46. 參考解答 問題一：\n1 2 3 4 5 6 7 8  document.querySelector(\u0026#39;.google\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, buttonHandler); document.querySelector(\u0026#39;.yahoo\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, buttonHandler); function buttonHandler() { const id = this.dataset.id; const url = \u0026#39;https://www.hexschool.com\u0026#39;; window.location.assign(`${url}/?recommend=${id}`); }   CodePen\n問題二：\n1  window.location.search.replace(\u0026#39;?recommend=\u0026#39;, \u0026#39;\u0026#39;);   ","description":"JS 函式 41 ~ 46 關","id":67,"section":"posts","tags":["JavaScript","JS 學徒特訓班"],"title":"JS 學徒特訓班 - Date、Location 41 ~ 46 關","uri":"https://chupai.github.io/posts/2008/js60_5/"},{"content":" JavaScript筆記 目錄\n \rLocation 物件 Location 物件是瀏覽器提供的原生物件，提供 URL 相關的資訊和操作方法。\n可以透過 window.location 或 document.location 取得。\n1. 屬性  Location.href：網址（URL） Location.protocol：網址中的通訊協定，包括冒號 : Location.host：主機名稱 Location.hostname：網域名稱 Location.port：\t網址中的埠號 Location.pathname：網址路徑，從根路徑 / 開始 Location.search：網址參數，從問號 ? 開始 Location.hash：網址 hash 值，從 # 開始 Location.username：域名前面的使用者名稱 Location.password：域名前面的密碼 Location.origin：URL 的協議  只有 origin 屬性是唯讀。\n2. 方法  Location.assign()：接受一個 URL 字串作為參數，瀏覽器會立刻跳轉至新網址。 Location.replace()：與 assign() 相同，差異在於 replace() 會刪除瀏覽器歷史 History 的當前網址，這表示回到上一頁的按鈕無法回到原先的網址。  常應用在行動裝置版的網頁跳轉   Location.reload()：重新載入當前網址，等同按下瀏覽器刷新按鈕。 Location.toString()：回傳 URL 字串，等同讀取 Location.href 屬性。  網頁跳轉 如果對 Location.href 寫入完整的 URL，瀏覽器會立刻跳轉到新網頁上：\n1 2 3 4  window.location.href = \u0026#39;https://www.google.com\u0026#39;; // 等同 window.location.assign(\u0026#39;https://www.google.com\u0026#39;);   直接改寫 location，也相當於寫入 href 屬性：\n1  window.location = \u0026#39;https://www.google.com\u0026#39;;   如果不是完整網址，可用於切換路徑、滾動到新的錨點等等：\n1 2 3 4 5 6 7  window.location.href = \u0026#39;/posts\u0026#39;; // 等同 window.location.pathname = \u0026#39;/post\u0026#39; window.location.href = \u0026#39;#top\u0026#39;; // 等同 window.location.hash = \u0026#39;#top\u0026#39;;   ","description":"Location 物件是瀏覽器提供的原生物件，提供 URL 相關的資訊和操作方法。","id":68,"section":"posts","tags":["JavaScript","window.location"],"title":"window.location","uri":"https://chupai.github.io/posts/2008/js_window_location/"},{"content":" JavaScript筆記 目錄\n 產生 0 ~ 99 的數字陣列。\n\r迴圈 最簡單的方法就是使用迴圈。\nfor 迴圈：\n1 2 3 4 5  const numbers = []; for (let i = 0; i \u0026lt; 100; i += 1) { numbers[i] = i; }   或者使用 push()：\n1 2 3 4 5  const numbers = []; for (let i = 0; i \u0026lt; 100; i += 1) { numbers.push(i); }   while 迴圈：\n1 2 3 4 5 6 7  const numbers = []; let i = 0; while (i \u0026lt; 100) { numbers.push(i); i += 1; }   一行程式碼 使用 Array.from 內建的 map() 函式：\n1 2 3 4  const numbers = Array.from({ length: 100 }, (v, k) =\u0026gt; k); // or const numbers = Array.from(Array(100), (v, k) =\u0026gt; k);   先使用 Object.keys 取得鍵名（陣列鍵名就是索引），再轉成陣列：\n1 2 3 4  const numbers = Array.from(Array(100).keys()); // or const numbers = [...Array(100).keys()];   ","description":"產生 0 ~ 99 的數字陣列。","id":69,"section":"posts","tags":["JavaScript","ES6","陣列"],"title":"連續的數字陣列","uri":"https://chupai.github.io/posts/2008/js_array_numbers/"},{"content":"這週是六角鼠年鐵人賽第二十九週。\n\r什麼是洗牌 洗牌（shuffle） 其實就是亂數排序，將一組陣列中的元素順序打亂，是一種很常用到的演算法，在生活中最常見的例子就是洗撲克牌。\n洗牌演算法的條件：\n 結果要能夠覆蓋所有的情況； 所有出現的結果機率相等。  假設有一個長度為 $n$ 的陣列，會有 $n!$ 種不同的組合情況。\n演算法必須可以產生出 $n!$ 中的每一種結果，不可以多或少，否則每種結果出現的機率不相等。\nFisher-Yates shuffle Fisher-Yates shuffle 是最標準的洗牌演算法。\n其實它就是隨機交換：\n1 2 3 4 5 6 7  function shuffle(arr) { const n = arr.length; for (let i = n - 1; i \u0026gt; 0; i -= 1) { const rand = Math.floor(Math.random() * (i + 1)); [arr[i], arr[rand]] = [arr[rand], arr[i]]; } }   從後面迭代陣列，產生隨機索引與未排序的最後一個元素交換位置（隨機索引包含自己）。\n讓我們來分析一下，假設陣列元素有 5 個：\n 第 1 次迭代：i = 4，rand 的範圍是 0 ~ 4 第 2 次迭代：i = 3，rand 的範圍是 0 ~ 3 第 3 次迭代：i = 2，rand 的範圍是 0 ~ 2 第 4 次迭代：i = 1，rand 的範圍是 0 ~ 1 第 5 次迭代：i = 0，rand 的範圍是 0  整個過程產生的所有可能結果為：\n $n! = 5! = 5 \\times 4 \\times 3 \\times 2 \\times 1$ 時間複雜度為 $O(n)$  i \u0026gt;= 0 這樣寫也可以，因為最後一次迭代可有可無：\n1 2 3 4 5 6 7  function shuffle(arr) { const n = arr.length; for (let i = n - 1; i \u0026gt;= 0; i -= 1) { const rand = Math.floor(Math.random() * (i + 1)); [arr[i], arr[rand]] = [arr[rand], arr[i]]; } }   或者將交換位置改成前面：\n1 2 3 4 5 6 7  function shuffle(arr) { const n = arr.length; for (let i = 0; i \u0026lt; n; i += 1) { const rand = Math.floor(Math.random() * (n - i)) + i; [arr[i], arr[rand]] = [arr[rand], arr[i]]; } }   假設陣列元素有 5 個：\n 第 1 次迭代：i = 0，rand 的範圍是 0 ~ 4 第 2 次迭代：i = 1，rand 的範圍是 1 ~ 4 第 3 次迭代：i = 3，rand 的範圍是 2 ~ 4 第 4 次迭代：i = 4，rand 的範圍是 3 ~ 4 第 5 次迭代：i = 5，rand 的範圍是 4  最終結果為 $5! = n!$，一樣符合洗牌演算法條件。\n錯誤的演算法 網路上有很多洗牌演算法實作其實是錯誤的，因為它看似隨機打亂順序，但分布率並不均勻，以下舉幾個常見的錯誤。\n第一種常見的錯誤，順序隨機洗牌：\n1 2 3 4 5 6 7  function shuffle(arr) { const n = arr.length; for (let i = 0; i \u0026lt; n; i += 1) { const rand = Math.floor(Math.random() * n); [arr[i], arr[rand]] = [arr[rand], arr[i]]; } }   隨機範圍不變，因此每次迭代都會有 $n$ 種結果，最終結果為 $n^n$。\n假設陣列元素有 5 個，最終產生的結果可能有 $5^5 = 3125$ 種，但最大的組合結果只有 $5! = 120$，這表示某些組合出現的機率會比較大，因此不符合條件。\n另一種常見的錯誤，使用 sort()：\n1  array.sort(() =\u0026gt; Math.random() - 0.5);   利用 -0.5 ~ 0.5 的數字，讓 sort() 的比較器函式 a 和 b 之間的大小關係是隨機的，所以排序結果也是隨機的。\n這種作法雖然簡潔優雅，但是它有很大的問題：\n 雖然每次比較的結果是隨機且均勻的，但各家瀏覽器實作 sort() 的方式不同，因此無法保證比較的次數。 假設比較次數為 $m$，每次每次比較的發生機率為 $1 / 2$，因此最終產生的結果為 $2^m$。 ","description":"洗牌（shuffle） 其實就是亂數排序。","id":70,"section":"posts","tags":["洗牌演算法","w3HexSchool"],"title":"JavaScript 學演算法（二十一）- 洗牌演算法","uri":"https://chupai.github.io/posts/2008/shuffle_algorithm/"},{"content":"這週是六角鼠年鐵人賽第二十八週。\n搜尋的操作是非常經典的演算法，身為資訊工程師，能否在最短時間內搜尋到所需要的資料，一直以來都是最關心的議題。\n\r什麼是搜尋（Search） 搜尋（Search），簡單來說就是在一堆資料中找出特定的資料輸出，核心的操作為「比較」，只有透過比較才能判斷是否符合輸出條件。\n根據資料量的大小，搜尋可分為：\n 內部搜尋：資料量小，可從主記憶儲存資料檔中進行尋找所要的資料之操作； 外部搜尋：資料量非常大，必須從外部記憶中尋找想要的資訊。因外部記憶體的操作較費時間，故需考慮如何減少存取時間與次數。  根據不同的資料結構，會有不同合適的搜尋演算法。搜尋演算法也非常的多，因為會根據需求的不同，而有很多不同的變化。\n以下會說明幾個基礎的搜尋演算法：\n 線性搜尋（Linear Search） 二分搜尋（Binary Search） 指數搜尋（Exponential Search） 內插搜尋（Interpolation Search）  線性搜尋（Linear Search） 線性搜尋（Linear Search） 或稱 循序搜尋法（Sequential Search），是一種最基本、最簡單、最低效的搜尋演算法。\n線性搜尋 是透過迭代集合中的每個元素，一筆一筆資料比較，直到找到所要尋找的特定值為止或搜尋完整個範圍仍找不到為止。簡單來說就是從頭到尾找一遍，最大的特性為不需要事先排序集合。\n舉例來說，迭代陣列尋找特定值：\n1 2 3 4 5 6 7 8 9  function linearSearch(arr, target) { const n = arr.length; for (let index = 0; index \u0026lt; n; index++) { if (target === arr[index]) { return index; } } return -1; }   回傳第一個符合條件的元素索引位置，若沒有回傳 -1。\n在 JavaScript 要在陣列中尋找特定元素，有以下方法使用：\n indexof() 類似上面的函式，但執行速度比自己寫的快。 findIndex() 迭代陣列，回傳第一個滿足指定條件的元素索引，與 indexof() 的差異在於，indexof() 使用 === 比較，findIndex() 能使用 callback 函式定義條件，適用於複雜的元素（例，物件），而且就算找到符合的條件元素，也會迭代完整個陣列。 其他陣列搜尋的方法還有 some() 、every()、find() 等等。  1. 分析 線性搜尋因為是從頭開始迭代至結尾，因此如果要找的資料在最後面或目標不存在，比較次數就會根據資料大小拉長。\n 特性：不需要事先排序 時間複雜度  最佳：$O(1)$ 最差：$O(n)$ 平均：$O(n)$   空間複雜度為： $O(1)$  二分搜尋（Binary Search） 二分搜尋（Linear Search） 或稱 折半搜尋演（Half-Interval Search）、對數搜尋（Logarithmic Search），是一種在 「已排序陣列」 中搜尋某一特定元素的搜尋演算法。\n二分搜尋會將陣列中間位置的值與目標進行比較，再判斷目標在左還是右。每次判斷都會縮小一半的搜尋範圍，直到找到目標或目標不存在。\n簡單來就說，就類似「終極密碼遊戲」，猜一個數字，會有三種回應：\n 比目標小 比目標大 猜中了  1. 演算法實作 二分搜尋輸入的陣列必須是已排序狀態。\n1 2 3 4 5 6 7 8 9 10 11 12 13  function binarySearch(sortedArray, target) { let [start, end] = [0, sortedArray.length - 1]; while (start \u0026lt;= end) { const mid = Math.floor((start + end) / 2); if (target === sortedArray[mid]) { return mid; } if (target \u0026lt; sortedArray[mid]) { end = mid - 1; } else { start = mid + 1; } } return -1; }   雖然不建議，但可以使用遞迴結構來改寫：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function binarySearch10(sortedArray, target) { return _binarySearch(0, sortedArray.length - 1); function _binarySearch(start, end) { if (start \u0026gt; end) { return -1; } const mid = Math.floor((start + end) / 2); if (target === sortedArray[mid]) { return mid; } if (target \u0026lt; sortedArray[mid]) { return _binarySearch(start, mid - 1); } else { return _binarySearch(mid + 1, end); } } }   不過空間複雜度會從 $O(1)$ 變成 $O(\\log n)$。\n2. 分析 每次判斷都會縮小一半的搜尋範圍，因此整體執行時間約為 $\\log_2$。\n 特性：需要事先排序陣列 時間複雜度  最佳：$O(1)$ 最差：$O(\\log n)$ 平均：$O(\\log n)$   空間複雜度為： $O(1)$  二分搜尋與線性搜尋相比，速度是線性搜尋的指數倍，但使用二分搜尋的前提下，陣列必須先排序過。\n指數搜尋（Exponential Search） 指數搜尋（Exponential Search） 或稱 Galloping Search，是一種特殊的二元搜尋，主要用在搜尋無限、無邊界的已排序序列。\n指數搜尋不是從中間位置來判斷，而會從索引位置 $2^{0}$ 開始，不斷遞增 $2^{1}$、$2^{2}$ 直到 $2^{i}$ 位置，若比目標大，會停止指數成長，改用二用搜尋，也就是取中位置來回頭尋找目標。\n1. 演算法實作 首先，我們先改寫二元搜尋，多傳入起始和終點的參數，也就是搜尋範圍：\n1 2 3 4 5 6 7 8 9 10 11 12 13  function binarySearch10(sortedArray, target, _start = 0, _end = sortedArray.length - 1) { let [start, end] = [_start, _end]; while (start \u0026lt;= end) { const mid = Math.floor((start + end) / 2); if (target === sortedArray[mid]) { return mid; } if (target \u0026lt; sortedArray[mid]) { end = mid - 1; } else { start = mid + 1; } } return -1; }   接下來是指數搜尋本體：\n1 2 3 4 5 6 7 8 9 10  function exponentialSearch(sortedArray, target) { const n = sortedArray.length; if (target === sortedArray[0]) { return 0; } let i = 1; while (i \u0026lt; n \u0026amp;\u0026amp; sortedArray[i] \u0026lt; target) { i = i * 2; } if(sortedArray[i] === target) { return i; } return binarySearch(sortedArray, target, i / 2, Math.min(i, n - 1)); }   2. 分析 使用指數搜尋，若目標很靠近序列前端，那麼會提升執行效率。因為縮小搜尋範圍，效率會比二分搜尋高。\n 特性：需要事先排序陣列 時間複雜度  最佳：$O(1)$ 最差：$O(\\log n)$ 平均：$O(\\log n)$   空間複雜度為： $O(1)$  內插搜尋（Interpolation Search） 內插搜尋（Interpolation Search） 又稱 插補搜尋、插值搜尋，也是一種特殊的二元搜尋，它是依照資料位置的分佈，利用內插公式預測目標的所在位置，搜尋方式與二分搜尋相同。\n二分搜尋是預測中間位置，而內插搜尋則是用直線斜率預測目標位置，一般而言，資料量愈大，數值分佈會愈平均，內插搜尋的效率會比二分搜尋法好。\n1. 內插公式 資料的值為 $y$、索引值為 $x$：\n 斜率 = $\\dfrac{y_2 - y_1}{x_2 - x_1}$  目標值為 $k$、預測目標索引位置為 $m$：\n $\\dfrac{y_2 - y_1}{x_2 - x_1}$ = $\\dfrac{k - y_1}{m - x_1}$ $m$ = $\\dfrac{(k - y_1)(x_2 - x_1)}{y_2 - y_1} + x_1$  2. 演算法實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function interpolationSearch(sortedArray, target) { let [start, end] = [0, sortedArray.length - 1]; while (start \u0026lt;= end) { const [x1, x2, y1, y2, k] = [start, end, sortedArray[start], sortedArray[end], target]; const m = Math.floor(((k - y1) * (x2 - x1)) / (y2 - y1) + x1); if (m \u0026gt; end || m \u0026lt; start) { break; } if (target === sortedArray[m]) { return m; } if (target \u0026gt; sortedArray[m]) { start = m + 1; } else { end = m - 1; } } return -1; }   3. 分析 如果資料分佈不均，近似線差異太大，最差時間複雜度高達 $O(n)$，如果資料分佈平均，執行效率會優於二元搜尋。\n 特性：需要事先排序陣列 時間複雜度  最佳：$O(1)$ 最差：$O(n)$ 平均：$O(\\log(\\log n))$   空間複雜度為： $O(1)$ ","description":"搜尋的操作是非常經典的演算法，身為資訊工程師，能否在最短時間內搜尋到所需要的資料，一直以來都是最關心的議題。","id":71,"section":"posts","tags":["搜尋演算法","w3HexSchool"],"title":"JavaScript 學演算法（二十）- 搜尋演算法","uri":"https://chupai.github.io/posts/2008/search_algorithm/"},{"content":" 竹白的 JS 學徒特訓班筆記 - 目錄\n 記錄六角學院所開的 JS 學徒特訓班，為期 60天的特訓。\n\r第三十六關：ES6 起步走 - Template String 樣板字串  題目連結\n 36. 問題 第 20 關 用 Template String 樣板字串來改寫。\n如果你已經早就會 ES6 字串處理，請觀看以下文章，挑選一個你不會的技術觀念，並分享你學到了什麼\n 邁向 JavaScript 勇者之路 [重新認識 JavaScript ES6 入門手冊  36. 參考解答 略。\n第三十七關：let、const  題目連結\n 37. 問題 還請挑戰者們分享你找到的 JS ES6 let 與 const 文章，補充在下方列表，並嘗試自己寫一些範例，並回報於 Slack 上\n37. 參考解答 變數\n第三十八關：let 與 const 觀念複習  題目連結\n 38. 問題 請在 Slack 回覆以下的解答，以及解釋為什麼？\n同時附上你找到的文章，條列在最下方\n問題一：\n請問下面會出現的 console 是？\n1 2  console.log(a); //ReferenceError let a = 10;   問題二：\n以下是否會正常執行？若不會，會顯示什麼紅字錯誤？\n1 2  let a = 1; a = 3;   1 2  let b = 1; let b = 2;   1 2  const c = 3; c = 4   問題三：此為熱門面試題目（選答）\n請問 var、let、const 的區別是？\n38. 參考答案 問題一：\n1 2 3  console.log(a); // Uncaught ReferenceError: Cannot access \u0026#39;a\u0026#39; before initialization let a = 10;   let 在正式值行前，變數不會賦值，因在沒值的狀況下被存取就會拋出錯誤。\n問題二：\n第一個正常執行。\n重複宣告：\n1 2 3 4  let b = 1; let b = 2; // Uncaught SyntaxError: Identifier \u0026#39;b\u0026#39; has already been declared   const 重新賦值：\n1 2 3 4  const c = 3; c = 4 // Uncaught TypeError: Assignment to constant variable.   問題三：\n var：函式作用域、可重複宣告、會汙染全域物件。 var、let：區塊作用域、無法重複宣告、不會汙染全域物件。  const：無法再次賦值    第三十九關：箭頭函式(arrow function)  題目連結\n 39. 問題  如果你是初學者，請回傳第 18 關的 forEach ，改用箭頭函式的寫法來撰寫 假使你已經會箭頭函式，請分享 arrow function 會如何影響到 this  39. 參考答案 略。\n第四十關：ES6 團戰關卡  題目連結\n 40. 問題  請挑選 20、35 關的其中一關，改為 ES6 寫法 程式碼必須使用到 ES6 的 36~39 關的技術，例如字串符、let、const、箭頭函式 如果你的 Code 早就已經改寫為 ES6 寫法，以下面試題目請挑選一題來解釋，並下方附上你的 HackMD 文章  請解釋什麼是 this？請寫範例解釋？ 你對 promise、promise all 有多熟悉？請寫範例解釋？ 什麼是原型繼承（prototype）？ Fetch 與 XMLHttpRequest    40. 參考答案  竹白記事本 - 函式呼叫與 this 竹白記事本 - Promise ","description":"JS 函式 36 ~ 40 關","id":72,"section":"posts","tags":["JavaScript","JS 學徒特訓班"],"title":"JS 學徒特訓班 - JS 函式 36 ~ 40 關","uri":"https://chupai.github.io/posts/2008/js60_4/"},{"content":" JavaScript筆記 目錄\n 一直沒時間將之前的筆記丟到這來，剛好最近參加 JS 學徒訓練班，就趁這次機會重新整理筆記。\n\r總結 直接來看總結。\n呼叫函式的方式會影響 this 的值：\n 直接作為函式來呼叫，通常 this 的值為全域物件，嚴格模式下為 undefined； 函式作為方法來呼叫，this 的值為被呼叫函式的所屬物件； 函式作為建構式來呼叫，this 的值為新建立的物件； 藉由 apply() 或 call() 呼叫，this 的值由第一個參數決定。  箭頭函式：\n 箭頭函式沒有自己的 this 的值，由建立時的環境來決定。  bind：\n 所有函式都具備 bind() 來建立一個新函式，此函式會綁定傳入的引數，除此之外，綁定的函式運作如原始的函式。  嚴格模式：\n 當 this 值為 undefined 或 null 會被強制轉成全域物件，而嚴格模式下，將不會強制轉值。  this 的誤解 this 有兩個因為過度解讀字面本身的意義，而造成的誤解。\n 第一個常見的誤解是 this 參考到函式本身； 另一個常見的誤解是 this 以某種方式參考了函式自身作用域。  請問會印出啥？\n1 2 3 4 5  function foo() { console.log(this); } foo(); // 預期結果為 function foo() { ... }   結果為全域物件（瀏覽器下是 Window 物件、node.js 底下是 Global 物件）。\n請問會印出啥？\n1 2 3 4 5 6 7 8 9 10  function foo() { var a = 2; this.bar(); } function bar() { console.log( this.a ); } foo(); // 預期結果為 2   結果為 undefined，因為全域物件下沒有 a。\nthis 的指向 1. 一般的函式呼叫 this 的值與物件導向有關，一但脫離了物件，this 的值並不重要。\n一般的函式呼叫，this 會指向預設的綁定（default binding），也就是全域物件（瀏覽器下是 Window 物件、node.js 底下是 Global 物件）。\n1 2 3 4 5 6 7 8  var name = \u0026#39;GlobalName\u0026#39;; function foo() { var name = \u0026#39;Chupai\u0026#39;; console.log(this.name); } foo(); // \u0026#34;GlobalName\u0026#34;   放到立即函式 IIFE ，直接在函式內直接在呼叫另一個函式：\n1 2 3 4 5 6 7 8 9  var name = \u0026#39;GlobalName\u0026#39;; (function() { function foo() { var name = \u0026#39;Chupai\u0026#39;; console.log(this.name); } foo(); // \u0026#34;GlobalName\u0026#34; })();   結果是一樣的。\n閉包 Closure：\n1 2 3 4 5 6 7 8 9 10  var name = \u0026#39;GlobalName\u0026#39;; function foo() { var name = \u0026#39;Chupai\u0026#39;; return function() { console.log(this.name); }; } foo()(); // \u0026#34;GlobalName\u0026#34;   這樣結果依然相同。\n回呼函式 Callback function：\n1 2 3 4 5 6 7 8 9 10 11 12 13  var name = \u0026#39;GlobalName\u0026#39;; function foo() { var name = \u0026#39;Chupai\u0026#39;; function boo() { console.log(this.name); } boo(); } foo(); // \u0026#34;GlobalName\u0026#34;   無論在哪一層， 一般的函式呼叫 this 都會指向全域物件。\n為什麼 this 會指向全域物件，關於這部分會在下方 嚴格模式 說明。\n2. 物件的方法呼叫 將函式綁定到一個物件屬性上，稱作方法（method）。\n如果呼叫物件的方法，this 的值為被呼叫函式的所屬物件。\n一個簡單的範例：\n1 2 3 4 5 6 7 8 9 10  var name = \u0026#39;GlobalName\u0026#39;; var obj = { name: \u0026#39;Chupai\u0026#39;, foo: function() { console.log(this.name); }, }; obj.foo(); // \u0026#34;Chupai\u0026#34;   foo 為 obj 的方法，因此 foo 內的 this 會指向 obj 物件。\n稍微改變一下程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13  var name = \u0026#39;GlobalName\u0026#39;; function foo() { console.log(this.name); } var obj = { name: \u0026#39;Chupai\u0026#39;, foo: foo }; foo(); // \u0026#34;GlobalName\u0026#34; obj.foo(); // \u0026#34;Chupai\u0026#34;   函式宣告的位置不重要，foo 內的 this 還是會指向 obj 物件。\n繼續看下個範例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  var name = \u0026#39;GlobalName\u0026#39;; function foo() { console.log(this.name); } var obj = { name: \u0026#39;Chupai\u0026#39;, boo: { name: \u0026#39;Wang\u0026#39;, foo: foo } }; obj.boo.foo(); // \u0026#34;Wang\u0026#34;   foo 為 obj.boo 物件的方法，所以它會指向 obj.boo 物件。\n3. 間接參考 接下來看一個常見的錯誤。\n如果將物件內的函式，賦予在一個變數上，並呼叫它：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var name = \u0026#39;GlobalName\u0026#39;; function foo() { console.log(this.name); } var obj = { name: \u0026#39;Chupai\u0026#39;, foo: foo, }; var callThisName = obj.foo; callThisName(); // \u0026#34;GlobalName\u0026#34;   當我們將 obj.foo 指定給變數 callThisName 時，會將 foo 函式的記憶體位置傳給 callThisName，因此當我們用 callThisName() 呼叫時，與 obj 無關，所以就只是一般的函式呼叫。\n另外，參數傳遞中的回呼函式，也屬於間接參考：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  var name = \u0026#39;GlobalName\u0026#39;; function foo() { console.log(this.name); } var obj = { name: \u0026#39;Chupai\u0026#39;, foo: foo, }; function boo(fn) { fn(); } boo(obj.foo); // \u0026#34;GlobalName\u0026#34;   4. 事件監聽 DOM 搭配事件監聽 addEventListener 時，監聽函式中的 this 會指向的則是該 DOM 物件。\n1 2 3 4 5  var dom = document.querySelector(\u0026#39;body\u0026#39;); dom.addEventListener(\u0026#39;click\u0026#39;, function() { console.log(this); // \u0026lt;body\u0026gt;...\u0026lt;/body\u0026gt; });   改變 this 的指向 會改變 this 的指向的情況：\n 使用 apply、call 函式方法； 使用 bind 函式方法； 使用建構函式 new 一個物件實體； 使用 ES6 的箭頭函式。  1. apply、call call() 與 apply() 是能呼叫函式的方法，並且能強制指定 this 值：\n1 2 3 4 5 6 7 8  var obj = {}; function foo() { console.log(this); }： foo(); // \u0026#34;Window{}\u0026#34; foo.call(obj); // Object{} foo.apply(obj); // Object{}   兩者第一個參數都是 this 值，也就是要綁定的物件。\n而兩者差異只在於後面的參數：\n1 2 3 4 5 6 7 8  var obj = {}; function foo(a, b) { console.log(this, a, b); } foo.call(obj, 1, 2); // Object{} 1 2 foo.apply(obj, [1, 2]); // Object{} 1 2   call() 第二個參數後，與平常呼叫函式一樣，apply() 則需要使用陣列將引數包起來。\n使用 call() 和 apply() 綁定 this 後，再用一次就無法改變 this 的指向：\n1 2 3 4 5 6 7 8 9 10  function foo() { console.log(this.a); } var boo = function () { foo.call({ a: 2 }); }; boo(); // 2 boo.call({ a: 10 }); // 2   此模式稱作硬綁定（hard binding），指的是綁定既明確又不會意外變回預設的綁定。\n2. bind() 因為硬綁定模式如此常用，ES5 新增了一個方法，將此模式包裝了起來，bind() 會回傳一個新的函式，當被呼叫時，將提供的值設為 this 值。\n1 2 3 4 5 6 7 8  function foo() { console.log(this.a); } var boo = foo.bind({ a: 2 }); boo(); // 2 boo.call({ a: 10 }); // 2   3. 使用建構函式 此部分只要了解建構函式的 this 是指向使用 new 建立的物件實體本身即可。\n1 2 3 4 5 6  function Foo(a) { this.a = a; } var bar = new Foo(2); console.log(bar.a); // 2   3. 箭頭函式 傳統函式的 this 是依呼叫的方法而定，因此當你的函式有好幾層時，會遇到一個問題：\n1 2 3 4 5 6 7 8 9 10 11 12  var obj = { a: 10, b: 20, print: function () { function add() { return this.a + this.b; } console.log(add()); }, }; obj.print(); // NaN   以上範例可以看到，我們在 print 方法內又建立一個函式並呼叫，因為是一般呼叫，因此 this 會會指向全域物件，所以 this.a 和 this.b 為 undefined，因此結果為 NaN。\n在 ES6 前，解決辦法是利用一個變數儲存 this 的值（常見命名 _this、that、vm、self）：\n1 2 3 4 5 6 7 8 9 10 11 12 13  var obj = { a: 10, b: 20, print: function () { var _this = this; function add() { return _this.a + _this.b; } console.log(add()); }, }; obj.print(); // 30   而 ES6 新增的箭頭函式，它本身並沒有 this，它會在定義時記住 this 值，也就在宣告它的地方的 this 是什麼，它的 this 就是什麼，會根據環境來：\n1 2 3 4 5 6 7 8 9 10 11 12  var obj = { a: 10, b: 20, print: function () { let add = () =\u0026gt; { return this.a + this.b; }; console.log(add()); }, }; obj.print(); // 30   箭頭函式注意事項：\n 箭頭函式一但綁定了 this 就不會再改變，使用 apply、call、bind 方法也無法修改； 箭頭函式也不能用在建構式上，會拋出錯誤； 用在監聽 DOM 的回呼函式上，this 會指向全域物件，因此要避免。  嚴格模式 ES5 之後，新增了嚴格模式，在嚴格模式下，一般函式呼叫的 this 值都是 undefined。\n1 2 3 4 5 6  \u0026#39;use strict\u0026#39;; function foo() { console.log(this); } foo(); // undefined   undefined 與全域物件有什麼關係？\n先來一段程式碼：\n1 2 3 4 5 6  function foo() { console.log(this); } foo.call(undefined); // Window{} foo.call(null); // Window{}   我們使用 call() 將 this 值設為 undefined，結果卻回傳全域物件。\n這是因為 JavaScript 的機制，當 this 值為 undefined 或 null 時，會將 this 值強制轉換為一個物件。\n在嚴格模式下，刻意將 undefined 或 null 設為 this 值，會回傳正確的 this 值。\n1 2 3 4 5 6 7  \u0026#39;use strict\u0026#39;; function foo() { console.log(this); } foo.call(undefined); // undefined foo.call(null); // null   這就是為什麼一般函式呼叫會回傳全域物件的原因。\n有的書會用「this 永遠指向最後呼叫它的那個物件」來解釋下面這段程式碼：\n1 2 3 4 5 6  function foo() { console.log(this); } foo(); // Window{} window.foo(); // Window{}   因為 foo() 等同 window.foo()，最後呼叫它的物件是全域物件，所以 this 指向全域物件。但這其實是不太正確的說法，this 值主要還是以函式的呼叫方式為主，foo() 的 this 值會是 undefined，會得到全域物件是因為被強制給值了。\n讓我們加上嚴格模式：\n1 2 3 4 5 6 7  \u0026#39;use strict\u0026#39;; function foo() { console.log(this); } foo(); // undefined window.foo(); // Window{}   window.foo() 的值還是指向全域物件，因為它是方法呼叫。\n1. 注意 但這裡要注意的是，呼叫地點是嚴格模式，並不會影響 this 的規則。\n1 2 3 4 5 6 7 8 9 10  function foo() { console.log( this.a ); } var a = 2; (function() { \u0026#39;use strict\u0026#39; foo(); // 2 })();   猜猜這個 this 到底是什麼？  JavaScript - 猜猜這個 \u0026ldquo;this\u0026rdquo; 到底是什麼？ 靠北 JS 之 This 到底是什麼辣  參考資料 書籍：\n 《忍者：JavaScript開發技巧探秘第二版》 《你所不知道的 JS - 範疇與 Closures、this 與物件原型》 《0 陷阱！0 誤解！8 天重新認識JavaScript！》 《JavaScript 技術手冊》  文章：\n JavaScript This 系列文：this 為什麼指向 window JavaScript This 系列文：this 與物件的關係\n ","description":"JavaScript 的大坑「this」。","id":73,"section":"posts","tags":["JavaScript","ES6","變數"],"title":"函式呼叫與 this","uri":"https://chupai.github.io/posts/2008/js_this/"},{"content":"這週是六角鼠年鐵人賽第二十七週。\n我們來看相較於 紅黑樹，可以說是非常簡單的平衡樹：樹堆（Treap）。\n\r樹堆 樹堆（Treap） 其名稱是 Tree 和 Heap 的結合。顧名思義，Treap 同時滿足二元搜尋樹和 Heap（堆積）的性質。屬於 笛卡爾樹（Cartesian Tree） 的一種，兩者在結構上是相同的，只是應用不同。\nTreap 結構相當於以隨機資料插入的二元搜尋樹，相較於其它平衡樹，實現可以說是非常簡單直觀。由於樹的結構並不等於添加元素順序，因此可有效避免一般的二元搜尋樹所出現的最糟情況。\n1. 性質 Treap 在二元搜尋樹的基礎上，每個節點都有一個隨機的 優先順序（priority）。\n Treap 為一棵二元搜尋樹； 左、右子樹也是 Treap； 每個節點都有一個隨機的 優先順序； 優先順序 保持著 Heap 性質。  Max Heap（最大堆積），所有的父節點都比子節點要大； Min Heap（最小堆積），所有的父節點都比子節點要小。    需要注意的兩點：\n Treap 相較於 Heap，不需要滿足 Complete binary tree（完全二元樹）的條件； Treap 相較於 AVL-Tree，屬於非嚴格平衡樹。  2. 新增操作 新增時，會給節點隨機分配一個優先順序，新增操作和一般二元搜尋樹相同，新增節點後，需要維護 Heap 的性質，會用到旋轉操作。\n以 Max Heap 為例：\n 新增節點到一個葉子節點上； 當前節點的優先順序比其根大，對根旋轉：  如果當前節點是根的左子節點，右旋轉； 如果當前節點是根的右子節點，左旋轉。    3. 刪除操作 因為 Treap 滿足 Heap 性質，所以只需要把要刪除的節點旋轉到葉子節點上，然後直接刪除就可以了。\n具體的方法：\n 比較被刪除節點的左、右子節點優先順序：\n- 左子樹優先順序大，執行右旋轉；\n- 右子樹優先順序大，執行左旋轉。 直到被刪除節點被旋轉到了葉子節點，然後直接刪除。  JavaScript 實作 Treap 1. 基本結構 我們簡單的寫一個隨機函式，用來模擬隨機分配的優先順：\n1 2 3  function random() { return Math.floor(Math.random() * 1000); }   節點：\n1 2 3 4 5 6 7 8  class TreapNode { constructor(data, priority = random()) { this.data = data; this.priority = priority; this.left = null; this.right = null; } }   節點比一般二元樹多一個優先順序。\n本體：\n1 2 3 4 5 6  class Treap { constructor() { this.root = null; } // methods }   2. 旋轉操作 與 AVL-Tree 相同。\n1 2 3 4 5 6 7 8 9 10 11 12 13  rightRotation(node) { const temp = node.left; node.left = temp.right; temp.right = node; return temp; } leftRotation(node) { const temp = node.right; node.right = temp.left; temp.left = node; return temp; }   3. 新增操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  insert(data) { const insertHelper = (node) =\u0026gt; { let curNode = node; if (!curNode) { return new TreapNode(data); } if (data \u0026lt; curNode.data) { curNode.left = insertHelper(curNode.left); if (curNode.left.priority \u0026gt; curNode.priority) { curNode = this.rightRotation(curNode); } } else if (data \u0026gt; curNode.data) { curNode.right = insertHelper(curNode.right); if (curNode.right.priority \u0026gt; curNode.priority) { curNode = this.leftRotation(curNode); } } return curNode; }; this.root = insertHelper(this.root); }   4. 刪除操作 因為節點是單向的，所以我們要記錄父節點和一個 key 紀錄當前節點是左、右子樹。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  remove(data) { let curNode = this.root; let parentNode = null; let key = \u0026#39;\u0026#39;; // 尋找刪除節點  while (curNode) { if (data \u0026lt; curNode.data) { parentNode = curNode; key = \u0026#39;left\u0026#39;; curNode = curNode.left; } else if (data \u0026gt; curNode.data) { parentNode = curNode; key = \u0026#39;right\u0026#39;; curNode = curNode.right; } else { break; } } // 旋轉刪除節點，直到最底下  while (curNode) { // 判斷節點狀態  const result = this.comparison(curNode); if (result === -1) { this.setNode(parentNode, null, key); return; } if (result === 1) { curNode = this.rightRotation(curNode); this.setNode(parentNode, curNode, key); key = \u0026#39;right\u0026#39;; parentNode = curNode; curNode = curNode.right; } else { curNode = this.leftRotation(curNode); this.setNode(parentNode, curNode, key); key = \u0026#39;left\u0026#39;; parentNode = curNode; curNode = curNode.left; } } }   輔助函式：\n1 2 3 4 5 6 7  setNode(parent, node, key) { if (!parent) { this.root = node; } else { parent[key] = node; } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  comparison(node) { if (!node.left \u0026amp;\u0026amp; !node.right) { return -1; } if (node.left \u0026amp;\u0026amp; !node.right) { return 1; } if (!node.left \u0026amp;\u0026amp; node.right) { return 0; } if (node.left.priority \u0026gt; node.right.priority) { return 1; } return 0; }   See the Pen Treap with Vue.js by Chupai@Design (@chupai) on CodePen. ","description":"樹堆（Treap）相較於紅黑樹，可以說是非常簡單的平衡樹。","id":74,"section":"posts","tags":["資料結構","二元搜尋樹","二元樹","Treap","平衡樹","樹堆","w3HexSchool"],"title":"JavaScript 學演算法（十九）- 樹堆","uri":"https://chupai.github.io/posts/2008/ds_treap/"},{"content":" 竹白的 JS 學徒特訓班筆記 - 目錄\n 記錄六角學院所開的 JS 學徒特訓班，為期 60天的特訓。\n\r第二十四關：資料格式處理，forEach + 陣列處理(一)  題目連結\n 劇情略。\n24. 題目 以下是預期希望出現正常的圖表，請改寫此 Codepen，並在 Slack 回傳你的解法：\nPS：HTML 與 CSS 面板壞掉了，只能變更 JS 面板\n24. 參考解答 1 2 3  newMonthMoney.forEach((item)=\u0026gt; { monthMoney.push(item); });   第二十五關：資料格式處理，forEach + 陣列處理(二)  題目連結\n 劇情略。\n25. 題目 以下是預期希望出現正常的圖表，請改寫此 Codepen，並在 Slack 回傳你的解法：\nPS：HTML 與 CSS 面板壞掉了，只能變更 JS 面板\n25. 參考解答 1 2 3 4  serverData.forEach((item)=\u0026gt; { let temp = [item.name, ...item.seasonOneData, ...item.seasonTwoData]; data.push(temp); });   教學、延伸知識連結  展開／其餘運算子\n  第二十六關：AJAX、axios 題目  題目連結\n 26. 問題 觀看 JS 新手教學 - AJAX 與資料處理，試著撈出 API 所有的姓名列表。\nhttps://raw.githubusercontent.com/hexschool/hexschoolNewbieJS/master/data.json 26. 參考解答 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const urlAPI = \u0026#39;https://raw.githubusercontent.com/hexschool/hexschoolNewbieJS/master/data.json\u0026#39;; let data = []; axios.get(urlAPI).then((res) =\u0026gt; { data = res.data; // 取得資料  rander(data); // 渲染 }); function rander(arr) { let html = \u0026#39;\u0026#39;; arr.forEach((item)=\u0026gt; { html += `\u0026lt;li\u0026gt;${item.name}\u0026lt;/li\u0026gt;` }); document.querySelector(\u0026#39;.list\u0026#39;).innerHTML = html; }   See the Pen JS 學徒特訓班 26 關 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  教學、延伸知識連結  axios中文文档 JSON-handle  第二十七關：陣列補充觀念  題目連結\n 27. 問題 請從以下連結，學習 2~3 種陣列的處理方式，聽說 sort 就蠻常見的，並在 slack 回報自己的範例程式碼與學到的東西。\n Cheatsheet for Array Methods - JavaScript 陣列方法大全 JavaScript Array 陣列操作方法大全 ( 含 ES6 ) JavaScript 陣列處理方法 [filter(), find(), forEach(), map(), every(), some(), reduce()  27. 參考解答 我以前的筆記：\n 陣列｜竹白記事本 迭代陣列｜竹白記事本 Slice、Splice、Split 的區別｜竹白記事本  第二十八關：陣列排序進度  題目連結\n 28. 問題 API：\nhttps://raw.githubusercontent.com/hexschool/hexschoolNewbieJS/master/data.json 撈出資料後，依照每個物件的 process 來進行進度排序，範例格式如下圖。\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;第 1 名是廖洧杰，他的特訓班完成度是 33%\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;第 2 名是王小明，他的特訓班完成度是 30%\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 28. 參考解答 process 資料格式為字串、數字部分為浮點數、單位為 %，因此若直接使用 parseInt() 取得數字，只能取得整數部分，小數部分就會有誤差，因此可以使用 parseFloat()。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  const urlAPI = \u0026#39;https://raw.githubusercontent.com/hexschool/hexschoolNewbieJS/master/data.json\u0026#39;; let data = []; axios.get(urlAPI).then((res) =\u0026gt; { data = res.data; // 取得資料  let sortedData = sortData(data); // 排序  rander(sortedData); // 渲染 }); function rander(arr) { let html = \u0026#39;\u0026#39;; arr.forEach((item, index)=\u0026gt; { html += `\u0026lt;li\u0026gt;第 ${index + 1}名是${item.name}，他的特訓班完成度是 ${item.process}\u0026lt;/li\u0026gt;` }); document.querySelector(\u0026#39;.list\u0026#39;).innerHTML = html; } function sortData(arr) { let temp = [...arr]; // 複製一份避免動到原始資料  temp.sort((a, b)=\u0026gt; parseFloat(b.process) - parseFloat(a.process)); return temp; }   See the Pen JS 學徒特訓班 28 關 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  教學、延伸知識連結  parseInt｜MDN parseFloat｜MDN sort()｜MDN  第二十九關：監聽切換排序功能  題目連結\n 29. 問題 承接上題，新增切換排序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;select\u0026gt; \u0026lt;option value=\u0026#34;id\u0026#34;\u0026gt;依照 id 編號排序(由1開始從上往下)\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;process\u0026#34;\u0026gt;依照完課率排序(由最高到最低)\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; // 以下為編號排序範例 \u0026lt;ul class=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;li\u0026gt;編號 ID 1 為廖洧杰，他的完成進度為 5 %\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;編號 ID 2 為王小明，他的完成進度為 33 %\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; // 以下為完課率排序範例 \u0026lt;ul class=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;li\u0026gt;編號 ID 2 為王小明，他的完成進度為 33 %\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;編號 ID 1 為廖洧杰，他的完成進度為 5 %\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;   29. 參考解答 監聽 \u0026lt;select\u0026gt; 取得 \u0026lt;option\u0026gt; 的值，用來判斷排序方式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  let selectDom = document.getElementById(\u0026#39;select\u0026#39;); selectDom.addEventListener(\u0026#39;change\u0026#39;, function() { let sortedData = sortData(data, this.value); rander(sortedData); }); function sortData(arr, mode = \u0026#39;id\u0026#39;) { let temp = [...arr]; // 複製一份避免動到原始資料  if (mode === \u0026#39;id\u0026#39;) { temp.sort((a, b)=\u0026gt; a - b); } else { temp.sort((a, b)=\u0026gt; parseFloat(b.process) - parseFloat(a.process)); } return temp; }   See the Pen JS 學徒特訓班 29 關 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  教學、延伸知識連結  現代 JavaScript 教程 - 表单，控件  第三十關：C3.js 圖表整合  題目連結\n 30. 問題  請嘗試用 codepen 附上你的解答，這次的需求是「用 c3.js 圖表顯示，看看誰的完課率最好，同時可以看出排名」 圖表不局限於上面的長條圖，也可尋找合適的圖 週六日請嘗試寫一篇 blog，分享解題流程，讓其他人也可以受益  30. 參考解答 See the Pen JS 學徒特訓班 30 關 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  第三十一關：部落格文章閱讀  題目連結\n 略。\n第三十二關：程式整合篇  題目連結\n 32. 問題 結合 29、30 關，左邊排序功能，右邊圖表顯示。\n32. 參考解答 See the Pen JS 學徒特訓班 32 關  by CHUPAIWANG (@CHUPAIWANG) on CodePen.  第三十三關：圓餅圖分析  題目連結\n 33. 問題  圓餅圖圖表\n 繪製尚未開賽跟已開賽的比例圓餅圖。\n33. 參考解答 1 2 3 4 5 6 7 8 9 10 11 12  let processCount = { non: 0, start: 0, }; data.forEach((item)=\u0026gt; { if (parseFloat(item.process) \u0026gt; 0) { processCount.start += 1; } else { processCount.non += 1; } });   See the Pen JS 學徒特訓班 33 關  by CHUPAIWANG (@CHUPAIWANG) on CodePen.  第三十四關：圓餅圖分析（中文字串判別）  題目連結\n 34. 問題 觀察每個參賽者的「姓名長度的字元數」\n34. 參考解答 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function strLen(str) { if (str == null) return 0; if (typeof str != \u0026#39;string\u0026#39;) { str += \u0026#39;\u0026#39;; } return str.replace(/[^\\x00-\\xff]/g, \u0026#39;01\u0026#39;).length; } let nameLengthCount = { lessSix: 0, moreSeven: 0, }; data.forEach((item)=\u0026gt; { if (strLen(item.name) \u0026gt; 6) { nameLengthCount.moreSeven += 1; } else { nameLengthCount.lessSix += 1; } });   See the Pen JS 學徒特訓班 34 關  by CHUPAIWANG (@CHUPAIWANG) on CodePen.  教學、延伸知識連結  JS判断字符串长度（英文占1个字符，中文汉字占2个字符）  第三十五關：圓餅圖與長條圖合併使用 35. 問題  範例連結\n 結合 API，同時顯示長條圖與圓餅圖，並顯示各區間完課率人數。\n35. 參考解答 注意，process 是浮點數，因此判斷區間時，\u0026lt;= 20 與 \u0026lt; 21 結果可能會有些微差異。\nSee the Pen JS 學徒特訓班 34 關  by CHUPAIWANG (@CHUPAIWANG) on CodePen. ","description":"JS 函式 24 ~ 35 關","id":75,"section":"posts","tags":["JavaScript","JS 學徒特訓班"],"title":"JS 學徒特訓班 - JS 函式 24 ~ 35 關","uri":"https://chupai.github.io/posts/2008/js60_3/"},{"content":" JavaScript筆記 目錄\n 一直沒時間將之前的筆記丟到這來，剛好最近參加 JS 學徒訓練班，就趁這次機會重新整理筆記。\n\r變數 Variable 程式碼會需要暫時儲存一些工作所需要的資料，它可以把這些資料儲存在變數中。\n變數必須先宣告才能使用它，有三種關鍵字可用來宣告：\n var：函式作用域 let：區塊作用域、無法重複宣告 const：區塊作用域、無法重複宣告、無法再次賦值  1. 使用 var 宣告變數 在 ES6 之前，var 是唯一可用於定義變數的關鍵字。\n宣告名稱為 a 的變數：\n1 2 3  var a; console.log(a); // undefined   若宣告時，未賦值，變數會被給予特殊值 undefined，表示值沒有被定義。\n建立變數後可以使用 = 指定運算子來賦值。\n1 2 3 4  var a; a = 10; console.log(a); // 10   var 可以重複宣告：\n1 2 3 4  var a = 1; var a = 2; console.log(a); // 2   雖然語法合法，但是不建議這麼做。\n在全域範圍宣告變數，變數會成為全域物件：\n1 2  var a = 10; console.log(this.a); // 10   2. 變數的資料型別 JavaScript 屬於動態定型語言，變數本身並沒有型別資訊，因此建立變數時，不需要宣告型別，同一個變數可以指定不同的資料型別。\n3. 同一個述句中宣告多個變數 1  var a, b;   4. 沒宣告的變數 不需告變數也能使用：\n1 2  a = 10; console.log(a); // 10   a 會變成全域變數，這是 JavaScript 的雷點之一。\n但在 ES5 之後，新增了嚴格模式，在嚴格模式之下，變數一定要宣告，否則會拋出錯誤。\n1 2 3 4 5 6  \u0026#39;use strict\u0026#39; a = 10; console.log(a); // Uncaught ReferenceError: msg is not defined   5. 還沒宣告的變數 在 var 宣告變數前呼叫，也不會報錯：\n1 2 3  console.log(a); // undefined var a = 10; console.log(a); // 10   這是因為變數的 提升（Hoisting） 行為。\n6. 作用域 Scope 5.1 函式作用域 使用 var 宣告變數將屬於當前的函式作用域，如果聲明位於任何函式外部的頂層，它就屬於全局作用域也就是全域變數。\n1 2 3 4 5  function num() { var a = 5; } console.log(a); // a is not defined   5.2 巢狀作用域 當你宣告了一個變數時，它就在這個作用域內的任何地方都是可用的，包括任何下層/內部作用域。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  function foo() { var a = 1; function bar() { var b = 2; function baz() { var c = 3; console.log(a, b, c); // 1 2 3  } baz(); console.log(a, b); // 1 2  } bar(); console.log(a); // 1 } foo();   7. 命名規則 變數命名規則，必須遵守以下條件：\n 不能以數字起始 不能使用關鍵字、或是保留字 任何 Unicode 都可以拿來當作 JavaScript 的變數  但這裡有一點要注意，undefined 在 JavaScript 並不是保留字：\n1 2 3 4 5 6  function foo() { var undefined = 10; return undefined; } console.log(foo()); // 10   在函式中，undefined 可以作為變數。\nlet、const 在 ES6 新增了兩種變數宣告方式。let 與 const 都是以區塊為作用域的宣告，而且不可以在同一個作用域下重複宣告，另外在全域範圍宣告變數，變數並不會成為全域物件。\n兩者差異在於 const 是常數為不能再次指定值。\n1. 以區塊為作用域的宣告 JavaScript 的變數作用域的基本單位永遠都是函式。如果需要建立一個區塊作用域，最常使用的方式就是使用立即函式運算式。\n1 2 3 4 5 6 7 8  var a = 2; (function(){ var a = 3; console.log( a ); // 3 })(); console.log( a ); // 2   而 let 或 const 只需要一對 {} 就能建立一個作用域。\n1 2 3 4 5 6 7  let a = 2; { let a = 3; console.log( a ); // 3 } console.log( a ); // 2   2. let let 最常使用的情境就是 if 迴圈，我們可以將變數的作用域限制於迴圈中。for 圓括號中的 let 變數仍然是在區塊作用域。\n舉例來說，如果使用 var 定義 i：\n1 2 3 4 5  for(var i = 0; i \u0026lt; 3; i++) { console.log(i); } console.log(i); // 3   你可以發現 i 汙染了全域。\n1 2 3 4 5  for(let i = 0; i \u0026lt; 3; i++) { console.log(i); } console.log(i); // Uncaught ReferenceError: i is not defined   for 迴圈中的 let 變數會作重新綁定。\n來看一個經典的範例：\n1 2 3 4 5 6 7 8 9  for(var i = 0; i \u0026lt; 3; i++) { setTimeout(function() { console.log(i); }, i * 1000); } // 3 // 3 // 3   因為 var 會直接將 i 宣告成全域變數，不斷透過 for 迴圈累加，在等到 setTimeout() 這個非同步程式實際執行時，只會拿到累加後的數值。\n1 2 3 4 5 6 7 8 9  for(let i = 0; i \u0026lt; 3; i++) { setTimeout(function() { console.log(i); }, i * 1000); } // 0 // 1 // 2   3. const 常數 constant 指是的數值不變的值。早期只有 var 時，宣告常數時，都是利用名稱全大寫來區分，但它還是能夠被更改。\n而使用 const 宣告變數，有一的特點，就是 「不能再次指定值」，宣告時一定要賦值。\n如果試著對 const 重新賦值，那將會報錯：\n1 2 3 4  const a = 1; a = 2; // Uncaught TypeError: Assignment to constant variable. console.log( 1 ); // 2   但如果一開始宣告的變數內容為物件型別，那其內容屬性還是可以被改變：\n1 2 3  const obj = {}; obj.a = \u0026#39;aa\u0026#39;;   你無法更改的只是變數本身。\n3. 重複宣告 上面提到，var 允許在同一個作用域下重複宣告，瀏覽器不會報錯，但 let 與 const 會出錯。\n1 2 3  let a; let a = 0; // Uncaught SyntaxError: Identifier \u0026#39;a\u0026#39; has already been declared   4. 還沒宣告的變數 上面提到，var 在其宣告的前後範圍都是有效的，是因為有 提升。\n但大部分的情況下，同常不應該有提升行為的出現，我們來看 let 的情況：\n1 2 3  console.log(a); // Uncaught ReferenceError: Cannot access \u0026#39;a\u0026#39; before initialization let a = 10;   let 在正式值行前，變數不會賦值，因在沒值的狀況下被存取就會拋出錯誤。\n撰寫風格 參考以下常見 ESLint 規範：\n Airbnb JavaScript Style Guide Google JavaScript Style Guide  總結幾點建議：\n let 可完全替代 var，不應該再繼續使用 var 宣告變數； 優先使用 const，除非需要再指定值才用 let； 不使用逗號 , 將變數值宣告在同一行； 不要將變數都放在區塊的最上層，而是在合理位置，在首次被使用的上面一行來宣告變數。 ","description":"JavaScript 變數 var、let、const","id":76,"section":"posts","tags":["JavaScript","ES6","變數"],"title":"變數","uri":"https://chupai.github.io/posts/2008/js_variable/"},{"content":" 竹白的 JS 學徒特訓班筆記 - 目錄\n 記錄六角學院所開的 JS 學徒特訓班，為期 60天的特訓。\n\r第十一關：函式參數再練習  題目連結\n 劇情略。\n11. 問題 題目一：老闆想要隨時扣你的薪水\n老闆：「今天是發薪日，先發給你薪資 23500 元(遞給小杰」\n老闆：「以下三步驟動作請寫成程式」\n老闆：「步驟一：昨天你上廁所太久了，我要扣你 1000 元」\n老闆：「步驟二：小黑說不喜歡你煮的狗食，我要再扣你 3500 元 (再次取走」\n老闆：「步驟三：我今天心情不太好，扣個 500 元意思一下」\n小杰：「屁啦！心情不太好關我啥事！」\n老闆：「這不是重點，快點算！將之前的寫法換成函式，並增加一個參數，讓我方便何時扣你多少都沒問題」\n老闆：「最後你寫的函式，要執行三次，每次都要回報你的總薪水剩下多少。」\n1 2 3 4 5  var salary = 23500; //請依照上面的武功秘笈 Codepen，依序實現兩步驟，算出小杰被扣了多少錢  console.log(\u0026#39;小杰目前還剩下\u0026#39; + salary + \u0026#39;元\u0026#39;);   題目二： if + 指派運算子\n老闆：「好了，現在我要告訴你贈品條件！」\n 目前小杰手上有 3 個贈品 消費滿 100 元就送對方贈品  下圖為第八關截圖，請依照以下邏輯進行改寫：\n 現在來了三個客人，並依序有消費，A顧客消費 150、B 顧客消費 99、C 顧客消費 110。 請設計一個函式，裡面代入一個參數為顧客消費金額，確認該客戶是否符合贈品條件，若符合就讓 giftNum 變數減少數量。 並依序執行三次函式，每次函式皆會 return 目前贈品數量剩下多少。  1 2 3 4 5 6 7 8 9  var giftNum = 3; // 贈品數量 var customerA = 150; // 顧客 A 消費金額 var customerB = 99; // 顧客 B 消費金額 var customerC = 99; // 顧客 C 消費金額  if (客戶A條件) {} if (客戶B條件) {} console.log(\u0026#39;目前贈品剩下\u0026#39; + giftNum + \u0026#39;個\u0026#39;);   題目三：if + 指派運算子\n老闆：「我現在補齊給你總計 200 個贈品！」\n老闆：「然後我覺得現在贈品門檻太高了，我決定大放送，只要滿 50 元就送一個！以此類推，他買 500 元就送 10 個贈品！」\n小杰：「老闆你竟然利用我的特休，我跟你沒完啦。」\n老闆：「別廢話，客人來了快點！他買完後告訴我贈品還夠不夠！」\n下圖為第八關截圖，giftNum 已改為 200 份，請依照以下邏輯進行改寫：\n 請用函式改寫，同時來了三組客人，請用你寫的函式連續執行三次，來幫助顧客是否有符合贈品條件。 另外每次執行函式時，都必須告訴老闆一次目前贈品數量。  第一組客人：Mary 買了 10 份薯條，10 份漢堡\n第二組客人：Bob 買了 1 份薯條\n第三組客人：Tim 買了 20 份薯條，15 份漢堡\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var giftNum = 200; // 贈品數量 var friesPrice = 30; // 薯條單價 var hamburgerPrice = 50; // 漢堡單價  // 以下是題目 // mary 買了 10 份薯條，10 份漢堡 // 請計算完贈品規則後，善用指派運算子去計算目前剩下的贈品有幾個 // 並用下面的 if 回報給老闆  if (條件式) { console.log(\u0026#39;老闆！贈品還夠！剩下\u0026#39; + giftNum + \u0026#39;個~\u0026#39;); } else { console.log(\u0026#39;老闆贈品賣光啦~\u0026#39;); }   11. 參考解答 題目一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function calculate(num) { salary -= num; return salary; } calculate(1000); console.log(\u0026#39;小杰目前還剩下\u0026#39; + salary + \u0026#39;元\u0026#39;); // \u0026#39;小杰目前還剩下22500元 \u0026#39;  calculate(3500); console.log(\u0026#39;小杰目前還剩下\u0026#39; + salary + \u0026#39;元\u0026#39;); // \u0026#39;小杰目前還剩下19000元\u0026#39;  calculate(500); console.log(\u0026#39;小杰目前還剩下\u0026#39; + salary + \u0026#39;元\u0026#39;); // \u0026#39;小杰目前還剩下18500元\u0026#39;   題目二：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function calculate(num) { if (num \u0026gt;= 100) { giftNum -= 1; } return giftNum; } calculate(customerA); console.log(\u0026#39;目前贈品剩下\u0026#39; + giftNum + \u0026#39;個\u0026#39;); // 目前贈品剩下2個  calculate(customerB); console.log(\u0026#39;目前贈品剩下\u0026#39; + giftNum + \u0026#39;個\u0026#39;); // 目前贈品剩下2個  calculate(customerC); console.log(\u0026#39;目前贈品剩下\u0026#39; + giftNum + \u0026#39;個\u0026#39;); // 目前贈品剩下1個   題目沒說明，因此這裡不考慮贈品不足（giftNum 變負數）的情況。\n題目三：\n1 2 3 4 5 6 7 8 9 10 11 12 13  function calculate(friesNum = 0, hamburgerNum = 0) { let total = friesPrice * friesNum + hamburgerPrice * hamburgerNum; giftNum -= Math.floor(total / 50); if (giftNum \u0026gt; 0) { console.log(\u0026#39;老闆！贈品還夠！剩下\u0026#39; + giftNum + \u0026#39;個~\u0026#39;); } else { console.log(\u0026#39;老闆贈品賣光啦~\u0026#39;); } } calculate(10, 10); // 老闆！贈品還夠！剩下184個 calculate(1); // 老闆！贈品還夠！剩下184個 calculate(20, 15); // 老闆！贈品還夠！剩下157個   第十二關：DOM 操作  題目連結\n 劇情略。\n12. 題目  請觀看此 Codepen 的線索，試圖找到密碼，並在 Slack 上回傳密碼 以下 Codepen 的 HTML 與 CSS 面板都壞掉了，你只能編輯 JS 面板，來去尋找線索  12. 參考解答 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  let url = \u0026#39;https://hexschool.github.io/JSTraining/stage12/\u0026#39;; // 區塊一，路徑放錯了，得用 setAttribute 換 src 屬性，換成 1.png document.querySelector(\u0026#39;.keyItem1 img\u0026#39;).setAttribute(\u0026#39;src\u0026#39;, `${url}1.png`); // 區塊二，唯一有放對，不需更改  // 區塊三，請用 innerHTML，指定 keyItem3，讓他插入 3.png 圖片 document.querySelector(\u0026#39;.keyItem3\u0026#39;).innerHTML = ` \u0026lt;div class=\u0026#34;keyItem keyItem3\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;${url}3.png\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt;`; // 區塊四，只能用 style 插入 background 4.png document.querySelector(\u0026#39;.keyItem4\u0026#39;).style.background = `url(\u0026#34;${url}4.png\u0026#34;)`;   解答 Codepen\n教學、延伸知識連結  JavaScript 教程 - DOM 現代 JavaScript 教程 - Document  第十三關：函式+if 判斷  題目連結\n 劇情略。\n13. 問題 以下為 BMI 計算方式：\n BMI 計算為：體重(公斤) / 身高的平方(單位為公尺)  例如 150 公分 50 kg = 50/(1.5*1.5) = 22.2 BMI 指數   BMI 數值狀態如下  體重過輕：BMI ＜ 18.5 正常：18.5 ≦ BMI ＜ 24 過重：24 ≦ BMI ＜ 27 輕度肥胖：27 ≦ BMI ＜ 30 中度肥胖：30 ≦ BMI ＜ 35 重度肥胖：BMI ≧3 5　    小杰打開 Code 才發現，裡面的 if 判斷根本都在亂寫，請依照上面的 BMI 狀態來改寫，並還小杰一個清白。\n請修改此 Codepen，並將修改結果回傳到 Slack。\n1 2 3 4 5 6 7 8 9 10  function calculationBMI(height, kg) { var bmi = kg / (height / 100 * height / 100); if (bmi \u0026gt; 20) { return \u0026#39;過胖！但能吃就是福，維持現況也沒什麼不好的~\u0026#39;; } else { return \u0026#39;你很瘦~ㄕㄡˋ~~\u0026#39;; } } console.log(calculationBMI(178, 70));   13. 參考解答 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  if (bmi \u0026lt; 18.5) { return \u0026#39;體重過輕\u0026#39;; } if (bmi \u0026lt;= 24) { return \u0026#39;正常\u0026#39;; } if (bmi \u0026lt;= 27) { return \u0026#39;過重\u0026#39;; } if (bmi \u0026lt;= 30) { return \u0026#39;輕度肥胖\u0026#39;; } if (bmi \u0026lt;= 35) { return \u0026#39;中度肥胖\u0026#39;; } return \u0026#39;重度肥胖\u0026#39;;   if 裡面已經使用 return，就不建議使用多餘的 else if 了。\n教學、延伸知識連結  禁止在 else 前有 return (no-else-return)｜ESLint 避免隨意而重複的if\u0026hellip;else JavaScript 复杂判断的更优雅写法 WEB前端if else 性能优化指南\n 理解 JavaScript 中的策略模式  第十四關：監聽與函式設計  題目連結\n 劇情略。\n14. 題目 小杰打開網頁後，發現工讀生只把 HTML 標籤寫好，JS 完全沒寫，\n因為 HTML 面板已經壞掉了，請直接修改 JS Code，\n讓 .total 的顯示數值，可以正常運作。\n並在 Slack 上回傳 carbon JS Code 與 Codepen。\nBMI 2.0版 Codepen 網址\n1 2 3 4 5 6 7  \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;height\u0026#34; placeholder=\u0026#34;請輸入您的身高(公分)\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;kg\u0026#34; placeholder=\u0026#34;請輸入您的體重(公斤)\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; class=\u0026#34;send\u0026#34; value=\u0026#34;計算\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;total\u0026#34;\u0026gt;您的 BMI 指數為 \u0026lt;span class=\u0026#34;BMI\u0026#34;\u0026gt;22\u0026lt;/span\u0026gt;， 狀態是 \u0026lt;span class=\u0026#34;status\u0026#34;\u0026gt;正常\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt;   14. 參考解答 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  document.querySelector(\u0026#39;.send\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, function () { let heightDom = document.querySelector(\u0026#39;.height\u0026#39;); let kgDom = document.querySelector(\u0026#39;.kg\u0026#39;); let height = Number(heightDom.value); let kg = Number(kgDom.value); let totalDom = document.querySelector(\u0026#39;.total\u0026#39;); // 若輸入不合法的值  if (isNaN(height) || isNaN(kg) || height \u0026lt; 1 || kg \u0026lt; 1) { totalDom.textContent = \u0026#39;請輸入大於 1 的數字\u0026#39;; return; } let bmi = Math.floor(kg / (((height / 100) * height) / 100)); let result = bmiResult(bmi); totalDom.innerHTML = ` 您的 BMI 指數為 \u0026lt;span class=\u0026#34;BMI\u0026#34;\u0026gt;${bmi}\u0026lt;/span\u0026gt;， 狀態是 \u0026lt;span class=\u0026#34;status\u0026#34;\u0026gt;${result}\u0026lt;/span\u0026gt;`; }); function bmiResult(bmi) { if (bmi \u0026lt; 18.5) { return \u0026#39;體重過輕\u0026#39;; } if (bmi \u0026lt;= 24) { return \u0026#39;正常\u0026#39;; } if (bmi \u0026lt;= 27) { return \u0026#39;過重\u0026#39;; } if (bmi \u0026lt;= 30) { return \u0026#39;輕度肥胖\u0026#39;; } if (bmi \u0026lt;= 35) { return \u0026#39;中度肥胖\u0026#39;; } return \u0026#39;重度肥胖\u0026#39;; }   教學、延伸知識連結  小tips: JS DOM innerText和textContent的区别\n  第十五關：物件運用 - 資料與渲染分離  題目連結\n 劇情略。\n15. 問題 以下是護理師改寫小杰的邏輯，程式碼連結\n護理師拿了之前工讀生的 Code 改寫，根本沒用小杰的。但可以看得出來，這個 Code 有刻意遺留了些不完整的地方，像是 bmiData 的物件沒有將條件寫完整，頗有想要再次考驗小杰的味道。\n請各位將你們的 Code 跟護理師的進行比較，看看差異在哪裡，並透過 Slack 分享自己吸收的結果，並試著依照自己的邏輯寫一遍。\n這次 HTML 面板壞掉了，你唯一可以改的面板只有 CSS 與 JS 面板。\n15. 參考解答 這裡就不優化了，直接補齊缺的部分。\n補齊所有狀態顏色：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  .blue { color: blue; } .green { color: green; } .pink { color: pink; } .orange { color: orange; } .purple { color: purple; } .red { color: red; }   建議語意化命名 class 名稱，但這裡就依照題目吧。\n補齊 BMIData 物件狀態：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  var BMIData = { overThin: { statusText: \u0026#39;體重過輕\u0026#39;, class: \u0026#39;blue\u0026#39;, }, normal: { statusText: \u0026#39;正常\u0026#39;, class: \u0026#39;green\u0026#39;, }, overweight: { statusText: \u0026#39;過重\u0026#39;, class: \u0026#39;pink\u0026#39;, }, mildObesity: { statusText: \u0026#39;輕度肥胖\u0026#39;, class: \u0026#39;orange\u0026#39;, }, moderateObesity: { statusText: \u0026#39;中度肥胖\u0026#39;, class: \u0026#39;purple\u0026#39;, }, severeObesity: { statusText: \u0026#39;重度肥胖\u0026#39;, class: \u0026#39;red\u0026#39;, }, };   補齊 calculationBMI 函式：\n1 2 3 4 5 6 7 8 9 10 11 12 13  if (bmi \u0026lt; 18.5) { render(\u0026#39;overThin\u0026#39;, bmi); } else if (bmi \u0026lt;= 24) { render(\u0026#39;normal\u0026#39;, bmi); } else if (bmi \u0026lt;= 27) { render(\u0026#39;overweight\u0026#39;, bmi); } else if (bmi \u0026lt;= 30) { render(\u0026#39;mildObesity\u0026#39;, bmi); } else if (bmi \u0026lt;= 35) { render(\u0026#39;moderateObesity\u0026#39;, bmi); } else { render(\u0026#39;severeObesity\u0026#39;, bmi); }    render 函式加入其他 class 前要先清除所有 class 樣式：\n1  statusDOM.classList.remove(...statusDOM.classList);   解答 CodePen\n教學、延伸知識連結  JavaScript 設計模式：關注點分離 Fastest way to clear classList  第十六關：forEach 與 HTML 字串累加  題目連結\n 劇情略。\n16. 問題 小杰一時間還不知道怎麼寫，所以先寫了陣列 + forEach 的方式來累加 HTML 字串，再來顯示介面出來。範例程式碼\n請你依照這邏輯，試著改寫物件格式，呈現的格式如下程式碼。\n設計好物件後，依序 push 五筆資料到陣列裡，最後整理完字串資料，再 innerHTML 到 ul 裡。\n這次 HTML 與 CSS 面板都壞了，請改寫 JS 面板。\nPS:請拿上面的 Codepen 改寫即可，不需拿前幾關的 code 來整合\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;小杰的身高為 178 公分，體重是 70 公斤，BMI 數據為 20，狀態為正常\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;小美的身高為 150 公分，體重是 200 公斤，BMI 數據為 38，狀態為超重\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 16. 參考答案： 物件格式改寫，我改一個就好，剩下雷同。\n1 2 3 4 5 6 7  { name: \u0026#39;廖洧杰\u0026#39;, height: 178, kg: 70, bmi: 22, status: \u0026#39;正常\u0026#39;, }   str 拿出來，避免每次迭代都被重置，並使用字串樣板加入變數。\n1 2 3 4 5 6 7 8 9 10  var str = \u0026#39;\u0026#39;; data.forEach(function (item) { var content = ` \u0026lt;li\u0026gt;${item.name}的身高為 ${item.height}公分， 體重是 ${item.kg}公斤， BMI 數據為 ${item.bmi}， 狀態為${item.status}\u0026lt;li\u0026gt;`; str += content; list.innerHTML = str; });   教學、延伸知識連結  樣板字面值｜MDN  第十七關：innerHTML+forEach  題目連結\n 劇情略。\n17. 問題 明明陣列裡面有五筆資料，但寫出來的程式碼，列表永遠只顯示一筆資料，究竟小杰哪裡觀念有問題呢？一起來幫助小杰吧~\n小杰程式碼網址\n請思考並在 Slack 回覆：\n str 放 forEach 外頭跟裡面的差異 innerHTML 放 forEach 外頭跟裡面的差異 innerHTML 當要寫內容進去時，會不會將裡面內容給覆蓋掉？  17. 參考解答  作用域不同，一個是全域，另一個只作用在 forEach 的 callback 函式內。放在外面才會累加結果。 innerHTML 放在外面就不會迭代，只會跑一次。 會覆蓋。  教學、延伸知識連結  append()、appendChild() 和 innerHTML 的区别\n ParentNode.append()｜MDN  第十八關：字串相加 innerHTML+ 樣式搭配  題目連結\n 劇情略。\n18. 問題 挑戰者們不要忘了，JS 始終要搭配妳寫好的 CSS 來進行渲染，護理師好像已經看膩了小杰爛到不行的陽春版本，寫了一個 .list2 版本，請依照他的 CSS 樣式邏輯，將 data 陣列裡面的資料，依序渲染到 .list2 裡面的 li 來顯示。\n護理師的 Codepen 網址\n18. 參考解答 1 2 3 4 5 6 7 8 9 10 11  var list2 = document.querySelector(\u0026#39;.list2\u0026#39;); var str = \u0026#39;\u0026#39;; data.forEach(function (item) { var content = ` \u0026lt;li class=\u0026#34;list-card\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;${item.name}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;你的身高是${item.height}\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt;`; str += content; }); list.innerHTML = str;   第十九關：驗收前夕  題目連結\n 劇情略。\n19. 問題 小杰打開師傅的程式碼，才發現這程式碼其實是來自於 Vic 這位工程師的範例程式碼。\n雖然跟設計稿有非常大的差異，但從程式邏輯中，慢慢掌握到了一些概念。\n請解讀 Vic 的（程式碼），並在 Slack 上回報他以下邏輯是做了什麼事情：\n arrayBMIrecord 的陣列用途是什麼？ 請描述 calculateBMI 函式做了什麼事情 請描述 render 函式做了什麼事情  19. 參考解答  儲存處理過的資料。 處理資料、將資料丟到 arrayBMIrecord、並執行 render 函式。 渲染 arrayBMIrecord 資料到畫面上。  第二十關：BMI 計算機團戰關卡  題目連結\n 劇情略。\n20. 題目  UI 設計稿  完成上方 UI 設計稿。\n20. 參考解答  使用樣板：HexSchool-BMI (Erica) CodePen：連結  教學、延伸知識連結  input type number｜MDN  第二十一關：BMI 追加功能  題目連結\n 劇情略。\n22. 問題 可憐的小杰又被威脅了，原來院長想要統計每次 BMI 測量的總平均值，一起做完這最後的需求，讓小杰順利離開醫院吧！\n22. 參考解答 1  \u0026lt;span class=\u0026#34;js-bmiAverage\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt;   1 2 3 4 5 6 7 8 9 10  const bmiAveragea = document.querySelector(\u0026#39;.js-bmiAverage\u0026#39;); function render() { let sum = 0; arrayBMIrecord.forEach((item) =\u0026gt; { sum += item.bmi; }); let avg = Math.floor(sum / arrayBMIrecord.length) || 0; bmiAveragea.textContent = avg; }   CodePen 解答\n第二十二關：陣列調整  題目連結\n 劇情略。\n22. 問題 最新的資料放在第一筆，讓最新資料都能排序在最前面，將資料進行反轉。\n22. 參考解答 有好幾種做法，渲染時，從後面迭代資料：\n1 2 3 4  for (let i = arrayBMIrecord.length - 1; i \u0026gt; 0; i -= 1) { const item = arrayBMIrecord[i]; // ... }   或是先淺拷貝一份資料，並使用 reverse() 反轉陣列，再迭代資料：\n1 2 3 4 5  let temp = [...arrayBMIrecord].reverse(); temp.forEach( // ... );   或是添加資料時，使用 unshift() 將最新資料加在最前面：\n1  arrayBMIrecord.unshift(userRecord);   但使用 unshift 效率不佳，因為背後的運作原理會將每個元素往後移動。\nCodePen 解答\n教學、延伸知識連結  Array的push与unshift方法性能分析  第二十三關：資料格式處理，陣列 unshift  題目連結\n 劇情略。\n23. 問題 小杰一看到題目整個傻眼，裡面用了他從來沒看過的圖表資料，好在老闆在程式碼裡面寫了些註解，讓小杰知道自己不需要懂圖表框架，好好的把資料處理好後，圖表自然就會顯示正常，一起來幫幫小杰吧！\n以下是預期希望出現正常的圖表，請改寫此 Codepen，並在 Slack 回傳你的解法：\nPS：HTML 與 CSS 面板壞掉了，只能變更 JS 面板\n23. 參考解答 1  monthMoney.unshift(title);   ","description":"JS 函式 23 ~ 20 關","id":77,"section":"posts","tags":["JavaScript","JS 學徒特訓班"],"title":"JS 學徒特訓班 - JS 函式 11 ~ 23 關","uri":"https://chupai.github.io/posts/2008/js60_2/"},{"content":" 竹白的 JS 學徒特訓班筆記 - 目錄\n 記錄六角學院所開的 JS 學徒特訓班，為期 60天的特訓。\n\r第一關：環境與變數環境  題目連結\n 1. 題目 第 1 題：\n1 2 3 4 5 6  // 1.產生 console.log 從上到下的值為？ // 2.出現幾個變數、型別、記憶體物件? var a; a = 1; a = \u0026#39;hello\u0026#39;; console.log(a);   第 2 題：\n1 2 3 4 5 6 7  // 1.產生 console.log 從上到下的值為？ // 2.出現幾個變數、型別、記憶體物件? var b = 3; var c = 4; console.log(d); var d = b + c; console.log(d);   第 3 題：\n1 2 3 4 5 6 7 8  // 1.產生 console.log 從上到下的值為？ // 2.出現幾個變數、型別、記憶體物件? console.log(e); var e; e = 5; e = \u0026#39;hello\u0026#39;; e = true; console.log(e);   1. 參考解答 第 1 題：\n \u0026quot;hello\u0026quot; 1個變數、2個型別、3個記憶體物件  1 2 3 4  var a ; // 已經有記憶體空間，但沒有值 a = 1; // 數值 a = \u0026#39;hello\u0026#39;; // 字串 console.log(a); // \u0026#34;hello\u0026#34;   第 2 題：\n undefined、7 3個變數、1個型別、6個記憶體物件  1 2 3 4 5 6 7 8  var b; // 已經有記憶體空間，但沒有值 var c; // 已經有記憶體空間，但沒有值 var d; // 已經有記憶體空間，但沒有值 console.log(d); // undefined b = 3; // 數值 c = 4; // 數值 d = b + c; // 數值 console.log(d); // 7   第 3 題：\n undefined、true 1個變數、3個型別、4個記憶體物件  1 2 3 4 5 6  var e; // 已經有記憶體空間，但沒有值 console.log(e); // undefined e = 5; // 數值 e = \u0026#39;hello\u0026#39;; // 字串 e = true; // 布林值 console.log(e); // true   教學、延伸知識連結  記憶體管理｜MDN 鐵人賽：JavaScript 變數的宣告與他的作用域 【译】JavaScript的内存管理和 4 种处理内存泄漏的方法  第二關：變數命名  題目連結\n 2. 題目 請依照以下房型資訊，去定義各個變數名稱，變數務必要命名比較語意化且好懂。\n3. 參考解答 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  const singleRoom = { peopleLimit: 1, bedSize: \u0026#39;單人床\u0026#39;, bathroomNum: 1, roomSize: 18, feetSize: \u0026#39;平方公尺\u0026#39;, description: \u0026#39;Single Room is only...\u0026#39;, checkInTimeFrom: \u0026#39;15:00\u0026#39;, checkInTimeTo: \u0026#39;21:00\u0026#39;, checkOutTimeFrom: \u0026#39;10:00\u0026#39;, checkOutTimeTo: \u0026#39;21:00\u0026#39;, facilities: { wifi: true, landlinePhone: true, breakfast: true, airConditioning: true, minibar: false, refrigerator: true, }, }   教學、延伸知識連結  無瑕的 JavaScript 程式碼（正體中文版）  第三關：變數型別轉換  題目連結\n 3. 題目 請依序告知以下 console.log 會顯示什麼值。\n第一題：\n1 2 3 4 5 6 7 8 9 10 11 12  var a = 1; console.log(typeof a); var b = \u0026#39;hello\u0026#39;; console.log(typeof b); var c = 1 + \u0026#39;hello\u0026#39;; console.log(typeof c); var d = 1 + \u0026#39;11\u0026#39;; console.log(d); console.log(typeof d);   第二題：\n1 2 3 4 5 6 7  var a; a = a + \u0026#39;hello\u0026#39;; console.log(a); console.log(typeof a); var b = 3; console.log(b * \u0026#39;hello\u0026#39;);   第三題：\n1 2 3 4 5 6 7  var a = 9; console.log(a + 9); console.log(a + \u0026#39;9\u0026#39;); var b = \u0026#39;9\u0026#39;; console.log(b * b); console.log(typeof (b * b));   3. 參考解答 第一題：\n1 2 3 4 5 6 7 8 9 10 11 12 13  var a = 1; console.log(typeof a); // \u0026#39;number\u0026#39;  var b = \u0026#39;hello\u0026#39;; console.log(typeof b); // \u0026#39;string\u0026#39;  var c = 1 + \u0026#39;hello\u0026#39;; console.log(typeof c); // \u0026#39;string\u0026#39;  var d = 1 + \u0026#39;11\u0026#39;; console.log(d); // \u0026#39;111\u0026#39; 隱含的強制轉型 console.log(typeof d); // \u0026#39;string\u0026#39;    使用 + 運算子，其中一邊為字串型別，會將另一邊強制轉型成字串。\n依據 ES5.1 語言規格的 section 11.6.1：\n 只要其中一邊為字串，就是字串相接：  非字串的型別會強制轉型成字串。   若雙方皆為非字串：  基本型別的值會轉為數值，物件型別（物件、陣列、函式）會先進行 ToPrimitive 轉換； 如果雙邊都沒有字串，就會進行數值運算。    第二題：\n1 2 3 4 5 6 7  var a; a = a + \u0026#39;hello\u0026#39;; console.log(a); // \u0026#39;undefinedhello\u0026#39; 隱含的強制轉型 console.log(typeof a); // \u0026#39;string\u0026#39;  var b = 3; console.log(b * \u0026#39;hello\u0026#39;); // NaN 隱含的強制轉型   -、*、/ 運算子與 + 運算子不同，它們只能對數值進行運算使用，因此會將非數值的值轉成數值。\n數值轉換過程是根據 ES5 的規格中 section 9.3 的 ToNumber：\n undefined：NaN null：+0 即 0 布林值：  true：1 false：+0 即 0   字串：數值或 NaN 物件型別（物件、陣列、函式）  會先進行 ToPrimitive 轉換，再執行 ToNumber    第三題：\n1 2 3 4 5 6 7  var a = 9; console.log(a + 9); // 18 console.log(a + \u0026#39;9\u0026#39;); // \u0026#39;99\u0026#39; 隱含的強制轉型  var b = \u0026#39;9\u0026#39;; console.log(b * b); // 81 隱含的強制轉型 console.log(typeof (b * b)); // \u0026#39;number\u0026#39;   教學、延伸知識連結  You Dont Know JS：型別與文法 第四章：強制轉型  第四關：比較運算子  題目連結\n 4. 題目 請依序告知以下 console.log 會顯示什麼值，若不知道答案，可將 code 貼在 chrome console 來顯示後，再回頭補知識點。\n第一題：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var a = 2; var b = 1; console.log(a \u0026gt; 0); console.log(a + b \u0026gt; 1); var c = 4; var d = 3; console.log(c == d); var e = 8; var f = 5; console.log(f \u0026gt;= e); console.log(f != e); console.log(f == e);   第二題 搭配型別自動轉型：\n1 2 3 4 5 6 7 8 9  var a = 3; var b = \u0026#39;3\u0026#39;; console.log(a == 1); console.log(a == b); var c = 2; var d = \u0026#39;5\u0026#39;; // 請解釋為什麼 console.log(c * d \u0026gt;= 5);   第三題 嚴謹模式：\n1 2 3 4 5 6  var a = 1; var b = \u0026#39;1\u0026#39;; console.log(a == 1); console.log(a == b); console.log(a === b); console.log(a !== b);   4. 參考解答 第一題：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var a = 2; var b = 1; console.log(a \u0026gt; 0); // true console.log(a + b \u0026gt; 1); // true  var c = 4; var d = 3; console.log(c == d); // false  var e = 8; var f = 5; console.log(f \u0026gt;= e); // false console.log(f != e); // true console.log(f == e); // false   第二題：\n1 2 3 4 5 6 7 8 9  var a = 3; var b = \u0026#39;3\u0026#39;; console.log(a == 1); // false console.log(a == b); // true  var c = 2; var d = \u0026#39;5\u0026#39;; // 請解釋為什麼 console.log(c * d \u0026gt;= 5); // true   第四關有說明過了，* 運算子只能對數值進行運算使用，因此會將非數值的值強制轉成數值。\n第三題：\n1 2 3 4 5 6  var a = 1; var b = \u0026#39;1\u0026#39;; console.log(a == 1); // true console.log(a == b); // true console.log(a === b); // false console.log(a !== b); // true   教學、延伸知識連結  You Dont Know JS：型別與文法 第四章：強制轉型 JavaScript 中的相等性視覺化圖表 JavaScript Equality Table   第五關：變數實作情境題  題目連結\n 劇情略。\n5. 問題 第一題：顧客 Bob 向店員詢價\n顧客 Bob：「請問我要買 4 個漢堡，30 份薯條，總共多少？」\n1 2 3 4 5 6 7 8 9 10  // 定義薯條跟漢堡的金額（金額不可以更改） var hamburgerPrice = 50; var friesPrice = 40; var bobTotal; // Code 寫在這，運算內容賦予到 bobTotal， // 並要利用到 hamburgerPrice、friesPrice // 算出 Bob 的提問。  console.log(\u0026#39;Bob 您好，您詢問的金額總計為\u0026#39; + bobTotal + \u0026#39;元\u0026#39;);   第二題：錢包剩下多少錢\nMark 錢包裡有 200 元，買了一個漢堡，三個薯條，他還剩下多少錢？\n1 2 3 4 5 6 7 8 9 10 11  // 定義薯條跟漢堡的金額（金額不可以更改） var hamburgerPrice = 50; var friesPrice = 40; var markWallet = 200; var markTotal; // Code 寫在這，運算內容賦予到 markTotal， // 並要利用到 markWallet、hamburgerPrice、friesPrice // 算出 Mark 購買後剩餘的金額。  console.log(\u0026#39;馬克買完東西後，錢包剩下\u0026#39; + markTotal + \u0026#39;元\u0026#39;);   第三題：顧客 Mary 提供折扣券\n顧客 Mary 身上有 5000 元，想要買 10 份漢堡、10 份薯條，因為他有會員卡，所以可以打九折優惠，請問他還剩下多少錢？\n1 2 3 4 5 6 7 8 9 10 11 12  // 定義薯條跟漢堡的金額（金額不可以更改） var hamburgerPrice = 50; var friesPrice = 40; var sale = 0.9; var maryWallet = 5000; var maryTotal; // Code 寫在這，運算內容賦予到 maryTotal， // 並要利用到 hamburgerPrice、friesPrice、sale、maryWallet // 算出 maryTotal 購買後剩餘的金額。  console.log(\u0026#39;Mary 買完東西後，錢包剩下\u0026#39; + maryTotal + \u0026#39;元\u0026#39;);   5. 參考解答 第一題：\n1 2 3  bobTotal = hamburgerPrice * 4 + friesPrice * 30; // Bob 您好，您詢問的金額總計為1400元   第二題：\n1 2 3  markTotal = markWallet - (hamburgerPrice * 1 + friesPrice * 3); // 馬克買完東西後，錢包剩下30元   第三題：\n1 2 3  maryTotal = maryWallet - (hamburgerPrice * 10 + friesPrice * 10) * sale; // Mary 買完東西後，錢包剩下4190元   第六關：邏輯運算子情境題  題目連結\n 劇情略。\n6. 題目 題目一：布林與比較運算子練習\n成為 VIP 會員的條件，只要購買滿 200 元，就可無條件成為會員，Bob 買了 2 個漢堡，2 個 薯條，是否有滿足條件？\n1 2 3 4 5 6 7 8 9 10  var VIPTotal = 200; var hamburgerPrice = 50; var friesPrice = 30; var isVIP; // 請透過比較運算子，將比較結果寫在 isVip 上 // 請利用 VIPTotal、hamburgerPrice、friesPrice 的變數進行比較 // isVIP 的型別必須為布林值 (true or false)  console.log(\u0026#39;Bob 的 VIP 條件為\u0026#39; + isVIP);   題目二：三心二意的老闆希望用邏輯運算子 \u0026amp;\u0026amp;\n老闆發現大家都只買薯條衝 VIP 資格，導致大家都不買漢堡，老闆好生氣，他認為他的美味蟹堡是全美最好吃的，小杰也不知道他的自信從哪裡來的。\n所以他跟小杰說，從今天起，VIP 條件必須同時符合以下兩點，才能成為 VIP 資格。\n 一次消費滿 200 元 一定要買 1 個漢堡  這時又來了兩位顧客，Mary 與 Mark，來看看他們有沒有符合條件吧！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // 此變數不可更改 var VIPTotal = 200; var hamburgerPrice = 50; var friesPrice = 30; var markHamburgerNum = 2; var markfriesNum = 4; var markIsVIP; // 如上面新增的變數，馬克買了 2 個漢堡，與 4 個薯條 // 請同時運用比較運算子與邏輯運算子，將比較結果寫在 markIsVIP 上 // markIsVIP 的型別必須為布林值 (true or false)  console.log(\u0026#39;mark 的 VIP 條件為\u0026#39; + markIsVIP); var maryHamburgerNum = 0; var maryfriesNum = 10; var maryIsVIP; // 如上面新增的變數，Mary 買了 0 個漢堡，與 10 個薯條 // 請同時運用比較運算子與邏輯運算子，將比較結果寫在 markIsVIP 上 // maryIsVIP 的型別必須為布林值 (true or false)  console.log(\u0026#39;mary 的 VIP 條件為\u0026#39; + maryIsVIP);   題目三：Mary 很生氣，他覺得現在的 VIP 資格吃人夠夠，希望用 || 邏輯運算子\nMary 說：「老闆我好歹是忠實老客戶欸，我買了你八年的薯條，而且遠遠超過 200 元，竟然還不算我是 VIP，你有沒有搞錯！」\n老闆怕了，他很擔心會上台灣的老天鵝娛樂被當作笑柄，所以他立馬將 VIP 條件改成，只要符合以下任一點消費條件，就能成為 VIP 資格。\n 一次消費滿 200 元 一定要買 1 個漢堡  我們再看看 Mary 有沒有符合條件吧！\n1 2 3 4 5 6 7 8 9 10 11 12 13  var VIPTotal = 200; var hamburgerPrice = 50; var friesPrice = 30; var maryHamburgerNum = 0; var maryfriesNum = 10; var maryIsVIP; // 如上面新增的變數，Mary 買了 0 個漢堡，與 10 個薯條 // 請同時運用比較運算子與邏輯運算子，將比較結果寫在 markIsVIP 上 // maryIsVIP 的型別必須為布林值 (true or false)  console.log(\u0026#39;mary 的 VIP 條件為\u0026#39; + maryIsVIP);   6. 參考解答 題目一：\n1 2 3  isVIP = hamburgerPrice * 2 + friesPrice * 2 \u0026gt;= VIPTotal; // Bob 的 VIP 條件為false   題目二：\n1 2 3 4 5 6 7 8 9 10 11  markIsVIP = markHamburgerNum \u0026gt; 1 \u0026amp;\u0026amp; hamburgerPrice * markHamburgerNum + friesPrice * markfriesNum \u0026gt;= VIPTotal; // mark 的 VIP 條件為true  maryIsVIP = maryHamburgerNum \u0026gt; 1 \u0026amp;\u0026amp; hamburgerPrice * maryHamburgerNum + friesPrice * maryfriesNum \u0026gt;= VIPTotal; // mary 的 VIP 條件為false   題目三：\n1 2 3 4 5  maryIsVIP = maryHamburgerNum \u0026gt; 1 || hamburgerPrice * maryHamburgerNum + friesPrice * maryfriesNum \u0026gt;= VIPTotal; // mary 的 VIP 條件為true   教學、延伸知識連結  運算式與運算子｜MDN 運算子優先序｜MDN  第七關：if - 認真的小杰竟被客訴  題目連結\n 劇情略。\n7. 題目 題目一：if 的練習\n老闆說現在要來驗收 if 成果，\n成為 VIP 會員的條件，只要購買滿 200 元，\n現在 會員 A 購買了 350 元，請用 if 判斷是否要給他 VIP 卡。\n1 2 3 4 5  var VIPTotal = 200; var memberPrice = 350; // 請透過 if 來設計回覆，如果對方滿足門檻 // 就回覆 console.log(\u0026#34;您好，您有達到 VIP 門檻。這裡給您 VIP 會員卡(遞上\u0026#34;)   題目二：if else 的練習\n又有人來申請 VIP 活動了！\n成為 VIP 會員的條件，只要購買滿 200 元，就可無條件成為會員，Mark 買了 2 個漢堡，2 個 薯條，是否有滿足條件？\n這次要記得用 if，以及注意你的語氣啊~ (小杰覺得人生好難\n1 2 3 4 5 6 7  var VIPTotal = 200; var hamburgerPrice = 50; var friesPrice = 30; // 請透過 if else 來去設計對方是否有達到條件，有或沒有都需要回覆對方 // 如果有，請顯示 console.log(\u0026#34;尊敬的客戶您好，您有達到 VIP 條件\u0026#34;) // 如果沒有達到條件，便用 else 顯示 console.log(\u0026#34;尊敬的客戶您好，您還差 xx 元，才有符合 VIP 條件哦~\u0026#34;)   題目三： if、else if、else 練習\n工作一整天，小杰累到懷疑人生，累歸累，但還是得吃東西，小杰吃東西有自己的 SOP，來幫幫小杰看看他該吃什麼食物。\n 小杰都用飢餓度 1~100 來計算，100 就是代表最飢餓，數值皆為整數，不會有小數點 小杰飢餓度 0~20 時，都吃飯糰 小杰飢餓度在 21~40 時，都吃肉燥飯+貢丸湯 小杰飢餓度在 41~60 時，都吃麥當勞 小杰飢餓度在 61~100 時，都吃 99 元火鍋吃到飽  今天小杰的飢餓度是 53，請引導小杰去指定地點用餐\n1 2 3 4 5 6 7 8 9 10  var hungryNum = 53; if (條件式) { console.log(); } else if (條件式) { console.log(); } // 請用 if、else if 去判斷主人公該吃什麼 // 各區塊回覆內容請顯示 console.log(\u0026#34;主人公因為飢餓度在\u0026#34;+hungryNum+\u0026#34;，所以他決定去吃麥當勞\u0026#34;)   7. 參考解答 題目一：\n1 2 3 4 5  if (memberPrice \u0026gt;= VIPTotal) { console.log(\u0026#39;您好，您有達到 VIP 門檻。這裡給您 VIP 會員卡(遞上\u0026#39;); } // 您好，您有達到 VIP 門檻。這裡給您 VIP 會員卡(遞上   題目二：\n1 2 3 4 5 6 7 8 9  let total = hamburgerPrice * 2 + friesPrice * 2; if (total \u0026gt;= VIPTotal) { console.log(\u0026#39;您好，您有達到 VIP 門檻。這裡給您 VIP 會員卡(遞上\u0026#39;); } else { let shortage = VIPTotal - total; console.log(\u0026#39;尊敬的客戶您好，您還差 \u0026#39; + shortage + \u0026#39; 元，才有符合 VIP 條件哦~\u0026#39;); } // 尊敬的客戶您好，您還差 40 元，才有符合 VIP 條件哦~   題目三：\n1 2 3 4 5 6 7 8 9 10 11 12 13  // 題目已經說明飢餓度 1~100 的整數，因此先不考慮此範圍外的輸入  if (hungryNum \u0026lt;= 20) { console.log(\u0026#39;主人公因為飢餓度在\u0026#39; + hungryNum + \u0026#39;，所以他決定去吃飯糰\u0026#39;); } else if (hungryNum \u0026lt;= 40) { console.log(\u0026#39;主人公因為飢餓度在\u0026#39; + hungryNum + \u0026#39;，所以他決定去吃肉燥飯+貢丸湯\u0026#39;); } else if (hungryNum \u0026lt;= 60) { console.log(\u0026#39;主人公因為飢餓度在\u0026#39; + hungryNum + \u0026#39;，所以他決定去吃麥當勞\u0026#39;); } else { console.log(\u0026#39;主人公因為飢餓度在\u0026#39; + hungryNum + \u0026#39;，所以他決定去吃 99 元火鍋吃到飽\u0026#39;); } // 主人公因為飢餓度在53，所以他決定去吃麥當勞   第八關：if 與指派運算子 - 幫幫小杰的金魚腦  題目連結\n 劇情略。\n8. 問題 題目一：老闆考考你指派運算子\n老闆：「我其實很懷疑你是不是真的會了，我考考你！」\n老闆：「剛好今天是發薪日，先發給你薪資 23500 元(遞給小杰」\n小杰：「謝謝腦闆，但你怎麼把我的薪資告訴大家了..」\n老闆：「這不是重點，以下兩步驟動作請寫成程式」\n老闆：「步驟一：因為你遲到一次，我要扣你 1000 元(取走小杰手上的 1000 元」\n老闆：「步驟二：然後你又偷吃 Pizza，我要再扣你 2500 元 (再次取走」\n小杰：「不是啊！那明明是小黑吃..」\n老闆：「這不是重點，快點算！算出你還剩下多少錢！」\n1 2 3 4 5  var salary = 23500; //請依照上面的武功秘笈 Codepen，依序實現兩步驟，算出小杰被扣了多少錢  console.log(\u0026#39;小杰目前還剩下\u0026#39; + salary + \u0026#39;元\u0026#39;);   題目二： if + 指派運算子\n老闆：「好了，現在我要告訴你贈品條件！」\n 目前小杰手上有 3 個贈品 消費滿 100 元就送對方贈品  而現在來了兩個客人，並依序有消費，請問現在他還剩下多少個贈品？\n1 2 3 4 5 6 7 8 9 10  var giftNum = 3; // 贈品數量 var customerA = 150; // 顧客 A 消費金額 var customerB = 99; // 顧客 B 消費金額  if (客戶A條件) { } if (客戶B條件) { } console.log(\u0026#39;目前贈品剩下\u0026#39; + giftNum + \u0026#39;個\u0026#39;);   題目三：if + 指派運算子\n老闆：「我現在補齊給你總計 50 個贈品！」\n老闆：「然後我覺得現在贈品門檻太高了，我決定大放送，只要滿 50 元就送一個！以此類推，他買 500 元就送 10 個贈品！」\n小杰：「老闆你今天這麼慷慨，那我的薪..」\n老闆：「別廢話，客人來了快點！他買完後告訴我贈品還夠不夠！」\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var giftNum = 50; // 贈品數量 var friesPrice = 30; // 薯條單價 var hamburgerPrice = 50; // 漢堡單價  // 以下是題目 // mary 買了 10 份薯條，10 份漢堡 // 請計算完贈品規則後，善用指派運算子去計算目前剩下的贈品有幾個 // 並用下面的 if 回報給老闆  if (條件) { console.log(\u0026#39;老闆！贈品還夠！剩下\u0026#39; + giftNum + \u0026#39;個~\u0026#39;); } else { console.log(\u0026#39;老闆贈品賣光啦~\u0026#39;); }   8. 參考解答 題目一：\n1 2 3 4  salary -= 1000; salary -= 2500 // \u0026#34;小杰目前還剩下20000元\u0026#34;   題目二：\n1 2 3 4 5 6 7 8  if (customerA \u0026gt;= 100) { giftNum -= 1; } if (customerB \u0026gt;= 100) { giftNum -= 1; } // \u0026#39;目前贈品剩下2個\u0026#39;   題目三：\n1 2 3 4 5 6 7 8 9 10 11  let maryTotal = friesPrice * 10 + hamburgerPrice * 10; let maryGiftNum = Math.floor(maryTotal / 50); giftNum -= maryGiftNum; if (giftNum \u0026gt; 0) { console.log(\u0026#39;老闆！贈品還夠！剩下\u0026#39; + giftNum + \u0026#39;個~\u0026#39;); } else { console.log(\u0026#39;老闆贈品賣光啦~\u0026#39;); } // \u0026#39;老闆！贈品還夠！剩下34個~\u0026#39;   第九關：觀念總整理 - 幫小杰學會 Function 之呼吸  題目連結\n 劇情略。\n9. 問題 請回覆以下 console.log 內容。\n第一式：變數型別之呼吸\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  var a = 1; a += 1; a += 5; var b = 5; console.log(a + b); var c = 3; var d = \u0026#39;hello\u0026#39;; console.log(c * d); var e = 8 + 2 * \u0026#39;9\u0026#39;; console.log(e); var f = 1; var g = \u0026#39;2\u0026#39;; var h = 3; console.log(typeof (f + g + h));   第二式：運算子之呼吸\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  var total = 200; var isVip = true; console.log(total \u0026gt;= 200 \u0026amp;\u0026amp; isVip); var a = true; var b = false; console.log(a \u0026amp;\u0026amp; b); console.log(a || b); var c = 10; var d = 20; var e = 30; console.log(c == 10 \u0026amp;\u0026amp; d \u0026gt;= 5 \u0026amp;\u0026amp; e !== 20); console.log(c == 10 || d \u0026gt;= 5 || e !== 20); console.log(c == 5 || d \u0026gt;= 40 || e !== 30);   第三式：運算子之呼吸\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  var maryIsVIP = true; if (maryIsVIP) { console.log(\u0026#39;哇貴婦餒！\u0026#39;); } else { console.log(\u0026#39;你一定搞錯了，叫你們店長出來！\u0026#39;); } var momSwim = false; var girlfriendSwim = true; if (momSwim \u0026amp;\u0026amp; girlfriendSwim) { console.log(\u0026#39;都不救，因為他們都會游泳\u0026#39;); } else { console.log(\u0026#39;小杰大喊：「你們誰不會游泳啊？？」\u0026#39;); if (girlfriendSwim) { console.log(\u0026#39;那你自己游上來！\u0026#39;); } else { console.log(\u0026#39;我先問我阿母會不會游泳！\u0026#39;); } if (momSwim) { console.log(\u0026#39;媽妳先自己游上來！\u0026#39;); } else { console.log(\u0026#39;媽我去救你！\u0026#39;); } }   9. 參考解答 第一式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  var a = 1; a += 1; a += 5; var b = 5; console.log(a + b); // 12  var c = 3; var d = \u0026#39;hello\u0026#39;; console.log(c * d); // NaN  var e = 8 + 2 * \u0026#39;9\u0026#39;; console.log(e); // 26  var f = 1; var g = \u0026#39;2\u0026#39;; var h = 3; console.log(typeof (f + g + h)); // \u0026#39;string\u0026#39;   第二式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  var total = 200; var isVip = true; console.log(total\u0026gt;=200 \u0026amp;\u0026amp; isVip); // true  var a = true; var b = false; console.log( a \u0026amp;\u0026amp; b); // false console.log( a || b); // true  var c = 10; var d = 20; var e = 30; console.log(c==10 \u0026amp;\u0026amp; d\u0026gt;=5 \u0026amp;\u0026amp; e !== 20); // true console.log(c==10 || d\u0026gt;=5 || e !== 20); // true console.log(c==5 || d\u0026gt;=40 || e !== 30); // false   第三式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  var maryIsVIP = true; if (maryIsVIP) { console.log(\u0026#39;哇貴婦餒！\u0026#39;); // \u0026#34;哇貴婦餒！\u0026#34; } else { console.log(\u0026#39;你一定搞錯了，叫你們店長出來！\u0026#39;); } var momSwim = false; var girlfriendSwim = true; if (momSwim \u0026amp;\u0026amp; girlfriendSwim) { console.log(\u0026#39;都不救，因為他們都會游泳\u0026#39;); } else { console.log(\u0026#39;小杰大喊：「你們誰不會游泳啊？？」\u0026#39;); // \u0026#34;小杰大喊：「你們誰不會游泳啊？？」\u0026#34;  if (girlfriendSwim) { console.log(\u0026#39;那你自己游上來！\u0026#39;); // \u0026#34;那你自己游上來！\u0026#34;  } else { console.log(\u0026#39;我先問我阿母會不會游泳！\u0026#39;); } if (momSwim) { console.log(\u0026#39;媽妳先自己游上來！\u0026#39;); } else { console.log(\u0026#39;媽我去救你！\u0026#39;); // \u0026#34;媽我去救你！\u0026#34;  } }   基本問題，就不說明了 😉。\n第十關：函式參數設計  題目連結\n 劇情略。\n10. 問題 第一題：客戶詢價函式，來更多個客人也不怕\n請改設計一個詢價用的函式，並新增三個參數，依序為客戶姓名、薯條數量，漢堡數量。\n同時來了三個客戶，請執行三次函式回報結果。\n1 2 3 4 5 6  // 定義薯條跟漢堡的金額（金額不可以更改） var hamburgerPrice = 50; var friesPrice = 40; var bobTotal; console.log(\u0026#34;Bob 您好，您詢問的金額總計為\u0026#34; + bobTotal + \u0026#34;元\u0026#34;);   第二題：好多客戶都在問小杰，他們錢包剩下多少錢，小杰表示無言\n下面截圖，請改設計一個查詢客戶錢包餘額用的函式，並新增四個參數，依序為客戶姓名、客戶錢包總額、薯條數量，漢堡數量。\n同時來了三個客戶，請執行三次函式回報結果。\n1 2 3 4 5 6 7  // 定義薯條跟漢堡的金額（金額不可以更改） var hamburgerPrice = 50; var friesPrice = 40; var markWallet = 200; var markTotal; console.log(\u0026#39;馬克買完東西後，錢包剩下\u0026#39; + markTotal + \u0026#39;元\u0026#39;);   第三題：好多人都擁有九折優惠券\n這一題，換您來設計函式與參數看看。\n突然間同時來了三個客戶，請執行三次函式回報結果。\n1 2 3 4 5 6 7 8  // 定義薯條跟漢堡的金額（金額不可以更改） var hamburgerPrice = 50; var friesPrice = 40; var sale = 0.9; var maryWallet = 5000; var maryTotal; console.log(\u0026#39;Mary 買完東西後，錢包剩下\u0026#39; + markTotal + \u0026#39;元\u0026#39;);   10. 參考解答 第一題：\n1 2 3 4 5  function customer(userName, hamburgerNum, friesPriceNum) { let total = hamburgerPrice * hamburgerNum + friesPrice * friesPriceNum; return userName + \u0026#39; 您好，您詢問的金額總計為\u0026#39; + total + \u0026#39;元\u0026#39;; }   第二題：\n1 2 3 4 5 6 7 8  function customer(userName, wallet, hamburgerNum, friesPriceNum) { let total = hamburgerPrice * hamburgerNum + friesPrice * friesPriceNum; let walletLast = wallet - total; return userName + \u0026#34;買完東西後，錢包剩下\u0026#34; + walletLast + \u0026#34;元\u0026#34;; }   題目沒說明，這裡不考慮錢不足的情況。\n第三題：\n1 2 3 4 5 6  function customer(userName, wallet, hamburgerNum, friesPriceNum) { let total = hamburgerPrice * hamburgerNum + friesPrice * friesPriceNum; let walletLast = wallet - total * sale; return userName + \u0026#39;買完東西後，錢包剩下\u0026#39; + walletLast + \u0026#39;元\u0026#39;; }   題目沒說明，這裡不考慮錢不足的情況，且客戶一定有優惠券。\n","description":"JS 變數 1 ~ 10 關","id":78,"section":"posts","tags":["JavaScript","JS 學徒特訓班"],"title":"JS 學徒特訓班 - JS 變數 1 ~ 10 關","uri":"https://chupai.github.io/posts/2008/js60_1/"},{"content":" 竹白的 JS 學徒特訓班筆記 - 目錄\n \r記錄六角學院所開的 JS 學徒特訓班，為期 60天的特訓。\n2020/08/01 中途加入，補進度：\n 2020/08/01 - JS 變數 1 ~ 10 關 2020/08/02 - JS 函式 11 ~ 23 關 2020/08/03 - JS 函式 24 ~ 35 關 2020/08/04 - JS 函式 36 ~ 40 關 2020/08/19 - Date、Location 41 ~ 46 關 2020/08/19 - AJAX 47 ~ 50 關 ","description":"竹白的 JS 學徒特訓班筆記","id":79,"section":"posts","tags":["JavaScript","JS 學徒特訓班"],"title":"JS 學徒特訓 - 目錄","uri":"https://chupai.github.io/posts/2008/js60_menu/"},{"content":" JavaScript筆記 目錄\n \r前言 Slice、Splice、Split 這幾個方法都是 S 開頭，因此若不熟悉很容易搞混，但它們又是處理 陣列 或 字串 常見的方法。\n Array.prototype.slice() Array.prototype.splice() String.prototype.split() String.prototype.slice()  slice 提取 陣列和字串都有 slice() 方法。\n1. Array.prototype.slice() 陣列的 slice() 會回傳一個指定索引範圍的新陣列（不改變原陣列）。\n1  arr.slice([begin[, end]])    begin：起始索引，若省略預設為 0； end：停止索引（不包含自己），若省略預設為 arr.length； 可以使用負數索引，從末項開始倒數。  1.1 範例 1 2 3 4 5 6 7 8 9 10 11 12 13  const arr = [0, 1, 2, 3, 4, 5]; // 無參數 0 ~ (arr.length - 1) console.log( arr.slice() ); // [0, 1, 2, 3, 4, 5]  // begin 2 ~ (arr.length - 1) console.log( arr.slice(2) ); // [2, 3, 4, 5]  // begin end 2 ~ (3 - 1) console.log( arr.slice(2, 4) ); // [2, 3]  // 負數 (arr.length - 2) ~ (arr.length - 1) console.log( arr.slice(-2) ); // [4, 5]   1.2 常見用法 用法一：淺拷貝陣列\n1 2  const arr = [0, 1, 2, 3, 4, 5]; const temp = arr.slice();   ES6 前沒展開運算子，都是使用 slice() 來淺拷貝陣列。\n用法二：從陣列前端、末端取 N 個元素使用\n1 2 3 4 5 6 7  const arr = [0, 1, 2, 3, 4, 5]; const first4 = arr.slice(0, 4); console.log( first4 ); // [0, 1, 2, 3]  const last4 = arr.slice(-4); console.log( last4 ); // [2, 3, 4, 5]   用法三：獲取陣列中的某段長度的子陣列\n1 2 3 4 5 6 7  const arr = [0, 1, 2, 3, 4, 5]; function pullSegment(arr, begin, len) { return arr.slice(begin, begin + len); } console.log( pullSegment(arr, 2, 3) ); // [2, 3, 4]   用法四：縮短陣列長度\n1 2 3 4  let arr = [0, 1, 2, 3, 4, 5]; arr = arr.slice(0, 3); console.log( arr ); // [0, 1, 2]   2. String.prototype.slice() 字串的 slice() 會回傳一個指定索引範圍字元的新字串（不改變原字串）。\n1  str.slice(beginIndex[, endIndex])   用法基本上與陣列的 slice() 差不多，直接看範例。\n2.1 範例 1 2 3 4 5 6  const str = \u0026#39;Hello world!\u0026#39;; console.log( str.slice() ); // \u0026#39;Hello world!\u0026#39; console.log( str.slice(2) ); // \u0026#39;llo world!\u0026#39; console.log( str.slice(2, 4) ); // \u0026#39;ll\u0026#39; console.log( str.slice(-2) ); // \u0026#39;d!\u0026#39;   2.1 類似方法 類似的方法還有 substring()、substr() 但 substr() 它不屬於 JavaScript 核心規範，所以如果是非瀏覽器的環境可能無法使用，所以盡可能避免使用。而 substring() 因為第二個參數小於第一個參數時，會自動換位，而且不支援負數，沒有 slice() 來的彈性。\nSplice 拼接 Array.prototype.splice() 藉由刪除既有元素或加入新元素來改變一個陣列的內容，並回傳一個包含被刪除的元素陣列。\n1  array.splice(start[, deleteCount[, item1[, item2[, ...]]]])    start：要插入或刪除的索引位置；  可以使用負數索引，從末項開始倒數 若大於 arr.length 則會被設為 0   deleteCount：要刪除的元素數量；  若省略或大於 arr.length，start 後的元素都會被刪除（包含 start）   item1, item2, ...：要插入的元素內容。  1. 範例 從指定索引位置開始，刪除所有元素（含指定索引）：\n1 2 3 4 5  const arr = [0, 1, 2, 3, 4, 5]; const removed = arr.splice(2); console.log(arr); // [0, 1] console.log(removed); // [2, 3, 4, 5]   從指定索引位置開始，刪除指定數量的元素：\n1 2 3 4 5  const arr = [0, 1, 2, 3, 4, 5]; const removed = arr.splice(2, 2); console.log(arr); // [0, 1, 4, 5] console.log(removed); // [2, 3]   從指定索引位置開始，刪除指定數量的元素，並插入元素：\n1 2 3 4 5  const arr = [0, 1, 2, 3, 4, 5]; const removed = arr.splice(2, 3, \u0026#39;aa\u0026#39;); console.log(arr); // [ 0, 1, \u0026#39;aa\u0026#39;, 5 ] console.log(removed); // [2, 3, 4]   2. 常見用法 移除陣列指定元素：\n1 2 3 4 5 6 7 8  function removeElement(arr, index) { arr.splice(index, 1); return arr; } const arr = [0, 1, 2, 3, 4, 5]; removeElement(arr, 2); console.log(arr); // [0, 1, 3, 4, 5]   split 分割 String.prototype.split() 方法會依照指定規則分割字串，並回傳一個陣列，內容為拆分的字串。\n1  str.split([separator[, limit]])    separator：字串或正則表達式，從符合的字元位置分割，若為空字串，則分割每個字元； limit：回傳的分割元素數量。  1. 範例 1 2 3 4 5 6 7 8 9  const monthString = \u0026#39;Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec\u0026#39;; console.log( monthString.split(\u0026#39;,\u0026#39;) ); // [ \u0026#39;Jan\u0026#39;, \u0026#39;Feb\u0026#39;, \u0026#39;Mar\u0026#39;, \u0026#39;Apr\u0026#39;, \u0026#39;May\u0026#39;, \u0026#39;Jun\u0026#39;, \u0026#39;Jul\u0026#39;, \u0026#39;Aug\u0026#39;, \u0026#39;Sep\u0026#39;, \u0026#39;Oct\u0026#39;, \u0026#39;Nov\u0026#39;, \u0026#39;Dec\u0026#39; ]  const num = \u0026#39;00000000\u0026#39;; console.log( num.split(\u0026#39;\u0026#39;, 2) ); // [ \u0026#39;0\u0026#39;, \u0026#39;0\u0026#39; ]   ","description":"處理陣列或字串常見的方法。","id":80,"section":"posts","tags":["JavaScript","陣列 Array","字串 String"],"title":"Slice、Splice、Split 的區別","uri":"https://chupai.github.io/posts/2007/js_slice_splice_split/"},{"content":"這週是六角鼠年鐵人賽第二十六週。\n最後我們來看紅黑樹刪除操作，相較於新增操作複雜。\n 紅黑樹（上）：B 樹、2-3-4 樹 紅黑樹（中）：新增操作 紅黑樹（下）：刪除操作  \r紅黑樹的刪除操作 在 紅黑樹 中，刪除一個節點，跟普通二元搜尋樹一樣有以下三種情況：\n 葉子節點（無子樹）。 節點有單邊子樹。 節點有左右兩邊子樹。  情況 3，的處理方式與普通二元搜尋樹相同，會從右子樹尋找最小值代替，將問題變成刪除替代節點（不是情況 1、就是情況 2）。\n但紅黑樹有兩種顏色的節點，因此還需要考慮節點顏色的不同，不過刪除操作後，需要平衡修正的，基本上只有刪除黑色的葉子節點。\n注意，這裡指的葉子節點是沒有子節點的節點，而不是紅黑樹定義的 NIL。\r 1. 節點有單邊子樹 因為有兩種顏色，所以節點有單邊子樹組合可能有 4 種，但實際存在的只有 1 種：\n 紅紅：不符合性質 4，不存在； 紅黑：不符合性質 4，不存在； 黑黑：不符合性質 5，不存在； 黑紅：存在。  性質 4、5：\n 性質 4：每個紅色節點必須有兩個黑色的子節點（不能有兩個連續的紅色節點）； 性質 5：從任一節點到其每個 NIL 的所有簡單路徑都包含相同數目的黑色節點。  黑紅組合，直接刪除黑色節點後，會由紅色節點遞補，不影響平衡。\ngraph TB; N --\u0026gt; A; A((D)) --- B((DL)) \u0026amp; n1; N1 --\u0026gt; AAA((DL)); class A,AA,AAA black; class B,BB red; class N,N1,n1,n2 transparent; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; graph TB; N --\u0026gt; AA; AA((D)) --- n2 \u0026amp; BB((DR)); N1 --\u0026gt; AAA((DR)); class A,AA,AAA black; class B,BB red; class N,N1,n1,n2 transparent; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 2. 刪除紅色葉子節點 刪除紅色葉子節點，也不會影響紅黑樹的特性，因此直接刪除即可，不需要修正。\ngraph TB; N --\u0026gt; A; A((P)) --- B((D)) \u0026amp; n1; N1 --\u0026gt; AAA((P)); class A,AA,AAA black; class B,BB red; class N,N1,n1,n2 transparent; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; graph TB; N --\u0026gt; AA; AA((P)) --- n2 \u0026amp; BB((D)); N1 --\u0026gt; AAA((P)); class A,AA,AAA black; class B,BB red; class N,N1,n1,n2 transparent; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; graph TB; N --\u0026gt; AA; AA((P)) --- BB((D)) \u0026amp; CC((B)); N1 --\u0026gt; A((P)); A((P)) --- n1 \u0026amp; B((B)); class AA black; class BB,CC red; class A,AA,AAA black; class B,BB red; class N,N1,n1,n2 transparent; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; graph TB; N --\u0026gt; AA; AA((P)) --- BB((B)) \u0026amp; CC((D)); N1 --\u0026gt; A((P)); A((P)) --- B((B)) \u0026amp; n1; class AA black; class BB,CC red; class A,AA,AAA black; class B,BB red; class N,N1,n1,n2 transparent; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 3. 刪除黑色葉子節點 遇到此情況最麻煩，因為可能會破壞紅黑樹性質 4，因此必須修正它。\n不需要修正的情況：\n 如果黑色葉子節點是根節點，直接刪除即可，不用修正。  修正的方法其實就是重新調整左、右子樹的黑色節點數量，讓他們保持相同，不違反性質 4，因此要判斷兄弟節點的狀態。\n需要修正的情況組合：\n 黑兄無侄紅父 紅兄（黑侄黑父） 黑兄紅侄 黑兄黑父  3.1 黑兄黑姪紅父  兄弟節點 B：黑色 姪子節點（兄弟子節點）：無 父節點 P：紅色  graph TB; N --\u0026gt; P; P((P)) --- D[D] \u0026amp; B((B)); class P red; class B black; class N transparent; class D del; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; 修正處理：P 設為黑色、B 設為紅色。\ngraph TB; N --\u0026gt; P; P((P)) --- D[D] \u0026amp; B((B)); class P white; class P black; class B red; class N,n1 transparent; class D del; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; 用 2-3-4 樹表示：\ngraph TB; A[P ? _] --- B[D] \u0026amp; C[B] \u0026amp; D[?]; AA[?] --- BB[P B] \u0026amp; CC[?]; class B del; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; 如果是鏡像情況，相同的修正處理方式。\n3.2 紅兄（黑侄黑父）  兄弟節點 B：紅色 姪子節點（兄弟子節點）Ｌ、Ｒ：一定有姪子節點，且為黑色 父節點 P：一定是黑色  graph TB; N --\u0026gt; P; P((P)) --- D[D] \u0026amp; B((B)); B((B)) --- L((L)) \u0026amp; R((R)); class P,L,R black; class B red; class N transparent; class D del; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 修正處理：對 P 進行左旋轉，並將 P 設為紅色，B 設為黑色。\ngraph TB; N --\u0026gt; B; B((B)) --- P((P)) \u0026amp; R((R)); P((P)) --- D[D] \u0026amp; L((L)); class B,L,R black; class P red; class N transparent; class D del; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 子樹 P 就變成情況一，執行相同修正處理：\ngraph TB; N --\u0026gt; B; B((B)) --- P((P)) \u0026amp; R((R)); P((P)) --- D[D] \u0026amp; L((L)); class B,P,R black; class L red; class N transparent; class D del; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 用 2-3-4 樹表示：\ngraph TB; A[_ P B] --- B[D] \u0026amp; C[L] \u0026amp; D[R]; A2[P B _] --- B2[D] \u0026amp; C2[L] \u0026amp; D2[R]; A3[B _] --- B3[P L] \u0026amp; C3[R]; class B,B2 del; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; 如果是鏡像情況，改對 P 進行右旋轉。\n3.3 黑兄紅侄  兄弟節點 B：黑色 父節點 P：黑色或紅色 姪子節點（兄弟子節點）Ｌ、Ｒ：紅色，共三種狀態：  L、R 都存在 只有 R 只有 L    基本狀態，L、R 都存在：\ngraph TB; N --\u0026gt; P; P((P)) --- D[D] \u0026amp; B((B)); B((B)) --- L((L)) \u0026amp; R((R)); class P white; class D,B black; class L,R red; class N transparent; classDef white fill:white,stroke:black; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 修正處理：對 P 執行左旋轉，並將 P 設為黑色、B 設為 P 的顏色、R 設為黑色。\ngraph TB; N --\u0026gt; B; B((B)) --- P((P)) \u0026amp; R((R)); P((P)) --- n1 \u0026amp; L((L)); class B white; class P,R black; class L red; class N,n1 transparent; classDef white fill:white,stroke:black; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 若只有 R、沒有 L，可執行相同修正處理：\ngraph TB; N --\u0026gt; P; P((P)) --- D[D] \u0026amp; B((B)); B((B)) --- n1 \u0026amp; R((R)); class P white; class D,B black; class L,R red; class N,n1 transparent; N1 --\u0026gt; B1; B1((B)) --- P1((P)) \u0026amp; R1((R)); class B1 white; class P1,R1 black; class L1 red; class N1,n11 transparent; classDef white fill:white,stroke:black; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 若只有 L，沒有 R，需先對 B 執行右旋轉，並將 L 設為黑色、B設為紅色，就會變上面的情況，再執行上面的修正處理：\ngraph TB; N --\u0026gt; P; P((P)) --- D[D] \u0026amp; B((B)); B((B)) --- L((L)) \u0026amp; n1; class P white; class D,B black; class L,R red; class N,n1 transparent; N2 --\u0026gt; P2; P2((P)) --- D2[D] \u0026amp; L2((L)); L2((L)) --- n2 \u0026amp; B2((B)); class P2 white; class D2,L2 black; class B2 red; class N2,n2 transparent; classDef white fill:white,stroke:black; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 用 2-3-4 樹表示：\ngraph TB; A[P] --- B[D] \u0026amp; C[_ B R]; A3[B] --- B3[P] \u0026amp; C3[R]; class B,B2 del; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; 如果是鏡像情況，左旋轉改右旋轉、右旋轉改左旋轉，修正邏輯相同。\n3.4 黑兄黑父  兄弟節點 B：黑色 父節點 P：紅色 姪子節點（兄弟子節點）：無或是黑色節點  graph TB; N --\u0026gt; P; P((P)) --- D[D] \u0026amp; B((B)); class P,B black; class N transparent; class D del; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; 首先，B 設為紅色：\ngraph TB; N --\u0026gt; P; P((P)) --- D[D] \u0026amp; B((B)); class P white; class P black; class B red; class N,n1 transparent; class D del; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; 樹依然是不平衡，因此將 P 設為當前節點，再次執行平衡操作。\n用 2-3-4 樹表示：\ngraph TB; N --\u0026gt; A; A[P] --- B[D] \u0026amp; C[B]; N1 --\u0026gt; A1; A1[null] --- B1[P B]; class N,N1 transparent; class B,B2 del; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; classDef transparent fill:transparent,stroke:transparent,color:transparent; classDef del fill:#fff,stroke:black,stroke-width:2px,color:#black,stroke-dasharray: 5; JavaScript 實作紅黑樹刪除操作 1. 刪除操作 因為紅黑樹的節點是雙向的，我們可以直接用尋找方法取得節點，並更改父節點的指向。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  remove(data, node = this.root) { const delNode = this.search(data, node); if (!delNode) { return false; } // 葉子節點  if (!delNode.left \u0026amp;\u0026amp; !delNode.right) { // 紅色  if (this.isRed(delNode)) { this.replaceParent(delNode, null); // 黑色  } else { this.deleteFixup(delNode); this.replaceParent(delNode, null); } // 單邊子樹  } else if (!delNode.left || !delNode.right) { // 單邊左子樹  if (delNode.left) { delNode.left.color = NodeColor.BLACK; delNode.left.parent = delNode.parent; this.replaceParent(delNode, delNode.left); // 單邊右子樹  } else { delNode.right.color = NodeColor.BLACK; delNode.right.parent = delNode.parent; this.replaceParent(delNode, delNode.right); } } else { const aux = this.findMin(delNode.right); delNode.data = aux.data; this.remove(aux.data, delNode.right); } return this.root; }   我們說明時，是刪除後修正，但實作時，先刪除就沒辦法傳入節點判斷了，因此這裡改成先判斷刪除後是否會影響平衡，若會影響平衡先調整在刪除。\n1.1 輔助方法 尋找節點、尋找最小值，在一般的二元搜尋樹都有說明過：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  search(data, node = this.root) { if (!node) { return false; } if (data === node.data) { return node; } if (data \u0026lt; node.data) { return this.search(data, node.left); } return this.search(data, node.right); } findMin(node = this.root) { let currentNode = node; while (currentNode \u0026amp;\u0026amp; currentNode.left) { currentNode = currentNode.left; } return currentNode; }   替換父節點的指向，在新增節點操作說明過：\n1 2 3 4 5 6 7 8 9 10  replaceParent(curNode, newNode) { const parent = curNode.parent; if (!parent) { this.root = newNode; } else if (parent.left === curNode) { parent.left = newNode; } else { parent.right = newNode; } }   2. 刪除操作平衡修正 節點代號，方便說明：\n 當前節點：N 父親節點：P 祖父節點：G 兄弟節點：B 姪子節點：L、R  檢查是否需要修正，修正條件「非根節點且為黑色」：\n 若 N 為 P 的左子節點，B 為 P 的右子節點：  若 B 是紅色，對 P 左旋轉，重新執行修正檢查。否則： 若 L 和 R 皆為黑色（包含 NIL）：  若 P 是紅色，將 P 設為黑色、右子節點設為紅色，結束修正。否則： 將 B 設為紅色，並將 N 設為 P，重新執行修正檢查。   若 L 是紅色且 R 不存在，對 B 執行右旋轉，並重新執行執行操作。否則： 對 P 轉左旋轉，並將 P、R 設為黑色，結束修正。   若 N 為 P 的右子節點，B 為 P 的左子節點：  若 B 是紅色，對 P 左旋轉，重新執行修正檢查。否則： 若 L 和 R 皆為黑色（包含 NIL）：  若 P 是紅色，將 P 設為黑色、左子節點設為紅色，結束修正。否則： 將 B 設為紅色，並將 N 設為 P，重新執行修正檢查。   若 L 是紅色且 R 不存在，對 B 執行左旋轉，並重新執行執行操作。否則： 對 P 轉右旋轉，並將 P、L 設為黑色，結束修正。    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  deleteFixup(node) { let currNode = node; while (currNode !== this.root \u0026amp;\u0026amp; !this.isRed(currNode)) { const { parent } = currNode; let bother; if (currNode === parent.left) { bother = parent.right; if (this.isRed(bother)) { this.leftRotation(parent); } if (!this.isRed(bother.left) \u0026amp;\u0026amp; !this.isRed(bother.right)) { if (this.isRed(parent)) { parent.color = NodeColor.BLACK; parent.right.color = NodeColor.RED; break; } bother.color = NodeColor.RED; currNode = parent; } else if (this.isRed(bother.left) \u0026amp;\u0026amp; !this.isRed(bother.right)) { this.rightRotation(bother); } else { this.leftRotation(parent); parent.color = NodeColor.BLACK; bother.right.color = NodeColor.BLACK; break; } } else { bother = parent.left; if (this.isRed(bother)) { this.rightRotation(parent); } if (!this.isRed(bother.left) \u0026amp;\u0026amp; !this.isRed(bother.right)) { if (this.isRed(parent)) { parent.color = NodeColor.BLACK; parent.left.color = NodeColor.RED; break; } bother.color = NodeColor.RED; currNode = parent; } else if (this.isRed(bother.right) \u0026amp;\u0026amp; !this.isRed(bother.left)) { this.leftRotation(bother); } else { this.rightRotation(parent); parent.color = NodeColor.BLACK; bother.left.color = NodeColor.BLACK; break; } } } }   紅黑樹總結 1. 紅黑樹和 AVL-Tree 比較 紅黑樹和 AVL-Tree 一樣是自平衡二元搜尋樹，都可以在 $O(\\log n)$ 時間內完成尋找、新增和刪除操作。\nAVL-Tree，屬於嚴格平衡樹，透過計算 BF，讓任意子節點的左右子樹高度相差不超過 1。\n而紅黑樹，透過增加節點顏色，來維持定義的特性，相對於 AVL-Tree 來說，犧牲了部分平衡性（多一層），換取平衡修正操作時的少量旋轉操作，整體來說效能要優於 AVL-Tree。\n 對於新增操作，AVL-Tree 和 紅黑樹 最多只需要執行 2 次旋轉操作，即平衡修正為 $O(1)$ 的時間複雜度 但刪除操作，AVL-Tree 需要維護被刪節點到根節點路徑上所有節點的平衡性，因此平衡修正時間複雜度需要 $O(\\log n)$。而紅黑樹的刪除操作，最多只需要三次旋轉，即平衡修正為 $O(1)$ 的時間複雜度。 查詢操作則是 紅黑樹 略遜於 AVL-Tree，因為它會比 AVL-Tree 多一層。  2. 視覺化 這是我用 Vue.js 製作的，可以很的方便觀察黑紅樹的結構變化：\nSee the Pen Red - Black Tree with Vue.js by Chupai@Design (@chupai) on CodePen. ","description":"最後我們來看紅黑樹刪除操作，相較於新增操作複雜。","id":81,"section":"posts","tags":["資料結構","二元搜尋樹","二元樹","紅黑樹","平衡樹","2-3 樹","2-3-4 樹","w3HexSchool"],"title":"JavaScript 學演算法（十八）- 紅黑樹（下）：刪除操作","uri":"https://chupai.github.io/posts/2007/ds_redblack-tree-3/"},{"content":"這週是六角鼠年鐵人賽第二十五週。\n上週我們簡單說明了紅黑樹的基本性質與理解 B 樹、2-3-4 樹，接下來，我們來看紅黑樹和 2-3-4 樹的等價關係與新增操作。\n 紅黑樹（上）：B 樹、2-3-4 樹 紅黑樹（中）：新增操作 紅黑樹（下）：刪除操作  \r紅黑樹和 2-3-4 樹的等價關係 2-3-4 樹在多數程式語言中實現起來相對困難，因為在樹上的操作涉及大量的特殊情況。而 紅黑樹 是基於它的理論基礎所發明的，實現起來更簡單一些。\n因此 紅黑樹本質上就是 2-3-4 樹，所有性質都可以從 2-3-4樹 來理解。\n1. 黑色節點 黑色節點，其實就是 2-3-4 樹的 2-節點，為一個中位數。。\ngraph TB; N[_ 40 _]; A((40)) --- n1 \u0026amp; n2; class A black; class n1,n2 transparent; classDef black fill:black,stroke:black,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 2. 紅色節點 黑色節點的子樹如果是紅色節點，表示彼此融合的意思，其實就是 2-3-4 樹的 3-節點、4-節點。\n3-節點：\ngraph TB; N[30 40 _]; A((40)) --- B((30)) \u0026amp; n1; N2[_ 40 50 ]; AA((40)) --- n2 \u0026amp; BB((50)); class A,AA black; class B,BB red; class n1,n2 transparent; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 4-節點：\ngraph TB; N[30 40 50]; A((40)) --- B((30)) \u0026amp; C((50)); class A black; class B,C red; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; 3. 2-3 樹 部分資料會說紅黑樹等價於 2-3 樹（3 階 B 樹），但正確來說，是「左傾紅黑樹」，屬於紅黑樹的變種，這裡不討論。\n紅黑樹的新增操作 紅黑樹新增節點後，會檢查樹使否平衡（是否違反紅黑樹性質），若不平衡，會透過「旋轉」和「變色」操作來修正。\n1. 保持根節點是黑色的 在 2-3-4 樹插入元素時，都是融合到節點中，因此在紅黑樹中，新增的節點一定的紅色的。\n首先，我們再一個空樹中新增一個節點：\ngraph TB; A((N)); classDef red fill:red,stroke:red,color:white; A:::red; 但紅黑樹的性質2：「樹的根節點為黑色」，因此需要將它修正成黑色的：\ngraph TB; A((N)); classDef black fill:black,stroke:black,color:white; A:::black; 2. 2-節點 一個黑色節點無任何子節點，表示它是一個 2-節點。\n那麼當我們新增節點，它會變成一個 3-節點，因此不需要做任何修正：\ngraph TB; A((P)) --- B((N)) \u0026amp; n1; AA((P)) --- n2 \u0026amp; BB((N)); class A,AA black; class B,BB red; class n1,n2 transparent; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 3. 3-節點 當我們對一個 3-節點新增節點，它會變成 4-節點，這時紅黑樹可能會違反性質4：「每個紅色節點必須有兩個黑色的子節點（不能有兩個連續的紅色節點）」，因此必須修正它。\n舉例來說，黑紅樹表示的 3-節在 2-3-4樹可能長這樣：\ngraph TB; N[30 40 _]; 但如果要再插入 20，左邊沒位置。因此要將 30 變成中位數：\ngraph TB; N[_ 30 40 ]; 這樣就能插入 20 了：\ngraph TB; N[20 30 40]; 接下來，我們來看需要修正的情況，首先來定義節點代號，方便說明：\n 祖父節點：G 父親節點：P 新增的節點：N  需要修正情況一：\ngraph TB; A((G)) --- B((P)) \u0026amp; n; B((P)) --- C((N)) \u0026amp; n1; class A black; class B,C red; class n,n1 transparent; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 需要對 G 執行右旋轉，並將 G 設為紅色、P 設為黑色：\ngraph TB; A((P)) --- B((N)) \u0026amp; C((G)); class A black; class B,C red; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; 如果你對旋轉操作不熟悉的話，可以先參考我的上一篇文章：AVL-Tree。\n需要修正情況二：\ngraph TB; A((G)) --- B((P)) \u0026amp; n; B((P)) --- n1 \u0026amp; C((N)); AA((G)) --- BB((N)) \u0026amp; nn; BB((N)) --- CC((P)) \u0026amp; nn1; class A,AA black; class B,C,BB,CC red; class n,n1,nn,nn1 transparent; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 需要先對 P 進行左旋轉，這樣就變成情況一了，再執行相同處理。\n情況三、四，基本上就是鏡像情況，先對 P 右旋轉：\ngraph TB; A((G)) --- n \u0026amp; B((P)); B((P)) --- C((N)) \u0026amp; n1; A1((G)) --- n11 \u0026amp; B1((N)); B1((N)) --- n111 \u0026amp; C1((P)); class A black; class B,C red; class n,n1 transparent; class A1 black; class B1,C1 red; class n11,n111 transparent; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 再對 G 左旋轉，並將 G 設為紅色、N 設為黑色：\ngraph TB; AA((N)) --- BB((G)) \u0026amp; CC((P)); class AA black; class BB,CC red; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; 4. 4-節點 如果對一個 4-節點新增節點，也就是會形成一個 5-節點，這時紅黑樹一樣會違反性質4。\ngraph TB; n --\u0026gt; A; A((A)) --- B((B)) \u0026amp; C((C)); B((B)) --- N((N)); class A black; class B,C red; class N red2; class n transparent; classDef black fill:black,stroke:black,color:black; classDef red fill:red,stroke:red,color:red; classDef red2 fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 我們會將整棵子樹執行「顏色翻轉 color flip」操作：\ngraph TB; n --\u0026gt; A; A((A)) --- B((B)) \u0026amp; C((C)); B((B)) --- N((N)); class A red; class B,C black; class N red2; class n transparent; classDef black fill:black,stroke:black,color:black; classDef red fill:red,stroke:red,color:red; classDef red2 fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; 顏色翻轉，其實就是 2-3-4 樹中的拆分與向上融合。\n當執行完顏色翻轉後，需要重新檢查黑紅樹是否違反性質。\nJavaScript 實作紅黑樹新增操作 1. 本體 顏色：\n1 2 3 4  const NodeColor = { RED: true, BLACK: false, };   我們使用布林值來定義紅色與黑色。\n節點：\n1 2 3 4 5 6 7 8 9  class RBTNode { constructor(data, parent = null) { this.data = data; this.parent = parent; this.left = null; this.right = null; this.color = NodeColor.RED; } }    data：儲存資料 parent：父節點 left：左子節點 right：右子節點 color：節點顏色（新增節點一定是紅色的，所以預設紅色）  紅黑樹的節點比普通的二元搜尋樹多了顏色和紀錄父節點屬性，也就是說，它是一個雙向鏈結。\n根：\n1 2 3 4 5 6  class RedBlackTree { constructor() { this.root = null; } // methods }   2. 旋轉操作 紅黑樹因為多了顏色和父節點，因此旋轉操作還需要更新顏色、父節點。\n2.1 右旋轉 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  rightRotation(node) { const temp = node.left; node.left = temp.right; temp.right = node; // 更新顏色  temp.color = node.color; node.color = NodeColor.RED; // 更新父節點  this.replaceParent(node, temp); temp.parent = node.parent; node.parent = temp; if (node.left) { node.left.parent = node; } }   2.2 左旋轉 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  leftRotation(node) { const temp = node.right; node.right = temp.left; temp.left = node; temp.color = node.color; node.color = NodeColor.RED; this.replaceParent(node, temp); temp.parent = node.parent; node.parent = temp; if (node.right) { node.right.parent = node; } }   2.3 輔助方法 替換父節點的指向：\n1 2 3 4 5 6 7 8 9 10  replaceParent(curNode, newNode) { const { parent } = curNode; if (!parent) { this.root = newNode; } else if (curNode === parent.left) { parent.left = newNode; } else { parent.right = newNode; } }    如果父節點不存在，更新樹的根節點； 如果是左子樹，更新左子樹； 若不是，則更新右子樹。  3. 新增操作 基本上與普通二元搜尋樹相同，只是多了父節點的指向與檢查是否平衡。\n歸迴版本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  insert(data) { const insertHelper = (node) =\u0026gt; { const curNode = node; if (data \u0026lt; curNode.data) { if (curNode.left) { insertHelper(curNode.left); } else { curNode.left = new RBTNode(data); curNode.left.parent = curNode; this.insertFixRBT(curNode.left); } } else if (data \u0026gt; curNode.data) { if (curNode.right) { insertHelper(curNode.right); } else { curNode.right = new RBTNode(data); curNode.right.parent = curNode; this.insertFixRBT(curNode.right); } } }; if (!this.root) { this.root = new RBTNode(data); this.insertFixRBT(this.root); } else { insertHelper(this.root); } }   迭代版本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  insert(data) { if (!this.root) { this.root = new RBTNode(data); this.insertFixup(this.root); return this.root; } let curNode = this.root; while (curNode) { if (data \u0026lt; curNode.data) { if (curNode.left) { curNode = curNode.left; } else { curNode.left = new RBTNode(data, curNode); this.insertFixup(curNode.left); break; } } else if (data \u0026gt; curNode.data) { if (curNode.right) { curNode = curNode.right; } else { curNode.right = new Node(data, curNode); this.insertFixup(curNode.right); break; } } } return this.root; }   4. 新增操作平衡修正 新增節點後，檢查紅黑樹是否符合特性，並修正它。\n節點代號，方便說明：\n 當前節點：N 父親節點：P 祖父節點：G 叔叔節點：U  檢查是否需要修正，修正條件「P 是紅色且 G 存在」：\n 若 P 為 G 的左子節點：  判斷 U 是否為紅色節點，若是，則執行顏色翻轉。 若不存在，判斷 N 是否為 P 的右子節點：  如果是右子節點，先對 P 執行左旋轉；   對 G 執行右旋轉。   若 P 為 G 的右子節點：  判斷 U 是否為紅色節點，若是，則執行顏色翻轉。 若不存在，判斷 N 是否為 P 的左子節點：  如果是左子節點，先對 P 執行右旋轉；   對 G 執行左旋轉。   以上修正結束，將目前節點設為祖父節點，再次檢查是否需要修正。  修正結束後，記得將根結點設為黑色。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  insertFixup(node) { let curNode = node; while (this.isRed(curNode.parent) \u0026amp;\u0026amp; curNode.parent.parent) { const { parent } = curNode; const grandparent = parent.parent; if (parent === grandparent.left) { if (this.isRed(grandparent.right)) { this.flipColor(grandparent); } else { if (curNode === parent.right) { this.leftRotation(parent); } this.rightRotation(grandparent); } } else { if (this.isRed(grandparent.left)) { this.flipColor(grandparent); curNode = grandparent; } else { if (curNode === parent.left) { this.rightRotation(parent); } this.leftRotation(grandparent); } } curNode = grandparent; } this.root.color = NodeColor.BLACK; }   4.1 輔助方法 判斷節點顏色：\n1 2 3  isRed(node) { return node ? node.color : false; }   顏色翻轉：\n1 2 3 4 5  flipColor(node) { node.color = NodeColor.RED; node.left.color = NodeColor.BLACK; node.right.color = NodeColor.BLACK; }   總結 這是我用 Vue.js 製作的，可以很的方便觀察黑紅樹的結構變化：\nSee the Pen Red - Black Tree - insert with Vue.js by Chupai@Design (@chupai) on CodePen.  下週來說明更麻煩的刪除操作。\n","description":"紅黑樹和 2-3-4 樹的等價關係與新增操作。","id":82,"section":"posts","tags":["資料結構","二元搜尋樹","二元樹","紅黑樹","平衡樹","2-3 樹","2-3-4 樹","w3HexSchool"],"title":"JavaScript 學演算法（十七）- 紅黑樹（中）：新增操作","uri":"https://chupai.github.io/posts/2007/ds_redblack-tree-2/"},{"content":"這週是六角鼠年鐵人賽第二十四週。\n紅黑樹和 AVL-Tree 一樣是自平衡二元搜尋樹，因為比較難理解、篇幅較長，所以分成三個階段來說明：\n 紅黑樹（上）：B 樹、2-3-4 樹 紅黑樹（中）：新增操作 紅黑樹（下）：刪除操作  \r紅黑樹簡介 紅黑樹（Red–black tree） 是一種自平衡二元搜尋樹，它是由 Rudolf Bayer 於 1972年發明，當時稱為 對稱二元 B 樹（Symmetric binary B-trees）。後來因為 Leo J. Guibas 和 Robert Sedgewick 於 1978年寫的一篇論文改名成現今的名稱。\n紅黑樹和 AVL-Tree 一樣是自平衡二元搜尋樹，都可以在 $O(\\log n)$ 時間內完成尋找、新增和刪除操作。但 紅黑樹相對於 AVL-Tree 來說，犧牲了部分平衡性以換取新增、刪除操作時少量的旋轉操作，整體來說效能要優於 AVL-Tree。\n1. 性質 首先我們來看定義紅黑樹規則的五點性質：\n 任何一個節點非紅即黑； 樹的根節點為黑色； 葉子節點為黑色（NIL）； 每個紅色節點必須有兩個黑色的子節點（不能有兩個連續的紅色節點）； 從任一節點到其每個 NIL 的所有簡單路徑都包含相同數目的黑色節點。  在紅黑樹定義中，葉子節點並不是沒有子節點的節點，而是指最後的 空值（NULL）節點，稱作「NIL」。\n但我為了之後方便說明，我們葉子節點，統一指「沒有子節點的節點」，空值（NULL）節點，稱作「NIL」。\n graph TB; A((13)) --- B((8)) \u0026amp; C((17)); B((8)) --- D((1)) \u0026amp; E((11)); C((17)) --- F((15)) \u0026amp; G((25)); D((1)) --- N1[NIL] \u0026amp; I((6)); E((11)) --- N10[NIL] \u0026amp; N11[NIL]; F((15)) --- N2[NIL] \u0026amp; N3[NIL]; G((25)) --- K((22)) \u0026amp; L((27)); I((6)) --- N4[NIL] \u0026amp; N5[NIL]; K((22)) --- N6[NIL] \u0026amp; N7[NIL]; L((27)) --- N8[NIL] \u0026amp; N9[NIL]; classDef black fill:black,stroke:black,color:white; classDef red fill:red,stroke:red,color:white; classDef transparent fill:transparent,stroke:transparent,color:transparent; class A,D,E,F,G,N1,N2,N3,N4,N5,N6,N7,N8,N9,N10,N11 black; class B,C,I,K,L red; 2. 說明紅黑樹前 紅黑樹如果直接依照性質來說明它的操作，會非常抽象難理解。\n因此再說明紅黑樹之前，必須先理解什麼是 B 樹、2-3-4 樹，對於理解紅黑樹有很大的幫助。因為紅黑樹是 2-3-4 樹的一種實現方式\nB 樹 B 樹（B-tree） 是一種自平衡的樹，B 是 Balance 平衡的意思，也是由普通的二元搜尋樹變換而來的，但最大的不同就是，它的節點可以擁有 2 個以上的子節點，也就說它已經不是二元樹了。\n1. 定義 一個 m 階的 B 樹 具有以下性質：\n 每一個節點最多有 m 個子節點； 每一個非葉子節點（根節點除外），最少有 ceil(m / 2) 個子節點； 若根節點非葉子節點時，它至少有 2 個子節點； 有 k 個子節點的非葉子節點擁有，擁有 k − 1 個 鍵 key（元素）； 所有的葉子節點都在同一層。  2. 絕對平衡 定義第 5 點：所有的葉子節點都在同一層，所以 B 樹是一顆絕對平衡的樹。\n絕對平衡，指的是對於任意一個節點，左右子樹高度相同。也就是說，節點不是沒子節點，就是子節點全滿。\n3. 插入操作 要插入一個新的元素，一定是在葉子結點中進行，並判斷當前節點的 key 數量是否小於最大值 m - 1：\n 若小於，表示當前節點有空間可以容納新元素，直接插入到這個節點中，並保持節點中的元素有序。 若節點已滿，將它拆分成一棵二元樹：  從該節點的原有元素和新元素選出中位數； 小於中位數的元素放入左邊節點，大於中位數的元素放入右邊節點，中位數作為分隔值； 最後，分隔值會被插入到父節點中，但可能會遇到以下情況：  若沒有父節點，創建一個新的根結點（增加了樹的高度）； 若父節點已滿，需要重複上述操作。      經過以上判斷，插入元素後，B 樹依然能保持絕對平衡。\n選出中位數可能會遇到插入新元素後，變成奇數的情況，無法整除，作法有很多種：\n 無條捨去或進位。 或是先選出中位數，才插入新元素。  4. 刪除操作 B 樹的刪除操作相對於插入操作是相對複雜一些。\n共有兩種策略：\n 定位並刪除元素，然後調整樹使它絕對平衡； 或是，從上到下處理這棵樹，在進入一個節點之前，調整樹使得之後一旦遇到了要刪除的 key，它可以被直接刪除而不需要再進行調整。  簡單來說，就是先刪除後調整，或者是先調整再刪除。\n以下使用前者來說明。\nB 樹 刪除一個元素時有以下兩種特殊情況：\n 這個元素位於葉子節點中，且是唯一的元素。 這個元素位於內部節點中。  下面分別是這些情況的處理過程。\n4.1 刪除葉子節點中的元素  搜尋要刪除的元素； 如果它在葉子節點，將它從中刪除； 若該元素是只唯一的元素，刪除後節點會不見，會導致父節點的子節點數量不符合性質 4，因此需要執行平衡修正。  4.2 刪除內部節點中的元素 內部節點（非葉子節點）中的每一個元素都是作為分隔兩顆子樹的分隔值。因此刪除後，我們可以取一個鄰近元素來作為新的分隔值，並刪除這個用替代的原素。\n取得新的分隔值共兩種方法：\n 從左子樹中，取最大的元素。 或是，從右子樹中，取最小的元素。  這個新的分隔值一定是位於葉子節點中，因此就變成了「刪除葉子節點中的元素」的情況。\n4.3 平衡修正 為了避免父節點的子節點數量不符合性質 4，我們會找一個元素來遞補遞補空缺。\n將缺少元素節點作為當前節點，判斷它的兄弟節點和父節點是否有多餘的元素：\n 如果兄弟節點存在，且有多餘的元素，那麼：  將父節點的分隔值下移，遞補被刪除元素的空缺； 將兄弟節點元素上移，遞補父節點下移分隔值的空缺； 樹重新平衡。   如果左、右弟都只有最小數量的元素，那麼：  將缺少元素節點與兄弟節點合併； 並將父節點的分隔值下移至合併後的節點； 最後檢查父節點：  若父節點依然保持最小數量的元素，樹重新平衡。否則： 父節點為根節點，且沒有元素，那麼刪除它，讓合併之後的節點成為新的根節點。否則： 不是根節點，將父節點作為當前節點，重新執行平衡修正。      若重新值行平衡修正，兄弟節點已經不是葉子節了，因此會有子樹，若父節點的分隔值下移，會繼承它的子樹（左兄繼承右子樹、右兄既成左子樹）。\n5. 實際應用 在實際應用中的 B 樹 的階數 m 都非常大，所以即使存儲大量的資料，B 樹 的高度依然很小。\n舉例來說，若資料量很大時，使用線性搜尋效率相當低，所以基本上會建立索引（index） 來取得資料。但資料量變得非常大時，索引大小也會變得很大，搜尋索引的效率也會降低，這時就可以透過 B 樹這種資料結構，將索引分成很多份（對應樹的節點），也就是分頁，從而增加效率。\nB 樹 主要是用外部儲存的一種資料結構，常被應用在資料庫和文件系統的實現上。\n2-3-4 樹 看完上面一堆說明後，可能會覺得這沙小🤣，我們還是直接來看 2-3-4 樹 吧。\n2-3-4 樹 就是階為 4 的 B 樹。\n 根據 B 樹性質 1，節點最多有 4 個子節點； 根據 B 樹性質 2，非葉子節點至少要有 2 個子節點； 根據 B 樹性質 1、4，每個節點最多擁有 3 個元素。  1. 節點 我們會用節點中存放的元素數量來決定節點的名稱：\n 當存放 1 個元素時，稱作「2-節點」，可擁有 2 個子節點； 當存放 2 個元素時，稱作「3-節點」，可擁有 3 個子節點； 當存放 3 個元素時，稱作「4-節點」，可擁有 4 個子節點。 因為是樹絕對平衡的，所以節點的子節點數量不是零，就是可擁有的最大數量。  這就是為什麼階為 4 的 B 樹叫作 2-3-4 樹。\n2. 插入操作 2.1 向空樹插入元素 首先，對一棵空樹，插入一個元素 70，那麼會產生樹的根節點：\ngraph TB; A[70]; 2.2 向有空間的節點插入元素 再插入一個元素 60 時，不會像二元搜尋樹一樣，插入到空節點中。而是「融合」到節點中，變成一個「3-節點」，並保持節點中的元素有序：\ngraph TB; A[60 70]; 繼續插入一個元素 50，會變成一個「4-節點」：\ngraph TB; A[50 60 70]; 注意，此時節點的空間已滿，已經是最大元素數量。\n2.3 向空間已滿的節點插入元素 如果繼續插入一個元素 40，你會發現，4-節點的可存放元素的空間已滿，因此需要「拆分」成一棵二元樹，再插入元素：\n 將 60 作為分隔值放入父節點中； 左邊節點放小於分隔值的元素； 右邊節點放大於分隔值的元素。  graph TB; A[60] --- B[50] \u0026amp; C[70]; AA[60] --- BB[40 50] \u0026amp; CC[70]; 接著要將這棵子樹插入到父節點中，但因為沒有父節點，所以節點 60 會作為新的根節點（樹高加 1）。\n2.4 父節點空間也已滿 接下來，我來看一個連續 4-節點的例子。\n假如要插入元素 10，會插入紅色框的這個 4-節點中：\ngraph TB; A[50 60 80] --- B[20 30 40] \u0026amp; C[55] \u0026amp; D[70] \u0026amp; E[90 100]; classDef red, fill:black,stroke:black,color:white; classDef red stroke:red; B:::red; 因此我們需要先將它拆分一棵二元樹：\ngraph TB; A[50 60 80] --- B[30] \u0026amp; C[55] \u0026amp; D[70] \u0026amp; E[90 100]; B[30] --- F[20] \u0026amp; G[40]; 將元素 10 插入到拆分後的子樹中：\ngraph TB; A[50 60 80] --- B[30] \u0026amp; C[55] \u0026amp; D[70] \u0026amp; E[90 100]; B[30] --- F[10 20] \u0026amp; G[40]; classDef green stroke:#61bfa6,stroke-width:2px; A:::green; 將子樹融合到父節點之前，需要檢查父節點是否也是 4-節點。\n如果是，一樣將它拆分：\ngraph TB; A[60] --- B[50] \u0026amp; C[80]; B[50] --- D[30] \u0026amp; E[55]; C[80] --- F[70] \u0026amp; G[90]; D[30] --- H[10 20] \u0026amp; I[40]; 接著就可以將之前的子樹向上融合。\n插入完成：\ngraph TB; A[60] --- B[50] \u0026amp; C[80]; B[30 50] --- D[10 20] \u0026amp; E[40] \u0026amp; H[55]; C[80] --- F[70] \u0026amp; G[90]; 3. 刪除操作 接下來看 2-3-4 樹的刪除操作，直接來看範例說明。\n刪除元素 5：\ngraph TB; A[50] --- B[30] \u0026amp; C[90]; B[20 40] --- D[5 10] \u0026amp; E[25 30] \u0026amp; F[45]; C[60 80] --- G[55] \u0026amp; H[70] \u0026amp; I[90]; D:::red; classDef red stroke:red,stroke-width:2px; 元素 5 不是葉節點中的唯一元素，可以直接刪除。\n刪除元素 45：\ngraph TB; A[50] --- B[30] \u0026amp; C[90]; B[20 40] --- D[10] \u0026amp; E[25 30] \u0026amp; F[45]; C[60 80] --- G[55] \u0026amp; H[70] \u0026amp; I[90]; F:::red; classDef red stroke:red,stroke-width:2px; 元素 45 是節點的唯一值，刪除後需要修正。兄弟節點有多餘元素：\n 分隔值 40 下移遞補空缺； 兄弟元素 30 上移，遞補分隔值空缺。  刪除元素 40：\ngraph TB; A[50] --- B[30] \u0026amp; C[90]; B[20 30] --- D[10] \u0026amp; E[25] \u0026amp; F[40]; C[60 80] --- G[55] \u0026amp; H[70] \u0026amp; I[90]; F:::red; classDef red stroke:red,stroke-width:2px; 元素 40 是節點的唯一值，刪除後需要修正它。兄弟節點只有最小數量的元素：\n 將 25 和空節點合併（刪除空節點）； 將分隔值 30 下移至合併後的節點； 父節點依然保持最小數量的元素。  刪除元素 25：\ngraph TB; A[50] --- B[30] \u0026amp; C[90]; B[20] --- D[10] \u0026amp; E[25 30]; C[60 80] --- G[55] \u0026amp; H[70] \u0026amp; I[90]; E:::red; classDef red stroke:red,stroke-width:2px; 元素 25 不是葉節點中的唯一元素，可以直接刪除。\n刪除元素 10：\ngraph TB; A[50] --- B[30] \u0026amp; C[90]; B[20] --- D[10] \u0026amp; E[30]; C[60 80] --- G[55] \u0026amp; H[70] \u0026amp; I[90]; D:::red; classDef red stroke:red,stroke-width:2px; 元素 40 是節點的唯一值，刪除後需要修正它。兄弟節點只有最小數量的元素：\n 將 30 和空節點合併（刪除空節點）； 將分隔值 20 下移至合併後的節點； 父節點無法保持最小數量的元素。  graph TB; A[50] --- B[null] \u0026amp; C[90]; B[null] --- D[20 30]; C[60 80] --- G[55] \u0026amp; H[70] \u0026amp; I[90]; B:::red; classDef red stroke:red,stroke-width:2px; 將空的父節點作為當前節點，重新執行平衡修正。兄弟節點有多餘元素：\n 分隔值 50 下移，並繼承分隔值 60 的左子樹 55； 兄弟元素 60 上移，遞補分隔值空缺。  刪除元素 90：\ngraph TB; A[60 ] --- B[50] \u0026amp; C[80]; B[50] --- D[20 30] \u0026amp; E[55]; C[80] --- H[70] \u0026amp; I[90]; I:::red; classDef red stroke:red,stroke-width:2px; 元素 90 是節點的唯一值，刪除後需要修正它。兄弟節點只有最小數量的元素：\n 將 70 和空節點合併（刪除空節點）； 將分隔值 80 下移至合併後的節點； 父節點無法保持最小數量的元素。  graph TB; A[60 ] --- B[50] \u0026amp; C[null]; B[50] --- D[20 30] \u0026amp; E[55]; C[null] --- H[70 80]; C:::red; classDef red stroke:red,stroke-width:2px; 將空的父節點作為當前節點，重新執行平衡修正。兄弟節點只有最小數量的元素：\n 將 50 和空節點合併（刪除空節點）； 將分隔值 60 下移至合併後的節點； 父節點為根節點，且沒有元素，讓合併之後的節點成為新的根節點。  刪除元素 60：\ngraph TB; A[50 60] --- B[20 30] \u0026amp; C[55] \u0026amp; D[70 80]; A:::red; classDef red stroke:red,stroke-width:2px; 從右子樹尋找最小值替代。接下來需要刪除替代元素 60：\ngraph TB; A[70 60] --- B[20 30] \u0026amp; C[55] \u0026amp; D[70 80]; D:::red; classDef red stroke:red,stroke-width:2px; 元素 70 不是葉節點中的唯一元素，可以直接刪除。\n刪除元素 50：\ngraph TB; A[50 70] --- B[20 30] \u0026amp; C[55] \u0026amp; D[80]; A:::red; classDef red stroke:red,stroke-width:2px; 從右子樹尋找最小值替代。接下來需要刪除替代元素 55：\ngraph TB; A[55 70] --- B[20 30] \u0026amp; C[null] \u0026amp; D[80]; C:::red; classDef red stroke:red,stroke-width:2px; 元素 55 是節點的唯一值，刪除後需要修正它。兄弟節點有多餘元素：\n 分隔值 55 下移； 兄弟元素 30 上移，遞補分隔值空缺。  graph TB; A[30 70] --- B[20] \u0026amp; C[55] \u0026amp; D[80]; 總結 對 B 樹 和 2-3-4 樹 有基本的概念，下週將說明 紅黑樹 與 2-3-4 樹 的等價關係，還有紅黑樹的新增操作。\n","description":"接下來我們來看與 AVL-Tree 一樣是自平衡二元搜尋樹的「紅黑樹」，因為比較難理解篇幅較長，所以分成三個階段來說明。","id":83,"section":"posts","tags":["資料結構","二元搜尋樹","二元樹","紅黑樹","平衡樹","B 樹","2-3-4 樹","w3HexSchool"],"title":"JavaScript 學演算法（十六）- 紅黑樹（上）：B 樹、2-3-4 樹","uri":"https://chupai.github.io/posts/2007/ds_redblack-tree-1/"},{"content":"這週是六角鼠年鐵人賽第二十三週。\n二元搜尋樹最大的問題就是，它會出現極端情況，傾斜某一邊，因此它的新增、搜尋、刪除操作最差時間複雜度為 $O(n)$。為了實現更高效的查詢，因此就有人發明了「平衡樹」。\n\r平衡樹概述 平衡樹（Balanced Tree） 是二元搜尋樹的改良版本，其目標在保持每一節點兩邊所含的項目數量相等，故可將根節點至任一葉節點之最長路徑最小化。\n「平衡」的意思，其實就是讓整棵樹看起來比較對稱、比較平衡，不會出現左右子樹其中一邊很高或很矮的情況。它能在 $O(\\log n)$ 內完成新增、搜尋和刪除操作。\n常見的平衡樹有：\n AVL-Tree：最早被發明的平衡樹，任意子節點的左右子樹高度相差不超過 1，屬於嚴格平衡樹。 紅黑樹（Red–black tree）：相較於 AVL-Tree，犧牲部分平衡（高 1 層），利用節點顏色，減少平衡操作的旋轉次數。 樹堆（Treap）：是有一個隨機附加域滿足堆積的性質的二元搜尋樹，其結構相當於以隨機資料新增的二元搜尋樹。  1. 旋轉（Rotation）操作 幾乎所有的平衡樹都是透過 旋轉（Rotate） 操作，使得樹趨於平衡。\n首先我們來看二元樹基本的旋轉操作，左旋轉和右旋轉：\n3.1 左旋轉 對 A 做左旋轉：\ngraph TB; A((A)) --- n1[null] \u0026amp; B((B)); B((B)) --- n2[null] \u0026amp; C((C)); C((C)) --- nnn1[null] \u0026amp; nnn2[null]; classDef n1 fill:#c2ff8b; classDef n2 fill:#ff8b8b; classDef n3 fill:#fff68b; n1:::n1; n2:::n2; 步驟如下：\n 將 B 的左子節點移動到 A 的右子節點位置； 再將 A 移動到 B 的左子節點位置；  graph TB; A((A)) --- n1[null] \u0026amp; n2[null]; classDef n1 fill:#c2ff8b; classDef n2 fill:#ff8b8b; classDef n3 fill:#fff68b; BB((B)) --- AA((A)) \u0026amp; C((C)); AA((A)) --- nn1[null] \u0026amp; nn2[null]; C((C)) --- nnn1[null] \u0026amp; nnn2[null]; classDef n1 fill:#c2ff8b; classDef n2 fill:#ff8b8b; n1:::n1; n2:::n2; nn1:::n1; nn2:::n2; 看上去，就像 A 逆時針旋轉。\n1.2 右旋轉 對 A 做右旋轉：\ngraph TB; A((A)) --- B((B)) \u0026amp; n1[null]; B((B)) --- C((C)) \u0026amp; n3[null]; C((C)) --- nnn1[null] \u0026amp; nnn2[null]; classDef n1 fill:#c2ff8b; classDef n2 fill:#ff8b8b; classDef n3 fill:#fff68b; n1:::n1; n3:::n3; 步驟如下：\n 將 B 的右子節點移動到 A 的左子節點位置； 再將 A 移動到 B 的右子節點位置；  graph TB; A((A)) --- n3[null] \u0026amp; n1[null] ; classDef n1 fill:#c2ff8b; classDef n2 fill:#ff8b8b; classDef n3 fill:#fff68b; BB((B)) --- C((C)) \u0026amp; AA((A)); AA((A)) --- nn3[null] \u0026amp; nn1[null]; C((C)) --- nnn1[null] \u0026amp; nnn2[null]; classDef n1 fill:#c2ff8b; classDef n2 fill:#ff8b8b; n1:::n1; n3:::n3; nn1:::n1; nn3:::n3; 看上去，就像 A 順時針旋轉。\nAVL-Tree AVL-Tree 全名為 Adelson-Velsky-Landis Tree，得名於它的發明者 G. M. Adelson-Velsky 和 Evgenii Landis，是最早被發明的平衡樹，因為是二元搜尋樹的優化版，因此又稱作「平衡二元搜尋樹」。\n它的任意子節點的左右子樹高度相差不超過 1，所以它也被稱為「高度平衡樹」。\n大部分的操作與二元搜尋樹相同，差異在於 AVL-Tree 新增或刪除資料時，會進行平衡操作（重新結構化），以保持性質及均勻的搜尋路徑，而不會導致樹過度傾斜。\n1. 平衡因子 BF 平衡因子（Balanced Factor，BF）是用來判斷節點的左右子樹高度相差多少。\n計算方式為，左子樹的高度減去它的右子樹的高度：\n 負數表示左子樹比右子樹高； 正數表示右子樹比左子樹高； 零表示左子樹和右子樹等高。  在 AVL-Tree 中，每一節點的平衡因子為 1、0 或 -1。帶有平衡因子 -2 或 2 的節點被認為是不平衡的，需要重新平衡。\n1.1 節點高度公式 節點高度為一個節點至某個葉節點的最長距離，其公式為：\n 節點高度 = max(左子節點高, 右子節點高) + 1\n 子節點為 null 時，高度視為 -1。\ngraph TB; classDef transparent fill:transparent,stroke:transparent,color:transparent; A((A)) --- B((B)); A((A)) --- C((C)); B((B)) --- D((D)) \u0026amp; E((E)); D((D)) --- F((F)) \u0026amp; F2((F2)); F2:::transparent;  F Height = max(-1, -1) + 1 = 0 D Height = max(0, -1) + 1 = 1 E Height = max(-1, -1) + 1 = 0 B Height = max(1, 0) + 1 = 2 C Height = max(-1, -1) + 1 = 0 A Height = max(2, 0) + 1 = 3  1.2 平衡因子計算  節點的平衡因子 = 左子樹的高度 - 右子樹的高度\n graph TB; classDef transparent fill:transparent,stroke:transparent,color:transparent; A((A)) --- B((B)); A((A)) --- C((C)); B((B)) --- D((D)) \u0026amp; E((E)); D((D)) --- F((F)) \u0026amp; F2((F2)); F2:::transparent;  F、E、C 沒有左、右子樹，所以左、右子樹高度為 -1  BF = -1 - (-1) = 0   D 左樹高度為 0、沒有右樹、  BF = 0 - (-1) = 1   B 左樹高度為 1、右樹高度為 0  BF = 1 - 0 = 1   A 左樹高度為 2、右樹高度為 0  BF = 2 - 0 = 2    2. 平衡操作 新增／刪除操作的平衡操作共有兩種策略：\n 預判是否影響樹的平衡，先調整樹再執行新增／刪除操作； 或是，執行新增／刪除操作後，再判斷樹是否需要執行平衡操作。  以下使用後者來說明，並使用新增節點為例。\n新增／刪除操作後，請考慮以下四種情況，會有不同的調整方式：\n LL 型 RR 型 LR 型 RL 型  4.1 LL 型 \u0026amp; RR 型 這兩種情況是鏡像的，所以處理的思路完全是一致的：\n LL 型：當新增的節點在不平衡的節點的左側的左側  對不平衡節點執行 右旋轉。   RR 型：當新增的節點在不平衡的節點的右側的右側  對不平衡節點執行 左旋轉。    直接看範例。\nLL 型：50 因為新增 30 而導致 BF 變成 2，因此需要調整，而 30 位於 50 的 左側的左側。\ngraph TB; A((50)) --- B((40)); A((50)) --- n1[null]; B((40)) --- C((30)); B((40)) --- n2[null]; class A red; class C green; class n1,n2 transparent; classDef red stroke:red,stroke-width:2px; classDef green stroke:#61bfa6,stroke-width:2px; classDef transparent fill:transparent,color:transparent,stroke:transparent; 處理方式，對 50 做右旋轉：\ngraph TB; B((40)) --- C((30)) \u0026amp; A((50)); 另一種情況，50 因為新增 20 而導致 BF 變成 2，而 20 位於 50 的左側的左側：\ngraph TB; A((50)) --- B((40)) \u0026amp; C((60)); B((40)) --- D((30)) \u0026amp; E((45)); D((30)) --- F((20)) \u0026amp; n1((null)); class A red; class F green; class n1,n2 transparent; classDef red stroke:red,stroke-width:2px; classDef green stroke:#61bfa6,stroke-width:2px; classDef transparent fill:transparent,color:transparent,stroke:transparent; 一樣對 50 做右旋轉：\ngraph TB; A((40)) --- B((30)) \u0026amp; C((50)); B((30)) --- D((20)) \u0026amp; n1((null)); C((50)) --- E((45)) \u0026amp; F((60)); class n1 transparent; classDef transparent fill:transparent,color:transparent,stroke:transparent; RR 型就是 LL 型的鏡像情況。\n4.2 LR 型 \u0026amp; RL 型 這兩種情況是鏡像的，所以處理的思路完全是一致的：\n LR 型：當新增的節點在不平衡的節點的左側的右側  先對不平衡節點的左子節點執行 左旋轉； 再對不平衡節點執行 右旋轉。   RL 型：當新增的節點在不平衡的節點的右側的左側  先對不平衡節點的右子節點執行 右旋轉； 再對不平衡節點執行 左旋轉。    直接看範例。\nLR 型：50 因為新增 45 而導致 BF 變成 2，因此需要調整，而 30 位於 50 的左側的右側。\ngraph TB; A((50)) --- B((40)); A((50)) --- n1[null]; B((40)) --- n2[null]; B((40)) --- C((45)); class A red; class C green; class n1,n2 transparent; classDef red stroke:red,stroke-width:2px; classDef green stroke:#61bfa6,stroke-width:2px; classDef transparent fill:transparent,color:transparent,stroke:transparent; 處理方式，先對 40 做左旋轉，會變成 LL 型，再對 50 做右旋轉：\ngraph TB; A((50)) --- B((40)) \u0026amp; n1[null]; B((45)) --- C((40)) \u0026amp; n2[null]; BB((45)) --- CC((40)) \u0026amp; AA((50)); class n1,n2 transparent; classDef red stroke:red,stroke-width:2px; classDef green stroke:#61bfa6,stroke-width:2px; classDef transparent fill:transparent,color:transparent,stroke:transparent; 另一種情況，50 因為新增 41 而導致 BF 變成 2，而 41 位於 50 的左側的右側：\ngraph TB; A((50)) --- B((40)) \u0026amp; C((60)); B((40)) --- D((30)) \u0026amp; E((45)); E((45)) --- F((41)) \u0026amp; n1((null)); class A red; class F green; class n1,n2 transparent; classDef red stroke:red,stroke-width:2px; classDef green stroke:#61bfa6,stroke-width:2px; classDef transparent fill:transparent,color:transparent,stroke:transparent; 一樣先對 40 做左旋轉，會變成 LL 型，再對 50 做右旋轉：\ngraph TB; AA((50)) --- BB((45)) \u0026amp; CC((60)); BB((45)) --- DD((40)) \u0026amp; n11((null)) DD((40)) --- FF((30)) \u0026amp; EE((41)); A((45)) --- B((40)) \u0026amp; C((50)); B((30)) --- D((30)) \u0026amp; E((41)); C((50)) --- n1((null)) \u0026amp; F((60)); class n1,n11 transparent; classDef transparent fill:transparent,color:transparent,stroke:transparent; RL 型就是 LR 型的鏡像情況。\nJavaScript 實作 AVL-Tree 二元樹的節點：\n1 2 3 4 5 6 7  class BTNode { constructor(data) { this.data = data; this.left = null; this.right = null; } }   本體：\n1 2 3 4 5 6  class AVLTree { constructor() { this.root = null; } // methods }   1. 計算平衡因子 計算平衡因子需要節點高度，因此我們需要計算節點高度的方法：\n1 2 3 4 5 6 7 8  getNodeHeight(node) { if(!node) { return -1; } // 1  // 2  const lh = this.getNodeHeight(node.left); const rh = this.getNodeHeight(node.right); return Math.max(lh, rh) + 1; // 3 }    子節點為 null 時，高度視為 -1。 使用歸迴取得左子節點高、右子節點高。 節點高度 = max(左子節點高, 右子節點高) + 1。  計算平衡因子：\n1 2 3  getBF(node) { return this.getNodeHeight(node.left) - this.getNodeHeight(node.right); }   公式：BF = 左子樹的高度 - 右子樹的高度。\n2. 旋轉操作 右旋轉：\n1 2 3 4 5 6  rightRotation(node) { const temp = node.left; node.left = temp.right; temp.right = node; return temp; }   左旋轉：\n1 2 3 4 5 6  leftRotation(node) { const temp = node.right; node.right = temp.left; temp.left = node; return temp; }   3. 平衡操作 平衡操作，檢查節點是否平衡：\n 若 BF \u0026gt; 1，表示不平衡，且左子樹高於右子樹，判斷是 LL、還是 LR：  若是 LR 型：  先對不平衡節點的左子節執行左旋轉，變成 LL 型；   LL 型，對不平衡節點執行右旋轉。   若 BF \u0026lt; -1，表示不平衡，且右子樹高於左子樹，判斷是 RR、還是 RL：  若是 RL 型：  先對不平衡節點的左子節執行右旋轉，變成 LL 型；   RR 型，對不平衡節點執行左旋轉。    判斷新增的節點是被加在左側還是右側，可以計算左、右子樹哪邊高，就能知道加在哪邊，因此我們可以計算 BF，若是負的右子樹高，反之，正的左子樹高。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  balance(node) { if (!node) { return node; } const nodeBF = this.getBF(node); if (nodeBF \u0026gt; 1) { if (this.getBF(node.left) \u0026lt; 0) { node.left = this.leftRotation(node.left); } node = this.rightRotation(node); } else if (nodeBF \u0026lt; -1) { if (this.getBF(node.right) \u0026gt; 0) { node.right = this.rightRotation(node.right); } node = this.leftRotation(node); } return node; }   4. 新增操作 新增節點後，需要檢查節點至根節點這條路徑，是否符合平衡條件，因此我們可以使用遞迴的方式回頭檢查節點是否符合平衡：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  insert(data) { const insertHelper = (node) =\u0026gt; { let curNode = node; if (!curNode) { return new BTNode(data); } if (data \u0026lt; curNode.data) { curNode.left = insertHelper(curNode.left); } else if (data \u0026gt; curNode.data) { curNode.right = insertHelper(curNode.right); } curNode = this.balance(curNode); return curNode; }; this.root = insertHelper(this.root); }   5. 刪除節點 刪除操作與普通的二元素搜尋樹相同，刪除節點後，檢查節點至根節點這條路徑，是否符合平衡條件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  remove(data) { const removeNode = (data, node) =\u0026gt; { let curNode = node; // let  if (!curNode) { return false; } if (data \u0026lt; curNode.data) { curNode.left = removeNode(data, curNode.left); } else if (data \u0026gt; curNode.data) { curNode.right = removeNode(data, curNode.right); } else { if (!curNode.left \u0026amp;\u0026amp; !curNode.right) { return null; } if (!curNode.left) { return curNode.right; } if (!curNode.right) { return curNode.left; } const aux = this.findMin(curNode.right); curNode.data = aux.data; curNode.right = removeNode(aux.data, curNode.right); } curNode = this.balance(curNode); // new  return curNode; }; this.root = removeNode(data, this.root); }   總結 1. 分析 二元搜尋樹最大的問題就是，它會出現極端情況，傾斜某一邊，因此它的新增、搜尋、刪除操作最差時間複雜度為 $O(n)$。\n而 AVL-Tree 再新增和刪除時，就會自動平衡二元樹，因此不會有極端情況發生。因此它的新增、搜尋、刪除操作平均、最差時間複雜度都為 $O(\\log n)$。\n2. 平衡操作時間複雜度 平衡操作是透過旋轉 1 次或 2 次來降低樹高。\n新增操作因為是增加樹高，而造成樹不平衡，因此最多只需要執行 1 次平衡操作即可平衡整棵樹（最多旋轉 2 次），所以新增的平衡操作時間複雜度為 $O(1)$。\n但刪除操作是因為降低樹高，而造成樹不平衡，因此執行平衡操作後，父節點可能又會不平衡，要再次執行平衡操作，所以最糟的情況下需要執行多次平衡操作，時間複雜度為 $O(\\log n)$。\n我們下週要講的紅黑樹的刪除平衡操作可以在 3 次旋轉內完成平衡操作。\n3. 視覺化 這是我用 Vue.js 製作的，可以很方便的觀察 AVL-Tree 結構變化：\nSee the Pen AVL-Tree Tree with Vue.js by Chupai@Design (@chupai) on CodePen. ","description":"AVL-Tree 是最早被發明的平衡樹。","id":84,"section":"posts","tags":["資料結構","二元搜尋樹","二元樹","AVL-Tree","平衡樹","w3HexSchool"],"title":"JavaScript 學演算法（十五）- AVL-Tree","uri":"https://chupai.github.io/posts/2007/ds_avl-tree/"},{"content":"這週是六角鼠年鐵人賽第二十二週。\n之前我們已經簡單介紹 樹 \u0026amp; 二元樹，但我們沒有實作它，接下來我們將說明一種最常使用的二元樹資料結構：「二元搜尋樹（Binary Search Tree）」，還有實作二元樹的走訪。\n\r二元搜尋樹 二元搜尋樹（Binary Search Tree, BST）、二元搜索樹，也稱為 有序二元樹（Ordered binary tree） 或 排序二元樹（Sorted binary tree），是一種具有特殊性值的二元樹。\n1. 定義 可以是一棵空樹或者具有下列性質的二元樹：\n 若任意節點的左子樹不空，則左子樹上所有節點的值均小於它的根節點的值； 若任意節點的右子樹不空，則右子樹上所有節點的值均大於它的根節點的值； 任意節點的左、右子樹也分別為二元搜尋樹。  這個定義可能會出現一些變化：\n 上面的定義，不能允許出現重複的資料。 若允許重複的資料，定義會更改成：  左子樹，小於等於；或是： 右子樹，大於等於。    這是一顆普通的二元搜尋樹的結構：\ngraph TB; 10((10)) --- 5((5)); 10((10)) --- 15((15)); 5((5)) --- 4((4)); 15((15)) --- 12((12)); 5((5)) --- 8((8)); 8((8)) --- 6((6)); 8((8)) --- 9((9)); 15((15)) --- 16((16)); JavaScript 實作二元搜尋樹 1. 二元樹的基本結構 實作二元樹通常會用鏈結串列表示法。\n二元樹的節點：\n1 2 3 4 5 6 7  class BTNode { constructor(data) { this.data = data; this.left = null; this.right = null; } }    data：用來存放的資料值； left：指向左子樹的指標； right：指向右子樹的指標。  二元搜尋樹本體：\n1 2 3 4 5 6  class BinarySearchTree { constructor() { this.root = null; } // methods }   操作方法：\n 二元搜尋樹基本操作：  搜尋 新增 刪除   二元樹的走訪操作：  DFS：前序、中序、後序 BFS：層序    2. 搜尋操作 根據 BST 的性質，對於每個節點：\n 若目標值等於節點的值，則回傳節點； 若目標值小於節點的值，則繼續在左子樹中搜尋； 若目標值大於節點的值，則繼續在右子樹中搜尋； 若節點不存在，回傳 null。  使用迭代的方式實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  search(data, node = this.root) { let curNode = node; while (curNode) { if (data === curNode.data) { return curNode; } if (data \u0026lt; curNode.data) { curNode = curNode.left; } else { curNode = curNode.right; } } return null; }   使用遞迴實作：\n1 2 3 4 5 6 7 8 9 10 11 12  search(data, node = this.root) { if (!node) { return null; } if (data === node.data) { return node; } if (data \u0026lt; node.data) { return this.search(data, node.left); } return this.search(data, node.right); }   簡化：\n1 2 3 4  search(data, node = this.root) { if (!node || node.data === data) return node; return node.data \u0026lt; data ? this.search(data, node.right) : this.search(data, node.left); }   3. 新增操作 新增操作是建立 BST 的基礎操作，有許多不同的做法，但這裡只討論最經典的方式。\n與搜尋操作類似，對於每個節點：\n 若不允重複值，目標值等於節點的值時，結束操作。 若目標值小於節點的值，則前往左子樹； 若目標值大於節點的值，則前往右子樹； 若節點為空，設置新節點。  使用迭代實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  insert(data) { if (!this.root) { this.root = new BTNode(data); return; } let curNode = this.root; while (curNode) { if (data \u0026lt; curNode.data) { if (curNode.left) { curNode = curNode.left; } else { curNode.left = new BTNode(data); break; } } else if (data \u0026gt; curNode.data) { if (curNode.right) { curNode = curNode.right; } else { curNode.right = new BTNode(data); break; } } else { break; } } }    先判斷樹是否為空樹，若是，則將新節點設為根節點，新增結束；否則： 判斷當前節點，預設為根節點：  若小於當前節點資料，判斷左子樹是否存在：  存在，將當前節點設為左子樹，重新判斷。 不存在，將右子樹設為新節點，新增結束。   若大於當前節點資料，判斷右子樹是否存在：  存在，將當前節點設為右子樹，重新判斷。 不存在，將右子樹設為新節點，新增結束。。   若等於當前節點資料，新增失敗。    使用遞迴實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  insert(data) { const insertHelper = (node) =\u0026gt; { const curNode = node; if (data \u0026lt; curNode.data) { if (curNode.left) { insertHelper(curNode.left); } else { curNode.left = new BTNode(data); } } else if (data \u0026gt; curNode.data) { if (curNode.right) { insertHelper(curNode.right); } else { curNode.right = new BTNode(data); } } }; if (!this.root) { this.root = new BTNode(data); } else { insertHelper(this.root); } }   ４. 最小值／最大值 尋找最小值節點，就是一直往左子樹移動，直到空子樹，回傳最後一個左子樹：\n1 2 3 4 5 6 7  findMin(node = this.root) { let currentNode = node; while (currentNode \u0026amp;\u0026amp; currentNode.left ) { currentNode = currentNode.left; } return currentNode; }   尋找最大值節點，反過來就是一直往右子樹移動，直到空子樹，回傳最後一個右子樹：\n1 2 3 4 5 6 7  findMax(node = this.root) { let currentNode = node; while (currentNode \u0026amp;\u0026amp; currentNode.right) { currentNode = currentNode.right; } return currentNode; }   5. 刪除操作 在二元搜尋樹刪除一個節點，需要考慮節點的三種情況：\n 葉子節點（無子樹），直接刪除。 節點有單邊子樹，用子樹代替該節點。 節點有左右兩邊子樹，處理方式為：  尋找被刪除節點鄰近的節點值來代替； 取得鄰近的節點方式：  前驅節點：左子樹取最大值 後繼節點：右子樹取最小值（範例使用它）   接著刪除用來代替的節點。    比較麻煩的是，二元搜尋樹節點是單向的，沒有父節點指標，所以我們需要透過遞迴的方式來更新節點。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  remove(data) { const removeNode = (data, node) =\u0026gt; { const curNode = node; // 1  if (!curNode) { return false; } // 2  if (data \u0026lt; curNode.data) { curNode.left = removeNode(data, curNode.left); // 3  } else if (data \u0026gt; curNode.data) { curNode.right = removeNode(data, curNode.right); // 4  } else { // 4.1  if (!curNode.left \u0026amp;\u0026amp; !curNode.right) { return null; } // 4.2  if (!curNode.left) { return curNode.right; } if (!curNode.right) { return curNode.left; } // 4.3  const aux = this.findMin(curNode.right); curNode.data = aux.data; curNode.right = removeNode(aux.data, curNode.right); } return curNode; }; this.root = removeNode(data, this.root); }   要刪除節點，就比須先找到它：\n 節點不存在。 小於當前節點資料，前往左子樹； 大於當前節點資料，前往右子樹； 等於當前節點，刪除：  葉子節點，直接刪除。 單邊子樹，用子樹代替。 左右兩邊子樹：  取得右子樹最小值； 替換值； 刪除右子樹最小值節點。      6. DFS DFS 共有三種走訪順序：\n 前序走訪 中序走訪 後序走訪   關於走訪，之前在 樹 \u0026amp; 二元樹 有說明。\n 6.1 遞迴 首先是前序走訪，執行順序為：\n （N）訪問當前節點 （L）走訪左子樹 （R）走訪右子樹  遞迴：\n1 2 3 4 5 6 7 8 9 10 11 12 13  preOrderTraversal() { const temp = []; preHelper(this.root); return temp; function preHelper(node) { if (node) { temp.push(node.data); preHelper(node.left); preHelper(node.right); } } }   中序、後序走訪差異不大：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  inOrderTraversal() { const temp = []; inHelper(this.root); return temp; function inHelper(node) { if (node) { inHelper(node.left); temp.push(node.data); inHelper(node.right); } }; } postOrderTraversal() { const temp = []; postHelper(this.root); return temp; function postHelper(node) { if (node) { postHelper(node.left); postHelper(node.right); temp.push(node.data); } }; }   6.2 迭代 我們可以使用堆疊（stack）來模擬遞迴結構。\n前序走訪：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  preOrderTraversal() { const temp = []; const stack = []; if (this.root) { stack.push(this.root); } while (stack.length) { const node = stack.pop(); temp.push(node.data); if (node.right) { stack.push(node.right); } if (node.left) { stack.push(node.left); } } return temp; }   因為堆疊是後進先出，因此要先將右子樹推入堆疊再推入左子樹。\n中序走訪：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  inOrderTraversal() { const temp = []; const stack = []; let node = this.root; while (node || stack.length) { while (node) { stack.push(node); node = node.left; } node = stack.pop(); temp.push(node.data); node = node.right; } return temp; }   先將左子樹全部加入堆疊中，然後逐個取出。\n後序走訪可以將前序作法的右子樹與左子樹的堆入順序交換，即 NLR 變成 NRL，最後輸出時反轉陣列，變成 LRN。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  postOrderTraversal() { const temp = []; const stack = []; if (this.root) { stack.push(this.root); } while (stack.length) { const node = stack.pop(); temp.push(node.data); if (node.left) { stack.push(node.left); } if (node.right) { stack.push(node.right); } } return temp.reverse(); }   6.3 輸出 這是二元搜尋樹結構：\ngraph TB; 10((10)) --- 5((5)); 10((10)) --- 15((15)); 5((5)) --- 4((4)); 15((15)) --- 12((12)); 5((5)) --- 8((8)); 8((8)) --- 6((6)); 8((8)) --- 9((9)); 15((15)) --- 16((16)); 輸出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const nums = [10, 5, 4, 8, 6, 9, 15, 12, 16]; const BST = new BinarySearchTree(); for (const data of nums) { BST.insert(data); } console.log( BST.preOrderTraversal() ); // [ 10, 5, 4, 8, 6, 9, 15, 12, 16 ]  console.log( BST.inOrderTraversal() ); // [ 4, 5, 6, 8, 9, 10, 12, 15, 16 ]  console.log( BST.postOrderTraversal() ); // [ 4, 6, 9, 8, 5, 12, 16, 15, 10 ]   二元搜尋樹使用不同順序的走訪，有不同的功能：\n 使用先序走訪，可以結構化輸出。 使用中序走訪，可以從小到大輸出，具有排序的功能。 使用後序走訪，可以用於計算有層級關係的所有元素的大小。  7. BFS 層序走訪會先訪問離根節點最近的節點，也就是它會由上而下，並在同一個階層，由左至右依序訪問節點。\n通常會使用佇列（queue）來實現：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  levelorderTraversal() { const temp = []; const queue = []; if (this.root) { queue.push(this.root); } while(queue.length) { const node = queue.shift(); temp.push(node.data); if(node.left) { queue.push(node.left); } if(node.right) { queue.push(node.right); } } return temp; }   層序走訪會依照階層，由左至右依序訪問節點：\n1 2  console.log( BST.levelorderTraversal() ); // [ 10, 5, 15, 4, 8, 12, 16, 6, 9 ]   我們可以稍作修改，用陣列存儲每一層的節點：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  levelorderTraversal() { const temp = []; const queue = []; if (this.root) { queue.push(this.root); } while (queue.length) { const subTemp = []; const len = queue.length; for (let i = 0; i \u0026lt; len; i += 1) { const node = queue.shift(); subTemp.push(node.data); if (node.left) { queue.push(node.left); } if (node.right) { queue.push(node.right); } } temp.push(subTemp); } return temp; }   1 2  console.log( BST.levelorderTraversal() ); // [ [ 10 ], [ 5, 15 ], [ 4, 8, 12, 16 ], [ 6, 9 ] ]   總結 1. 分析 二元搜尋樹的新增、搜尋、刪除操作時間複雜度會根據樹的高來決定，最佳、平均的時間複雜度為 $O(\\log n)$。\n但二元搜尋樹最大的問題就是，它會出現極端情況，傾斜某一邊。舉例來說，當我們順序新增元素，二元搜尋樹會退化成鏈結串列，元素數量多少，樹高就是多少，造成新增、搜尋、刪除操作最差時間複雜度為 $O(n)$。\n舉例，依序輸入1 2 3 4：\ngraph TB; 11((1)) --- 2((null)) \u0026amp; 22((2)); 22((2)) --- 3((null)) \u0026amp; 33((3)); 33((3)) --- 4((null)) \u0026amp; 44((4)); 2. 將二元搜尋樹變平衡 如果要將一棵傾斜的二元搜尋樹變得平衡，可以這樣處理：\n 對二元搜尋樹執行的中序走訪取得有序的陣列； 利用有序的陣列，重建一棵平衡的二元搜尋樹：  從陣列的中間位置取一個元素，得到樹的根節點。 對陣列的左邊和右邊遞迴執行相同操作，得到根節點的左、右子樹。    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  balanceBST() { const nodeList = this.inOrderTraversal(); const { length } = nodeList; if (length \u0026lt; 3) { return this.root; } this.root = rebuild(0, length - 1); function rebuild(start, end) { if (start \u0026gt; end) { return null; } const mid = Math.floor((start + end) / 2); const node = new BTNode(nodeList[mid]); node.left = rebuild(start, mid - 1); node.right = rebuild(mid + 1, end); return node; } }   3. 平衡樹 為了避免二元搜尋樹出現極端情況，有人發明了「平衡樹（Balanced Tree）」，它能在新增節點時，自動平衡，下週詳細說明。\n4. 視覺化 這是我用 Vue.js 製作的，可以很方便的觀察二元搜尋樹結構變化：\nSee the Pen Binary Search Tree with Vue.js by Chupai@Design (@chupai) on CodePen. ","description":"二元搜尋樹是一種具有特殊性值的二元樹。","id":85,"section":"posts","tags":["資料結構","二元搜尋樹","二元樹","w3HexSchool"],"title":"JavaScript 學演算法（十四）- 二元搜尋樹","uri":"https://chupai.github.io/posts/2006/ds_binary_search_tree/"},{"content":"這週是六角鼠年鐵人賽第二十一週，上週已經簡單描述樹狀結構的概念，接下來繼續看排序演算法的 堆積排序。\n\r堆積（Heap） 堆積（Heap） 是一種用於排序的特殊二元樹，始於 J. W. J. Williams 在 1964年發表的 堆積排序（Heap sort），當時他提出了二元堆積樹作為此演算法的資料結構。\n堆積具有以下兩種特性：\n 為 Complete binary tree（完全二元樹），除了最底層，其他層的節點都是填滿的，而且最後一階層的節點必須由左至右填入； 任意節點小於（或大於）它的所有後裔，最小元（或最大元）在堆積的根上（堆積序性）。  所有的父節點都比子節點要小，稱作 最小堆積（Min Heap） 所有的父節點都比子節點要大，稱作 最大堆積（Max Heap）    1. Complete binary tree Complete tree，指的是一棵二元樹中，除了最後一層，其餘層都是滿的二元樹，最後一階層的節點必須由左至右填入。\n若樹的深度為 k，那麼至少有 $2^{k}$ 個節點，最多有 $2^{k+1} - 1$個節點。\ngraph TB; A((A)) --- B((B)) \u0026amp; C((C)); B((B)) --- D((D)) 這是一棵深度為 2 的二元樹，它至少有 $2^{2} = 4$ 的節點。\n2. 最小堆積 最小堆積，所有的父節點都比子節點要小。\ngraph TB; A((1)) --- B((3)) \u0026amp; C((4)); B((3)) --- D((6)) \u0026amp; E((7)) 3. 最大堆積 最大堆積，所有的父節點都比子節點要大。\ngraph TB; A((7)) --- B((6)) \u0026amp; C((4)); B((6)) --- D((3)) \u0026amp; E((1)) 堆積排序 堆積排序（Heap sort） 是指利用 堆積 所設計的一種排序演算法。可以看成是 選擇排序 的改良版。\n流程：\n 先將資料堆積化（最大或最小）； 然後將第一個元素與最後元素交換位置； 重複上述步驟，直到排序完成。  這裡有一組數列資料：\nnums = [10, 50, 30, 60, 15, 40] 將他轉成 Complete binary tree，結構如下：\ngraph TB; 0((10)) --- 1((50)) \u0026amp; 2((30)); 1((50)) --- 3((60)) \u0026amp; 4((15)); 2((30)) --- 5((40)); 接下來我們要將 Complete binary tree 調整成堆積資料結構，如果是遞增排序會調整成最大堆積，遞減排序則調整成最小堆積。\n兩者調整過程差異不大，這邊就只說明如何遞增排序。\n1. 堆積化 首先要取得最後一個父節點位置，如果節點數量為 n，那麼最後一個父節點的位置會是 n / 2（取商）。\n從最後一個父節點開始，由右至左開始比較其子節點，若子節點值大於父節點，則相互對調。\n6 / 2 = 3，從第三個位置的節點開始：\n 父節點 30  比 40 小，交換位置   父節點 50  50、60、15 三者之間左子節點最大，交換位置    graph TB; 0((10)) --- 1((50)) \u0026amp; 2((40)); 1((60)) --\u0026gt; 4((50)); 1((60)) --- 3((15)); 2((40)) --\u0026gt; 5((30)); 接下來，提升了一層，交換後還有子節點，需要繼續往下比較：\n 父節點 10  10、60、40 三者之間左子節點最大，交換位置 10、50、15 三者之間左子節點最大，交換位置    graph TB; 0((60)) --\u0026gt; 1((50)); 0((60)) --- 2((40)); 1((50)) --\u0026gt; 3((10)); 1((50)) --- 4((15)); 2((40)) --- 5((30)); 2. 排序 再來是排序動作，我們將最大堆積的最頂層元素，與最後一個元素交換位置：\ngraph TB; 0((30)) --- 1((50)) \u0026amp; 2((40)); 1((50)) --- 3((10)) \u0026amp; 4((15)); 2((40)) --- 5((60)); classDef sorted fill:#9dff96,stroke:#6afd5e; 5:::sorted; 如此一來我們的遞增排序就已經排好一個元素了，因此可以將它排除。\n接下來我們要繼續維持 最大堆積，因此要再次調整樹，最頂層的就會是第二大的：\ngraph TB; 0((50)) --- 1((30)) \u0026amp; 2((40)); 1((30)) --- 3((10)) \u0026amp; 4((15)); 2((40)) --- 5((60)); classDef sorted fill:#9dff96,stroke:#6afd5e; 5:::sorted; 一樣將它與最後一個元素交換位置後排除：\ngraph TB; 0((15)) --- 1((30)) \u0026amp; 2((40)); 1((30)) --- 3((10)) \u0026amp; 4((50)); 2((10)) --- 5((60)); classDef sorted fill:#9dff96,stroke:#6afd5e; 5:::sorted; 4:::sorted; 持續重複上述步驟，直到排序完成：\ngraph TB; 0((10)) --- 1((15)) \u0026amp; 2((30)); 1((15)) --- 3((40)) \u0026amp; 4((50)); 2((30)) --- 5((60)); 演算法實作 1. 將陣列調整成最大堆積 1 2 3 4 5 6 7 8  function buildMaxHeap(arr) { let n = arr.length; const lastParent = Math.floor(n / 2) - 1; for (let i = lastParent; i \u0026gt;= 0; i--) { maxHeapify(arr, i, n); } }    取得最後一個父節點索引位置。 從最後一個父節開始執行最大堆積調整操作至根節點。  2. 最大堆積調整操作： 參數：\n arr：待排序陣列。 index：檢查的起始索引位置。 heapSize：目前堆積大小，因為我們直接在原陣列上操作，因此這是用來判斷目前要調整的範圍。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function maxHeapify(arr, index, heapSize) { const iLeft = 2 * index + 1; // 1  const iRight = iLeft + 1; // 2  let iMax = index; // 3  // 4  if (iLeft \u0026lt; heapSize \u0026amp;\u0026amp; arr[iMax] \u0026lt; arr[iLeft]) { iMax = iLeft; } if (iRight \u0026lt; heapSize \u0026amp;\u0026amp; arr[iMax] \u0026lt; arr[iRight]) { iMax = iRight; } // 5  if (iMax !== index) { swap(arr, iMax, index); maxHeapify(arr, iMax, heapSize); } }    左子節點位置。 右子節點位置。 紀錄目前最大節點的位置，預設為當前節點。 首先判斷節點位置是否有超出堆積範圍，再比較是否為最大的。 如果目前最大節點的位置不等於當前節點位置，表示左或右子節點比較大，因此執行交換操作與繼續往下執行調整函式（遞迴操作）。  陣列交換函式：\n1 2 3 4 5  function swap(arr, a, b) { let temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; }   上面程式碼使用了使用到了遞迴操作，那麼當資料數量非常非常大時，很容易導致 堆疊溢位，因此可以改寫用迭代方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  function maxHeapify(arr, index, heapSize) { let iLeft; let iRight; let iMax; let iCur = index; while (true) { iLeft = 2 * iCur + 1; iRight = iLeft + 1; iMax = iCur; if (iLeft \u0026lt; heapSize \u0026amp;\u0026amp; arr[iMax] \u0026lt; arr[iLeft]) { iMax = iLeft; } if (iRight \u0026lt; heapSize \u0026amp;\u0026amp; arr[iMax] \u0026lt; arr[iRight]) { iMax = iRight; } if (iMax === iCur) { break; } else { swap(arr, iMax, iCur); iCur = iMax; } } }   3. 排序操作 1 2 3 4 5 6 7 8 9 10 11  function heapSort(arr) { const n = arr.length; buildMaxHeap(arr); // 1  // 2  for (let i = n - 1; i \u0026gt; 0; i--) { swap(arr, 0, i); // 3  maxHeapify(arr, 0, i); // 4  } }    將陣列調整成最大堆積，第一個節點將會是值最大的。 將最後一個節點與第一個節點交換位置，並重新對第一個節點執行堆積調整操作（記得移除已排序好節點）。 交換函式的 i 指的是最後一個節點位置。 調整操作的 i 指的是目前堆積長度。  分析 堆積排序 可以看成是 選擇排序 的改良版，利用 堆積 這種 半排序（partially sorted） 的資料結構輔助並加速排序。主要運行時間主要是消耗在初始堆積化與重新堆積化上。\n 不穩定排序 時間複雜度  最佳：$O(n \\log n)$ 最差：$O(n \\log n)$ 平均：$O(n \\log n)$   空間複雜度為：$O(1)$ ","description":"堆積排序（Heap Sort） 可以看成是 選擇排序 的改良版本。","id":86,"section":"posts","tags":["排序演算法","堆積排序","w3HexSchool"],"title":"JavaScript 學演算法（十三）- 堆積排序","uri":"https://chupai.github.io/posts/2006/sort_algorithm_heap_sort/"},{"content":"這週是六角鼠年鐵人賽第二十週，經典的排序演算法還有一個 堆積排序，再說明堆積排序前，先來看之前還沒提到的樹狀資料結構，之後才比較好理解 堆積排序。\n\r樹（Tree） 樹（Tree），是一種模擬現實生活中的樹幹和樹枝的資料結構。屬於一種階層架構的非線性資料結構。\n生活中常見樹狀結構資料，例如：家族族譜、決策模型、淘汰賽比賽圖等等。對於前端工程師來說，我們最常操作的 DOM 就是樹狀結構資料。\n1. 樹的基本觀念 在樹狀結構中的最基本單位，稱為 節點（Node），節點之間的連結即樹的 分支（Branch）。\ngraph TB; A((A)) --- B((B)) \u0026amp; C((C)); 樹的起點稱為 根節點（Root），具有唯一性，例如 A 即根節點。樹根延展出去就是樹枝，也就是根節點可以分支 0 至 n 個節點，分支出去的節點為 子節點（Child）。\ngraph TB; A((A)) --- B((B)) \u0026amp; C((C)); B((B)) --- D((D)) \u0026amp; E((E)); C((C)) --- F((F)) \u0026amp; G((G)) \u0026amp; H((H)); F((F)) --- I((I)); H((H)) --- J((J)); J((J)) --- K((K)); 在樹枝下一樣可以擁有下一層樹枝，D 和 E 為 B 的子節點，B 為 D 和 E 的 父節點（Parent）。B 和 E 因為父節點相同，兩者為 兄弟節點（Siblings）。從根節點到某節點 路徑（Path） 上的所有節點都是此節點的 祖先節點（Ancestor），例如 K 的祖先節點就包含 J、H、C、A。反之，某節點底下的所有節點稱為 後代節點（Descendant）。\n節點和其子節點可以構成 子樹（Subtree），例如 B、D、E 就形成一棵子樹。\n沒有子節點的節點稱為 葉節點（Leaf） 或 外部節點（External），例如 D、E、I、G、K。其餘有子節點的節點則稱作 分支（Branch）節點 或 內部節點（Internal） ，而一個節點擁有的子節點數量稱作 分支度（Degree）。\n節點的 階層（Level） 是從根開始定義起，根為第一層，根的子為第二層，以此類推，例如根節點於 1 階層，而 D 位於 3 階層。\n節點 深度（Depth） 為一個節點至根節點的距離，例如根節點的深度為 0，D 的深度為 2。階層與深度的關係為：Level = Depth + 1。\n一個節點至某個葉節點的最長距離則稱作 節點高度（Height of node），例如 F 的高度為 1、C 的高度為 3，所有葉節點的高度為 0。根節點的高度等同 樹高（Height of tree），也等同 樹的深度（Depth of tree）。\n注意，有部分的文獻會將根節點的 階層（Level） 定義為 0，也就是等同於 深度（Depth）。\r 2. 樹的特點 樹是由一個或多個節點所組成的有限集合，並且有以下特點：\n 存在且只有一個 根節點（Root）； 樹裡面不存在 環路（Cycle），若要尋找特定節點，只存在一條 路徑（Path）； 除了根節點外，每個節點只會有一個 父節點（Parent）。 除了根節點外，每個子節點可以分為多個不相交的子樹。  環路（Cycle），指的是樹在各節點之間不可以有迴圈，或不連結的左、右子樹。\n3. 樹的種類 除非特別指明，一般的樹都是 有序樹（OrderedTree），是指樹中任意節點的子節點之間有順序關係，每個結點的各子樹看成是從左到右有次序的（即不能互換），常見的有以下幾種：\n 二元樹（Binary tree） 二元搜尋樹（Binary Search Tree） AVL-Tree 紅黑樹（Red–black tree）  另外還有 無序樹（UnoderedTree），又稱「自由樹」，樹中任意節點的子節點之間沒有順序關係。\n什麼是二元樹 樹依不同分支度（Degree）可以區分程很多種，在資料結構中，最廣泛使用的樹狀結構就是 二元樹（Binary tree）。\n二元樹（Binary tree），簡單來說就是限制每個節點最多只能有兩個的子節點，也就是節點分支度只能小於等於 2。\n二元樹特點：\n 可以為空集合； 分支度只能小於等於 2； 子樹有左、右方向的分別。  1. 左子樹與右子樹 非空集合的二元樹由三個元素組合：\n 根節點（Root） 左子樹（Left Subtree） 右子樹（Right Subtree）  graph TB; A((A)) --- B((B)) \u0026amp; C((C)); subgraph Right Subtree C((C)) --- F((F)) \u0026amp; G((G)); G((G)) --- H((H)) \u0026amp; I((I)); end subgraph Left Subtree B((B)) --- D((D)) \u0026amp; E((E)); end 2. 歪斜樹 歪斜樹（Skewed Tree），指一棵樹完全沒有左或右其中一邊節點的二元樹，如果集中左邊稱作「左歪斜樹」，反之集中右邊稱作「右歪斜樹」。\ngraph TB; classDef transparent fill:transparent,stroke:transparent,color:transparent; A((A)) --- B((B)) \u0026amp; B2((B2)); B((B)) --- C((C)) \u0026amp; C2((C2)); B2((B2)):::transparent; C2((C2)):::transparent; 3. Strictly binary tree Strictly binary tree，指的是每個節點的子節點只能是 0 或 2 的二元樹，簡單來說就是「除了葉節點以外，每個節點都有兩個子節點」。\ngraph TB; A((A)) --- B((B)) \u0026amp; C((C)); B((B)) --- D((D)) \u0026amp; E((E)); 4. Perfect binary tree Perfect binary tree，指的是每一層上的節點數都是最大節點的二元樹。一棵深度為 k 的樹，它的總節點數量為 $2^{k+1} - 1$。特點是\ngraph TB; A((A)) --- B((B)) \u0026amp; C((C)); B((B)) --- D((D)) \u0026amp; E((E)); C((C)) --- F((F)) \u0026amp; G((G)); 這是一棵深度為 2 的樹，它的總節點數量為 $2^{2+1} - 1 = 7$。\n5. Complete binary tree Complete tree，指的是一棵二元樹中，除了最後一層，其餘層都是滿的二元樹，最後一階層的節點必須由左至右填入。\n若樹的深度為 k，那麼至少有 $2^{k}$ 個節點，最多有 $2^{k+1} - 1$個節點。\ngraph TB; A((A)) --- B((B)) \u0026amp; C((C)); B((B)) --- D((D)) 這是一棵深度為 2 的樹，它至少有 $2^{2} = 4$ 的節點。\n6. Full Binary tree Full Binary tree 定義基本上等同於 Strictly binary tree。但中文資料對於 Full Binary tree 的定義，大多數等同 Perfect binary tree。關於這部分的差異我就不知道為什麼了。\n二元樹的表示法 二元樹在實作上有多種方法可以建立，以下簡單說明最常見的兩種方式。\n1. 陣列表示法 使用一維陣列儲存，將二元樹的節點根據公式依序放在對應的陣列索引：\n 根節點放在陣列索引位置 0。 若節點索引為 i：  節點的左子節點，放在陣列索引位置 (2 * i) + 1。 節點的右子節點，放在陣列索引位置 (2 * i) + 2。 若節點不為根節點，節點的父節點放在陣列索引位置 (i - 1) / 2（取商）。    以一棵深度為 2 的 Perfect binary tree 為例：\ngraph TB; A((A)) --- B((B)) \u0026amp; C((C)); B((B)) --- D((D)) \u0026amp; E((E)); C((C)) --- F((F)) \u0026amp; G((G));    陣列索引 0 1 2 3 4 5 6     節點 A B C D E F G    B 節點的索引為 1：\n 左子節點（Ｄ）的索引位置為 2 * 1 + 1 = 3 右子節點（E）的索引位置為 2 * 2 + 2 = 4 父節點（A）的索引位置為 (2 - 1) / 2 = 0  陣列表示法適合用來儲存 Perfect binary tree，可以快速尋找左右子節點和父節點，但缺點也很明顯：\n 當二元樹稀疏或不平衡時，即使節點不存在，仍然會保留對應的陣列索引位置，因此會造成閒置的空間配置。 若增加或刪除節點時，需要移動多個節點。  2. 鏈結串列表示法 鏈結串列表示法是用一個節點結構表示樹上的每個節點，結構內除了儲存該節點本身的值，另外有兩個 指標（Pointer），分別指向節點的左子節點和右子節點，沒有子節點則指向 null。\n   指標 資料 指標     left data right    鏈結串列表示法，節點新增或刪除容易操作，但尋找父節點較不易，而且當二元樹稀疏或不平衡時，就會浪費指標空間。\n二元樹的走訪 二元樹的走訪（Binary tree traversal），走訪（Traversal） 或稱作 遍歷、搜尋（Search），簡單來說就是訪問樹中的每個節點，並執行特定的操作（可能是檢查值、更新、刪除等等）。\n二元樹的走訪方式有兩種：\n 深度優先搜尋（Depth-first Search，DFS）\n由根節點出發，選擇某一子樹並以垂直方向由上到下處理，將其後代節點訪問完後，再選擇另一子樹遞迴地處理。 廣度優先搜尋（Breath-first Search，BFS）\n由根節點出發，以水平方向由左到右處理，將同階層的兄弟節點訪問完畢後，接續處理下一接層的所有節點。  DFS - 前序：\nBFS：\n1. 深度優先搜尋 DFS 走訪一個節點有三個動作：\n （L）走訪左子樹 （R）走訪右子樹 （N）訪問當前節點  graph TB; N((N)) --- L((L)) \u0026amp; R((R)); 這三個動作根據執行順序，一共會有 3! = 6 種組合：NLR、NRL、LNR、LRN、RNL、RLN。限制只能先走左子樹、再走右子樹，因此只會剩下三種組合：NLR、LNR、LRN。\n所以，DFS 根據訪問節點的順序不同，有以下三種類型：\n 前序（Preorder） 中序（Inorder） 後序（Postorder）  graph TB; 1((1)) --- 2((2)) \u0026amp; 3((3)); 2((2)) --- 4((4)) \u0026amp; 5((5)); 3((3)) --- 6((6)) \u0026amp; 7((7)); 4((4)) --- 8((8)); 以中序 LNR 為例，執行動作順序：\n （L）走訪左子樹 （N）訪問當前節點 （R）走訪右子樹  從根節點 1 起步 走訪 1 左樹，2 走訪 2 左樹，4 走訪 4 左樹，8 走訪 8 左樹，空子樹 訪問：8 走訪 8 右樹，空子樹 訪問：4 走訪 4 右樹，空子樹 訪問：2 走訪 2 右樹，5 走訪 5 左樹，空子樹 訪問：5 走訪 5 右樹，空子樹 訪問：1 走訪 1 右樹，3 走訪 3 左樹，6 走訪 6 左樹，空子樹 訪問：6 走訪 6 右樹，空子樹 訪問：3 走訪 3 右樹，7 走訪 7 左樹，空子樹 訪問：7 走訪 7 右樹，空子樹 根據走訪過程，此中序走訪結果為：8 4 2 5 1 6 3 7  前序 NLR：  執行順序：1 2 4 8 5 3 6 7   中序 LNR：  執行順序：8 4 2 5 1 6 3 7   後序 LRN：  執行順序：8 4 5 2 6 7 3 1    DFS 通常會使用 遞迴（Recursion） 或 堆疊（Stack） 實作。\n2. 廣度優先搜尋 BFS 和深度優先搜尋不同，廣度優先搜尋會先訪問離根節點最近的節點。也就是它會由上而下，並在同一個階層，由左至右依序訪問節點，因此又稱作 層序走訪（Levelorder Traversal）。\nDFS 通常會使用 佇列（Queue） 實作。\n總結 簡單紀錄樹與二元樹的概念，下週會先說明堆積排序，而樹的實作部分則再之後會使用二元搜尋樹來說明。\n","description":"再說明堆積排序前，先來看之前還沒提到的樹狀資料結構。","id":87,"section":"posts","tags":["資料結構","樹","二元樹","w3HexSchool"],"title":"JavaScript 學演算法（十二）- 樹 \u0026 二元樹","uri":"https://chupai.github.io/posts/2006/ds_tree_and_binary_tree/"},{"content":"這週是六角鼠年鐵人賽第十九週，這週來說明 希爾排序（Shell Sort）。\n\r希爾排序（Shell Sort） 希爾排序（Shell Sort），也稱 遞減增量排序，是 插入排序 的一種更高效的改進版本，為不穩定排序。\n插入排序（Insertion Sort） 的兩點特性：\n 在已經排好序的資料操作時，是效率高的，即可以達到 $O(n)$。 但一般情況是低效，每次只能將資料移動一位。  而 希爾排序 是在 插入排序 基礎上添加了 間隔長度（gap） 的概念，使得 插入排序 可以分組執行，並且資料的移動距離可以大於一。\n其概念為，將整個陣依照預先指定的 gap，交錯分割成數個小陣列，並以插入排序的方式將這些小陣列個別排序，然後逐漸縮小 gap，直到 gap 等於 1。此時再作最後一次插入排序。\n舉例：\nnums = [9, 8, 7, 6, 5, 4, 3, 2, 1] gap = 3 9 8 7 6 5 4 3 2 1 9 6 3 =\u0026gt; 3 6 9 8 5 2 =\u0026gt; 2 5 8 7 4 1 =\u0026gt; 1 4 7 3 2 1 6 5 4 9 8 7 gap = 2 3 2 1 6 5 4 9 8 7 3 1 5 9 7 =\u0026gt; 1 3 5 7 9 2 6 4 8 =\u0026gt; 2 4 6 8 1 2 3 4 5 6 7 8 9 gap = 1 1 2 3 4 5 6 7 8 9 =\u0026gt; 1 2 3 4 5 6 7 8 9 演算法實作 這是基本的插入排序：\n1 2 3 4 5 6 7 8 9 10 11 12 13  function insertionSort(arr) { const n = arr.length; for (let i = 1; i \u0026lt; n; i++) { const temp = arr[i]; let j = i; while (j \u0026gt; 0 \u0026amp;\u0026amp; temp \u0026lt; arr[j - 1]) { arr[j] = arr[j - 1]; j -= 1; } arr[j] = temp; } return arr; }   希爾排序的設計者 Donald Shell 最初建議選擇 gap = n / 2 比較好理解。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function shellSort(arr) { const n = arr.length; let gap = Math.floor(n / 2); while (gap \u0026gt; 0) { // 與插入排序極為相似  for (let i = gap; i \u0026lt; n; i++) { const temp = arr[i]; let j = i; while (j \u0026gt;= gap \u0026amp;\u0026amp; temp \u0026lt; arr[j - gap]) { arr[j] = arr[j - gap]; j -= gap; } arr[j] = temp; } gap = Math.floor(gap / 2); // 縮小間隔長度  } return arr; }   簡易執行時間比較：\nSee the Pen Shell Sort by Chupai@Design (@chupai) on CodePen.  優化間隔長度 間隔長度的選擇是是希爾排序的重要部分。\n希爾排序的時間複雜度不容易計算，因為會根據間距值來決定。\n 使用最差的間距，最差時間複雜度：$O(n^2)$ 使用最佳的間距，最佳時間複雜度：$O(n \\log n)$ 平均複雜會根據間距值來決定 空間複雜度為： $O(1)$  最佳的間隔長度是透過複雜的數學公式所計算出來的，而且會根據資料大小，而有所不同。這裡不做深究，相關細節可參考 wikipedia。\n我們以最常見的 Marcin Ciura 為例。\n定義間隔長度常數，並在執行排序時傳入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  const CIURA_GAPS = [1750, 701, 301, 132, 57, 23, 10, 4, 1]; function shellSort(arr, gaps) { const n = arr.length; for (let gap of gaps) { for (let i = gap; i \u0026lt; n; i++) { const temp = arr[i]; let j = i; while (j \u0026gt;= gap \u0026amp;\u0026amp; temp \u0026lt; arr[j - gap]) { arr[j] = arr[j - gap]; j -= gap; } arr[j] = temp; } } return arr; } shellSort(arr, CIURA_GAPS);   ","description":"希爾排序（Shell Sort） 是插入排序的一種更高效的改進版本。","id":88,"section":"posts","tags":["排序演算法","希爾排序","w3HexSchool"],"title":"JavaScript 學演算法（十一）- 希爾排序","uri":"https://chupai.github.io/posts/2006/sort_algorithm_shell_sort/"},{"content":"這週是六角鼠年鐵人賽第十八週，這週簡單說明 快速排序（Quick Sort）。\n\r快速排序（Quick Sort） 快速排序（Quick Sort） 是實用性很高的排序法，與合併排序一樣是使用 分治法 的應用。\n操作流程：\n 快速排序是從數列中隨機選擇一個數作為 基準（pivot）。 將比基準小的移至 基準 左邊，形成左區塊 將比基準大的移至 基準 右邊，形成右區塊 分別對左邊和右邊的區塊重複前項 3 操作（遞迴），直到區塊中只剩一個元素。  演算法實作 1. 簡單好懂版本 此版本使用遞迴結構，並使用額外空間儲存比較後的元素，不會改變原陣列。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function quickSort(arr) { const n = arr.length; if (n \u0026lt; 2) { return arr; } // 1  const pivot = arr[0]; // 2  const [leftArr, rightArr] = [[], []]; // 3  for (let i = 1; i \u0026lt; n; i++) { if (pivot \u0026gt; arr[i]) { leftArr.push(arr[i]); } else { rightArr.push(arr[i]); } } // 4  return [...quickSort(leftArr), pivot, ...quickSort(rightArr)]; }    遞迴停止條件：如果陣列內只剩一個元素就停止或陣列為空，也可以寫成 n \u0026lt;= 1。 選擇第一個元素作為基準。 比較元素，將元素分為左右兩邊。 遞迴、合併（小的放基準前面，大的放後面），也可以寫成 quickSort(left).concat([pivot], quickSort(rightArr))。  此版本雖然簡單好懂，但空間複雜度不佳，會消耗大量記憶體。\n2. 原地（in-place）劃分版本 原地（in-place）劃分版本是使用交換位置來劃分兩個區塊。\n將第一個元素作為 基準，比較元素後，會分成兩個區塊：\n 左邊區塊：比基準小的元素 右邊區塊：比基準大的元素，包含等於  流程：\n 右邊區塊第一個元素預設為第二個位置。 當遇到比基準小的值，會與右邊區塊的第一個值交換位置。 全部比較完畢後，基準與左邊區塊最後一個元素交換位置。  See the Pen 快速排序 - 劃分操作：第一個元素為基準 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  劃分操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function partition(arr, start, end) { const swap = (arr, a, b) =\u0026gt; [arr[a], arr[b]] = [arr[b], arr[a]]; // 1  const pivot = arr[start]; // 2  let firstRightIndex = start + 1; // 3  // 4  for (let i = start + 1; i \u0026lt;= end; i++) { // 5  if (arr[i] \u0026lt; pivot) { swap(arr, i, firstRightIndex); firstRightIndex += 1; } } const lastLeftIndex = firstRightIndex - 1; // 6  swap(arr, start, lastLeftIndex); return lastLeftIndex; }    陣列交換位置函式 將第一元素作為基準元素。 紀錄目前左邊區塊的第一元素位置，預設為基準元素的下一個。 從第二個元素開始遍歷至最後一個。 遇到比基準小的元素就交換，並遞增紀錄變數 firstRightIndex。 firstMaxIndex - 1 右邊區塊的第一元素位置的前一個就是左邊區塊最後一個元素。 最後回傳目前基準元素的位置，因為已經交換位置了，所以回傳 lastLeftIndex。  接下來回到函式本體：\n1 2 3 4 5 6 7 8 9  function quickSort(arr, start = 0, end = arr.length - 1) { if( start \u0026gt;= end) { return arr; } // 1  const pivotIndex = partition(arr, start, end); // 2  // 3  quickSort(arr, start, pivotIndex - 1); quickSort(arr, pivotIndex + 1, end); return arr; }    停止歸遞條件 執行劃分操作 歸遞  最終程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  function quickSort(arr, start = 0, end = arr.length - 1) { if (start \u0026gt;= end) { return arr; } const pivotIndex = partition(arr, start, end); quickSort(arr, start, pivotIndex - 1); quickSort(arr, pivotIndex + 1, end); return arr; function partition(arr, start, end) { const swap = (arr, a, b) =\u0026gt; ([arr[a], arr[b]] = [arr[b], arr[a]]); const pivot = arr[start]; let firstRightIndex = start + 1; for (let i = start + 1; i \u0026lt;= end; i++) { if (arr[i] \u0026lt; pivot) { swap(arr, i, firstRightIndex); firstRightIndex += 1; } } const lastLeftIndex = firstRightIndex - 1; swap(arr, start, lastLeftIndex); return lastLeftIndex; } }   3. 優化基準的選擇 快速排序時間複雜最佳的情況必須剛好 基準 為數列的中間值，如果選取到最小或最大值，則會是最糟的情況。那麼我們選擇第一個元素作為 基準，如果數列已是排序狀態，就會導致演算法時間複雜度是最糟結果。\n為了避免這種極端的 基準 出現，比較常見的做法為選取中間位置或是隨機選取作為 基準，選取到最小或最大值的機率會降低。\n取中間位置的元素，再比較前需先將元素換到開頭。\nSee the Pen 快速排序 - 劃分操作：中間元素為基準 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function partition(arr, start, end) { const swap = (arr, a, b) =\u0026gt; [arr[a], arr[b]] = [arr[b], arr[a]]; const mid = Math.floor((start + end) / 2); // 1  const pivot = arr[mid]; let firstRightIndex = start + 1; swap(arr, mid, start); // 2  for (let i = start + 1; i \u0026lt;= end; i++) { if (arr[i] \u0026lt; pivot) { swap(arr, i, firstRightIndex); firstRightIndex += 1; } } const lastLeftIndex = firstRightIndex - 1; swap(arr, start, lastLeftIndex); return lastLeftIndex; }    取中間位置索引。 將基準元素先換至開頭。  隨機選取基準：\n1 2 3 4 5  // 1 改成 const pivotIndex = Math.floor(Math.random() * (end - start + 1) + start); const pivot = arr[pivotIndex]; // 2 改成 swap(arr, pivotIndex, start);   See the Pen 快速排序 - 劃分操作：隨機選取基準 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  除了選取中間位置元素和隨機選取元素作為 基準，另外還有其他避免極端情況的優化方式：\n 三數中位數 Median of three 中位數的中位數 Median of medians  4. 迭代結構 跟合併排序一樣，當資料數量非常非常大時，歸遞結構的操作很容易導致 堆疊溢位，因此可以改寫成迭代結構。\n我們可以用陣列模擬堆疊空間，將待劃分區塊的 start 和 end 保存在裡面。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function quickSort1(arr) { const stack = []; stack.push(0); stack.push(arr.length - 1); while (stack.length \u0026gt; 0) { const end = stack.pop(); const start = stack.pop(); if (start \u0026lt; end) { const pivotIndex = partition(arr, start, end); stack.push(start); stack.push(pivotIndex - 1); stack.push(pivotIndex + 1); stack.push(end); } } return arr; }   分析 簡易分析，若每次都會將數列剛好劃分成一半，反覆劃分直到剩一個元素，需要操作 $\\log_{2}n$ 次。每次劃分操作每個元素都會執行比較，也就是 $n$ 次，因此整體執行時間約為 $n \\log_{2} n$。\n但 基準 如果選取到最小或最大值，每次劃分元素都會集中一邊，需要操作 $n$ 次 才會剩一個元素。因此整體執行時間會變成為 $n^2$。\n 不穩定排序 時間複雜度  最佳：$O(n \\log n)$ 最差：$O(n^2)$ 平均：$O(n \\log n)$   空間複雜度為：根據實現的方式不同而不同 ","description":"快速排序（Quick Sort） 是實用性很高的排序法，與合併排序一樣是使用 分治法的應用。","id":89,"section":"posts","tags":["排序演算法","快速排序","w3HexSchool"],"title":"JavaScript 學演算法（十）- 快速排序","uri":"https://chupai.github.io/posts/2000601_sort_algorithm_quick_sort/"},{"content":"這週是六角鼠年鐵人賽第十七週，這週簡單說明 合併排序（Merge Sort）。\n\r合併排序（Merge Sort） 合併排序（Merge Sort） 又稱為 歸併排序，是建立在合併操作上的一種有效的排序演算法，是採用 分治法 的一個非常典型的應用。\n分治法（Divide and Conquer）簡單來說就是將問題分成兩個子問題或更多的子問題，再繼續將子問題分解成更小的子問題，直到可以簡單求解，接著將所有子問題的結果合併，就能求得元問題的解。分治法一般會使用遞迴實現。\n操作流程，採用分治法，分為兩個操作：\n 分割：將數列平均分割成兩半，重複操作直到區塊中只剩一個元素。 合併：接著再將各個子陣列合併，合併時會反覆比較第一個數，並將較小的元素移至上一層中。重複操作直到剩一個數列，排序完畢。  合併排序的實現有兩種方法：\n 遞迴結構（自頂向下 Top-down） 迭代結構（自底向上 Bottom-up）  一般來說，合併排序是使用遞迴結構來實現的，但遞迴有一個問題，就是需要使用到額外空間來儲存子陣列，而且當遞迴函式被呼叫的過於頻繁，可能導致 堆疊溢位。\n為了優化合併排序（迭代結構），我們可以跳過分割這個操作，也就是一開始就將它們視為已分割狀態，比較相鄰兩個元素進行合併操作，每輪進行合併操作的元素都會翻倍成長。\n遞迴結構實作 遞迴結構一共需要兩個函式，並透過遞迴函式的方式來處理。\n1. 分割操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function mergeSort(arr) { const n = arr.length; // 1  // 2  if (n \u0026lt; 2) { return arr; } const midIndex = Math.floor(n / 2); // 3  // 4  const leftArray = arr.slice(0, midIndex); const rightArray = arr.slice(midIndex); // 5  mergeSort(leftArray); mergeSort(rightArray); }    陣列元素數量。 遞迴停止條件：如果陣列內只剩一個元素就停止或陣列為空。 取陣列的中間索引。 使用 slice() 將陣列分割成兩個子陣列。 使用遞迴繼續分割兩個子陣列。  2. 合併操作 合併操作函式，會傳入兩個陣列，並依元素大小排序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function merge(leftArr, rightArr) { const temp = []; // 1  // 2  while (leftArr.length \u0026amp;\u0026amp; rightArr.length) { // 3  if (leftArr[0] \u0026lt; rightArr[0]) { temp.push(leftArr.shift()); } else { temp.push(rightArr.shift()); } } return temp.concat(leftArr, rightArr); // 4 }    宣告變數儲存合併結果。 while 迴圈終止條件：當一個陣列為空就跳出迴圈。 比較大小後，使用 shift() 將元素刪除，並加到結果陣列中。 將剩餘元素的陣列與結果合併。  以上實作法方邏輯上沒問題，網路上很多文章的範例也都是這樣實作的（包含 維基百科） 。\n但 shift 方法背後原理操作，在刪除第一個元素後，其餘的元素都會往前移動，其實並不高效。\n因此建議使用以下方式來實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  function merge(leftArr, rightArr) { const temp = []; // 1  let [leftIndex, rightIndex] = [0, 0]; // 2  // 3  while (leftIndex \u0026lt; leftArr.length \u0026amp;\u0026amp; rightIndex \u0026lt; rightArr.length) { if (leftArr[leftIndex] \u0026lt; rightArr[rightIndex]) { // 4  temp.push(leftArr[leftIndex]); leftIndex += 1; } else { temp.push(rightArr[rightIndex]); rightIndex += 1; } } // 5  while (leftIndex \u0026lt; leftArr.length) { temp.push(leftArr[leftIndex]); leftIndex += 1; } while (rightIndex \u0026lt; rightArr.length) { temp.push(rightArr[rightIndex]); rightIndex += 1; } return temp; }    宣告變數儲存合併結果。 宣告變數來紀錄當前索引。 while 迴圈終止條件：當前索引大於陣列長度，表示這個陣列都加到結果陣列中了。 比較大小後，將元素放進結果陣列中，並將當前索引往前（+1）。 將剩餘元素的陣列與結果合併。  更簡潔的寫法：\n1 2 3 4 5  // 4 temp.push(leftArr[leftIndex++]); // 5 return [...temp, ...leftArr.slice(leftIndex), ...rightArr.slice(rightIndex)];   以下為使用 shift() 和使用索引兩種方式的簡易的執行時間比較，你可以發現，雖然 shift() 實作簡潔好理解，但執行速度差異非常大。\nSee the Pen 合併排序（Merge Sort） by Chupai@Design (@chupai) on CodePen.  3. 完成演算法 將分割的子陣列，呼叫 merge() 合併：\n1 2 3 4 5 6 7 8 9  function mergeSort(arr) { const n = arr.length; if (n \u0026lt; 2) { return arr; } const midIndex = Math.floor(n / 2); const leftArray = arr.slice(0, midIndex); const rightArray = arr.slice(midIndex); return merge(mergeSort(leftArray), mergeSort(rightArray)); }   完整程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  function mergeSort(arr) { const n = arr.length; if (n \u0026lt; 2) { return arr; } const midIndex = Math.floor(n / 2); const leftArray = arr.slice(0, midIndex); const rightArray = arr.slice(midIndex); return merge(mergeSort(leftArray), mergeSort(rightArray)); function merge(leftArr, rightArr) { const temp = []; let [leftIndex, rightIndex] = [0, 0]; while (leftIndex \u0026lt; leftArr.length \u0026amp;\u0026amp; rightIndex \u0026lt; rightArr.length) { if (leftArr[leftIndex] \u0026lt; rightArr[rightIndex]) { temp.push(leftArr[leftIndex++]); } else { temp.push(rightArr[rightIndex++]); } } return [...temp, ...leftArr.slice(leftIndex), ...rightArr.slice(rightIndex)]; } }   這種實作方式，並不會更改原陣列，會回傳一個排序後的新陣列。\n4. 優化版本 使用 slice() 分割陣列的方式，雖然簡潔好理解，但會額外使用很多記憶體空間，因此我們可以直接在原陣列上進行分割的操作。\n要在原陣列上進行分割操作，我們會使用紀錄索引位置的方式。\n一共需要傳入 start 開頭和 end 結尾，再計算出 mid 中間位置。\n 左子陣列為 start 至 mid 右子陣列為 mid + 1 至 end  1 2 3 4 5 6 7 8 9 10 11 12 13  // 1 function mergeSort(arr, start = 0, end = arr.length - 1) { if (start === end) { return arr; } // 2  const mid = Math.floor((start + end) / 2); // 3  // 4  mergeSort(arr, start, mid); mergeSort(arr, mid + 1, end); merge(arr, start, mid, end); // 3  return arr; }    start 和 end 的參數預設值為陣列開頭和結尾。 停止歸遞條件：開頭與結尾索引相同時就停止。 計算中間的索引位置。 歸遞 合併操作  合併操作函式，基本邏輯與原本的差不多，但最後一步不回傳排序好的陣列，而是用記錄下來的索引位置，直接覆蓋掉原陣列：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  function merge(arr, start, mid, end) { let temp = []; let [leftIndex, rightIndex] = [start, mid + 1]; // 1  while (leftIndex \u0026lt;= mid \u0026amp;\u0026amp; rightIndex \u0026lt;= end) { if (arr[leftIndex] \u0026lt; arr[rightIndex]) { temp.push(arr[leftIndex++]); } else { temp.push(arr[rightIndex++]); } } while (leftIndex \u0026lt;= mid) { temp.push(arr[leftIndex++]); } while (rightIndex \u0026lt;= end) { temp.push(arr[rightIndex++]); } // 3  for (let i = start; i \u0026lt;= end; i++) { arr[i] = temp[i - start]; } }    左右陣列起始索引。 終止條件：起始索引等於結尾索引。 將排序完的元素，覆蓋掉原陣列。  完整程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  function mergeSort(arr, start = 0, end = arr.length - 1) { if (start === end) { return arr; } const mid = Math.floor((start + end) / 2); mergeSort(arr, start, mid); mergeSort(arr, mid + 1, end); merge(arr, start, mid, end); return arr; function merge(arr, start, mid, end) { let temp = []; let [leftIndex, rightIndex] = [start, mid + 1]; while (leftIndex \u0026lt;= mid \u0026amp;\u0026amp; rightIndex \u0026lt;= end) { if (arr[leftIndex] \u0026lt; arr[rightIndex]) { temp.push(arr[leftIndex++]); } else { temp.push(arr[rightIndex++]); } } while (leftIndex \u0026lt;= mid) { temp.push(arr[leftIndex++]); } while (rightIndex \u0026lt;= end) { temp.push(arr[rightIndex++]); } for (let i = start; i \u0026lt;= end; i++) { arr[i] = temp[i - start]; } } }   此作法可以減少記憶體的使用（減少空間複雜度），但會更動原陣列。\n迭代結構實作 當資料數量非常非常大時，歸遞結構的操作很容易導致 堆疊溢位，因此可以改用迭代結構。\n上面實作完成後，你可以發現，我們可以直接跳過分割這個步驟，直接將它視為已分割後的狀態，直接進行合併操作。\n流程：\n 將陣列中相鄰兩個元素進行合併操作（排序）。 每輪進行操作的元素數量會翻倍成長。 當長度大於等於陣列元素數量，排序完畢。  1 2 3 4 5 6 7 8 9 10 11 12  function mergeSort(arr) { let n = arr.length; for (let i = 1; i \u0026lt;= n; i *= 2) { for (let j = 0; j + i \u0026lt; n; j += i * 2) { const start = j; const end = Math.min(j + i * 2 - 1, n - 1); const mid = j + i - 1; merge(arr, start, mid, end); } } return arr; }    i = 1：起始元素數量為 1。 i \u0026lt;= n：當元素數量大於等於 n 表示排序完畢。 i *= 2：每輪元素數量會翻倍。 j = 0：從頭開始取元素遍歷。 j + i \u0026lt; n：當索引 j + i 超過 n 表示這輪都合併操作過了。 j += i * 2：一次操作元素的數量會是 i 兩倍。 end：若要操作的元素索引大於陣列，就取陣列的最後一個元素。  完整程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  function mergeSort(arr) { let n = arr.length; for (let i = 1; i \u0026lt;= n; i *= 2) { for (let j = 0; j + i \u0026lt; n; j += i * 2) { const start = j; const end = Math.min(j + i * 2 - 1, n - 1); const mid = j + i - 1; merge(arr, start, mid, end); } } return arr; function merge(arr, start, mid, end) { let temp = []; let [leftIndex, rightIndex] = [start, mid + 1]; while (leftIndex \u0026lt;= mid \u0026amp;\u0026amp; rightIndex \u0026lt;= end) { if (arr[leftIndex] \u0026lt; arr[rightIndex]) { temp.push(arr[leftIndex++]); } else { temp.push(arr[rightIndex++]); } } while (leftIndex \u0026lt;= mid) { temp.push(arr[leftIndex++]); } while (rightIndex \u0026lt;= end) { temp.push(arr[rightIndex++]); } for (let i = start; i \u0026lt;= end; i++) { arr[i] = temp[i - start]; } } }   分析 簡易分析，假設資料為 $n$，分割操作可以略過不計。每輪操作的資料數量固定為 $n$，共會執行 $\\log_{2}n$ 輪合併操作，整體執行時間約為 $n \\log_{2}n$。\n 穩定排序 時間複雜度  最佳：$O(n \\log n)$ 最差：$O(n \\log n)$ 平均：$O(n \\log n)$   空間複雜度為： $O(n)$ ","description":"合併排序（Merge Sort） 又稱為 歸併排序，是建立在合併操作上的一種有效的排序演算法，是採用 分治法 的一個非常典型的應用。","id":90,"section":"posts","tags":["排序演算法","排序演算法","合併排序","w3HexSchool"],"title":"JavaScript 學演算法（九）- 合併排序","uri":"https://chupai.github.io/posts/200525_sort_algorithm_merge_sort/"},{"content":"這週是六角鼠年鐵人賽第十六週，資料結構先暫停一下，換換口味，來看排序。排序演算法（Sort Algorithm）是基礎演算法之一，是一種能將一串資料依照特定排序方式進行排列的一種演算法。\n\r什麼是排序（Sort） 1. 定義 排序（Sort），將一組資料一使用者需求，予以重新排列其順序。\n一般會依資料之大小順序排序（由大至小、或由小至大）。\n2. 分類 排序演算法分類方式有以下這幾種。\n第一類：內部與外部\n 內部排序（Internal Sort） 又稱「陣列排序」  定義：排序之工作，主要在主記憶體（RAM）完成。 意指資料量小，可以直接放在記憶體內進行。   外部排序（External Sort） 又稱「檔案排序」  定義：排序之工作，主要是在輔助記憶體（Disk, File）完成。 意指資料量大，無法直接存放在記憶體，必須先存放於輔助記憶體內再處理。    第二類：穩定性與不穩定性\n 穩定性（Stable）：相同值的資料，排序後順序和排序前一樣。 不穩定性（Unstable）：相同值的資料，排序後順序不一定和排序前一樣。  第三類：簡單與高等\n 簡單排序：排序演算法簡單，但執行時間較長。 高等排序：排序演算法複雜，執行時間較短。  第四類：比較與非比較\n 比較排序：通過比較來決定元素間的相對次序。 非比較排序：不通過比較來決定元素間的相對次序。  3. 常見排序演算法 排序相關動畫影片，可以稍微的看一下：\n 如何最有效率地整理書架？ - Chand John 15 Sorting Algorithms in 6 Minutes  簡單排序：\n 氣泡排序（Bubble Sort） 選擇排序（Selection Sort） 插入排序法（Insertion Sort）  初學排序所必須知道的三個最基本排序演算法，但它們由於速度不快而不實用。\n高等排序：\n 合併排序 Merge Sort 快速排序 Quick Sort 希爾排序 Shell Sort 堆積排序 Heap Sort  高等排序通常用於高效處理大量資料（幾萬起跳），不過有些對於資料過於小（幾千幾百）可能反而比簡單排序還慢。\n簡單排序 1. 氣泡排序（Bubble Sort） 氣泡排序（Bubble Sort）又稱為冒泡排序、泡沫排序，是排序演算法中最簡單的，但運行時間是最差的。\n其排序方式為相臨資料反覆進行比較，若發現資料順序不對，就將資料互換。資料將如氣泡般，從一端漂浮到另一端。\n流程模擬動畫：\nSee the Pen Sort Algorithm - Bubble Sort with Vue.js by Chupai@Design (@chupai) on CodePen.  遞增排列運作原理：\n 第一輪\n比較相鄰的元素，如果前者大於後者就相互交換；\n從頭到尾執行比較動作，可以確保最後一個元素將會是最大的。 第二輪\n扣除最後一個元素（已排序完畢元素），針對其餘元素重複上述步驟；  每輪執行比較的元素會越來越少，執行至剩一個元素，排序完畢。\n氣泡排序的過程範例：\nnums = [4, 2, 3, 1]; 第一輪 4 2 交換 =\u0026gt; 2 4 3 1 4 3 交換 =\u0026gt; 2 3 4 1 4 1 交換 =\u0026gt; 2 3 1 4 第二輪 2 3 不換 =\u0026gt; 2 3 1 4 3 1 交換 =\u0026gt; 2 1 3 4 第三輪 2 1 交換 =\u0026gt; 1 2 3 4 氣泡排序分析：\n 穩定排序 時間複雜度  最佳：$O(n)$ 最差：$O(n^2)$ 平均：$O(n^2)$   空間複雜度為： $O(1)$  演算法實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function bubbleSort (arr) { const n = arr.length; // 1  // 2  for(let i = 0; i \u0026lt; n - 1; i++) { // 3  for(let j = 0; j \u0026lt; n - 1 - i; j++) { // 4  if(arr[j] \u0026gt; arr[j + 1]) { // 5  const temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } return arr; }    元素數量。 執行 n - 1 輪（最後一次只剩自己，所以不比較）。 交換 n - 1 - i 次（兩兩互相比較，所以 -1，並扣除每輪已經排好的元素，所以減 i）。 比較大小。 元素交換位置。  交換位置也可以使用 ES6 的解構指定（destructuring assignment）：\n1  [arr[j], arr[j+1]] = [arr[j+1], arr[j]];   你可以建立一個交換函式，之後很多排序法都會用到：\n1 2 3 4 5 6 7 8  function swap(arr, index1, index2) { const temp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = temp; // - ES6 的方式  // [array[index1], array[index2]] = [array[index2], array[index1]]; }   氣泡排序的平均與最差的時間複雜度都是 $O(n^2)$，但最佳的情況（輸入陣列已是排序好的）時間複雜度為 $O(n)$（元素不做任何的交換）。\n要讓最佳的情況時間複雜度為 $O(n)$，需要優化一下程式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function bubbleSort (arr) { const n = arr.length; let swapped = true; for(let i = 0; (i \u0026lt; n - 1) \u0026amp;\u0026amp; swapped; i++) { swapped = false; for(let j = 0; j \u0026lt; n - 1 - i; j++) { if(arr[j] \u0026gt; arr[j + 1]) { swapped = true; swap(arr, j, j + 1); } } } return arr; }   加上一個標注（flag），在新的一輪開始時，判斷上一輪是否有發生交換，如果沒有表示剩餘的元素已經排序完畢，下一輪會因為 swapped 被設為 false 就會跳出迴圈。\n2. 選擇排序（Selection Sort） 選擇排序（Selection Sort） 是一種簡單直觀的排序演算法，類似氣泡排序。\n其排序方式為反覆進行搜數列中的最小值，並與最左側的資料交互。\n流程模擬動畫：\nSee the Pen Sort Algorithm - Selection Sort with Vue.js by Chupai@Design (@chupai) on CodePen.  遞增排列運作原理：\n 第一輪\n預設第一個元素為最小值，往右側進行搜尋最小值；\n若遇到比目前最小值還小的元素就替換掉；\n搜尋至最後，將最小值與最左側元素交換位置。 第二輪\n扣除第一個元素，針對其餘元素重複以上的步驟。  持續上述步驟，每輪執行比較的元素會越來越少，直到排序完畢。\n選擇排序的過程範例：\nnums = [4, 1, 3, 2]; 第一輪 min 4 (預設) min 1 交換位置 =\u0026gt; 1 4 3 2 第二輪 min 4 (預設) min 3 min 2 交換位置 =\u0026gt; 1 2 4 3 第三輪 min 4 (預設) min 3 交換位置 =\u0026gt; 1 2 3 4 選擇排序分析：\n 不穩定排序。 時間複雜度  Best Case：$O(n^2)$ Worst Case：$O(n^2)$ Average Case：$O(n^2)$   空間複雜度為： $O(1)$  演算法實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function selectionSort(arr) { const n = arr.length; // 1  // 2  for(let i = 0; i \u0026lt; n; i++) { // 3  let minIndex = i; // 4  for(let j = 1 + i; j \u0026lt; n; j++) { // 5  if(arr[j] \u0026lt; arr[minIndex]) { minIndex = j; } } swap(arr, i, minIndex); // 6  } return arr; }    元素數量。 執行 n 輪。 minIndex 用來紀錄最小值的索引。 因為 minIndex 預設為第一元素 j 從 1 開始尋找，每輪會扣除已排好的元素，所以加 i。 比較是否為最小值。 一輪結束後就將最小值與 i 交換。  選擇排序就算陣列已經是排序好的狀態，還是要經過多輪比較，所以不論是最好、最壞、平均的時間複雜度皆為 $O(n^2)$。但跟氣泡排序比起來，執行交換操作只需要 n 次。\n3. 插入排序（Insertion Sort） 插入排序（Insertion Sort）是也一種簡單直觀的排序演算法，你如果玩過撲克牌，就都有用過。\n其排序方式為，將左側作為已排序數列，右側為未排序數列，從未排序的數列中取第一個，放到已排序數列中的適當位置。\n流程模擬動畫：\nSee the Pen Sort Algorithm - Insertion Sort with Vue.js by Chupai@Design (@chupai) on CodePen.  遞增排列運作原理：\n 第一輪\n從第一個元素開始，該元素視為已經被排序；\n取出下一個元素，判斷要插入左側元素的前面還是後面。 第二輪\n已經被排序已有兩個元素；\n取出下一個元素，判斷要插入左側元素的前面還是後面；\n如果是前面就依序往下判斷。  持續上述步驟，右側位被排序的元素會遞減，直到排序完畢。\n插入排序的過程範例：\nnums = [4, 2, 3, 1]; 第一輪 [4] [2 3 1] [ 4] 2 [2 4] 第二輪 [2 4] [3 1] [2 4] 3 [2 3 4] 第三輪 [2 3 4] [1] [2 3 4] 1 [2 3 4] 1 [ 2 3 4] 1 [1 2 3 4] 分析：\n 穩定排序。 時間複雜度  Best Case：$O(n)$ Worst Case：$O(n^2)$ Average Case：$O(n^2)$   空間複雜度為： $O(1)$  演算法實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function insertionSort(arr) { const n = arr.length; // 1  // 2  for (let i = 1; i \u0026lt; n; i++) { let temp = arr[i]; // 3  let j = i; // 4  // 5  while (j \u0026gt; 0 \u0026amp;\u0026amp; temp \u0026lt; arr[j - 1]) { arr[j] = arr[j - 1]; // 6  j -= 1; } arr[j] = temp; // 7  } return arr; }    元素數量。 從第二個元素開始，所以 i = 1。 使用一個變數儲存要判斷元素的值。 使用一個變數儲存前要判斷元素的當前索引。 只要當前索引比 0 大，並且小於左側的值，就繼續比較。 將左側的值往後移。 將要判斷元素的值插入正確位置上。  4. 總結 這三種簡單演算法複雜度基本上差不多：\n   排序方法 最佳時間 最差時間 平均時間 空間 穩定性     氣泡 Bubble $O(n)$ $O(n^2)$ $O(n^2)$ $O(1)$ 穩定   選擇 Selection $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不穩定   插入 Insertion $O(n)$ $O(n^2)$ $O(n^2)$ $O(1)$ 穩定    這是一個簡易的執行時間計時器，對 100 ~ 10000 個隨機數字進行排序。\nSee the Pen Simple Sorting Algorithm EXECUTION TIME by Chupai@Design (@chupai) on CodePen.  執行時間會根據執行環境而有所不同，不過基本上元素數量越小，看不出彼此間的差異，但你可以觀察到當元素達到 10000 時，氣泡排序明顯是最差的，而插入排序稍微快於選擇排序。\n不過這三種排序法，資料量非常大時（幾十萬起跳），基本上都要跑很久，所以實際應用上都不適合，下週來看比較實用的合併排序。\n","description":"排序演算法（Sort Algorithm）是基礎演算法之一，是一種能將一串資料依照特定排序方式進行排列的一種演算法。","id":91,"section":"posts","tags":["排序演算法","氣泡排序","插入排序","選擇排序","w3HexSchool"],"title":"JavaScript 學演算法（八）- 排序演算法","uri":"https://chupai.github.io/posts/200518_sort_algorithm/"},{"content":"這週是 六角鼠年鐵人賽 第十五週，這週來看具有不重父元素特性的資料結構，「集合」 \u0026amp;「 映射」。\n\r集合（Set） 集合（Set） 是一組無順序且唯一的資料所組成的資料結構，概念衍生自數學的「集合」。\n特性：\n 無序性：集合內各元素無特定排序或排序不重要。 互異性：集合內每個元素且只能出現一次。 確定性：給定一個集合，任給一個元素，該元素或者屬於或者不屬於該集合，二者必居其一。  基本操作：\n 檢查某元素是否在集合內 新增元素 刪除元素。  集合的基本操作，沒有取得指定元素的操作，這是因為集合是無序的資料結構，沒有索引或鍵名可以快速取得元素，必須透過迭代來查詢。\n運算：\n 聯集：將兩個集合的元素合併成一個新集合（元素不重複）。 交集：將兩個集合中共有的元素，組成一個新集合。 對稱差：將兩個集合中不重複的元素，組成一個新集合。 差集：給定兩集合，回傳一個包含存在第一個集合元素但不存在於第二集合的集合  JavaScript 實作集合 JavaScript 在 ES6 就新增了 Set 物件，但我們這裡嘗試使用物件模擬簡易的 Set。\n1. 建立類別 1 2 3 4 5 6  class MySet { constructor() { this.items = {}; } // methods }   裝資料的容器 items 使用物件而非陣列，是因為 JavaScript 的物件屬性不會重複，可以確保集合內的元素都是唯一的。\n2. 方法 基本操作：\n add(element)：新增元素。 delete(element)：移除元素。 has(element)：檢查元素是否存在。  因為 add 和 delete 方法會用到 has 方法，所以先來實現 has 方法。可以使用 in 關係運算子，來判斷元素是否是 items 物件的屬性：\n1 2 3  has(element) { return element in this.items; }   或是使用 hasOwnProperty() 來判斷物件是否有該屬性：\n1 2 3  has(element) { return this.items.hasOwnProperty(element); }   如果你有使用 ESLint 會拋出 錯誤，可以改成 Object.prototype.hasOwnProperty.call(this.items, element)。\n新增元素 add 方法，必須先檢查元素是否存在，如果元素已存在就跳出：\n1 2 3 4  add(element) { if (this.has(element)) return; this.items[element] = element; }   刪除元素 delete 方法，也要檢查元素是否存在，如果元素已存在就刪除：\n1 2 3 4 5  delete(element) { if (this.has(element)) { delete this.items[element]; } }   其餘輔助屬性方法：\n clear()：清空。 size()：元素數量。 values()：回傳一個包含所有元素的陣列。  最終程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class MySet { constructor() { this.items = {}; } has(element) { return Object.prototype.hasOwnProperty.call(this.items, element); } add(element) { if (this.has(element)) return; this.items[element] = element; } delete(element) { if (this.has(element)) { delete this.items[element]; } } clear() { this.items = {}; } size() { return Object.keys(this.items).length; } values() { return Object.values(this.items); } }   建立實體：\n1 2 3 4 5 6 7 8 9  const set = new MySet(); set.add(1); set.add(2); set.add(3); console.log(set.values()); // [1, 2, 3]  set.delete(1); console.log(set.values()); // [2, 3]   因為是簡易的 Set，所以有很多問題，例如：物件的屬性只能儲存字串，如果元素值為其他的型別都會被強制轉型成字串。\n3. ES6 原生 Set Set 只能使用建構式建立：\n1  new Set([iterable]);   能夠接受一個參數 iterable（可迭代物件）。\n1 2 3 4 5  const set1 = new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); console.log(set1); // Set {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;}  const set2 = new Set(\u0026#39;Hello\u0026#39;); console.log(set2); // Set {\u0026#39;H\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;}   屬性方法：\n add()：新增元素。 clear()：移除其所有元素。 delete()：移除指定元素。 has()：檢查員素是否存在。 values()：回傳一個 Iterator 物件，包含著 Set 物件中所有元素，由插入順序排序。 size：元素數量。 forEach()：迭代處理元素，用法等同陣列的 forEach()。  1 2 3 4 5 6 7 8 9  const set = new Set(); set.add(\u0026#39;a\u0026#39;); set.add(\u0026#39;b\u0026#39;); set.add(\u0026#39;c\u0026#39;); console.log(set); // Set {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;}  set.delete(\u0026#39;b\u0026#39;); console.log(set);    更詳細內容請參考 MDN。\n 集合操作 使用 ES6 原生 Set。\n1. 聯集 創建一個函式，回傳兩個集合中所有元素的新集合。\n最基本的作法就是迭代集合，將元素新增至新集合中：\n1 2 3 4 5 6  function uion(set1, set2) { const newSet = new Set(); set1.forEach(item =\u0026gt; newSet.add(item) ); set2.forEach(item =\u0026gt; newSet.add(item) ); return newSet; }   更簡單的的作法就是，使用展開運算子（spread operator），將兩個集合在一個陣列中展開，並建立新集合。\n1 2 3  function union(set1, set2) { return new Set([...set1, ...set2]); }   1 2 3 4  const set1 = new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); const set2 = new Set([\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;]); console.log(union(set1, set2)); // Set {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;}   2. 交集 將兩個集合中共有的元素，組成一個新集合。\n1 2 3 4 5 6 7 8 9  function intersection(set1, set2) { const temp = new Set(); set1.forEach(item =\u0026gt; { if(set2.has(item)) { temp.add(item); } }); return temp; }   使用 has() 去檢查元素。\n1 2 3 4  const set1 = new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); const set2 = new Set([\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;]); console.log(intersection(set1, set2)); // Set {\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;}   3. 對稱差 將兩個集合中不重複的元素，組成一個新集合。\n1 2 3 4 5 6 7 8 9 10 11  function difference(set1, set2) { const temp = union(set1, set2); const intersectionSet = intersection(set1, set2); intersection.forEach(item =\u0026gt; { if(temp.has(item)) { temp.delete(item); } }); return temp; }   簡單來說就是聯集減去交集。\n1 2 3 4  const set1 = new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); const set2 = new Set([\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;]); console.log(difference(set1, set2)); // Set {\u0026#39;b\u0026#39;, \u0026#39;e\u0026#39;}   4. 差集 給定兩集合，回傳一個包含存在第一個集合元素但不存在於第二集合的集合。\n1 2 3 4 5 6 7 8 9  function subtracting(set1, set2) { const temp = new Set(set1); set2.forEach((item) =\u0026gt; { if (temp.has(item)) { temp.delete(item); } }); return temp; }   先複製 set1 再減去 set2 擁有的元素。\n或者是新建一個集合，再將沒重複的元素新增至新集合中：\n1 2 3 4 5 6 7 8 9  function subtracting(set1, set2) { const temp = new Set(); set2.forEach((item) =\u0026gt; { if (!temp.has(item)) { temp.add(item); } }); return temp; }   1 2 3 4  const set1 = new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); const set2 = new Set([\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;]); console.log(subtracting(set1, set2)); // Set {\u0026#39;b\u0026#39;}   5. 子集 檢查該集合是是否為另一個集合的子集。\n1 2 3 4 5 6 7 8  function subSet(set1, set2) { if (set1.size \u0026gt; set2.size) return false; for (let item of set1) { if (!set2.has(item)) return false; } return true; }   forEach 沒辦法 return 所以我們使用 for of 來迭代 Set。\n1 2 3 4 5  console.log(subSet(new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]), new Set([\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;]))); // false  console.log(subSet(new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]), new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;]))); // true   映射（Map） 映射（Map）或稱 關聯陣列（Associative Array）、字典（Dictionary）是一種以「鍵值對 {key: value} 」形式儲存的有序資料結構，會根據不同語言有不同的名稱。\n映射，就如同電話簿中的名字和號碼一樣，先找到名字，就知道它的電話號碼。鍵（key）就是姓名，而值（value）如同電話號碼。\n定義：\n key 一定對映 value 一個映射不能包含重複的 key 每個 key 最多只能對映到一個 value  基本操作：\n 新增 刪除 查詢  JavaScript 中的映射 JavaScript 的物件物件本質上是鍵值對的資料結構，當你需要將 key 對應到 value 時，可以將字串作為 key 對應到任何型別的 value，搭配 in、delete、[] 等，能達到映射的相關操作。\n然而，物件終究不是映射類型，可能會遇到以下問題：\n 因為物件原型的特性，因此可能對應到意外的東西。 不易知道物件裡有多少對應。 物件無法使用非字串值作為 key。 無法保證 key 的順序。  請考慮以下情況，物件無法使用非字串值作為屬性名：\n1 2 3 4 5 6 7 8 9  const m = {}; const x = { id: 1 }; const y = { id: 1 }; m[x] = \u0026#39;foo\u0026#39;; m[y] = \u0026#39;bar\u0026#39;; console.log(m[x]); // bar   你可以發現 { id: 1 } 被強制轉型成字串，m[x] 與 m[y] 指向同一個屬性。\n1. ES6 原生 Map 物件 JavaScript 在 ES6 實現了 Map 物件，就是字典。\nMap 只能使用建構式建立：\n1  new Map([iterable]);   iterable 基本上為陣列（或其他元素成鍵值對的可迭代物件）。\n用法如下：\n1 2 3 4 5 6  const m = new Map([ [\u0026#39;a\u0026#39;, 1], [\u0026#39;b\u0026#39;, 2], ]); console.log(m); // Map { \u0026#39;a\u0026#39; =\u0026gt; 1, \u0026#39;b\u0026#39; =\u0026gt; 2 }   陣列的第一個項目就 key，第二個為 value。\n或是使用 Object.entries 方法，它回傳的格式就如同上面所需要的：\n1 2 3 4 5 6  const obj = { a: 1, b: 2 }; const iterable = Object.entries(obj); console.log(iterable); // [ [ \u0026#39;a\u0026#39;, 1 ], [ \u0026#39;b\u0026#39;, 2 ] ]  const m = new Map(iterable); console.log(m); // Map { \u0026#39;a\u0026#39; =\u0026gt; 1, \u0026#39;b\u0026#39; =\u0026gt; 2 }   也就是說可以使用此方法將物件轉成 Map。\n存取元素的方法為：\n set(key, value)：根據 key 存儲 value。 get(key)：根據 key 回傳 value，如果 map 中該 key 不存在，回傳 undefined。  1 2 3 4 5 6  const m = new Map(); m.set(\u0026#39;a\u0026#39;, 1); console.log( m.get(\u0026#39;a\u0026#39;) ); // 1 console.log( m.get(\u0026#39;b\u0026#39;) ); // undefined   set() 會回傳當前 map 實體，因此可以採鏈式寫法：\n1 2 3 4 5  const m = new Map(); m.set(\u0026#39;a\u0026#39;, 1) .set(\u0026#39;b\u0026#39;, 2) .set(\u0026#39;c\u0026#39;, 3);   移除元素需要使用 delete(key)，而不是 delete 運算子，而 has(key) 可以判斷 key 是否存在。\n1 2 3 4 5 6 7 8  const m = new Map([ [\u0026#39;a\u0026#39;, 1], [\u0026#39;b\u0026#39;, 2] ]); console.log( m.has(\u0026#39;a\u0026#39;) ); // true m.delete(\u0026#39;a\u0026#39;); console.log( m.has(\u0026#39;a\u0026#39;) ); // false   Map 與物件另一個最大差異就是有 forEach 方法和可以使用 for of 迭代：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const m = new Map([ [\u0026#39;a\u0026#39;, 1], [\u0026#39;b\u0026#39;, 2], [\u0026#39;c\u0026#39;, 3], ]); m.forEach((value, key) =\u0026gt; { console.log(value, key); }); // 1 \u0026#39;a\u0026#39; // 2 \u0026#39;b\u0026#39; // 3 \u0026#39;c\u0026#39;  for (let key of m) { console.log(key); } // [\u0026#39;a\u0026#39;, 1] // [\u0026#39;b\u0026#39;, 2] // [\u0026#39;c\u0026#39;, 3]    更詳細內容請參考 Map。\n 2. WeakMap 除了 Map，ES6 還新增了 WeakMap。\nWeakMap 與 Map 基本上一樣，除了以下幾點：\n WeakMap 的 key 只接受物件作為 key 。 WeakMap 的 key 所指向的物件可以被垃圾回收。 WeakMap 無法被迭代或清除。  1 2 3 4 5 6  const wm = new WeakMap(); const obj = {}; wm.set(obj, 1); // 正常 wm.set(\u0026#39;a\u0026#39;, 2); // Uncaught TypeError Invalid value used as weak map key   WeakMap 只有以下屬性方法：\n get(key) set(key, value) delete(key) has(key)  size、values()、entries()、forEach() 等皆沒有。\nWeakMap 對 key 引用是「弱引用」，這意味著若沒有其他引用存在時，垃圾回收機制就會釋放該物件所佔用的記憶體空間。因此 WeakMap 被設計成無法迭代。\n舉例來說，我們使用一個 Map 來記錄用戶的訪問次數：\n1 2 3 4  let john = { name: \u0026#39;John\u0026#39; }; const visitsCountMap = new Map(); visitsCountMap.set(john, 1);   某天這個用戶都不會來了，所以我們不需要它的訪問資料了，我們如果只有移除 john 的指向，map 內的內容還是會存在：\n1 2 3  john = null; console.log( visitsCountMap.size ); // 1   因為還需要清除 map 的內容，所以不能先移除 john 的指向，需要改成先移除 map 內的引用，再移除 john 的指向：\n1 2 3 4 5 6 7  // 上段程式碼改成這樣  visitsCountMap.delete( john ); console.log( visitsCountMap.size ); // 0  // 清除 map 的內容再移除指向 john = null;   但這樣的資料移除非常麻煩，因此就有了 WeakMap：\n1 2 3 4 5  let john = { name: \u0026#39;John\u0026#39; }; const visitsCountWeakMap = new WeakMap(); visitsCountWeakMap.set(john, 1); john = null;   { name: 'John' } 這個物件，除了 WeakMap 沒有其他引用了，所以這個物件會自動的從記憶體和 visitsCountWeakMap 中刪除。\n 更詳細內容請參考 WeakMap。\n","description":"這週是六角鼠年鐵人賽第十五週，這週來看具有不重複元素特性的資料結構，「集合」與「 映射」。","id":92,"section":"posts","tags":["資料結構","集合","映射","w3HexSchool"],"title":"JavaScript 學演算法（七）- 集合 \u0026 映射","uri":"https://chupai.github.io/posts/200517_ds_set_map/"},{"content":" JavaScript筆記 目錄\n \rES6 為 {} 物件字面值新增了幾個方便擴充功能，以下只提幾個常用。\n簡寫 1. 屬性值簡寫 舉一個簡單的範例來說明。\n變數與屬性名相同，這種應用場景很常見：\n1 2 3 4 5 6 7 8  function foo(a, b) { return { a: a, b: b }; } console.log(foo(1, 2)); // {a: 1, b: 2}   但在 ES6 環境下，可以這樣寫：\n1 2 3 4 5  function foo(a, b) { return { a, b }; } console.log(foo(1, 2)); // {a: 1, b: 2}   當屬性名與值名稱相同時，可以省略後面的值。\n或者是：\n1 2 3 4 5  const foo = \u0026#39;bar\u0026#39;; const baz = { foo }; // 等同於 const baz = { foo: foo };   2. 方法簡寫 定義方法時，都會有 function 宣告。\n1 2 3 4 5 6 7  const obj = { foo: function(a) { console.log(a); }, }; obj.foo(1); // 1   在 ES6 環境下，可以省略這個 function 宣告：\n1 2 3 4 5 6 7  const obj = { foo(a) { console.log(a); }, }; obj.foo(1); // 1   但使用簡寫的方式，函式為不具名，而且無法使用箭頭函式。\n屬性名稱 在 ES6 新增了可計算的功能，可以利用 [] 包裹運算式，當作鍵名。\n1 2 3 4 5 6 7 8 9  let prefix = \u0026#39;foo\u0026#39;; let myObject = { [prefix + \u0026#39;bar\u0026#39;]: \u0026#39;hello\u0026#39;, [prefix + \u0026#39;baz\u0026#39;]: \u0026#39;world\u0026#39; }; myObject.foobar; // hello myObject[\u0026#39;foobaz\u0026#39;]; // world   ","description":"ES6 為物件字面值 {} 新增了幾個重要的方便擴充功能。","id":93,"section":"posts","tags":["JavaScript","物件字面值擴充功能","ES6"],"title":"物件字面值擴充功能","uri":"https://chupai.github.io/posts/200515_js_object_literal_extension/"},{"content":" JavaScript筆記 目錄\n \r解構指定 ES6 引進了一個新語法功能，解構指定（destructuring assignment）或稱解構賦值，可以想成是一種有結構的指定。\n在 JavaScript 中最常用的兩種資料結構為陣列與物件，而解構指定用於提取陣列或物件中的資料，存放到一系列的變數中。\n請考慮以下程式碼：\n1 2 3  function foo() { return [1, 2, 3]; }   如果有一個函式回傳了一個陣列，要將陣列中的內容一一用變數儲存。\n傳統作法為：\n1 2 3 4 5 6  var tmp = foo(); var a = tmp[0]; var b = tmp[1]; var c = tmp[2]; console.log(a, b, c); // 1 2 3   必須先將函式結果儲存，在一個一個宣告變數給值。\n但如果改用新語法：\n1 2 3  let [a, b ,c] = foo(); console.log(a, b, c); // 1 2 3   就這麼麼簡單。\n1. 陣列解構 陣列解構的基本語法：\n1 2 3  let [a,b] = [1, 2]; console.log(a, b); // 1 2   2. 物件解構 物件解構的基本語法：\n1 2 3  let { a, b } = { x: 1, y: 2 }; console.log(a, b); // 1 2   左邊實際上是 **物件字面值的簡短語法：\n1 2 3 4  // 等同 let { a: a, b: b } = { a: 1, b: 2 }; console.log(a, b); // 1 2   左側的屬性值屬於變數名稱：\n1 2 3  let { a: x, b: y } = { a: 1, b: 2 }; console.log(x, y); // 1 2   必須注意，左側的必須有對應的的屬性名才能指定：\n1 2 3  let { a } = { b: 1 }; console.log(a); // undefined   屬性順序並不重要，只要有對應的屬性名即可：\n1 2 3  let { a, b } = { b: 2, a: 1 }; console.log(a, b); // 1 2   允許同一個屬性被列出多次：\n1 2 3  let { a: x, a: y } = { a: 1 }; console.log(x, y); // 1 1   這表示能夠解構一個子物件，並且捕捉那個子物件，舉例來說：\n1 2 3 4 5 6 7 8  let { a: { x: X, x: Y }, a: a, } = { a: { x: 1 } }; console.log(X); // 1 console.log(Y); // 1 console.log(a); // { x: 1 }   子陣列也可以：\n1 2 3 4 5  let { a: X, a: Y, a: [Z] } = { a: [1] }; console.log(X); // [1] console.log(Y); // [1] console.log(Z); // 1   3. 不只是宣告 指定就是使用 = 運算子，所以解構指定不一定只能用在宣告上。\n舉例來說：\n1 2 3 4  let a,b; [a, b] = [1, 2]; console.log(a, b); // 1 2   變數已宣告，解構只負責進行指定動作。\n但如果是物件就需要注意：\n1 2 3  let a,b; {a, b} = {a:1, b: 2}; // SyntaxError: Unexpected token \u0026#39;=\u0026#39;   會拋出錯誤是因為 {a, b} 的 {} 被解析成區塊，而非物件字面值，因此可以加上 ()，避免這種情況：\n1 2 3 4  let a, b; ({ a, b } = { a: 1, b: 2 }); console.log(a, b); // 1 2   應用 交換值：\n1 2 3 4 5 6  let a = 1; let b = 2; [a, b] = [b, a]; console.log(a, b); // 2 1   建立物件映射（map）：\n1 2 3 4 5 6  let o1 = { a: 1, b: 2, c: 3 }; let o2 = {}; ({ a: o2.x, b: o2.y, c: o2.z } = o1); console.log(o2); // {x: 1, y: 2, z: 3}   或是將一個物件映射至陣列，或是反過來：\n1 2 3 4 5 6 7 8 9 10 11 12 13  let o1 = { a: 1, b: 2, c: 3 }; let a2 = []; ({ a: a2[0], b: a2[1], c: a2[2] } = o1); console.log(a2); // [1, 2, 3]  // 反過來 let a1 = [1, 2, 3]; let o2 = {}; [o2.a, o2.b, o2.c] = a1; console.log(o2); // {a: 1, b: 2, c: 3}   解構指定運算式 解構指定運算式會回傳右邊完整的物件或陣列。\n1 2 3 4  let o = {a:1, b:2}; let a,b; console.log({a,b} = o); // {a: 1, b: 2}   驗證：\n1 2 3 4 5 6  let obj = { a: 1, b: 2 }; let a, b, obj2; obj2 = { a, b } = obj; console.log(obj2 === obj); // ture   陣列也是如此：\n1 2 3 4 5 6  let arr = [1, 2]; let a, b, arr2; arr2 = [a, b] = arr; console.log(arr === arr2); // ture   解構的數量 不必指定所有出現的值：\n1 2 3 4 5 6 7 8 9  let [a] = [1, 2, 3, 4]; let [, b] = [1, 2, 3, 4]; console.log(a); // 1 console.log(b); // 2  let {c} = {a:1, b:2, c: 3}; console.log(c); // 3   也可以留空來略過某些值。\n如果指定過多的值，變數沒有對應值，內容就會是 undefined。\n1 2 3 4 5 6 7  let [a, b, c] = [1, 2]; console.log(c); // undefined  let { x, y } = { x: 1 }; console.log(y); // undefined   1. 展開運算子 在解構中，使用展開運算子，將會收集那些多出來的值。\n陣列：\n1 2 3 4  let [a, ...b] = [1, 2, 3, 4]; console.log(a); // 1 console.log(b); // [2, 3, 4]   物件：\n1 2 3 4  let { a, ...b } = { a: 1, b: 2, c: 3, d: 4 }; console.log(a); // 1 console.log(b); // {b: 2, c: 3, d: 4}   預設值 使用類似預設函式引數的 = 語法，就可以給予變數預設值。\n1 2 3 4 5 6 7 8 9  let [a = 1, b = 2] = [10]; console.log(a); // 10 console.log(b); // 2  let { x = 5, y = 10 } = { x: 20 }; console.log(x); // 20 console.log(y); // 10   參數解構 一個簡單的函式與呼叫：\n1 2 3 4 5  function foo(x) { console.log(x); } foo(42);   foo(42) 執行的時候，引數 42 被指定給了參數 x。由上述可合理推論解解構指定，當然也可以用於函式參數。\n參數的解構：\n1 2 3 4 5 6 7 8 9 10  function foo([a, b]) { console.log(a, b); } function boo({ a, b }) { console.log(a, b); } foo([1, 2]); // 1 2 boo({ a: 1, b: 2 }); // 1 2   1. 預設值 上面有提到解構賦值也能給予預設值，函式參數也能給預設值，因此必須留意兩者之間的行為差異。\n1 2 3 4 5 6 7 8 9  function foo({ x = 10 }) { console.log(x); } foo(123); // 10 foo(1); // 10 foo([]); // 10 foo({}); // 10 foo(); // TypeError   輸入的引數，沒有對應的值將會使用預設值，但如果引數是空的將會拋出錯誤。\n因此可以使用參數預設值來解決，預設給予一個空物件：\n1 2 3 4 5 6 7 8  function foo({ x = 10 } = {}) { console.log(x); } foo(123); // 10 foo(1); // 10 foo([]); // 10 foo({}); // 10 foo(); // 10   別寫成這樣：\n1 2 3 4 5  function foo({ x } = { x: 10 }) { console.log(x); } foo(); // 10   雖然當引數沒有傳入，也會得到預設值，但完全是不同意思。\n1 2 3 4 5 6  // 承接上方程式碼  foo(123); // undefined foo(1); // undefined foo([]); // undefined foo({}); // undefined   第一種作法為，當引數沒輸入會套用空物件，不論引數是啥，都會套用 { x: 10 } 來解構。\n而第二種做法則是將 { x: 10 } 作為參數預設值，而非解構預設值，因此只在引數沒被輸入時適用，如果輸入的引數無法解構，都會獲得 undefined 的結果。\n1. 具名參數 有時候一個函式可能會有許多參數，舉例來說：\n1 2 3  function showMenu(title, width, height, items) { // ... }   當參數變多時，要輸入引數時，就必須記住輸入順序，才能正確輸入，而且當要插入新參數，以前所呼叫的函式會變得難以維護。\n因此這裡就可以用解構賦值語法來處理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function showMenu({ title = \u0026#39;new Title\u0026#39;, width = 200, height = 200, items = [], }) { //... } let options = { title: \u0026#39;My menu\u0026#39;, items: [\u0026#39;Item1\u0026#39;, \u0026#39;Item2\u0026#39;], }; showMenu(options);   具名參數的優點：\n 參數多的情況下，也容易理解程式意義 方便顯示可省略參數 自由變更參數順序  另外要注意，定義具名參數要記得給參數預設值空物件 {}，否則沒輸入引數會拋出錯誤。\n2. 其餘預算子 其餘預算子可以被解構，換句話說，可以把這個陣列解開，並將各個元素取出成為個別的變數。\n1 2 3 4 5 6 7  function foo(...[a, b, c]) { console.log(a, b, c); } foo(1); // 1 undefined undefined foo(1, 2, 3); // 1 2 3 foo(1, 2, 3, 4); // 1 2 3   ","description":"ES6 引進了一個新語法功能，解構指定（destructuring assignment）或稱解構賦值，可以想成是一種有結構的指定。","id":94,"section":"posts","tags":["JavaScript","解構指定","ES6"],"title":"解構指定","uri":"https://chupai.github.io/posts/200514_js_destructuring_assignment-copy/"},{"content":" JavaScript筆記 目錄\n \r\u0026hellip; 運算子 ES6 新增了 ... 運算子，但在不同位置，會有不同的功能，所以會有兩種叫法：\n 展開運算子（Spread Operator） 其餘運算子（Rest Operator）  展開運算子 展開運算子（Spread Operator）可用於陣列、類陣列、物件，但使用地點有些微差異。\n 陣列、類陣列  陣列字面值 函式呼叫時作為引數   物件  只能於物件字面值中使用    1. 基本用法 展開運算子會將陣列展開為個別的值。\n1 2 3 4 5 6 7 8 9  let number = [1, 2, 3]; let string = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; console.log(...number); // 1 2 3 console.log(...string); // \u0026#39;a\u0026#39; \u0026#39;b\u0026#39; \u0026#39;c\u0026#39;  // 等同於 console.log(1, 2, 3); console.log(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;);   主要是用在呼叫函式時的要傳入引數：\n1 2 3 4 5 6 7 8  function foo(a, b, c) { console.log(a + b + c); } foo(...[1, 2, 3]); // 6  // 等同 apply() foo.apply(null, [1, 2, 3]); // 6   ES6 之前，如果要將陣列拆開當作引數傳入都會用函式的 apply() 方法，但現在展開運算子完全可以取代它。\n展開運算子除了用在陣列本身，也可以用在陣列字面值中，將陣列展開：\n1 2 3  let number = [2, 3]; console.log([1, ...number, 5]); // [1, 2, 3, 5]   用於合併陣列非常方便，原本需要使用 concat()，現在可以使用 ... 來代替：\n1 2 3 4 5 6 7 8  let arr1 = [1, 2, 3]; let arr2 = [4, 5, 6]; let temp1 = arr1.concat(arr2); console.log(temp1); // [1, 2, 3, 4, 5, 6]  let temp2 = [...arr1, ...arr2]; console.log(temp2); // [1, 2, 3, 4, 5, 6]   也可利用它來淺拷貝陣列：\n1 2 3 4 5  let arr1 = [1, 2, 3]; let arr2 = [...arr1]; console.log(arr2); // [1, 2, 3] console.log(arr1 === arr2); // false   2. 類陣列（Array-likes） 展開運算子不只是陣列可用，類陣列（Array-likes）也能使用，因為它具有索引和 length 屬性。\narguments 物件：\n1 2 3 4 5 6 7  function foo() { console.log(arguments instanceof Array); // false  let arg = [...arguments]; console.log(arg instanceof Array); // true } foo();   DOM 物件操作後所得到的串列：\n1 2 3 4  const list = document.getElementsByTagName(\u0026#39;body\u0026#39;); console.log(list instanceof Array); // false console.log([...list] instanceof Array); // true   字串：\n1 2 3  let string = \u0026#39;hello\u0026#39;; console.log([...\u0026#39;hello\u0026#39;]); // [\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;]   2. 物件 展開運算子如果直接用在物件上會拋出錯誤，因為展開運算子只能用於具有索引和 length 屬性的物件。\n1 2 3  let obj = { a: 1, b: 2 }; console.log(...obj); // Uncaught TypeError: Found non-callable @@iterator   你可以想成 a: 1, b: 2 沒東西裝。\n但如果要展開一個物件，可於物件字面值內。你可以想成 a: 1, b: 2 外面還有一個 {} 裝它。\n因此可以應用在淺拷貝物件上：\n1 2 3 4 5  let obj = { a: 1, b: 2 }; let obj2 = { ...obj }; console.log(obj2); // { a: 1, b: 2 } console.log(obj === obj2); // false   其餘運算子 在函式宣告中的最後一個參數加上 ... 運算子，會稱其為「其餘運算子（Rest Operator）」，它與展開運算子效果上剛好完全相反，其餘運算子是把許多的參數轉換成一個陣列。\n1 2 3 4 5  function foo(...args) { console.log(args); } foo(1, 2, 3); // [1, 2, 3]   其餘運算子因為是用於參數上，因此又稱為「其餘參數」，應用於參數不固定的函式上。\nES6 之前，會利用 arguments 物件來存取傳入的引數。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function foo(var_args) { for (var i = 0; i \u0026lt; arguments.length; i++) { var tmp = arguments[i]; if (typeof tmp !== \u0026#39;number\u0026#39;) { console.log(\u0026#39;輸入的值不是數字：\u0026#39; + tmp); } else { console.log(\u0026#39;輸入的值是數字：\u0026#39; + tmp); } } } foo(1, 2, 5, \u0026#39;a\u0026#39;); // \u0026#34;test.js:6 輸入的值是數字：1\u0026#34; // \u0026#34;test.js:6 輸入的值是數字：2\u0026#34; // \u0026#34;test.js:6 輸入的值是數字：5\u0026#34; // \u0026#34;test.js:4 輸入的值不是數字：a\u0026#34;   arguments 物件是類陣列，因此如果使用陣列方法需要將其轉換成陣列。\n為了程式碼的可讀性，通常會給可變長度的參數一個假名稱，讓閱讀程式碼時，知道這裡是輸入可變長度的參數。\n上段程式碼改用其餘運參數：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function foo(...args) { args.forEach(i =\u0026gt; { if (typeof i !== \u0026#39;number\u0026#39;) { console.log(\u0026#39;輸入的值不是數字：\u0026#39; + i); } else { console.log(\u0026#39;輸入的值是數字：\u0026#39; + i); } }); } foo(1, 2, 5, \u0026#39;a\u0026#39;); // \u0026#34;test.js:6 輸入的值是數字：1\u0026#34; // \u0026#34;test.js:6 輸入的值是數字：2\u0026#34; // \u0026#34;test.js:6 輸入的值是數字：5\u0026#34; // \u0026#34;test.js:4 輸入的值不是數字：a\u0026#34;   如果使用箭頭函式，其餘運算子必須以小括號標記，即使函式只有一個參數：\n1 2 3  let sumAll = (...number) =\u0026gt; number.reduce((total, next) =\u0026gt; total + next); console.log(sumAll(1, 3, 5)); // 9   ","description":"ES6 新增了... 運算子，但在不同位置，會有不同的功能，所以會有兩種叫法，分別為「展開」和「其餘」運算子。","id":95,"section":"posts","tags":["JavaScript","展開運算子","其餘運算子","ES6"],"title":"展開／其餘運算子","uri":"https://chupai.github.io/posts/200513_js_spread_and_rest_operator/"},{"content":"這週是 六角鼠年鐵人賽 第十四週，讓我們來看只關注頭尾的資料結構「堆疊」和「佇列」。\n\r堆疊（Stack） 堆疊（Stack），中國稱「栈」，是一種 後入先出（LIFO, Last In First Out） 的資料結構。\n1. 後入先出 LIFO 在 LIFO 的資料結構中，將優先處理最晚加進來的元素（最新）。\n堆疊使用兩種基本操作：\n push：將資料放入堆疊頂端（新增） pop：拿出疊頂端的資料（刪除）  簡單來說，就是先進去資料的最後出來、最後進去的資料最先出來。可以將堆疊想像成疊盤子，不論放盤子或取盤子，都只能從最上方，最先拿的盤子一定是最後一個放上來的。\n也就是說，在堆疊中，越底層的資料越舊，越靠近頂層越新，而且只能讀取最上層的資料（最新的）。\n2. JavaScript 實作堆疊 大部分的程式語言都提供內置的堆疊，但 JavaScript 沒有，所以我們用陣列來實作一個。\n2.1 宣告類別 宣告一個 Stack 類別：\n1 2 3 4 5 6  class Stack { constructor() { this.items = []; } // methods }   我們需要一個能夠存儲堆疊裡的元素的資料結構，因此我們可以使用陣列來實作。\n2.2 屬性方法 主要方法：\n push(element(s))：新增一個或多個元素到堆疊頂部。 pop()：移除堆疊頂部元素，同時回傳被移除的元素。  為了符合 LIFO 原則，我們使用陣列的 push 和 pop 方法實作。\n1 2 3 4 5 6 7  push(element) { this.items.push(element); } pop() { return this.items.pop(); }   輔助工具：\n peek() 或 top()：僅回傳堆疊頂端的元素。 isEmpty()：檢查堆疊內是否有元素，是空的回傳 true，否則回傳 false。 clear()：移除堆疊內的所有元素。 size()：回傳堆疊裡的元素個數，也就是資料長度。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 獲取最後一個元素 peek() { return this.items[this.items.length - 1]; } // 判斷儲存堆疊資料的陣列長度是否為 0 isEmpty() { return this.items.length === 0; } // 最簡單的清空，給一個新的空陣列 clear() { this.items = []; } // 回傳儲存堆疊資料的陣列長度 size() { return this.items.length; }   最終程式碼如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Stack { constructor() { this.items = []; } push(element) { this.items.push(element); } pop() { return this.items.pop(); } peek() { return this.items[this.items.length - 1]; } isEmpty() { return this.items.length === 0; } clear() { this.items = []; } size() { return this.items.length; } }   2.3 建立實體 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  const stack1 = new Stack(); // 新增元素 stack1.push(\u0026#39;盤子1\u0026#39;); stack1.push(\u0026#39;盤子2\u0026#39;); // 印出長度 console.log(stack1.size()); // 2  // 移除最上方元素 console.log(stack1.pop()); // \u0026#39;盤子2\u0026#39;  // 最上方元素 console.log(stack1.peek()); // \u0026#39;盤子1\u0026#39;  // 清除 stack1.clear(); // 是否為空 console.log(stack1.isEmpty()); // true   2.4 基於物件的堆疊 除了使用陣列來儲存堆疊元素，也可以改用物件來儲存堆疊裡的元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class Stack { constructor() { this.items = {}; this.count = 0; } push(element) { this.items[this.count] = element; this.count += 1; } pop() { if (this.isEmpty()) { return undefined; } this.count -= 1; const result = this.items[this.count]; delete this.items[this.count]; return result; } isEmpty() { return this.count === 0; } clear() { this.items = {}; this.count = 0; } size() { return this.count; } }   佇列（Queue） 佇列（Queue），中國稱「队列」，特性是 先進先出（FIFO, First-In-First-Out） 的資料結構。\n1. 先入先出 FIFO 在 FIFO 的資料結構中，會優先處理最早加進來的元素（最舊）。\n佇列使用兩種基本操作：\n enqueue：由佇列的後端（Rear / Back）添加新資料。 dequeue：由佇列的前端（Front）移除資料。  舉個生活上的例子，排隊上廁所：先到的人先上，後來的排後面。\n當你想要按順序處理元素時，使用佇列會是一個很好的選擇。\n2. JavaScript 實作佇列 大部分的程式語言都提供內置的佇列，但 JavaScript 沒有，所以我們用陣列來實作一個。\n2.1 宣告類別 宣告一個 Queue 類別：\n1 2 3 4 5 6  class Queue { constructor() { this.items = []; } // methods }   並用陣列來儲存佇列裡的元素。\n2.2 屬性方法 佇列的兩種主要操作方法：\n enqueue(element(s))：新增一個或多個元素到佇列尾部。 dequeue()：移除佇列的第一個元素，並回傳被移除的元素。  1 2 3 4 5 6 7 8  enqueue(element) { this.items.push(element); } dequeue() { return this.items.shift(); }   輔助工具：\n front() 或 head()：僅回傳佇列的第一個元素。 rear() 或 tail()：僅回傳佇列的最一個元素。 isEmpty()：檢查佇列內是否有元素，是空的回傳 true，否則回傳 false。 clear()：移除佇列內的所有元素。 size()：回傳佇列裡的元素個數，也就是資料長度。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  front() { return this.items[0]; } rear() { return this.items[this.items.length - 1]; } isEmpty() { return this.items.length === 0; } clear() { this.items = []; } size() { return this.items.length; }   最終程式碼如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class Queue { constructor() { this.items = []; } enqueue(element) { this.items.push(element); } dequeue() { return this.items.shift(); } front() { return this.items[0]; } rear() { return this.items[this.items.length - 1]; } isEmpty() { return this.items.length === 0; } clear() { this.items = []; } size() { return this.items.length; } }   2.3 建立實體 模擬排隊：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const queue = new Queue(); // 隊伍空的嗎? console.log(queue.isEmpty()); // ture  // 排隊 queue.enqueue(\u0026#39;A\u0026#39;); queue.enqueue(\u0026#39;B\u0026#39;); queue.enqueue(\u0026#39;C\u0026#39;); // 先出隊的 console.log(queue.dequeue()); // \u0026#39;A\u0026#39;  // 剩幾個? console.log(queue.size()); // 2  // 隊伍最後一個 console.log(queue.rear()); // \u0026#39;C\u0026#39;   3. 優先佇列（Priority Queue） 在一般情況下，從佇列中處理（刪除）的一定是第一個加入的元素，但優先佇列（Priority Queue），不必遵守佇列 FIFO 的特性，每個元素都會設定優先級，優先級最高（數字越小越高）的會優先處理，若相同級別才看排列順序。\n用排隊來比喻就是 VIP 會員等級，等級越高優先服務，或是醫院急診室會評估傷患等級來給予治療順序。\n優先佇列的差異在於 enqueue 方法，在加入元素時，會根據優先級決定插入的位置。\n priority 為優先級，預設值給它無限大。 我們用一個 queueElement 物件來儲存元素和優先級的值。 如果佇列為空直接入列，否則比較優先級。 一個一個比較元素優先級：  優先級較高就用插入在它的前面，並結束函式； 如果都沒有就加到佇列後端。    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Priorityqueue extends Queue { enqueue(element, priority = Infinity) { const queueElement = { element, priority }; if (this.isEmpty()) { this.items.push(queueElement); } else { for (let i = 0; i \u0026lt; this.items.length; i++) { if (priority \u0026lt; this.items[i].priority) { this.items.splice(i, 0, queueElement); return; } } this.items.push(queueElement); } } }   建立實體：\n1 2 3 4 5 6 7 8 9 10 11  const pq = new Priorityqueue(); pq.enqueue(\u0026#39;A\u0026#39;, 1); pq.enqueue(\u0026#39;B\u0026#39;); pq.enqueue(\u0026#39;C\u0026#39;, 1); pq.enqueue(\u0026#39;D\u0026#39;, 2); console.log(pq.dequeue()); // { element: \u0026#39;A\u0026#39;, priority: 1 } console.log(pq.dequeue()); // { element: \u0026#39;C\u0026#39;, priority: 1 } console.log(pq.dequeue()); // { element: \u0026#39;D\u0026#39;, priority: 2 } console.log(pq.dequeue()); // { element: \u0026#39;B\u0026#39;, priority: Infinity }   堆疊的應用 1. 十進制轉二進制 十進制轉二進制轉換過程：\n 10 / 2 = 5 餘 0 5 / 2 = 2 餘 1 2 / 2 = 1 餘 0 1 / 2 = 0 餘 1 10 的二進制結果為 1010  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function divideBy2(decNumber) { const remStack = new Stack(); let number = decNumber; let rem = null; // 餘數  // 將餘數放進堆疊中  while (number \u0026gt; 0) { rem = Math.floor(number % 2); remStack.push(rem); number = Math.floor(number / 2); } // 將結果連成字串  let baseString = \u0026#39;\u0026#39;; while (!remStack.isEmpty()) { baseString += remStack.pop(); } return baseString; }   將上面程式碼稍微修改，可以改成十進制轉 2 ~ 36 進制，10 ~ 35 用英文字母表示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function baseConverter(decNumber, base) { if (!(base \u0026gt;= 2 \u0026amp;\u0026amp; base \u0026lt;= 36)) { return \u0026#39;\u0026#39;; } const remStack = new Stack(); const DIGITS = \u0026#39;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39;; let number = decNumber; let rem = null; while (number \u0026gt; 0) { rem = Math.floor(number % base); remStack.push(rem); number = Math.floor(number / base); } let baseString = \u0026#39;\u0026#39;; while (!remStack.isEmpty()) { baseString += DIGITS[remStack.pop()]; } return baseString; }   2. 驗證括號的問題  Leetcode: 20. Valid Parentheses\n驗證括號（Valid Parentheses）或稱 平衡括號（Balanced Brackets）。\n 給定一個包括 (、{、[、)、}、] 的字串，判斷字串是否有效。\n有效字串需滿足：\n 左括號必須用相同類型的右括號閉合。 左括號必須以正確的順序閉合。  注意空字串可被認為是有效字串。\n範例：\n1 2 3 4 5  \u0026#39;()\u0026#39; // ture \u0026#39;()[]{}\u0026#39; // true \u0026#39;(]\u0026#39; // false \u0026#39;([)]\u0026#39; // false \u0026#39;{[]}\u0026#39; // true   流程：\n 檢查字串，遇到 ( { [ 就放到堆疊中 若遇到 ) ] } 就去找堆疊頂端的資料是否有相對應的 ( { [  沒有就回傳 false 若有就將堆疊頂端對應的 ( { [ 移除   最後檢查堆疊內使否為空  如果是空的回傳 true 不是空的，表示有沒對應到的 ( { [ 回傳 false    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function isValid(s) { const stack = []; const OPENING = { \u0026#39;(\u0026#39;: 0, \u0026#39;[\u0026#39;: 1, \u0026#39;{\u0026#39;: 2 }; const CLOSEING = { \u0026#39;)\u0026#39;: 0, \u0026#39;]\u0026#39;: 1, \u0026#39;}\u0026#39;: 2 }; for (let i = 0; i \u0026lt; s.length; i++) { const character = s[i]; if (OPENING[character] \u0026gt;= 0) { stack.push(character); } else if (CLOSEING[character] \u0026gt;= 0) { const peek = stack[stack.length - 1]; if (OPENING[peek] === CLOSEING[character]) { stack.pop(); } else { return false; } } } return stack.length === 0; }   總結 堆疊和佇列這類最基本的資料結構，它們因為特殊條件限制，只關心頭尾的新增、刪除、獲取的操作，並不關心內部的元素的狀態。\n","description":"這週是六角鼠年鐵人賽第十四週，讓我們來看只關注頭尾的資料結構「堆疊」和「佇列」。","id":96,"section":"posts","tags":["資料結構","堆疊","佇列","w3HexSchool"],"title":"JavaScript 學演算法（六）- 堆疊 ＆ 佇列","uri":"https://chupai.github.io/posts/200504_ds_stack_queue/"},{"content":"這週是 六角鼠年鐵人賽 第十三週，要來簡單說明與陣列類似的資料結構「鏈結串列 Linked list」。\n\r前言 首先來談談陣列的缺點，在大多數的程式語言中，陣列的長度（大小）宣告後就是固定的，也就是說，宣告時已經決定最大空間，如果預設的空間太小容易發生上溢，如果太大容易造成記憶體空間浪費。\n而且從陣列的開頭或中間插入、刪除元素時，往往需要般動其他元素，因此效率不佳。\n鏈結串列是什麼 鏈結串列（Linked list），中國稱「链表」，與陣列一樣都是線性資料結構，但不同於陣列，它為鏈式儲存結構，也就是記憶體位置儲存為不連續性。\n1. 定義 鏈結串列是由一連串 節點（node） 組成，節點之間是透過指標來連接。所以儲存上並不需要連續的空間。\n每個節點包含：\n 資料元素 指標  指標（又稱鏈結、引用），通常為一或兩個，用來指向上／下個的位置，若沒有上／下一個節點，則為空。如果指標斷裂，資料就遺失。\n舉生活上的例子來說，鏈結串列如同火車的車廂一樣，一節拉著一節。\n相較於陣列，鏈結串列的元素並不是連續放置的，插入或移除元素不需要移動其他元素，只需要修改上／下個指標的指向。\n因為鏈結串列沒有索引，若要存取特定特定，需要從頭開始找起，因此相較於陣列，存取資料較費時。\n2. 類型 鏈結串列有很多種不同的類型：\n 單向鏈結串列（Singly Linked List） 雙向鏈結串列（Doubly Linked List） 迴圈鏈結串列（Circularly Linked List）  2.1 單向鏈結串列 單向鏈結串列，又稱單鏈結串列、線性鏈結串列、普通鏈結串列，是最基本的鏈結串列，其特點是鏈結串列的鏈結方向是單向的，對鏈結串列的存取要通過從頭部開始，依序往下讀取。\n2.2 雙向鏈結串列 雙向鏈結串列，又稱為雙鏈結串列，它與單向鏈結串列最大的區別在於，每個結點中都有兩個指標，分別指向上一個和下一個結點。\n所以，從雙向鏈結串列中的任意一個結點開始，都可以很方便地存取它的上一個和下一個結點。\n2.3 迴圈鏈結串列 迴圈鏈結串列，又稱環狀鏈結串列、循環鏈結串列，它與一般的鏈結串列操作基本一致，但串列頭尾的指標會連接再一起，形成一個環。\n3. 時間複雜度 不管是維基百科還是其他鏈結串列相關文章，都只寫鏈結串列的時間複雜度分別為：\n 插入、刪除：$O(1)$ 存取、查詢：$O(n)$  但要注意的是，插入與刪除的 $O(1)$ 指的是，已經獲取節點的前提下所執行的動作。沒有獲取節點，要插入或刪除指定位置的節點，會先經過查詢節點這個動作，所以時間複雜度會變為 $O(n)$。\n但假如節點位置為開頭，時間複雜度也為 $O(1)$。\n4. 優缺點比較 鏈結串列與陣列的優缺點比較。\n陣列的優點：\n 可利用 index 隨機存取（Random Access）只需要 $O(1)$ 的時間。 可靠度高，不會因為鏈結斷裂而遺失資料。  陣列的缺點：\n 在開頭或中間插入、刪除元素，需要花費 $O(n)$ 的時間將元素移動。 連續的記憶體空間，可能會有用不到的空間，而造成浪費。 若陣列已滿，會需要花費 $O(n)$ 的時間搬動資料到新的陣列內。  鏈結串列的優點：\n 資料在記憶體中非連續。 插入、刪除元素只需要修改上／下個指標的指向。  鏈結串列的優點：\n的缺點：\n 只能順序存取，需要花費 $O(n)$ 的時間。 鏈結斷裂就會遺失資料。  JavaScript 實作鏈結串列 JavaScript 沒有內建鏈結串列，我們使用物件來模擬。\n鏈結串列的資料結構：\n1 2 3 4 5 6 7 8 9 10  { data: \u0026#39;data1\u0026#39;, next: { data: \u0026#39;data2\u0026#39;, next: { data: \u0026#39;data3\u0026#39;, next: null } } }   首先會建立兩個類別，分別是 Node 表示節點、LinkedList 提供插入、刪除節點以及其他輔助方法。\n1. Node 節點 Node 包含資料和指標：\n data：資料 next：指向下一個節點。  1 2 3 4 5 6  class Node { constructor(data) { this.data = data; this.next = null; } }   2. LinkedList 基本屬性：\n head：指向串列開頭節點 tail：指向串列結尾節點 length：節點數量  1 2 3 4 5 6 7 8  class LinkedList { constructor() { this.head = null; this.tail = null; this.length = 0; } // methods }   2.1 輔助方法 先建立會用到的輔助方法。\nisEmpty() 檢查串列是否為空：\n1 2 3  isEmpty() { return this.length === 0; }   getNode() 取得指定位置節點：\n1 2 3 4 5 6 7 8 9 10 11 12  getNode(index) { // 判斷指定位置是否在範圍內  if (index \u0026lt; 0 || index \u0026gt;= this.length) return null; // 從頭開始迭代到指定位置訪問  let currNode = this.head; let currIndex = 0; while (currIndex \u0026lt; index) { currIndex += 1; currNode = currNode.next; } return currNode; }   為了方便驗證，建立一個 print() 照順序印出所有節點資料值：\n1 2 3 4 5 6 7 8 9  print() { const temp = []; let currNode = this.head; while (currNode) { temp.push(currNode.data); currNode = currNode.next; } return temp.join(\u0026#39;, \u0026#39;); }   2.2 插入新節點  append(data)：在串列尾部插入一個節點。 insert(index, data)：在指定位置插入一個節點。  在串列尾部插入一個節點可分為兩種情況：\n 串列為空，更新 head 和 tail。 串列不為空，則更新 tail。  需要先將原本的 tail 指向新的節點； 再更新 tail。    1 2 3 4 5 6 7 8 9 10 11  append(data) { const newNode = new Node(data); if (this.isEmpty()) { this.head = newNode; this.tail = newNode; } else { this.tail.next = newNode; this.tail = newNode; } this.length += 1; }   在指定位置插入元素，需要考慮三種情況：\n 插入串列結尾後面，等同使用 append 方法。 插入串列開頭，為取代 head。 在中間位置插入，需要修改上一個節點的指標。  取得指定位置的上一個節點； 再取得指定位置上原本的節點； 重新定義上一個節點指標，指向新插入的節點； 最後將新插入的節點指標，指向原本的節點。    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  insert(index, data) { if (index \u0026gt;= this.length) { this.append(data); return; } const newNode = new Node(data); if (index \u0026lt;= 0) { newNode.next = this.head; this.head = newNode; } else { const prevNode = this.getNode(index - 1); const currNode = prevNode.next; prevNode.next = newNode; newNode.next = currNode; } this.length += 1; }   驗證：\n1 2 3 4 5 6 7 8 9 10 11 12 13  const list = new LinkedList(); list.append(\u0026#39;data1\u0026#39;); list.append(\u0026#39;data2\u0026#39;); list.append(\u0026#39;data3\u0026#39;); console.log(list.print()); // \u0026#39;data1, data2, data3\u0026#39;  list.insert(0, \u0026#39;a\u0026#39;); console.log(list.print()); // \u0026#39;a, data1, data2, data3\u0026#39; list.insert(4, \u0026#39;b\u0026#39;); console.log(list.print()); // \u0026#39;a, data1, data2, data3, b\u0026#39; list.insert(2, \u0026#39;b\u0026#39;); console.log(list.print()); // \u0026#39;a, data1, b, data2, data3, b\u0026#39;   2.3 刪除節點 先判index 有效，刪除指定位置的節點：\n 刪除的節點是開頭，重新指定 head。 其他節點，則找到目標節點，並修改上一個節點的指向，如果目標節點是 tail（指標指向 null）記得要重新指定。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  removeAt(index) { if (index \u0026lt; 0 || index \u0026gt;= this.length) return; if (index === 0) { this.head = this.head.next; } else { const prevNode = this.getNode(index - 1); const delNode = prevNode.next; const nextNode = delNode.next; prevNode.next = nextNode; if (nextNode === null) { this.tail = prevNode; } } this.length -= 1; }   2.4 其他方法 getData() 取得指定位置節點的資料值：\n1 2 3 4  get(index) { const node = this.getNode(index); return node ? node.data : null; }   indexOf() 根據資料的值，回傳索引（第一個符合條件的），沒有則回傳 -1：\n1 2 3 4 5 6 7 8 9 10  indexOf(data) { let currNode = this.head; let currIndex = 0; while (currNode) { if (currNode.data === data) return currIndex; currIndex += 1; currNode = currNode.next; } return -1; }   remove() 根據資料的值，刪除符合的第一個節點：\n1 2 3 4  remove(data) { const index = this.indexOf(data); return this.removeAt(index); }   clear() 清空串列：\n1 2 3 4 5  clear() { this.head = null; this.tail = null; this.length = 0; }   size() 回傳串列的節點個數：\n1 2 3  size() { return this.length; }   3. 最終程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118  class Node { constructor(data) { this.data = data; this.next = null; } } class LinkedList { constructor() { this.head = null; this.tail = null; this.length = 0; } append(data) { const newNode = new Node(data); if (this.isEmpty()) { this.head = newNode; this.tail = newNode; } else { this.tail.next = newNode; this.tail = newNode; } this.length += 1; } insert(index, data) { if (index \u0026gt;= this.length) { this.append(data); return; } const newNode = new Node(data); if (index \u0026lt;= 0) { newNode.next = this.head; this.head = newNode; } else { const prevNode = this.getNode(index - 1); const currNode = prevNode.next; prevNode.next = newNode; newNode.next = currNode; } this.length += 1; } removeAt(index) { if (index \u0026lt; 0 || index \u0026gt;= this.length) return; if (index === 0) { this.head = this.head.next; } else { const prevNode = this.getNode(index - 1); const delNode = prevNode.next; const nextNode = delNode.next; prevNode.next = nextNode; if (nextNode === null) { this.tail = prevNode; } } this.length -= 1; } indexOf(data) { let currNode = this.head; let currIndex = 0; while (currNode) { if (currNode.data === data) return currIndex; currIndex += 1; currNode = currNode.next; } return -1; } remove(data) { const index = this.indexOf(data); return this.removeAt(index); } getNode(index) { if (index \u0026lt; 0 || index \u0026gt;= this.length) return null; let currNode = this.head; let currIndex = 0; while (currIndex \u0026lt; index) { currIndex += 1; currNode = currNode.next; } return currNode; } getData(index) { const node = this.getNode(index); return node ? node.data : null; } isEmpty() { return this.length === 0; } clear() { this.head = null; this.tail = null; this.length = 0; } size() { return this.length; } print() { const temp = []; let currNode = this.head; while (currNode) { temp.push(currNode.data); currNode = currNode.next; } return temp.join(\u0026#39;, \u0026#39;); } }   4. 雙向鏈結串列 接下來我們來實作雙向鏈結串列，它與單向鏈結串列的差異在於，節點會有兩個指標。\n節點上會多一個指向上一個節點的指標：\n1 2 3 4 5 6 7  class DoublyNode { constructor(data) { this.data = data; this.next = null; this.prev = null; } }   除了插入、刪除節點要多加處理 prev 指標，其他方法操作與單向鏈結串列相同，我們這裡直接繼承 LinkedList：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  class DoublyLinkedList extends LinkedList { append(data) { const newNode = new DoublyNode(data); if (this.isEmpty()) { this.head = newNode; this.tail = newNode; } else { newNode.prev = this.tail; // new  this.tail.next = newNode; this.tail = newNode; } this.length += 1; return true; } insert(index, data) { if (index \u0026gt;= this.length) { this.append(data); return; } const newNode = new DoublyNode(data); if (index \u0026lt;= 0) { this.head.prev = newNode; // new  newNode.next = this.head; this.head = newNode; } else { const prevNode = this.getNode(index - 1); const currNode = prevNode.next; prevNode.next = newNode; newNode.next = currNode; } this.length += 1; } removeAt(index) { if (index \u0026lt; 0 || index \u0026gt;= this.length) return; if (index === 0) { this.head = this.head.next; this.head.prev = null; // new  } else { const prevNode = this.getNode(index - 1); const delNode = prevNode.next; const nextNode = delNode.next; prevNode.next = nextNode; if (nextNode === null) { this.tail = prevNode; } else { nextNode.prev = prevNode; // new  } } this.length -= 1; } }   5. 迴圈鏈結串列 迴圈鏈結串列 tail 的 next 指標會指向 head、head 的 prev 指標會指向 tail，而非 null。\nLeetCode 相關題目  707. Design Linked List 設計鏈結串列 141. Linked List Cycle 迴圈鏈結串列 206. Reverse Linked List 反轉鏈結串列  總結 陣列是 JavaScript 最常使用的資料結構，JavaScript 的陣列與其它語言相比很特殊，沒有元素型別與大小限制，但將元素從開頭插入或移除，時間複雜度一樣需要 $O(n)$，而鏈結串列只需要 $O(1)$。\n如果沒有頻繁存取元素的需求，而有需要頻繁將元素插入開頭，可以考慮使用鏈結串列的資料結構邏輯。\n","description":"這週是六角鼠年鐵人賽第十三週，要來簡單說明與陣列類似的資料結構「鏈結串列 Linked list」。","id":97,"section":"posts","tags":["資料結構","鏈結串列","w3HexSchool"],"title":"JavaScript 學演算法（五）- 鏈結串列 Linked list ","uri":"https://chupai.github.io/posts/200427_ds_linkedlist/"},{"content":"這週是 六角鼠年鐵人賽 第十二週，要來簡單說明，最基本的資料結構「陣列 Array」。\n\r陣列是什麼 在計算機科學中，陣列資料結構（array data structure），簡稱 陣列（Array），中國稱「数组」，是最基本的資料結構，屬於線性有序的資料結構。\n大多數的高階程式語言都會內建的陣列資料型別（type），少部分是由雜湊表、連結串列、搜尋樹來實現。\n1. 定義 陣列是由相同類型的元素所組成的有序的資料結構，通常由一塊連續的記憶體位置儲存。\n因為是連續的記憶體位置，所以大部分的高階語言，陣列宣告後的長度（大小）是不能改變的，如果需要調整陣列大小，需要將所有元素搬到新的陣列。\n陣列在插入、刪除元素的效率非常差，因為需要移動（往前或往後）其餘元素。\n元素可以透過索引（index）做隨機存取（Random Access），有時亦稱直接存取。\n陣列特色：\n 線性有序的資料結構 相同類型的元素所組成 由一塊連續的記憶體位置儲存 可以透過索引隨機存取 索引初始位置為 0  JavaScript 的陣列 JavaScript 的陣列與大部分的高階語言的陣列相比，非常不一樣。\n我們上面提到，陣列的定義最主要就是：\n 相同類型的元素所組成 由一塊連續的記憶體位置儲存  但 JavaScript 屬於於動態型別的程式語言，變數單純只是容器，型別是根據賦予的值來決定。因此陣列可以存放不同型別的元素。\nJavaScript 是基於原型模式的物件導向語言，幾乎所有的事物都是物件，或是具有類似物件的行為，陣列也不例外，它本質上屬於一種特殊的物件。\n1 2 3 4  typeof [] // \u0026#34;object\u0026#34;  const array = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; console.log( Object.keys(array) ); // [\u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;]   所以 JavaScript 的陣列與其它程式語言相比，執行速度較慢。\n1. 記憶體儲存 另外，JavaScript 的陣列並不一定是儲存於連續記憶體空間。\n早期的 JavaScript 引擎用為「鏈式儲存結構」，而到了 Chrome 的 V8 才使用「順序儲存結構」與「鏈式儲存結構」混合模式。\n在多數的情況下，V8 引擎的陣列是「順序儲存結構」也就是分配連續記憶體，而以下情況為非連續記憶體：\n 稀疏陣列 元素的非單一型別  非連續記憶體的陣列用的是類似雜湊表（hash table）對映的方式存在。\n陣列的操作 JavaScript 基本操作請參考：\n 陣列 迭代陣列 ","description":"這週是六角鼠年鐵人賽第十二週，最基本的資料結構「陣列 Array」。","id":98,"section":"posts","tags":["資料結構","陣列 Array","w3HexSchool"],"title":"JavaScript 學演算法（四）- 陣列 Array ","uri":"https://chupai.github.io/posts/200426_ds_array/"},{"content":" JavaScript筆記 目錄\n \r對陣列做迭代 對陣列做迭代是最常見的陣列操作，最基本的的迭代方式就是使用 for 迴圈：\n1 2 3 4 5 6 7 8 9  let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; for (let i = 0; i \u0026lt; arr.length; i++) { console.log(arr[i]); } // \u0026#34;a\u0026#34; // \u0026#34;b\u0026#34; // \u0026#34;c\u0026#34;   但如果需要對陣列從頭到尾的迭代，使用 for 迴圈太繁瑣，需要索引值、結束條件。\n因此可以改用 forEach 方法或 ES6 的 for of 迴圈來迭代陣列。\n   類型 效能 說明     for 最高 雖然繁瑣，但自由度高，可使用變數改變索引值，也可以使用 break、return、continue 等語句   for in 最低 可用於物件，但不建議用於陣列   forEach 中間 搭配箭頭函式可使程式碼更簡潔   for of 中間（高於 forEach） 簡潔，而且比起 forEach 可使用 break、return、continue 等語句，但沒有索引    1. forEach 首先我們來看看 forEach 方法，它會將陣列內的每個元素，皆傳入並執行給定的函式一次，不會產生新的陣列。\n語法如下：\n1 2 3  arr.forEach(function callback(currentValue[, index[, array]]) { //your iterator }[, thisArg]);    callback 函式共有三個參數：  currentValue：陣列當前元素 index：陣列當元素的索引值 array：陣列本身   thisArg：執行 callback 回呼函式的 this（即參考之 Object）值 回傳值： undefined  currentValue 為必填參數，而 index 與 array 則選擇性。\n試著改寫開頭的 for 迴圈，達到結果。\n1 2 3 4 5 6 7 8 9 10 11 12  let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; arr.forEach(function(item) { console.log(item); }) // \u0026#34;a\u0026#34; // \u0026#34;b\u0026#34; // \u0026#34;c\u0026#34;  // 使用箭頭函式 arr.forEach((item) =\u0026gt; console.log(item));   當傳入參數 thisArg，callback 函式的 this 就會指向你所傳入的物件。\n1 2 3 4 5 6 7 8 9 10  const arr = [1, 2, 3]; const arr2 = [\u0026#39;一\u0026#39;, \u0026#39;二\u0026#39;, \u0026#39;三\u0026#39;]; arr.forEach(function(item, index) { console.log(item + \u0026#39;：\u0026#39; + this[index]); }, arr2); // \u0026#34;1：一\u0026#34; // \u0026#34;2：二\u0026#34; // \u0026#34;3：三\u0026#34;   2. for of 迴圈 在 ES6 新增了 for of 迴圈，它可以用於可迭代物件（Array、Map、Set、String、TypedArray，arguments）上，也就是只要是實現了 Interable 介面的資料型別都能被遍歷。\n1 2 3 4 5 6 7 8 9  let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; for (let element of arr) { console.log(element); } // \u0026#34;a\u0026#34; // \u0026#34;b\u0026#34; // \u0026#34;c\u0026#34;   使用 for of 遍與 forEach 的最大差異就是可以中斷：\n1 2 3 4 5 6 7 8 9 10 11  let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;]; for (let element of arr) { if (element === \u0026#39;c\u0026#39;) { break; } console.log(element); } // \u0026#34;a\u0026#34; // \u0026#34;b\u0026#34;   操作陣列元素 處理陣列中的元素，並不更動原陣列是常見的操作。\n使用 forEach 方法，須先建立一個新的陣列搭配 push 方法。\n舉例，合併姓名：\n1 2 3 4 5 6 7 8 9 10 11 12  const inventors = [ { first: \u0026#39;Albert\u0026#39;, last: \u0026#39;Einstein\u0026#39; }, { first: \u0026#39;Isaac\u0026#39;, last: \u0026#39;Newton\u0026#39; }, ]; const names = []; inventors.forEach((item) =\u0026gt; { names.push(`${item.first}${item.last}`); }); console.log(names); // [\u0026#34;Albert Einstein\u0026#34;, \u0026#34;Isaac Newton\u0026#34;]   如果改用 map 方法：\n1 2 3 4 5 6  inventors.map(function(item) { return `${item.first}${item.last}`; }); // 箭頭函式 inventors.map(item =\u0026gt; `${item.first}${item.last}`);   map 方法會建立一個新的陣列，其內容為原陣列的每一個元素經由回呼函式運算後所回傳的結果之集合。\n參數基本上與 forEach() 相同，但回呼函式多了一個 return 可以將會將處理結果放到新的陣列中，並回傳新的陣列。\n讓我們來實作一下 map 方法，瞭解其原理：\n1 2 3 4 5 6 7 8 9  function map(arr, callback) { let result = []; for (let i = 0; i \u0026lt; arr.length; i++) { result.push(callback(arr[i])); } return result; } map(inventors, (item) =\u0026gt; `${item.first}${item.last}`);   其他陣列迭代操作方法：\n map() ：執行結果存到新陣列。 filter()：將符合條件的元素存到新陣列。 find()：找到第一個符合條件的元素。 some() ：判斷有元素符合條件。 every()：判斷所有元素都符合條件。 reduce()：根據規則縮減陣列。  1. 過濾陣列 filter 方法會建立一個經指定之函式運算後，由原陣列中通過該函式檢驗之元素所構成的新陣列。 return 是用來判斷條件。如果 return 值為 true 會將該元素放入新陣列。\n通常用來篩選資料：\n1 2 3 4 5 6 7  const numbers = [33, 22, 66, 88, 10, 5, 6, 9]; const bigNum = numbers.filter(function(item) { return item \u0026gt; 30; }); console.log( bigNum ); // [33, 66, 88]   找出大於 30 的數值。\n3. 陣列搜尋 some 方法會測試陣列中是否至少有一個元素通過由給定之函式所實作的測試。return 判斷條件。如果至少 return 一次 true 則回傳 true。\n尋找陣列中使否有元素是奇數值：\n1 2 3 4 5 6 7 8  const array = [1, 2, 3, 4, 5]; const arraySome = array.some(function (even) { return even % 2 === 0; }); console.log( arraySome ); // true   要在一個陣列中搜尋某個值，一般來說會使用 indexOf()，它會回傳第一個符合的值的索引，沒找到回傳 -1。\n1 2 3  const arr = [1, 2, 3, 4, 5]; console.log(arr.indexOf(2)); // 1   但 indexOf() 是使用 === 來進行比較，因此如果傳入字串'2'，就會找不到。\n1 2 3  // 承接上段程式碼  console.log(arr.indexOf(\u0026#39;2\u0026#39;)); // -1   在 ES5 時，會使用 some() 來變通比對邏輯，但也只能判斷該陣列是否擁有該元素，無法實際獲取實際符合條件元素。\n1 2 3 4 5 6 7  // 承接上段程式碼  let result = arr.some(function(even) { return even == \u0026#39;2\u0026#39;; }) console.log(result); // true   而到了 ES6 新增了 find()，解決了這個問題。\nfind 方法會回傳第一個滿足所提供之測試函式的成員值。否則回傳 undefined。與 some() 的差異在於，回傳第一個 return 值為 true 的元素。\n找出第一個符合條件的元素：\n1 2 3 4 5 6 7 8 9 10 11 12  const inventory = [ {name: \u0026#39;apples\u0026#39;, quantity: 2}, {name: \u0026#39;bananas\u0026#39;, quantity: 0}, {name: \u0026#39;cherries\u0026#39;, quantity: 5} ]; const inventoryFind = inventory.find(function(item) { return item.name === \u0026#39;cherries\u0026#39;; }); console.log( inventoryFind ); // { name: \u0026#39;cherries\u0026#39;, quantity: 5 }   findIndex() 也是 ES6 新增的方法，findIndex() 與 find() 差異只在於，其會回傳其索引，如果沒有符合的元素，將回傳 -1。\n1 2 3 4 5 6 7 8  // 承接上段程式碼  const inventoryIndexFind = inventory.findIndex(function(item) { return item.name === \u0026#39;cherries\u0026#39;; }); console.log(inventoryIndexFind); // 2   因此 find() 可以應用在更新資料，而 findIndex() 會用來刪除資料。\n1 2 3 4 5 6  const cart = [ {id: 1, count: 0}, {id: 2, count: 0}, {id: 3, count: 0}, {id: 4, count: 0}, ];   找出 id 為 3 並將 count 更新成 5：\n1 2 3 4 5 6 7 8 9 10 11  let item = cart.find((item)=\u0026gt; item.id === 3); item.count = 5; console.log( cart ); // [ // {id: 1, count: 0}, // {id: 2, count: 0}, // {id: 3, count: 5}, // {id: 4, count: 0}, // ]   刪除 id 為 3 的元素：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const cart = [ {id: 1, count: 0}, {id: 2, count: 0}, {id: 3, count: 0}, {id: 4, count: 0}, ]; let index = cart.findIndex((item)=\u0026gt; item.id === 3); cart.splice(index, 1); console.log( cart ); // [ // {id: 1, count: 0}, // {id: 2, count: 0}, // {id: 4, count: 0}, // ]   every 方法會測試陣列中的所有元素是否都通過了由給定之函式所實作的測試。\n與 some() 的差異在於，every() 必須要全部的元素都符合條件才會回傳 true。\n是否全部都是基數：\n1 2 3 4 5 6 7 8  const array = [1, 2, 3, 4, 5]; const arrayEvery = array.every(function (even) { return even % 2 === 0; }); console.log( arrayEvery ); // false   4. reduce reduce 方法將一個累加器及陣列中每項元素（由左至右）傳入回呼函式，將陣列化為單一值。其實就是帶有暫存器的 forEach()。\n語法：\n1  arr.reduce(callback[accumulator, currentValue, currentIndex, array], initialValue)    accumulator：用來累積回呼函式回傳值的累加器，若有提供的話，詳如下敘。累加器是上一次呼叫後，所回傳的累加數值。 initialValue：於第一次呼叫 callback 時要傳入的累加器初始值。若沒有提供初始值，則原陣列的第一個元素將會被當作初始的累加器。假如於一個空陣列呼叫 reduce() 方法且沒有提供累加器初始值，將會發生錯誤。 return：放入累加器中  假設要計算一個數值陣列的總合值為多少，使用 for 迴圈都會額外宣告一個 total 變數來當作累加器。\n1 2 3 4 5 6 7 8 9  const numbers = [1, 2, 3, 4, 5, 6]; let total = 0; for(let i = 0; i \u0026lt; numbers.length; i++) { total += numbers[i]; } console.log( total ); // 21   使用 reduce()：\n1 2 3 4 5 6 7 8  const numbers = [1, 2, 3, 4, 5, 6]; const numTotal = numbers.reduce(function(total, item) { return total + item }, 0); console.log( numTotal ); // 21   而 reduceRight() 基本上與 reduce() 一樣，差異是從右到左進行累加。\n我們用扁平化（flatten）一個元素為陣列的陣列來觀察差異：\n1 2 3 4 5 6 7 8 9 10 11  const arr = [[0, 1], [2, 3], [4, 5]]; function callback(a, b) { return a.concat(b); } let result1 = arr.reduce(callback, []); let result2 = arr.reduceRight(callback, []); console.log(result1); // [0, 1, 2, 3, 4, 5] console.log(result2); // [4, 5, 2, 3, 0, 1]   ","description":"對陣列做迭代是最常見的陣列操作。","id":99,"section":"posts","tags":["JavaScript","陣列 Array"],"title":"迭代陣列","uri":"https://chupai.github.io/posts/200425_js_array_iterate/"},{"content":" JavaScript筆記 目錄\n \r概述 在 JavaScript 中的陣列與其他語言的不同之處在於，JavaScript 的陣列只是容器。任何類型的資料，都可以放入陣列。\n1. 陣列其實就是物件 每個陣列都會有索引值（index），是從 0 開始的順序整數值，但陣列其實就是擁有固定鍵名的物件。\n1 2 3 4 5  typeof [] // \u0026#34;object\u0026#34;`  const array = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; console.log( Object.keys(array) ); // [\u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;]   使用 Object.keys() 傳回陣列的所有 鍵名（key name）。可以看到陣列的鍵名就是整數 0、1、2。\n雖然 typeof 無法判斷陣列與物件，但可以利用 instanceof 運算子區分陣列和物件。\n1 2 3 4 5  const o = {}; const a = []; console.log( o instanceof Array ); // false console.log( a instanceof Array ); // true   或是使用 Array.isArray() 來判斷：\n1 2 3 4  // 承接上方程式碼  console.log( Array.isArray(o) ); // false console.log( Array.isArray(a) ); // true   2. 為何要使用陣列？ 假設需要儲存一年中每個月的平均溫度：\n1 2 3 4 5 6  let averageTep1 = 25; let averageTep2 = 22; let averageTep3 = 24; let averageTep4 = 28; let averageTep5 = 29; ...   使用變數來存放絕對不是一個好辦法。\n因此可以使用陣列來存放資料，能夠一次管理多個變數，\n1 2 3 4 5 6 7 8 9 10  const averageTep = []; averageTep[0] = 25; averageTep[1] = 22; averageTep[2] = 24; averageTep[3] = 28; averageTep[4] = 29; ... console.log( averageTep ); // [25, 22, 24, 28, 29 ...]   還可以搭配物件使用：\n1 2 3 4 5 6 7 8  const person = [ {name: \u0026#39;Peter\u0026#39;, sex: \u0026#39;male\u0026#39;}, {name: \u0026#39;Mike\u0026#39;, sex: \u0026#39;male\u0026#39;}, {name: \u0026#39;Merry\u0026#39;, sex: \u0026#39;female\u0026#39;} ] console.log( person[0].name ); // \u0026#34;Peter\u0026#34; console.log( person[2].sex ); // \u0026#34;female\u0026#34;   基本操作 1. 建立 建立陣列有兩種基本方式：\n 建構函式 Array() 陣列實值 []  1 2 3 4 5  const arr1 = [1, 2, 3]; const arr2 = new Array(1, 2, 3); console.log( arr1 ); // [1, 2, 3] console.log( arr2 ); // [1, 2, 3]   new Arry() 與 Arry() 同義，表示 new 可省略。。\n但是，在 JavaScript 應該優先考慮使用 [] 陣列實值。除了用到字元比較少之外，還有 JavaScript 是自由度高的程式語言，new Array() 有可能會被複寫，創造出不是陣列的東西。\n另外 Array 建構式有一種特殊的使用方式，如果只傳入一個數值引數被傳入，那此建構函式不會把該值當成陣列中內容，而是當作長度 lenght。\nJavaScript 的陣列不需要預設大小，宣告後就可以新增需要的值（大部分高階語言的陣列宣告後大小就固定了）。\n2. 取值 可以透過索引取得元素的指定值：\n1 2 3 4 5 6 7  const array = [1, 2, 3, 4, 5]; console.log( array[0] ); // 1 console.log( array[1] ); // 2 console.log( array[2] ); // 3 console.log( array[3] ); // 4 console.log( array[4] ); // 5   3. 陣列內容操作 除了一開始宣告就有的元素，還可以直接透過賦值方式新增陣列元素：\n1 2 3 4 5 6  const array = []; array[0] = 1; array[1] = 2; console.log( array ); // [1, 2];   如果該索引位置已經有該元素，那將會覆蓋原來的值。\n新增／刪除頭尾的元素可以使用：\n push() 會添加一個或多個元素至陣列的末端，並且回傳陣列的新長度。 unshift() 會添加一個或多個元素至陣列的開頭，並且回傳陣列的新長度。 pop() 會移除並回傳陣列的最後一個元素。此方法會改變陣列的長度。 shift() 會移除並回傳陣列的第一個元素。此方法會改變陣列的長度。  以下兩個陣列方法能新增最後或最前的元素：\n1 2 3 4 5 6 7 8 9 10  // 承接上段程式碼  array.push(3); console.log( array ); // [1, 2, 3]  array.push(4, 5, 6); console.log( array ); // [1, 2, 3, 4, 5, 6]  array.unshift(0, 0); console.log(array); // [0, 0, 1, 2, 3, 4, 5, 6]   以下兩個陣列方法能移除最後或最前的元素：\n1 2 3 4 5 6 7  const array = [1, 2, 3, 4]; array.pop(); console.log( array ); // [1, 2, 3]  array.shift(); console.log( array ); // [2, 3]   如果要刪除特定位置的元素，如果用 deleta 運算子將其移除，會有以下問題：\n1 2 3 4 5 6  const array = [1, 2, 3, 4]; delete array[1]; console.log( array.length ); // 4 console.log( array ); // [1, undefined, 3, 4]   這樣會導致陣列變成稀疏陣列（關於稀疏陣列將在下面說明）。\n3.1 特定位置插入元素、刪除特定位置元素 要在陣列中插入元素、移除特定元素，可以使用 splice()，能通過刪除或替換現有元素或者原地添加新的元素來修改陣列，並以陣列形式回傳被修改的內容。\n此方法會改變原陣列。\n語法：\n1  array.splice(start[, deleteCount[, item1[, item2[, ...]]]])    start：指定修改的起始位置，可以是負數，由末尾計算索引。 deleteCount：表示要移除的數組元素的個數，從起始位置開始刪除。 item1, item2, ...：要插入的元素，由起始位置之後插入，如果不設定將只會刪除元素。  假設我們要在索引位置 2 之後插入一個新的元素：\n1 2 3 4 5  const array = [0, 1, 2, 3, 4, 5]; array.splice(2, 0, \u0026#39;a\u0026#39;); console.log( array ); // [0, 1, \u0026#34;a\u0026#34;, 2, 3, 4, 5]   起始位置設為 2，刪除個數 0。\n如果我們要刪除索引位置 3 的元素：\n1 2 3 4 5  const array = [0, 1, 2, 3, 4, 5]; array.splice(3, 1); console.log( array ); // [0, 1, 2, 4, 5]   起始位置設為 3，刪除個數 1，不設定插入元素。\n3.2 填充陣列 fill() 為 ES6 新增的方法，可以一次設定，起始位置至終止位置的值。不包含終止位置。\n此方法會改變原陣列。\n語法：\n1  array.fill(value[, start[, end]])    value 設定值 start 起始位置 end 終止位置  1 2 3 4 5 6 7  let arr = [0, 1, 2, 3]; console.log(arr.fill(\u0026#39;a\u0026#39;, 1, 3)); // [0, \u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;, 3]  console.log(arr.fill(\u0026#39;b\u0026#39;)); // ) [\u0026#34;b\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;b\u0026#34;]   3.3 複製貼上 copyWithin() 是 ES6 新增的方法，它能夠複製陣列中的某一段，並貼到陣列的其他位置，並取代原本的值。copyWithin() 並不會改變陣列的長度，如果貼上的長度會超過結尾會停止。\n語法：\n1  array.copyWithin(target[, start[, end]])    target：要貼上的起始位置。 start：要複製的起始位置。 end：要複製的結束位置，不包括這個位置元素。 如果是負數由結尾計算。  1 2 3 4 5 6  console.log([1, 2, 3, 4, 5].copyWithin(2)); console.log([1, 2, 3, 4, 5].copyWithin(-2)); console.log([1, 2, 3, 4, 5].copyWithin(0, 2)); console.log([1, 2, 3, 4, 5].copyWithin(0, -2)); console.log([1, 2, 3, 4, 5].copyWithin(0, 3, 4)); console.log([1, 2, 3, 4, 5].copyWithin(-2, -3, -1));   4. 提取陣列中的元素 slice() 會回傳一個新的陣列，這一對是一個由 begin 和 end 決定的原陣列的淺拷貝（包括 begin，不包括end）。\n此方法原陣列不會被改變。\n語法：\n1  array.slice([begin[, end]]);    begin：提取起始處的索引（從 0 開始），從該索引開始提取原陣列元素。 end：提取終止處的索引（從 0 開始），在該索引處結束提取原陣列元素。slice 會提取原陣列中索引從 begin 到 end 的所有元素（包含 begin，但不包含 end）。  begin 和 end 都可以是負數，在這種情況下，從末尾計算索引。\n從陣列中提取索引位置 1 到 2 的元素到新陣列：\n1 2 3 4  const arr = [0, 1, 2, 3, 4]; let newArr = arr.slice(1, 3); console.log( newArr );   如果要提取某位置後的所有元素，可以省略 end：\n1 2 3 4  const arr = [0, 1, 2, 3, 4]; let newArr = arr.slice(2); console.log(newArr); // [2, 3, 4]   因為會建立新的陣列，因此可用來淺拷貝陣列：\n1 2 3 4  const arr = [0, 1, 2, 3, 4]; let newArr = arr.slice(); console.log( newArr ); // [0, 1, 2, 3, 4]   如果搭配展開運算子 ... ，可以建立出一個移除特定位置的新陣列。\n假設要移除索引 3 的元素：\n1 2 3 4 5 6 7  const arr = [0, 1, 2, 3, 4, 5]; let index = 3; let newArr = [...arr.slice(0, index), ...arr.slice(index + 1)]; console.log( newArr ); // [0, 1, 2, 4, 5]   5. 元素數量 陣列的 length 屬性可以查看裡面存放多少資料。\n1 2 3  let array = [1, 2, 3, 4, 5]; console.log( array.length ); // 5   length 屬性可讀可寫，因此也可以將其賦值為0，會等同清空陣列。\n1 2 3  array.length = 0; console.log( array ); // []   如果將 length 屬性賦值的數值小於元素，將會刪除後面的元素。\n但這裡需要注意，如果將 length 給予大於其元素的數值，那會導致陣列變成稀疏陣列。\n5.1 清空 Array 的操作 常見的作法有兩種，兩種看似都是清空陣列，但並不相同：\n Array.length = 0 Array = []  第一種在上面有提到過，就是將陣列元素都移除。\n而第二種要注意的是，陣列跟物件一樣是傳址，每個陣列都會有自己的記憶體位址，而 Array = [ ] 其實是將一個新的空陣列記憶體位置傳給原本存放舊陣列的變數。\n簡單來說，Array.length = 0，是將原本的陣列所有元素移除，而 Array = [] 是重新給一個新陣列。\n舉例說明：\n1 2 3 4 5 6 7 8 9  const myCart = []; myCart.push(\u0026#39;手機\u0026#39;, \u0026#39;電視\u0026#39;); console.log( myCart ); // [\u0026#34;手機\u0026#34;, \u0026#34;電視\u0026#34;]  const MingCart = myCart; MingCart.push(\u0026#39;風扇\u0026#39;); console.log( myCart ); // [\u0026#34;手機\u0026#34;, \u0026#34;電視\u0026#34;, \u0026#34;風扇\u0026#34;]   假設我有一個空購物車，我買了手機、電視，放進購物車。\n小明也有一個購物車，而且跟我共用。\n所以小明加入、刪除商品，我的購物車都會受到影響。\n如果使用 Array.length = 0，因為是共用的購物車，所以小明的購物車也會被清空。\n1 2 3 4  // 承接第一段程式碼  myCart.length = 0; console.log( MingCart ); // []   但如果使用 Array = []，那我會得到一個新的空購物車，而小明還是使用原本的購物車。\n1 2 3 4  // 承接第一段程式碼  myCart = []; console.log( MingCart ); // [\u0026#34;手機\u0026#34;, \u0026#34;電視\u0026#34;, \u0026#34;風扇\u0026#34;]   6. 合併陣列 concat() 用於合併兩個或多個陣列。此方法不會更改現有陣列，而是返回一個新陣列。\n1 2 3 4 5  const arr1 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; const arr2 = [\u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; console.log( arr1.concat(arr2) ); // [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;]   7. 字串相關方法 陣列有自己的 toString 方法，會回傳以逗號分隔的元素列表的字串：\n1 2 3  const arr = [1, 2, 3]; console.log( arr.toString() ); // \u0026#34;1,2,3\u0026#34;   其他轉字串操作的也是一樣結果：\n1 2 3 4  // 承接上方程式碼  console.log( String(arr) ); // \u0026#34;1,2,3\u0026#34; console.log( arr + \u0026#39;\u0026#39; ); // \u0026#34;1,2,3\u0026#34;   因為陣列沒有 Symbol.toPrimitive，也沒有 valueOf()，它們只能執行 toString() 進行轉換。\njoin()  能將一個陣列的所有元素連接成一個字串並回傳這個字符串。如果陣列只有一個項目，那麼將回傳該項目而不使用分隔符號。\n語法：\n1  array.join([separator])   separator 分隔符號，預設為 ,。\n1 2 3 4  let arr = [1, 2, 3]; console.log( arr.join() ); // \u0026#34;1,2,3\u0026#34; console.log( arr.join(\u0026#39;?\u0026#39;) ); // \u0026#34;1?2?3\u0026#34;   9. 排序陣列 reverse() 方法會原地（in place）反轉（reverses）一個陣列。陣列中的第一個元素變為最後一個，而最後一個元素則變成第一個。\n1 2 3 4 5  const arr = [1, 2, 3, 4]; arr.reverse(); console.log(arr); // [4, 3, 2, 1]   sort()方法會原地（in place）對一個陣列的所有元素進行排序，並回傳此陣列。\n語法：\n1  arr.sort([compareFunction])    compareFunction 指定一個函式來定義排序順序。假如省略此參數，陣列將根據各個元素轉為字串後的每一個字元之 Unicode 編碼位置值進行排序。 回傳值：排序後的陣列  如果使用 compareFunction 函式，就要定義這個回呼函式 compareFunction（a, b），讓排序演算法知道兩筆資料項之間的關係，可能的執行結果包括：\n 如果回呼函式回傳值小於 0，則會把 a 排在小於 b 之索引的位置，即 a 排在 b 前面。 如果回呼函式回傳值等於 0，a 與 b 皆不會改變彼此的順序，但會與其他全部的元素比較來排序。 如果回呼函式回傳值大於 0，則會把 b 排在小於 a 之索引的位置，即 b 排在 a 前面。  所以，比較函式會是以下形式：\n1 2 3 4 5 6 7 8 9 10  function compare(a, b) { if (在某排序標準下 a 小於 b) { return -1; } if (在某排序標準下 a 大於 b) { return 1; } // a 必須等於 b  return 0; }   如果比較數值而不是字串，比較函式可以僅僅利用 a 減 b。以下函式將會升冪排序陣列：\n1 2 3  function compareNumbers(a, b) { return a - b; }   如果要降冪排序就改成 b - a。\n範例說明：\n1 2 3 4 5 6 7 8  const inventors = [ { name: \u0026#39;Albert\u0026#39;, year: 1879 }, { name: \u0026#39;Isaac\u0026#39;, year: 1643 }, { name: \u0026#39;Galileo\u0026#39;, year: 1564 }, { name: \u0026#39;Marie\u0026#39;, year: 1867 }, { name: \u0026#39;Johannes\u0026#39;, year: 1571 }, { name: \u0026#39;Nicolaus\u0026#39;, year: 1473 } ];   排序數值大小，將資料依據出生年分排序：\n1 2 3 4 5 6 7 8 9 10 11 12 13  const yearSort = inventors.sort(function(a, b) { return a.year - b.year; }); console.log( yearSort ); // [ // { name: \u0026#39;Nicolaus\u0026#39;, year: 1473 }, // { name: \u0026#39;Galileo\u0026#39;, year: 1564 }, // { name: \u0026#39;Johannes\u0026#39;, year: 1571 }, // { name: \u0026#39;Isaac\u0026#39;, year: 1643 }, // { name: \u0026#39;Marie\u0026#39;, year: 1867 }, // { name: \u0026#39;Albert\u0026#39;, year: 1879 } // ]   排序字串，將資料依據字串第一個字母排序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  inventors.sort(function(a, b) { if(a.name[0] \u0026lt; b.name[0]) { return -1; } if(a.name[0] \u0026gt; b.name[0]) { return 1; } return 0; }); console.log( inventors ); // [ // { name: \u0026#39;Albert\u0026#39;, year: 1879 }, // { name: \u0026#39;Galileo\u0026#39;, year: 1564 }, // { name: \u0026#39;Isaac\u0026#39;, year: 1643 }, // { name: \u0026#39;Johannes\u0026#39;, year: 1571 }, // { name: \u0026#39;Marie\u0026#39;, year: 1867 }, // { name: \u0026#39;Nicolaus\u0026#39;, year: 1473 } // ];   也可以使用 ?: 三元條件運算子簡化：\n1 2 3 4 5 6 7 8 9 10 11 12 13  inventors.sort(function(a, b) { return (a.name[0] \u0026gt; b.name[0]) ? 1 : (a.name[0] \u0026lt; b.name[0]) ? -1 : 0 }); console.log( inventors ); // [ // { name: \u0026#39;Albert\u0026#39;, year: 1879 }, // { name: \u0026#39;Galileo\u0026#39;, year: 1564 }, // { name: \u0026#39;Isaac\u0026#39;, year: 1643 }, // { name: \u0026#39;Johannes\u0026#39;, year: 1571 }, // { name: \u0026#39;Marie\u0026#39;, year: 1867 }, // { name: \u0026#39;Nicolaus\u0026#39;, year: 1473 } // ];   注意事項：\n sort() 不會產生新陣列，會變動原本的陣列。 排序不一定是穩定的，各家瀏覽器都不同，可以參考下面文章。   從 Array 的 sort 方法，聊到各瀏覽器的實作，沒想到 Chrome 和FireFox 的排序如此不同\n 8. 查詢陣列  indexOf(item, from)：從索引 from 的位置往右查詢 item，如果 from 省略則從頭開始。回傳符合的第一個元素的索引，沒有則回傳 -1。 lastIndexOf(item, from)：和上面相同，只是往 from 的左邊查詢，如果省略就是從尾部開始。 includes(item, from)：從索引 from 查詢 item，如果找到則回傳 true。  1 2 3 4 5 6 7 8 9 10  const arr = [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;a\u0026#39;]; console.log(arr.indexOf(\u0026#39;c\u0026#39;)); // 1 console.log(arr.indexOf(\u0026#39;c\u0026#39;, 2)); // 2  console.log(arr.lastIndexOf(\u0026#39;c\u0026#39;)); // 2 console.log(arr.lastIndexOf(\u0026#39;c\u0026#39;, 1)); // 1  console.log(arr.includes(\u0026#39;c\u0026#39;)); // ture console.log(arr.includes(\u0026#39;c\u0026#39;, 2)); // ture   但要注意的是，這些方法是使用 === 嚴格比較。\n如果要處理比較複雜的比較，可以改使用 find() 或 findIndex()。\n陣列兩個容易誤用的重點 陣列兩個容易誤用的重點：\n 稀疏陣列（Sparse Array） 類陣列（Array-Like）  1. 稀疏陣列 稀疏陣列是指陣列中有 插槽（slot） 可能未定義其值或被略過而導致存放 undefined 的狀況，範例如下：\n1 2 3 4 5 6 7  const arr = []; arr[0] = 1; arr[2] = [ 3 ]; console.log( arr[1] ); // undefined console.log( arr.length ); // 3   雖然這樣不會出錯誤，但如果不注意這種小細節，在之後的陣列操作上會出現難以發現的 BUG。\n若使用「很像數字」的字串當成鍵名來存資料，鍵值會被強制轉型為數字。\n1 2 3 4 5  const arr = [ ]; arr[\u0026#39;13\u0026#39;] = 42; console.log( arr.length ); // 14   這樣導致 arr 成了稀疏陣列，其長度就被誤判，因此沒事別對陣列額外新增 鍵值對（key-value）。若索引值非數值還是用乖乖使用物件吧。\n1.1 Array.of() Array() 建構函式建立陣列，有一個常見陷阱，就是當只有一個引數傳入，並不會產生已那個數字為元素的陣列。\n預期建立的陣列為 [3]，但實際結果為一個長度為 3 的稀疏陣列：\n1 2 3 4  const arr = Array(3); console.log( arr[0] ); // undefined console.log( arr.length ); // 3   ES6 新增了 Array.of() 用來取代 Array()，不會發上述的怪異行為：\n1 2 3 4  const arr = Array.of(3); console.log(arr[0]); // 3 console.log(arr.length); // 1   不過一樣很少會用到，使用陣列實值建立陣列優先。\n2. 類陣列（Array-Like） 類陣列（Array-Like）是具有有索引和 length 屬性的物件，可能各種形式的 串列（lists） 或字串，看起來很像陣列，但並非真正的陣列，所以沒有繼承陣列的方法。\n有時候為了使用陣列的方法（例如 map、indexOf 等等方法）來處理類陣列的元素，因此會需要將其轉成真正的陣列。\n舉例來說 DOM 物件操作後所得到的串列：\n1 2 3 4 5  const list = document.getElementsByTagName(\u0026#39;div\u0026#39;); list console.log( list ); // HTMLCollection(3) [div, div, div] console.log( list.length ); // 3   document.getElementsByTagName 會得到一個節點集合，並非真正的陣列，因此沒有繼承陣列的方法，因此需要將它轉成陣列，才能使用陣列的方法。\n轉換串列成陣列的方法\n Array.prototype.slice.call() Array.apply() [...] ES6 新增 Array.from() ES6 新增  1 2 3 4 5 6 7  const link = document.links; Array.isArray( link ); // false Array.isArray( Array.prototype.slice.call(link)); // true Array.isArray( Array.apply(null, link)); // true Array.isArray( [...link]); // true Array.isArray( Array.from(link)); // true   ","description":"幾乎所有程式語言都支援陣列，因為陣列是最簡單的資料結構。","id":100,"section":"posts","tags":["JavaScript","陣列 Array"],"title":"陣列","uri":"https://chupai.github.io/posts/200424_js_array/"},{"content":"這週是 六角鼠年鐵人賽 第十一週，學習基礎演算法之前，先來瞭解基本的資料結構。\n\r為什麼要學習資料結構 因為不同的資料結構，將會影響程式設計（演算法）的方法與效率。\n 程式 = 資料結構 + 演算法\nAlgorithms + Data Structures = Programs\n 選擇正確的資料結構，可以提高演算法的效率。\n什麼是資料結構 在電腦科學中，資料結構（Data Structure）是電腦中儲存、組織資料的方式。簡單來說，當資料存在記憶體中的時候，決定資料的存放順序及存放位置的，就是資料結構。\n舉例來說，假設要儲存考試成績，你不會用變數一個一個去存它，通常會用一個陣列來存放：\n1 2 3 4 5  let score1 = 80; let score2 = 60; let score3 = 70; let scores = [80, 60 , 70];   因為當要儲存的資料變多時，用變數一個一個去存資料，要處理資料時，非常麻煩。\n換句話說，所謂資料結構，就是考慮如何運用變數儲存要處理的資料，而演算法就是要處理這些資料的方法。將資料有組織的存放在程式內，可以提升程式的執行效率。\n常見的資料結構  陣列（Array） 連結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹狀結構（Tree） 圖形結構（Graph） 堆積（Heap） 雜湊表（Hash table）  資料結構的分類 資料結構，根據元素之間的關係，分為兩大類：\n 線性關係的資料結構 非線關係的性結構  1. 線性關係 線性關係的資料結構，其組成資料元素間具有線性關係，簡單來說就是「資料會排成一直線」。\n每個元素只有另外兩個元素相鄰，也就是只有前、後兩個方向：\n 第一個元素沒有前驅者（前面的元素） 最後一個元素沒有後繼者（後面的元素） 其餘的元素都各只有一個前驅者（predecessor）和一個後繼者（successor）  線性關係的資料結構又分為兩種物理結構：\n 順序儲存結構，例：陣列、堆疊、佇列 鏈式儲存結構，例：連結串列  2. 非線性關係 而非線性關係的資料結構，簡單來說就是資料元素間不是只有前後關係。\n非線性關係的資料結構包含：\n 階層關係，例：樹 相鄰關係，例：圖  資料結構操作 常見的資料結構操作的時間複雜度與空間複雜度。\n圖片來源：Know Thy Complexities!\n總結 不過大多數情況下 Javascript 開發關心的是「資料的邏輯結構」而非「資料的儲存結構」。因為 JavaScript 只有物件，陣列實際上也是物件，多數的資料結構都必須使用物件或陣列來模擬實作。\n","description":"這週是六角鼠年鐵人賽第十一週，學習基礎演算法之前，先來瞭解基本的資料結構。","id":101,"section":"posts","tags":["演算法 Algorithm","資料結構","w3HexSchool"],"title":"JavaScript 學演算法（三）- 資料結構概述","uri":"https://chupai.github.io/posts/200419_data_structure/"},{"content":"這週是 六角鼠年鐵人賽 第十週（是不是有銅角獎啦？！），說明如何評估演算法的好壞。\n\r演算法的好壞 一個問題不一定只有一種演算法能解決。那我們怎麼評估演算法的好壞呢？\n最直覺的方式，就是測量程式的執行時間、程式的記憶體使用量。\n但是，即便是相同的演算法，也會因為以下變數而有所不同：\n 不同電腦的處理速度 實作的程式語言 輸入的大小 不同情況的資料  所以需要用一個「不受環境、數據狀況，比較客觀的方式」去分析一個演算法。\n所以我們會用 複雜度 來分析演算法：\n 時間複雜度（Time complexity）\n指演算法所耗費的時間。 空間複雜度（Space Complexity）\n指演算法所需要消耗的儲存記憶體資源。  時間複雜度與空間複雜度是相互影響的，當追求一個較好的時間複雜度時，可能會使空間複雜度的性能變差。舉例來說，Google Chrome 相較於其他瀏覽器，運行速度較快，但它的缺點就是占用很多記憶體。\n根據調查顯示，用戶對於執行效率有極高的要求，對於網頁開啟的忍耐極限是 6 秒甚至更短。在這個大背景下，一個好的演算法，更專注於討論時間複雜度。另外，現在的儲存空間很便宜，而且當 資料量變大 時，空間複雜度的差異通常不大，但 時間複雜度則會有極大的差異。\n不同情況下的分析 每當輸入資料的情況不同時，演算法呈現的效果也不同，舉例來說，在圖書館找一本書，並一本一本找：\n 最佳情況：第一本就是要找的書 最糟情況：最後一本才是要找的書 平均情況：中途就找到要找的書  上述三種情況都可以被用來分析演算法。但最佳情況對演算法沒有多大幫助，通常我們只考慮最糟情況，也就是演算法複雜度的上限值。\n輸入大小與執行時間的關係 我們舉一個非常簡單的例子。\n以 求等差數列的和 來說，假設要求出 1 + 2 + 3 + \u0026hellip; + n 的和，有兩種作法：\n 一個一個加 套用公式計算  用 for 迴圈一個一個的加：\n1 2 3 4 5 6 7  function sum(n) { let sum = 0; for(let i = 0; i \u0026lt;= n; i++) { sum += i; } return sum; }   等差數列的和公式，我們小時候應該都有學過：\n 一個等差數列的和，等於其首項與末項的和，乘以項數除以 2。\n 1 2 3  function sum(n) { return (1 + n) * n / 2; }   兩種作法的時間差異：\n 如果 $1$ 累加到 $n$ 迴圈需要跑 $n$ 次 不論 $n$ 多大，都只需要執行 $1$ 次。  假設執行一次只需要 0.01毫秒，當 $n$ 不大時，一個一個加與套用公式計算的時間差異並不大，但隨著 $n$ 越來越大，你會發現使用一個一個加的時間會變得非常可觀。\n由此可知，當輸入量非常大時，不同演算法執行上效率差異會非常大。\n 演算法效率：執行所需時間與資料量 $n$ 的關係。\n 演算法執行時間的計算方式  執行時間 = 執行次數 * 每次執行所需的時間\n 但是 每次執行所需的時間 會根據機器和語言的的差異而有所不同，因此演算法只考慮執行的次數。\n將演算法中基本操作的執行次數作為演算法時間複雜度的度量，即時間複雜度不是演算法程式的運行時間，而是其中基本操作的總次數。\n舉例來說：\n1 2 3 4 5 6 7  function sum(n) { let sum = 0; for(let i = 0; i \u0026lt; n; i++) { sum += i; } return sum; }   假設每行的執行時間都一樣，記做 $t$。\n line2：需要 $1$ 個 $t$ 的時間 line3：需要 $n$ 個 $t$ 的時間 line4：也是 $n$ 個 $t$ 的時間 line6：需要 $1$ 個 $t$ 的時間 那麼執行時間就是 $(2n + 2) * t$ 執行次數為 $2n + 2$  再考量下面這個例子：\n1 2 3 4 5 6 7 8 9  function sum(n) { let sum = 0; for(let i = 0; i \u0026lt; n; i++) { for(let j = 0; j \u0026lt; n; j++) { sum += i * j; } } return sum; }    line2：需要 $1$ 個 $t$ 的時間 line3：需要 $n$ 個 $t$ 的時間 line4：也是 $n^2$ 個 $t$ 的時間 line5：也是 $n^2$ 個 $t$ 的時間 line8：需要 $1$ 個 $t$ 的時間 執行次數為 $2n^2 + n + 2$  複雜度分析工具 我們在之前已經提過，演算法通常只考慮最糟情況，也就是演算法複雜度的上限值。\n因此我們會用 Big O Notation 來表示演算法的複雜度。\n Big O Notation（$O$），念作 Big Oh 😮，是用於描述函數漸近行為的數學符號，更確切地說，它是用另一個函數來描述一個函數數量級的漸近上界，用 $O(f(n))$ 表示。\n 假設輸入 $n$，而演算法的執行時間為一個函數 $f(n)$，以下五個演算法分別為：\n $1$ $10$ $2n + 1$ $2n^2$ $\\log_2n$  當 $1$ 與 $10$ 比較時，並不會說 $1$ 比 $10$ 有效率，因為當 $n$ 趨近無限大時，$1$ 與 $10$ 兩者差異不大，舉例來說：假如你身上有一千億，當你要花 1元跟 10元時，你會認為 10元的比較貴嗎？不會都是小錢。\n分析演算法是看當資料量「最多」會達到怎麼樣的趨勢，也就是 $n$ 趨近無限大時，並不會在意細節，只看函數的最高次方，會忽略係數、其他次方項與常數。\n用 Big O 表示上述函數之複雜度分析：\n $O(1)$ $O(1)$ $O(n)$ $O(n^2)$ $O(\\log n)$  由此可知，當我們在計算演算法的時間時，只需要大概的算一下迴圈數，大致上判斷一下丟進去的資料量會讓程式執行幾次即可，不需要像之前一樣計算的那麼仔細。\n常見時間複雜度 圖片來源：8 time complexities that every programmer should know\n根據上圖，若同樣處理 $n$ 筆資料，那麼各個時間複雜度成本如下：\n$O(1)\u0026lt;O(\\log n)\u0026lt;O(n)\u0026lt;O(n \\log n)\u0026lt;O(n^2)\u0026lt;O(2^n)\u0026lt;O(n!)$\n成本越高，表示效率越差。\n常見的時間複雜度：\n   執行時間 名稱 演算法舉例     $O(1)$ 常數時間 Constant time 普通數學運算   $O(\\log n)$ 對數時間 Logarithmic time 二分搜尋   $O(n)$ 線性時間 Linear time 簡易搜尋、插入排序法   $O(n \\log n)$ 線性對數時間 Linearithmic Time 比較排序   $O(n^2)$ 平方時間 Quadratic time 選擇排序、泡沫排序   $O(2^n)$ 指數時間 Exponential time 費波那契數列   $O(n!)$ 階乘時間 Factorial time 暴力搜尋解決旅行推銷員問題    輸入 10、100、1000 資料量需花費的時間比較：\n   執行時間 10個資料量 100個資料量 1000個資料量     $O(1)$ 1 1 1   $O(\\log n)$ 3 6 9   $O(n)$ 10 100 1000   $O(n \\log n)$ 30 600 9000   $O(n^2)$ 100 10000 1000000   $O(2^n)$ 1024 1.26e+29 1.07e+301   $O(n!)$ 3628800 9.3e+157 4.02e+2567    當複雜度到達或超過 $O(2^n)$ 時，只要 $n$ 稍大一點，基本上程式就會跑到天荒地老都跑不出來，因此最好避免過高的複雜度。\n空間複雜度 上邊説了那麼一大堆的時間複雜度，相比空間複雜度就是指演算法執行時所花費的記憶體空間的趨勢。\n其計算方式與時間複雜度相似，也使用 Big-O 來表示其複雜度。\n1. 計算演算法使用記憶體量 計算演算法所需的記憶體量，只需要計算使用的變數量。\n舉例來說：\n1 2 3 4 5 6 7  function sum(n) { let sum = 0; for(let i = 0; i \u0026lt; n; i++) { sum += i; } return sum; }   不管程式的執行步驟數是多少，我們的變數始終只有 sum 與 i，也就是變數量只有 2。因此空間複雜度為 $O(1)$。\n再考量下面這個例子：\n1 2 3 4 5 6 7  function show(n) { let arr = []; for (let i = 0; i \u0026lt; n; i++) { arr.push(i); } return arr; }   迴圈每次執行一次 push 方法，就會申請一個空間存儲變量，很明顯的，記憶體的佔用量會隨著輸入量而線性成長，故這個演算法的空間複雜度為 $O(n)$。\n2. 常見的空間複雜度 常見的空間複雜度只有 $O(1)$、$O(n)$、$O(n^2)$，其他的話很少會用到。\n總結 評估演算法的好壞，就是要分析演算法的複雜度，而時間複雜度與空間複雜度式相互影響的，但時間複雜度比空間複雜度重要。\n","description":"這週是 六角鼠年鐵人賽 第十週（是不是有銅角獎啦？！），說明如何評估演算法的好壞。","id":102,"section":"posts","tags":["演算法 Algorithm","w3HexSchool"],"title":"JavaScript 學演算法（二）- 演算法分析","uri":"https://chupai.github.io/posts/200406_analysis_of_algorithms/"},{"content":"這週是 六角鼠年鐵人賽 第九週，接下來幾週大概是我學習演算法筆記，既然是學前端，當然就是使用 JavaScript 來實作。\n\r何謂演算法？ 演算法，英文名稱 Algorithm，中國稱為 算法。\n 演算法，簡單來就是一套解決問題的方法。\n 要簡單明瞭何謂演算法，推薦觀看這個影片：人腦也可以執行演算法 - David J. Malan。\n1. 演算法與程式 演算法通常是電腦所執行的，但演算法在電腦誕生之前就存在，演算法是數學家所提出來的。\n電腦看起來很聰明，但其實電腦只會做 0 跟 1 的運算，而我們就是透過 程式，把現實世界需要解決的問題變成數學問題，丟給電腦來幫我們做運算處理，而這個解題的方法就是演算法。\n所以說，演算法是用以執行計算或完成作業的程序，所有步驟都要能用數學方式表現，而程式是實作演算法的方式。也就是說：\n 演算法相當於「思考程序」 程式相當於為了表現演算法的「語言」  2. 演算法的表示方式  設計程式時，通常會使用 虛擬碼 pseudocode 來表示； 設計電子電路，會使用 流程圖 來表示； 而為了理解演算法，會使用文字與圖片來輔助說明。  演算法的定義 演算法 是對特定問題求解步驟的一種描述，一般演算法嚴謹的條件必須符合五個標準：\n 輸入（Input）：至少有零個或以上的輸入（可以沒輸入或多個輸入）。 輸出（Output）：至少有一個或以上回傳結果（經過演算法計算獲得）。 確定性/明確性（Definiteness）：每一個指令步驟必須明確而不造成混淆。在一定條件下，相同的輸入只能有唯一結果。 有限性（Finiteness）：在有限步驟後一定會結束（完成或終止），確保不會進入無窮迴圈。 可行性/有效性（Effectiveness）：步驟清楚可行，能使用數學運算出結果（表示能夠實現）。  一個好的演算法 一個演算法如果要設計好，必須達到以下目標：\n 正確性（correctness）：不含語法錯誤，對各種需求的輸入數據都能滿足。 可讀性（readability）：簡潔易懂。 健壯性（robustness）：非法數據被輸入時，不會引起演算法崩潰、出錯。 效率與低存儲量需求：即，演算法執行時間短 或 演算法記憶體使用量低。  總結 這週就簡敘述何謂演算法，下週將說明如何分析演算法的好壞。\n目錄 前言：\n 何謂演算法？ 演算法分析  資料結構：\n 資料結構概述 陣列 Array 鏈結串列 Linked list 堆疊 ＆ 佇列 集合 \u0026amp; 映射 樹 \u0026amp; 二元樹 二元搜尋樹 AVL-Tree 紅黑樹（上）：B 樹、2-3-4 樹 紅黑樹（中）：新增操作 紅黑樹（下）：刪除操作 樹堆  排序演算法：\n 排序演算法 合併排序 快速排序 希爾排序 堆積排序  搜尋演算法：\n 搜尋演算法  洗牌演算法：\n 洗牌演算法  演算法設計：\n 遞迴 分治法、動態規劃 ","description":"這週是 六角鼠年鐵人賽 第九週，接下來幾週大概用記錄我學習演算法的筆記，既然是學前端，當然就是使用 JavaScript。","id":103,"section":"posts","tags":["演算法 Algorithm","w3HexSchool"],"title":"JavaScript 學演算法（一）- 何謂演算法？","uri":"https://chupai.github.io/posts/200404_algorithm/"},{"content":"這週是 六角鼠年鐵人賽 第八週，紀錄 Vue 表單驗證套件 - Vee Validate 操作方法。\n前言  VeeValidate 官網\n VeeValidate 是專用於 Vue.js 的表單驗證套件。它有很多預設驗證規則，也支持自定義驗證規則。\n由於 2.x版本 與 3.x版本 的操作非常不同，所以簡單紀錄一下。\nVeeValidate 2 1. 安裝 安裝舊版本：\nnpm install vee-validate@2.2.15 --save 導入：\n1 2 3  // main.js import VeeValidate from \u0026#39;vee-validate\u0026#39;; Vue.use(VeeValidate);   1.1 會遇到的問題 如果 Focus 到 input 標籤再點外面，不會進行驗證，可以修改 events，加上 blur：\n1 2 3 4 5  // main.js  Vue.use(VeeValidate, { events: \u0026#39;input|blur\u0026#39;, });   1.2 中文化 舊方法 2.1.0-beta.24版之前：\n1 2 3 4 5 6 7  // main.js  import VeeValidate from \u0026#39;vee-validate\u0026#39;; import zhTW from \u0026#39;vee-validate/dist/locale/zh_TW\u0026#39;; VeeValidate.Validator.localize(\u0026#39;zhTW\u0026#39;, zhTW); Vue.use(VeeValidate);   新方法，必須先安裝 vue-i18n：\nnpm install vue-i18n --save 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // main.js import VeeValidate from \u0026#39;vee-validate\u0026#39;; import zhTW from \u0026#39;vee-validate/dist/locale/zh_TW\u0026#39;; import VueI18n from \u0026#39;vue-i18n\u0026#39;; Vue.use(VueI18n); const i18n = new VueI18n({ locale: \u0026#39;zhTW\u0026#39;, }); Vue.use(VeeValidate, { events: \u0026#39;input|blur\u0026#39;, i18n, dictionary: { zhTW, }, }); // 記得載入 i18n new Vue({ i18n, router, render: (h) =\u0026gt; h(App), }).$mount(\u0026#39;#app\u0026#39;);   2. 基本用法 1 2 3 4 5 6 7 8  \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34; placeholder=\u0026#34;輸入姓名\u0026#34; v-validate=\u0026#34;\u0026#39;required\u0026#39;\u0026#34; :class=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: errors.has(\u0026#39;name\u0026#39;) }\u0026#34; /\u0026gt; \u0026lt;span v-if=\u0026#34;errors.has(\u0026#39;name\u0026#39;)\u0026#34;\u0026gt;請輸入姓名\u0026lt;/span\u0026gt;    input 標籤內要設定 name 這個特性，特性值的部分則是根據該欄位性質做設定，例：姓名就是 name，地址就是 address。 加上 v-validate=\u0026quot;'required'\u0026quot;，表示這一個欄位是必填的。 errors.has('name') ，填入 name 特性值。初始值為 fasle，當觸發 input 標籤時，就會開始驗證，如果欄位未填寫值為 true。  可以配合 v-if 顯示提式字； 或是搭配 :class 加入提式樣式。    假設要驗證 email 格式，則可以使用 v-validate=\u0026quot;'required|email'\u0026quot;。\n而 errors.first('email') 它會根據 email 驗證的各種狀態來顯示不同的提示文字。\n2.1 獲取錯誤訊息  errors.first('field')：獲取關於當前 field 的第一個錯誤訊息 collect('field')：獲取關於當前 field 的所有錯誤訊息 has('field')：當前 filed 是否有錯誤 all()：當前表單所有錯誤 any()：當前表單是否有任何錯誤  ３. 表單提交前的處理 最後我們還需要設定表單驗證方法，來避免送出錯誤的資料格式：\n1 2 3 4 5 6 7  this.$validator.validate().then((result) =\u0026gt; { if (result) { // 當驗證成功時執行 AJAX 的行為  } else { // 驗證失敗產生的行為  } });   VeeValidate 3 VeeValidate 在 v3.x版本之後的使用方法與之前完全不同。\n1. 安裝 安裝最新版本 vee-validate：\nnpm install vee-validate --save 導入：\n1 2 3 4 5 6 7 8 9 10 11 12 13  // main.js import { ValidationObserver, ValidationProvider, extend, localize} from \u0026#39;vee-validate\u0026#39;; import * as rules from \u0026#39;vee-validate/dist/rules\u0026#39;; import TW from \u0026#39;vee-validate/dist/locale/zh_TW.json\u0026#39;; Object.keys(rules).forEach((rule) =\u0026gt; { extend(rule, rules[rule]); }); localize(\u0026#39;zh_TW\u0026#39;, TW); Vue.component(\u0026#39;ValidationObserver\u0026#39;, ValidationObserver); Vue.component(\u0026#39;ValidationProvider\u0026#39;, ValidationProvider);   安裝內容會在下方依序說明。\n2. 添加規則 預設情況下，VeeValidate 不附帶任何驗證規則，這是為了使檔案輕量。\n首先導入定義規則所需的 extend 函式：\n1 2 3  import { extend } from \u0026#39;vee-validate\u0026#39;; // rules   接下來，就是加入規則。\n2.1 安裝所有規則 安裝所有規則有兩種遍歷作法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  import { extend } from \u0026#39;vee-validate\u0026#39;; import * as rules from \u0026#39;vee-validate/dist/rules\u0026#39;; // 作法一 Object.keys(rules).forEach((rule) =\u0026gt; { extend(rule, rules[rule]); }); // 作法二(with typescript) for (let [rule, validation] of Object.entries(rules)) { extend(rule, { ...validation, }); }   除了上述方法，另一種方法是安裝 vee-validate 的完整捆綁包，而不是預設捆綁包，該捆綁包預裝了所有驗證規則及其英文消息。\n將 'vee-validate' 替換成 'vee-validate/dist/vee-validate.full.esm'，就可以一次安裝所有驗證規則，而不用導入 extend 函式。\n1  import { ValidationObserver, ValidationProvider } from \u0026#39;vee-validate/dist/vee-validate.full.esm\u0026#39;;   但不建議一次安裝全部規則，應該使用下面的方式，按照需求安裝。\r 2.2 導入規則 為了避免一次加載全部規則，我們可以選擇需求來導入規則：\n1 2 3 4 5  import { extend } from \u0026#39;vee-validate\u0026#39;; import { required, email } from \u0026#39;vee-validate/dist/rules\u0026#39;; // 按需求導入規則  extend(\u0026#39;required\u0026#39;, required); extend(\u0026#39;email\u0026#39;, email);   更多可用規則可以參考 官方文件。\n3. 基本用法 導入 ValidationProvider 元件：\n1 2 3 4 5 6 7 8 9 10 11  import { ValidationProvider } from \u0026#39;vee-validate\u0026#39;; // 在 main.js 全域註冊元件 Vue.component(\u0026#39;ValidationProvider\u0026#39;, ValidationProvider); // 區域註冊元件（推薦） export default { components: { ValidationProvider, }, };   2.X 版原本是添加 v-validate，而 3.X版則改用 ValidationProvider 元件進行包裹：\n1 2 3 4 5 6 7 8 9 10  \u0026lt;ValidationProvider v-slot=\u0026#34;{ failed, errors }\u0026#34; name=\u0026#34;name\u0026#34; rules=\u0026#34;required\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34;\u0026gt;*收件人姓名\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34; :class=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: failed }\u0026#34; placeholder=\u0026#34;輸入姓名\u0026#34; /\u0026gt; \u0026lt;span v-if=\u0026#34;failed\u0026#34; class=\u0026#34;text-danger\u0026#34;\u0026gt;{{ errors[0] }}\u0026lt;/span\u0026gt; \u0026lt;/ValidationProvider\u0026gt;    name 為報錯時，顯示的名稱。 在 rules 上，添加要驗證的規則。 插槽範圍內可用的屬性，可以參考 官方文件。  errors：錯誤訊息列表，errors[0] 則代表驗證錯誤規則底下定義的 messages failed：如果經過驗證且無效，則值為 false    預設情況下，ValidationProvider 渲染器為 span 標籤，可以使用套件提供的 prop 來改變呈現標籤：\n1  \u0026lt;ValidationProvider tag=\u0026#34;div\u0026#34;\u0026gt;\u0026lt;/ValidationProvider\u0026gt;   3.3 更詳細 更多可用 prop 可以參考 官方文件。\n另外還提供了許多方法可以使用，可以參考 官方文件。\n4. 表單提交前的處理 1 2 3 4 5 6 7 8 9 10 11  import { ValidationObserver } from \u0026#39;vee-validate\u0026#39;; // 在 main.js 全域註冊元件 Vue.component(\u0026#39;ValidationObserver\u0026#39;, ValidationObserver); // 區域註冊元件（推薦） export default { components: { ValidationObserver, }, };   詳細的處理表單範例，可以參考 官方文件。\n基本範例：\n1 2 3 4 5 6  \u0026lt;ValidationObserver v-slot=\u0026#34;{ invalid }\u0026#34;\u0026gt; \u0026lt;form @submit.prevent=\u0026#34;onSubmit\u0026#34;\u0026gt; \u0026lt;!-- .... --\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; :disabled=\u0026#34;invalid\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/ValidationObserver\u0026gt;   提交按鈕目前為禁用，只有當表單通過驗證才可以送出。\n提交前驗證：\n1 2 3 4 5  \u0026lt;ValidationObserver v-slot=\u0026#34;{ handleSubmit }\u0026#34;\u0026gt; \u0026lt;form @submit.prevent=\u0026#34;handleSubmit(onSubmit)\u0026#34;\u0026gt; \u0026lt;!-- .... --\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/ValidationObserver\u0026gt;   ValidationObserver 提供了一個 handleSubmit 可用於保護表單提交的 handleSubmit 功能。\n重置表單：\n1 2 3 4 5 6  \u0026lt;ValidationObserver v-slot=\u0026#34;{ reset }\u0026#34;\u0026gt; \u0026lt;form @reset.prevent=\u0026#34;reset\u0026#34;\u0026gt; \u0026lt;!-- .... --\u0026gt; \u0026lt;button type=\u0026#34;reset\u0026#34;\u0026gt;Reset\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/ValidationObserver\u0026gt;   4.1 使用 $refs 先通過 $refs 找到 ValidationObserver 元件，呼叫組件中的方法 validate()，如果所有條件都為真（就是說所有的校驗都通過了）回傳 true，否則回傳 false。\n1 2 3 4 5  \u0026lt;ValidationObserver ref=\u0026#34;form\u0026#34;\u0026gt; \u0026lt;form @submit.prevent=\u0026#34;onSubmit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/ValidationObserver\u0026gt;   1 2 3 4 5 6 7 8 9  onSubmit () { this.$refs.form.validate().then((success) =\u0026gt; { if (success) { // 證成功後的行為包含 AJAX傳送、重製表單等等  } else { // 驗證失敗產生的行為  } }); },    官方文件。\n 4.2 顯示初始驗證狀態 使用 immediate顯示　初始驗證狀態：\n1 2 3  \u0026lt;ValidationObserver rules=\u0026#34;required\u0026#34; v-slot=\u0026#34;{ errors }\u0026#34;　immediate\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/ValidationObserver\u0026gt;   詳細的互動和用戶體驗範例，可以參考 官方文件。\n4.3 更詳細 插槽範圍內可用的屬性，可以參考 官方文件。\n更多可用 prop 可以參考 官方文件。\n5. 驗證狀態 驗證狀態\n6. 中文化 vee-validate 附帶了一個很小的 i18n 字典，可滿足基本的 i18n 需求。vee-validate 的預設語言是 en。\n雖然 vee-validate 具有 40 多個可用於互動的驗證的語言環境，但是預設情況下不會安裝它們，因此我們需要導入所需的語言環境。\n導入安裝語言環境所需的 localize 函式：\n1  import { localize } from \u0026#39;vee-validate\u0026#39;;   安裝需要的使用語言環境，並使用 localize() 增加新的語言環境：\n1 2 3  import TW from \u0026#39;vee-validate/dist/locale/zh_TW.json\u0026#39;; localize(\u0026#39;zh_TW\u0026#39;, TW);   ","description":"這週是 六角鼠年鐵人賽 第八週，紀錄 Vue 表單驗證套件 - Vee Validate 操作方法。","id":104,"section":"posts","tags":["VeeValidate","Vue","w3HexSchool"],"title":"Vue筆記 - 表單驗證套件 VeeValidate","uri":"https://chupai.github.io/posts/200328_vee-validate/"},{"content":"這週是 六角鼠年鐵人賽 第七週，挑戰剛開始時，我的文章是放在 Bloggi，而且第一週文章就是 Bloggi 如何使用（明顯混分😂），但後來想想，Bloggi 沒有留言、沒有備份、嵌入 CodePen 會跑版，為了避免之後不必要的麻煩，還是用自己建立一個 Blog 吧。\n\rGitHub Pages 架設部落格最頭痛的問題就是放網站的空間，通常架設網站不是自己用 NAS 來架設，就是花錢租主機空間。\n以上兩種方法都是需要一定的花費，但是透過 GitHub Pages 來架站，則完全免費，但也有一定的 條件：\n 網站大小不能超過 1 GB 網站每月流量不能超過 100 GB 一小時內的網站更新不得超過 10 次  以上限制對一般需求一定夠用，而且 GitHub 是著名的軟體原始碼代管服務，有一定的穩定性。\n要說唯一的缺點，就是 GitHub Pages 只能架設「靜態網站」，因此無法架設 Wordpress 之類的部落格。\n這時候就需要使用到 靜態網頁產生器 來建立 Blog。\n1. 熱門靜態網頁產生器  Top 5 Static Site Generators for 2020 10 best static site generators  Hugo 簡介  Hugo 官網\n Hugo 是一個用 Go 語言編寫的靜態網站生成器，最大的優點就是編譯速度相對於 Jekyll、Hexo 簡直是飛快。\n 基於 go 語言開發，沒有錯綜複雜的依賴關係 社區活躍 功能完善 前端語言支持的種類豐富 整體框架靈活易懂 修改即時預覽  近期有越來越多人因為 Hugo 的編譯速度，將部落格從 Hexo 搬移到 Hugo，不過 Hugo 也有一個很大的缺點，就是相對 Hexo 來說，Blog 的主題太少，也是有人因為 Hexo 有喜歡的主題而捨棄 Hugo。\n搭建 Hugo 1. 前置作業 MacOS 可以直接使用 Homebrew 安裝 Hugo。\nbrew install hugo 在 Windsow 環境必須先下載 hugo_extended_0.67.0_Windows-64bit.zip。\n解壓縮後，會有一個 hugo.exe 檔案。創建一個新資料夾：C:\\hugo，並將 hugo.exe 檔案放到裡面。\n接下來配置環境變數，點選本機（右鍵） \u0026gt; 內容 \u0026gt; 進階系統設定 \u0026gt; 環境變數 \u0026gt; Path \u0026gt; 編輯 \u0026gt; 新增路徑：C:\\hugo。\n2. 建立一個專案 開啟終端機並切換到 hugo/ 資料夾下，執行以下命令：\nhugo new site myBlog myblog 可以替換成任意名稱。\n機器上會產生一個 myBlog 資料夾，結構如下：\nmyBlog/ │ ├── archetypes/ │ │ │ └─ default.md # 預設 markdown ├── content/ # 頁面、文章（markdown） ├── data/ # 資料庫 ├── layouts/ # 自定義的樣板 ├── static/ # 靜態資源 ├── themes/ # 網站的主題 └── config.toml # 網站的配置 3. 加入主題 因為 Hugo 預設沒有任何主題的，因此必須在 Hugo Themes 選擇一個來套用。\n記得先安裝 git 工具，接下來在 myBlog/ 資料夾下加入 git 版控：\ngit init 從 Github 下載主題並將其添加到 theme 目錄中：\ngit submodule add https://github.com/AmazingRise/hugo-theme-diary.git themes/diary 如果沒安裝 git：\n 可以直接下載該主題最新版本，並解壓縮； 將資料夾重新命名 並將其移至 themes 資料夾。  最後開啟跟目錄下的 config.toml 檔案，設定使用主題：\ntheme = \u0026quot;diary\u0026quot; 或是將 theme/ 內的 config.toml 取代根目錄的。\n最基本的主題安裝流程大概是這樣。\n但要注意，因為 config 配置檔，支援 toml、yaml、json 三種格式，也可以放在 config/ 資料夾內，然後拆分不同模組的配置。所以並不是每個主題的安裝方式都相同，因此最好詳細閱讀每個主題下方的說明。\n4. 新增頁面 hugo new 會根據 archetypes/ 資料夾下的 default.md 產生在 content/ 資料夾下。\nhugo new [路徑]頁面名.md 單頁面，一般會放在 content/ 資料夾下，例如：\nhugo new about.md 文章一般會放在 content/posts/ 內，例如：\nhugo new posts/my-first-post.md 不同的主題，會有不同的資料夾結構，單頁面與文章的 Front Matter 設定也都不相同，因此可以查看主題文件說明。\n5. 本地端測試 預覽草稿 Draft：\nhugo server -D 預覽（不包含草稿）：\nhugo server 預覽網址：http://localhost:1313/\n建議在本地測試時，config.toml 設定檔內的 baseURL 先設為空值。\n自定義 1. Front Matter Front-matter 是 md 檔案最上方的分隔區域，用於指定個別檔案的變數。\n預設使用 yaml 格式，使用 --- 分隔：\n1 2 3 4 5  --- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true ---   另外還支持 toml、json 格式，分別使用 +++ 與 {} 分隔。\n預設屬性分別為：\n title：標題名，使用 hugo new 建立會與檔名相同。 date：日期，使用 hugo new 建立為目前時間。 draft：草稿，如果是 true 生成網站時，不包括此頁面。  1.1 常用 Front Matter 屬性 另外，列出其他 Hugo 支持的常用 Front Matter 屬性：\n description：內容描述，主要用於 SEO 優化。 tags：標籤。 categories：分類。 keywords：關鍵字。 url：文章 url 名稱，預設使用檔案名稱。 weight：列表頁的文章排序，越小越靠前，無設定則依照時間排序。  其他屬性，主要看你用的主題所對應到板模上的變數，主題的文件都會詳細說明。\n1.2 Archetypes Archetypes 意思為原型，可以當作是生成 md 檔案的模板。\n當我們使用 hugo new 建立 md 檔案時，會根據 archetypes/ 資料夾下的模板來建立。\n舉例來說，如果 archetypes/ 下有一個 about.md，那麼以下指令就會根據它來產生檔案。\nhugo new about.md 如果沒有相同的檔名，會根據 default.md 來產生檔案。\n2. Config Hugo 將整個網站的設定配置都集中在 config.toml 檔中，預設為 toml 格式，一樣支持另外兩種格式（yaml、json）。\n 完整 Hugo Config 可以詳閱官方文件 Configure Hugo。\n 發佈到 Github Pages 上  Host on GitHub\n 事前準備：\n 安裝 Git 2.8 以上 GitHub 帳號 Hugo 網站  1. 建立 repository 在 GitHub 建立一個 repository，命名為：帳號.github.io。\n2. 設定 baseURL 將 config.toml 配置檔內的 baseURL 設為：\n1  baseURL = \u0026#34;http://帳號.github.io/\u0026#34;   3. 建立 public 資料夾 hugo 執行 hugo 就會產生 public/ 的資料夾。\n4. 上傳 在 public/ 資料夾下執行以下命令：\ngit init git remote add origin https://github.com/帳號/帳號.github.io.git git add . git commit -m \u0026quot;my Blog\u0026quot; git push -u origin master 接下來可能會讓你輸入你的 Github 帳號和密碼，之後就可以去 Github 和 http://帳號.github.io 查看是否成功。\n5. 更新 之後添加文章，只需要重新編譯 Hugo，重新提交到 Github 即可。\ngit add . git commit -m \u0026quot;本次更新的說明\u0026quot; git push origin master 新增留言板 因為是靜態網頁，所以留言板就區要依賴第三方。\nDisqus 是整合性留言管理系統，用來管理各種社群的留言平台。\n1. 註冊帳號 註冊帳號並取得 shortname。\n流程蠻簡單的，如果不清楚，可以自行搜尋一下教學流程，這裡就不多做說明。\nLanguage 如果選擇 Chinese 只有簡體。\n2. 在 Hugo 啟用 假設你的主題已經預設 Disqus 留言板了，那麼只需要在config.toml 配置檔填入 Disqus 的 shortname。\n1  disqusShortname = \u0026#34;yourdiscussshortname\u0026#34;   如果沒有，就需要將官方提供的檔案加到你的網站中。\n在 layouts/partials/ 資料夾下，加入 disqus.html 檔案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026lt;div id=\u0026#34;disqus_thread\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; (function() { // Don\u0026#39;t ever inject Disqus on localhost--it creates unwanted  // discussions from \u0026#39;localhost:1313\u0026#39; on your Disqus account...  if (window.location.hostname == \u0026#34;localhost\u0026#34;) return; var dsq = document.createElement(\u0026#39;script\u0026#39;); dsq.type = \u0026#39;text/javascript\u0026#39;; dsq.async = true; var disqus_shortname = \u0026#39;{{ .Site.DisqusShortname }}\u0026#39;; dsq.src = \u0026#39;//\u0026#39; + disqus_shortname + \u0026#39;.disqus.com/embed.js\u0026#39;; (document.getElementsByTagName(\u0026#39;head\u0026#39;)[0] || document.getElementsByTagName(\u0026#39;body\u0026#39;)[0]).appendChild(dsq); })(); \u0026lt;/script\u0026gt; \u0026lt;noscript\u0026gt;Please enable JavaScript to view the \u0026lt;a href=\u0026#34;https://disqus.com/?ref_noscript\u0026#34;\u0026gt;comments powered by Disqus.\u0026lt;/a\u0026gt;\u0026lt;/noscript\u0026gt; \u0026lt;a href=\u0026#34;https://disqus.com/\u0026#34; class=\u0026#34;dsq-brlink\u0026#34;\u0026gt;comments powered by \u0026lt;span class=\u0026#34;logo-disqus\u0026#34;\u0026gt;Disqus\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;   如果要在本地端測試 Disqus，可以將 if (window.location.hostname == \u0026quot;localhost\u0026quot;) return; 註解掉。\n最後開啟你主題內的 layouts/_default/ 資料夾中的 single.html 在適當位置貼上下面這段：\n1  {{ partial \u0026#34;disqus.html\u0026#34; . }}   這樣就完成了。\nGoogle Analytics 1. 建立帳戶 前往 Google Analytics，可以使用 Google 帳號，直接註冊。\n建立帳戶取得 Tracking ID。\n2. Hugo 設定 在 config.toml 加入 Tracking ID：\ngoogleAnalytics = \u0026quot;UA-XXXXX-Y\u0026quot; 在主題內的 layouts/partials/ 資料夾中的 head.html 在適當位置貼上下面這段：\n1  {{ template \u0026#34;_internal/google_analytics_async.html\u0026#34; . }}   容易遇到的問題 1. Markdown 圖片路徑 在 Markdown 圖片路徑中，是以 static/ 為根目錄寫全路徑。\n圖片位置：/static/imgae/cover/post1.png，那麼在 Markdown 中寫作：\n1  ![圖片說明](/imgae/cover/post1.png)   總結 目前就先記錄到這，之後如果有用到 Hugo 其他功能再補上。\n文章部分，之後會慢慢把 Blogger 的舊文搬過來，還有 Hackmd 的筆記整理後丟過來 🙂\n","description":"這週是 六角鼠年鐵人賽 第七週，Hugo 建立 Blog。","id":105,"section":"posts","tags":["Hugo","w3HexSchool"],"title":"Hugo 建立 Blog","uri":"https://chupai.github.io/posts/200316_hugo/"},{"content":"這週是 六角鼠年鐵人賽 第六週，上週剛好接觸到 Lodash，就簡單紀錄一下。\n\r簡介 你很可能需要經常重複寫一些工具函式，尤其是處理字串與陣列或是物件。為了使開發專案更有效率且好維護，Lodash 可能是你好選擇。\nLodash 是一個一致性、模組化、高性能的 JavaScript 實用工具函式庫，包含對字串、陣列、物件等常見型別的處理函式。\n其中部分是目前 ECMAScript 尚未制訂的規範，但同時被業界所認可的輔助函式。\n Lodash Lodash 中文網  目前在寫這篇文章時，Lodash 在 github 上星數高達 43.8k，版本為 4.17.15。\n另外，在 npm 中依賴 Lodash 的 package 非常多：packages depending on lodash。\nAPI Lodash 提供了非常多的工具方法，包含\n Array：適用於 陣列，例如分割、合併、刪除、查詢、重組等操作。 Collection：適用於 陣列 和 物件，部分可用於字串，例如遍歷、分組、查詢、過濾等操作。 Date：只有一個 now 方法。 Function：函式的操作。 Lang：各種型別的轉換、判斷或是深拷貝。 Math：基本的數學運算，例如數值的四捨五入、數組的最大、最小值等等。 Number：取得隨機數、判斷數值區間、求中間值。 Object：適用於 物件，例如物件的創建、擴展、轉換、搜索、集合等操作。 Seq：常用於創建鏈式呼叫，提高執行性能（惰性計算）。 String：適用於 字串 操作。 Util：實用工具函式。  1. 為什麼不用 ES6 語法就好？ Lodash 有很多方法 ES6 已經封裝好了，而且部分方法也可以使用 ES6 語法替換。加上 ES6 越來越多主流瀏覽器支持，另外還可以使用 Babel 將 ES6 編譯成 ES5。那麼我們還需要使用 Lodash 嗎？\n可以參考以下兩篇文章：\n 在 ES6 大行其道的今天，還有必要使用 lodash 之類的庫嗎？ 為什麼不用 ES6 完全替換 Lodash  2. 惰性求值 Lodash 另一個優勢就是其優異的計算性能。很大部分就來源於其使用的算法「惰性求值」。\n關於 惰性求值 可以參考以下文章：\n 惰性求值——lodash源碼解讀  3. SameValueZero 相等比 部分方法使用 SameValueZero 相等比，關於 SameValueZero 可以看這篇文章： ECMAScript 6相等演算 。\n安裝 1. 瀏覽器 下載檔案，直接引入：\n1  \u0026lt;script src=\u0026#34;lodash.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   或是使用 CDN。\n2. 在專案中使用 lodash 透過 npm 安裝：\nnpm i --save lodash 接著在你的程式碼中 import 即可：\n1  import _ from \u0026#39;lodash\u0026#39;;   但這樣做會將整包 Lodash 打包進去。如果只使用 Lodash 其中一兩個方法，會造成了不必要的資源浪費。\n解決辦法有三種：\n 單獨引入：lodash 每個函式都具有單獨的模組，可以只引入需要的模組。  1 2 3 4 5  import _map from \u0026#39;lodash.map\u0026#39;; import _random from \u0026#39;lodash.random\u0026#39;; // or import _map from \u0026#39;lodash/map\u0026#39;; import _random from \u0026#39;lodash/random\u0026#39;;    使用套件優化：  lodash-webpack-plugin babel-plugin-lodash   使用 lodash-es：  1  import { mapm , random } from \u0026#39;lodash-es\u0026#39;;   不過，是否需要對 Lodash 優化，可以參考這篇文章：lodash 在 webpack 中的各項優化的嘗試。\n2. Vue Cli Vue 除了上述方式，還可以使用 vue-lodash 套件：\n1 2 3 4 5  // main.js import Vue from \u0026#39;vue\u0026#39;; import VueLodash from \u0026#39;vue-lodash\u0026#39;; import lodash from \u0026#39;lodash\u0026#39;; Vue.use(VueLodash, { name: \u0026#39;custom\u0026#39;, lodash: lodash });   1 2 3 4 5 6 7 8 9 10 11 12 13  export default { methods: { test() { console.log( this.lodash.random(20) ); console.log( this._.random(20) ); console.log( this.custom.random(20) ); }, } }; console.log( Vue.lodash.random(20) ); console.log( Vue._.random(20) ); console.log( Vue.custom.random(20) );   常用方法 由於 Lodash 中 API 太多了，這裡只會列幾個會常用到的方法並簡單說明。更詳細的用法、參數可以看官方 API 文件。\n1. Array _.union() 將陣列合併，並去除重複的元素（SameValueZero 相等比較），會回傳一個新陣列。\n1  _.union([arrays])    [arrays] (...Array): 陣列組 回傳值：回傳新的陣列  1 2 3 4 5  let arr1 = [1, 2, 3, 4]; let arr2 = [2, 4, 6, 8]; let arr3 = [3, 5, 7, 9]; console.log( _.union(arr1, arr2, arr3) );   如果元素是物件，可使用 _.unionBy，另外還有 _.unionWith() 可以呼叫一個比較函式。\n_.intersection() 取得陣列組的交集元素（使用 SameValueZero 相等比較）。\n1  _.intersection([arrays])    [arrays] (...Array)：陣列組 回傳值：交集元素陣列  1 2 3 4 5 6 7  let arr1 = [0, 1, 2, 3, 4]; let arr2 = [0, 2, 4, 6, 8]; let arr3 = [0, 2, 3, 5, 7, 9]; console.log( _.intersection(arr1, arr2, arr3) ); // [0, 2]   如果元素是物件，可使用 _.intersectionBy()，另外還有 _.intersectionWith() 可以呼叫一個比較函式。\n_.difference() 檢查一個陣列，並將指定的值排除（SameValueZero 相等比較），會回傳一個新陣列。\n與 _.difference() 類似的方法還有 _.without() 與 _.pull()。\n1  _.difference(array, [values])    array (Array)：需要被檢查的陣列 [values] (...Array)：需要排除的值（放在陣列中） 回傳值：回傳新的陣列  1 2 3  let arr = [0, 1, 2, 3, 4]; console.log( _.difference(arr, [2, 4, 6, 8]) ); // [0, 1, 3]   如果元素是物件，可使用 _.differenceBy()，另外還有 _.differenceWith() 可以呼叫一個比較函式。\n_.uniq() 陣列重組，去除重複的元素（SameValueZero 相等比較），會回傳一個新陣列。\n1  _.uniq(array)    array (Array): 要檢查的陣列 回傳值：回傳新的陣列  1 2  console.log( _.uniq([1, 2, 2, 4, 1, 5]) ); // [1, 2, 4, 5]   如果元素是物件，可使用 _.uniqBy()，另外還有 _.uniqWith() 可以呼叫一個比較函式。\n_.indexOf() 搜尋陣列是否有值為 value 的元素（使用 SameValueZero 等值比較），並回傳第一個符合的索引值。\n1  _.indexOf(array, value, [fromIndex=0])    array (Array)：要查詢的陣列 value (*)：條件值 [fromIndex=0] (number)：初始位置  預設值為 0 也就是開頭 如果 fromIndex 為負值，則從陣列結尾數過來   回傳值：匹配值的索引值，否則回傳 -1  1 2 3 4 5  let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; console.log( _.indexOf(arr, \u0026#39;b\u0026#39;) ); // 1 console.log( _.indexOf(arr, \u0026#39;b\u0026#39;, -1) ); // -1 console.log( _.indexOf(arr, \u0026#39;b\u0026#39;, -2) ); // 4   _.lastIndexOf() 這個方法類似 indexOf ，區別是它是從右到左遍歷陣列的元素，預設起始位置為結尾。\n1  _.lastIndexOf(array, value, [fromIndex=array.length-1])    array (Array)：要查詢的陣列 value (*)：條件值 [fromIndex=array.length-1](number)：初始位置  預設值為 array.length-1 也就是結尾 如果 fromIndex 為負值，則從陣列結尾數過來   回傳值：匹配值的索引值，否則回傳 -1  1 2 3 4 5 6  let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; console.log( _.lastIndexOf(arr, \u0026#39;b\u0026#39;) ); // 4 console.log( _.lastIndexOf(arr, \u0026#39;b\u0026#39;, 0) ); // -1 console.log( _.lastIndexOf(arr, \u0026#39;b\u0026#39;, 2) ); // 1 console.log( _.lastIndexOf(arr, \u0026#39;b\u0026#39;, -2) ); // 4   2. Collection Collection（集合）的方法 陣列 或 物件 都可以使用，部分方法字串也可以。\n其中 map 及 filter 方法最常使用，因為原生 JavaScrtip 中是不支援物件的，因此當需要迭代物件時，會使用 for in 或 Object.keys。\n_.map() 迭代的集合的方法，回傳一個新陣列。\n1  _.map(collection, [iteratee=_.identity])    collection (Array|Object)：用來迭代的集合。 [iteratee=_.identity] (Array|Function|Object|string)：每次迭代呼叫的函式。  參數：(value, index|key, collection)   回傳值：新陣列  Lodash 中有許多方法是防止作為其他方法的迭代函式（註：即不能作為 iteratee 參數傳遞給其他方法），例如： _.every、 _.filter、 _.map、 _.mapValues、 _.reject 和 _.some。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  console.log( _.map([4, 8], (n) =\u0026gt; n * n) ); // [16, 64]  const square = (n) =\u0026gt; n * n; let arr = [2, 4]; let obj = { a: 2, b: 4 }; console.log( _.map(arr, square) ); // [4, 16]  console.log( _.map(obj, square) ); // [4, 16]  let users = [{ user: \u0026#39;barney\u0026#39; }, { user: \u0026#39;fred\u0026#39; }]; console.log( _.map(users, \u0026#39;user\u0026#39;) ); // [\u0026#39;barney\u0026#39;, \u0026#39;fred\u0026#39;]   另外可以參考這篇文章：map () 誰比較快和輕量？ Lodash vs ES6。\n_.filter() 根據條件過濾出符合條件的元素。\n1  _.filter(collection, [predicate=_.identity])    collection (Array|Object)：一個用來迭代的集合。 [predicate=_.identity] (Array|Function|Object|string)：每次迭代呼叫的函式。 回傳值：回傳新的陣列  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  let users = [ { user: \u0026#39;barney\u0026#39;, age: 36, active: true }, { user: \u0026#39;fred\u0026#39;, age: 40, active: false }, ]; _.filter(users, function(o) { return !o.active; }); // =\u0026gt; objects for [\u0026#39;fred\u0026#39;]  // The `_.matches` iteratee shorthand. _.filter(users, { age: 36, active: true }); // =\u0026gt; objects for [\u0026#39;barney\u0026#39;]  // The `_.matchesProperty` iteratee shorthand. _.filter(users, [\u0026#39;active\u0026#39;, false]); // =\u0026gt; objects for [\u0026#39;fred\u0026#39;]  // The `_.property` iteratee shorthand. _.filter(users, \u0026#39;active\u0026#39;); // =\u0026gt; objects for [\u0026#39;barney\u0026#39;]   _.includes() 檢查 value 是否在 collection中。\n1  _.includes(collection, value, [fromIndex=0])   collection (Array|Object|string)：要檢索的集合。\nvalue (*)：要檢索的值。\n[fromIndex=0] (number)：要檢索的索引位置。\n 回傳值：布林值  如果 collection 是一串，value 就是字元，否則使用 SameValueZero 做等值比較。\n1 2 3 4 5 6 7 8 9 10 11  _.includes([1, 2, 3], 1); // =\u0026gt; true  _.includes([1, 2, 3], 1, 2); // =\u0026gt; false  _.includes({ user: \u0026#39;fred\u0026#39;, age: 40 }, \u0026#39;fred\u0026#39;); // =\u0026gt; true  _.includes(\u0026#39;pebbles\u0026#39;, \u0026#39;eb\u0026#39;); // =\u0026gt; true   _.shuffle() 將集合打亂（使用 Fisher-Yates shuffle 洗牌算法）。\n1  _.shuffle(collection)    collection (Array|Object)：要打亂的集合 回傳值：回傳隨機元素的陣列  1 2 3 4 5 6 7 8 9  let arr = [0, 1, 2, 3, 4]; console.log( _.shuffle(arr) ); // [ 3, 4, 1, 0, 2 ] console.log( _.shuffle(arr) ); // [ 3, 0, 2, 4, 1 ]  let obj = { a: 1, b: 2, c: 3 }; console.log( _.shuffle(obj) ); // [ 2, 3, 1 ] console.log( _.shuffle(obj) ); // [ 1, 3, 2 ]   _.sampleSize() 從集合中獲得 n 個隨機元素。\n1  _.sampleSize(collection, [n=1])    collection (Array|Object)：要取樣的集合 [n=1] (number)：取樣的元素個數。 回傳值：回傳隨機元素的陣列  1 2 3 4 5 6  let arr = [0, 1, 2, 3, 4]; console.log( _.sampleSize(arr, 1) ); // [2] console.log( _.sampleSize(arr, 1) ); // [0] console.log( _.sampleSize(arr, 2) ); // [2, 1] console.log( _.sampleSize(arr, 2) ); // [0, 4]   _.sortBy() 創建一個元素陣列。以 iteratee 處理的結果升序排序。這個方法執行穩定排序，也就是說相同元素會保持原始排序\n1  _.sortBy(collection, [iteratees=[_.identity]])    collection (Array|Object)：用來迭代的集合。 [iteratees=[_.identity]] (...* (Array|Array[]|Function|Function[]|Object|Object[]|string|string[]))：這個函式決定排序。 回傳值：排序後的陣列  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  let arr = [1, 65, 44, 2, 3, 55]; console.log( _.sortBy(arr) ); let users = [ { user: \u0026#39;fred\u0026#39;, age: 48 }, { user: \u0026#39;barney\u0026#39;, age: 36 }, { user: \u0026#39;fred\u0026#39;, age: 40 }, { user: \u0026#39;barney\u0026#39;, age: 34 }, ]; console.log(_.sortBy(users, (item) =\u0026gt; item.user)); // [ { user: \u0026#39;barney\u0026#39;, age: 36 }, // { user: \u0026#39;barney\u0026#39;, age: 34 }, // { user: \u0026#39;fred\u0026#39;, age: 48 }, // { user: \u0026#39;fred\u0026#39;, age: 40 } ]  console.log(_.sortBy(users, \u0026#39;age\u0026#39;)); // [ { user: \u0026#39;barney\u0026#39;, age: 34 }, // { user: \u0026#39;barney\u0026#39;, age: 36 }, // { user: \u0026#39;fred\u0026#39;, age: 40 }, // { user: \u0026#39;fred\u0026#39;, age: 48 } ]  console.log(_.sortBy(users, [\u0026#39;user\u0026#39;, \u0026#39;age\u0026#39;])); // [ { user: \u0026#39;barney\u0026#39;, age: 34 }, // { user: \u0026#39;barney\u0026#39;, age: 36 }, // { user: \u0026#39;fred\u0026#39;, age: 40 }, // { user: \u0026#39;fred\u0026#39;, age: 48 } ]   3. Object _.get() 根據物件的路徑取值，沒有則回傳 undefined，可以設定預設值。\n1  _.get(object, path, [defaultValue])    object (Object)：要檢索的物件。 path (Array|string)：要獲取屬性的路徑，可以是字串或陣列。 [defaultValue] (*)：預設值。 回傳值：解析的值  1 2 3 4 5 6 7  let obj = { id: \u0026#39;1234\u0026#39;, list: [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;] }; console.log( _.get(obj, \u0026#39;id\u0026#39;) ); // \u0026#39;1234\u0026#39; console.log( _.get(obj, \u0026#39;list[0]\u0026#39;) ); // \u0026#39;a\u0026#39; console.log( _.get(obj, [\u0026#39;list\u0026#39;, \u0026#39;3\u0026#39;]) ); // \u0026#39;d\u0026#39; console.log( _.get(obj, \u0026#39;name\u0026#39;); // undefined console.log( _.get(obj, \u0026#39;name\u0026#39;, \u0026#39;no-find\u0026#39;) ); // \u0026#39;no-find\u0026#39;   _.pick() 創建一個從 object 中選中的屬性的物件。\n1  _.pick(object, [props])    object (Object)：來源物件。 [props] (...(string|string[]))：選中的屬性。（註：單獨指定或指定在陣列中。） 回傳值：回傳新物件  1 2 3  let object = { a: 1, b: \u0026#39;2\u0026#39;, c: 3 }; console.log( _.pick(object, [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;]) ); // { a:1, c:3 }   _.omit 為反向版的 _.pick。\n_.pickBy() 創建一個物件，這個物件組成為從 object 中經 predicate 判斷為真值的屬性。\n1  _.pickBy(object, [predicate=_.identity])    object (Object)：來源物件。 [predicate=_.identity] (Function)：呼叫每一個屬性的函式。  有 2個參數：(value, key)。   回傳值：回傳新物件  1 2 3 4  let obj = { a: 1, b: \u0026#39;2\u0026#39;, c: 3 }; console.log( _.pickBy(obj, _.isNumber) ); // { \u0026#39;a\u0026#39;: 1, \u0026#39;c\u0026#39;: 3 }   _.omitBy 為反向版的 _.pickBy。\n_.defaults() 安全的合併物件，遇到重複的屬性則忽略。\n1  _.defaults(object, [sources])    object (Object)：目標物件。 [sources] (...Object)：來源物件。 回傳值：這方法會改變目標物件，回傳目標物件  1 2 3 4 5 6 7 8  let obj1 = { foo: 1, boo: 2 }; let obj2 = { foo: 3, zoo: 4 }; let r = _.defaults(obj1, obj2); console.log(r); // { foo: 1, boo: 2, zoo: 4 } console.log(obj1); // { foo: 1, boo: 2, zoo: 4 } console.log(obj1 === r); // true   4. Lang _.cloneDeep() 資料的深拷貝。\n1  _.cloneDeep(value)    value (*)：要拷貝的資料。 回傳值：回傳拷貝的資料。  1 2 3 4  let obj = { a: { b: 1 } }; let newObj = _.cloneDeep(obj); console.log( obj.a === newObj.a ); // false   另外，可以參考以下文章：\n lodash源碼分析——deepclone，基於4.17.10版本\n Lodash 是如何實現深拷貝的  _.isEqual() 執行深比較來確定兩者的值是否相等。\n1  _.isEqual(value, other)    value (*)：用來比較的值。 other (*)：另一個用來比較的值。 回傳值：布林值  如果是物件，則比較自身的屬性，不包括繼承的和可列舉的屬性。不支持函式和DOM 節點比較。\n1 2 3 4 5 6 7  let object = { a: 1 }; let other = { a: 1 }; console.log(object === other); // false console.log(_.isEqual(object, other)); // true   5. Number _.clamp() 設定數值上下限，超出範圍，回傳上限或下限，否則回傳數值本身。\n1  _.clamp(number, [lower], upper)    number (number)：被限制的值。 [lower] (number)：可選，下限值。 upper (number)：上限值。 回傳值：  number 大於 upper 回傳 lower number 小於 lower 回傳 lower 在 upper 之間 lower 回傳 number 本身    1 2 3 4 5 6  console.log( _.clamp(5, 10) ); // 5 console.log( _.clamp(11, 10) ); // 10  console.log( _.clamp(11, -10, 10) ); // 10 console.log( _.clamp(-11, -10, 10) ); // -10 console.log( _.clamp(0, -10, 10) ); // 0   _.random() 隨機產生一個包括 lower 與 upper 之間的數，如果只設置一個參數則回傳 0 到該數之間的數值。\n1  _.random([lower=0], [upper=1], [floating])    [lower=0] (number)：下限。 [upper=1] (number)：上限。 [floating] (boolean)：指定是否回傳浮點數。  lower 與 upper 非浮點數預設為 false    1 2 3 4 5 6 7 8 9 10  _.random(5); // between 0 and 5 _.random(-5); // between -5 and 0 _.random(5, 10); // between 5 and 10 _.random(5, true); // a floating-point number between 0 and 5 _.random(1.2, 5.2); // a floating-point number between 1.2 and 5.2   _.inRange() 檢查 number 是否在 start 與 end 之間（但不包括 end）。\n1  _.inRange(number, [start=0], end)    number (number)：要檢查的值。 [start=0] (number)：開始範圍。  可選，沒設置預設值為 0。   end (number)：結束範圍。  如果第二個參數大於第三個參數，大的為 end。    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  _.inRange(3, 2, 4); // 3 是否在 2~3 之間 =\u0026gt; true _.inRange(4, 8); // 4 是否在 0~7 之間 =\u0026gt; true _.inRange(4, 2); // 4 是否在 0~1 之間 =\u0026gt; false _.inRange(2, 2); // 2 是否在 0~1 之間 =\u0026gt; false _.inRange(1.2, 2); // 1.2 是否在 0~1 之間 =\u0026gt; true _.inRange(3.2, 4); // 3.2 是否在 0~3 之間 =\u0026gt; false _.inRange(0, 4, 0); // 0 是否在 0~3 之間 =\u0026gt; true _.inRange(-3, -2, -6); // -3 是否在 -6~-2 之間 =\u0026gt; true   6. Util _.range() 建立一個指定範圍的數值陣列。\n1  _.range([start=0], end, [step=1])    [start=0] (number：開始的範圍。 end (number)：結束的範圍（不包括自己）。 [step=1] (number)：範圍的增量 或者 減量。  只有一個參數 _.range(n) 等同 _.range(0, n, 1)，如果是負數 _.range(-n) 等同 _.range(0, n, -1)。\nend 小於 start 而且 step 非負數，會創建一個空陣列。\n1 2 3 4 5 6  console.log( _.range(4) ); // [0, 1, 2, 3, 4] console.log( _.range(-4) ); // [0, -1, -2, -3] console.log( _.range(1, 4) ); // [1, 2, 3] console.log( _.range(0, 10, 5) ); // [0, 5, 10] console.log( _.range(0, -4, -1) ); // [0, -1, -2, -3] console.log( _.range(1, 4, 0) ); // [1, 1, 1]   _.times() 呼叫 iteratee 函式 n 次，並將結果存到陣列中，並回傳該陣列。\n1  _.times(n, [iteratee=_.identity])    n (number)：呼叫 iteratee 的次數。 [iteratee=_.identity] (Function)：每次迭代呼叫的函式，參數為 index。  1 2 3 4  console.log(_.times(3, String)); // [\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;] console.log(_.times(3, (index) =\u0026gt; index * index)); // [0, 1, 4]   _.uniqueId() 生成唯一 ID，可以添加前綴。\n1  _.uniqueId([prefix=\u0026#39;\u0026#39;])    [prefix=''] (string)：要添加到 ID 前綴的值。 回傳值：回傳生成的唯一 ID 字串。  1 2 3  console.log( _.uniqueId() ); // \u0026#39;1\u0026#39; console.log( _.uniqueId() ); // \u0026#39;2\u0026#39; console.log( _.uniqueId(\u0026#39;book\u0026#39;) ); // \u0026#39;book3\u0026#39;   7. Math _.sum() 陣列的總和。\n1  _.sum(array)   1 2  _.sum([4, 2, 8, 6]); // =\u0026gt; 20   如果元素是物件，可以使用 _.sumBy()。\n總結 這週先記錄到這邊，有空慢慢補上，下週見。\n","description":"這週是 六角鼠年鐵人賽 第六週，上週剛好接觸到 Lodash，就簡單紀錄一下。","id":106,"section":"posts","tags":["Lodash","w3HexSchool"],"title":"Lodash - JS 實用工具函式庫","uri":"https://chupai.github.io/posts/200315_lodash/"},{"content":"這週是 六角鼠年鐵人賽 第五週，紀錄一下 Vue Transition 用法。\n前言 在日常開發中，網頁動態效果是必不可少的一部分，不僅能讓元素直接的切換顯得更加自然，同時也能極大的增強用戶體驗。\n雖然我們可以使用原生 CSS 或 JS 來實現動態效果，但 Vue 提供了更簡單和高效的方式。\n1. Vue 的轉場工具 Vue 在插入、更新或者移除 DOM 時，提供多種不同方式的應用轉場效果。包括以下工具：\n 在 CSS transition 和 animation 中自動應用 class 名稱； 也可以配合使用第三方 CSS 動畫庫，例如 Animate.css。 在轉場鉤子函式中使用 JavaScript 直接操作 DOM； 也可以配合使用第三方 JavaScript 動畫庫，例如 Velocity.js。  transition 元件 Vue 提供了 transition 的封裝元件，在下列情形中，可以給任何元素和元件添加進入/離開的轉場效果：\n 元素或元件初始渲染時 元素或元件顯示/隱藏時（使用 v-if 或 v-show） 元素或元件切換時  先看一個簡單的基本範例：\n1 2 3 4  \u0026lt;button v-on:click=\u0026#34;show = !show\u0026#34;\u0026gt;Toggle\u0026lt;/button\u0026gt; \u0026lt;transition\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   1 2 3  data: { show: true, },   1 2 3 4 5 6 7 8 9 10 11  .v-enter, .v-leave-to { opacity: 0; } .v-leave, .v-enter-to { opacity: 1; } .v-enter-active, .v-leave-active { transition: opacity 1s; }   當我們使用 transition 元件將元素包住，Vue 會做以下處理：\n 自動偵測目標元素是否應用 CSS transition/animation 如果是，在恰當的時機添加/刪除 CSS 類別名稱。 如果 transition 元件提供了 JavaScript 鉤子函式，這些鉤子函式將在恰當的時機被呼叫。 如果沒有找到 JavaScript 鉤子並且也沒有檢測到 CSS transition/animation，DOM 操作 (插入/刪除) 在下一幀中立即執行。  See the Pen Vue CSS 轉場 基本範例 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  1. CSS 轉場的類別名稱 transition 元件共提供了，六種類別名稱提供切換。\n進場：\n v-enter：定義進場的開始狀態。  在元素被插入之前生效，插入之後的下一幀被移除   v-enter-active：定義進場生效時的狀態，在整個進場的階段中應用。  在元素被插入之前生效，在 transition/animation 完成之後移除 可用來定義進場的過程時間，延遲和曲線函數   v-enter-to：2.1.8版及以上 定義進場的結束狀態。  在元素被插入之後下一幀生效（與此同時 v-enter 被移除），在 transition/animation 完成之後移除    離場：\n v-leave：定義離場的開始狀態。  在離場被觸發時立刻生效，下一幀被移除   v-leave-active：定義離場生效時的狀態，在整個離場的階段中應用。  在離場被觸發時立刻生效，在 transition/animation 完成之後移除 這個類可以被用來定義離場的過程時間，延遲和曲線函數   v-leave-to：2.1.8版及以上 定義離場的結束狀態。  在離開轉場被觸發之後下一幀生效（與此同時 v-leave 被移除），在 transition/animation 完成之後移除    通常會設定 v-enter 與 v-leave-active 相同的效果、v-leave 與 v-enter-to 相同的效果，達到同尾相接形成一個循環，而 v-enter-to 與 v-leave-to 會用來設定轉場時間或動畫。\nenter-to 預設 opacity: 1、transform: none，所以不一定要設定。\r1.1 CSS transition transition 元件預設使用上述 v- 前綴的類別名稱。請參考一開始基本範例。\n因為不可能只用一種動態效果，因此使用自訂義的前綴，需要加上 name 特性，舉例來說，\u0026lt;transition name=\u0026quot;fade\u0026quot;\u0026gt;，套用的那麼類別名稱的前綴就會是 fade-enter。\n1 2 3 4 5 6  \u0026lt;button v-on:click=\u0026#34;show = !show\u0026#34;\u0026gt; Toggle \u0026lt;/button\u0026gt; \u0026lt;transition name=\u0026#34;fade\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   設定一個進場由透明度 0 變 1 並由右測 100px 處滑入，並且進場、離場分別設定不同的曲線函數：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  .fade-enter, .fade-leave-to { opacity: 0; transform: translateX(100px); } .fade-leave, .fade-enter-to { opacity: 1; } .fade-enter-active { transition: all 0.3s ease; } .fade-leave-active { transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1); }   See the Pen Vue CSS 轉場 轉場範例 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  再舉一個例子，由下往上進場，由右出場：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  .fade-enter { opacity: 0; transform: translateY(100%); } .fade-enter-to, .fade-leave { opacity: 1; } .fade-leave-to { opacity: 0; transform: translateX(100%); } .fade-enter-active,.fade-leave-active { transition: all 0.8s ease; }   See the Pen Vue CSS 轉場 轉場範例2 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  1.2 CSS animation CSS animation 用法同 CSS transition，區別是在動畫中 v-enter 類名在節點插入 DOM 後不會立即刪除，而是在 animationend 事件觸發時刪除。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  .bounce-enter-active { animation: bounce-in 0.5s; } .bounce-leave-active { animation: bounce-in 0.5s reverse; } @keyframes bounce-in { 0% { transform: scale(0); } 50% { transform: scale(1.5); } 100% { transform: scale(1); } }   See the Pen Vue CSS 轉場 動畫範例 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 使用自訂義類別名稱 我們可以通過以下 transition 元件特性來使用自訂義類別名稱：\n enter-class enter-active-class enter-to-class 2.1.8+ leave-class leave-active-class leave-to-class 2.1.8+  他們的優先級高於普通的類別名稱。\n舉個簡單得範例，來說明使用方式：\n1 2 3 4 5 6 7  .opacity-0 { opacity: 0; } .trs-time-3 { transition-duration: 3s; }   1 2 3 4 5 6 7 8  \u0026lt;transition enter-class=\u0026#34;opacity-0\u0026#34; leave-to-class=\u0026#34;opacity-0\u0026#34; enter-active-class=\u0026#34;trs-time-3\u0026#34; leave-active-class=\u0026#34;trs-time-3\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   See the Pen Vue CSS 轉場 自訂義 class by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2.1 第三方 CSS 動畫庫 自訂義類別名稱，對於套用第三方 CSS 動畫庫結合非常方便。\n舉例來說，使用 Animate.css 的動畫效果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;button v-on:click=\u0026#34;show = !show\u0026#34;\u0026gt; Toggle \u0026lt;/button\u0026gt; \u0026lt;transition enter-active-class=\u0026#34;animated tada\u0026#34; leave-active-class=\u0026#34;animated bounceOutRight\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;transition enter-active-class=\u0026#34;animated fadeInUp\u0026#34; leave-active-class=\u0026#34;animated flipInY\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   See the Pen Vue CSS 轉場 Animate.css by CHUPAIWANG (@CHUPAIWANG) on CodePen.  或者是 magic.css：\n1 2 3 4 5 6 7 8 9  \u0026lt;button v-on:click=\u0026#34;show = !show\u0026#34;\u0026gt; Toggle \u0026lt;/button\u0026gt; \u0026lt;transition enter-active-class=\u0026#34;magictime foolishIn\u0026#34; leave-active-class=\u0026#34;magictime tinDownOut\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   See the Pen Vue CSS 轉場 magic by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 轉場時間 3.1 同時使用 transition/animation Vue 為了知道轉場的完成，必須設置相應的事件監聽器。它可以是 transitionend 或 animationend，這取決於給元素應用的 CSS 規則。如果你使用其中任何一種，Vue 能自動識別類型並設置監聽。\n但有時候會遇到需要同時設置的情況，但兩邊的完成時間不一致，這時候就需要手動設置 transitionend 或 animationend 來明確告知 Vue 要監聽的類型。\n舉例來說，假設你分別使用自訂義的類別名稱和 Animate.css ：\n1 2 3 4 5 6 7 8 9 10 11  .fade-enter,.fade-leave-to { opacity: 0; } .fade-enter-to, .fade-leave { opacity: 1; } .fade-enter-active,.fade-leave-active { transition: opacity 3s; }   1 2 3 4 5 6 7 8  \u0026lt;transition name=\u0026#34;fade\u0026#34; type=\u0026#34;transition\u0026#34; enter-active-class=\u0026#34;animated swing fade-enter-active\u0026#34; leave-active-class=\u0026#34;animated bounce fade-leave-active\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   這裡要注意，使用自訂義類別名稱優先度大於普通的類別名稱，所以fade-enter-active 和 fade-leave-active 記得要補上。\nAnimate.css 預設動畫時間為 1s，而我們設置的 transition 時間為 3s，Animate.css 的動畫很外就觸發完成了，而轉場還沒結束。在很多情況下，Vue 可以自動得出轉場效果的完成時機，但還是有可能出現例外。\n為了避免出現例外，你就需要手動設定 type=\u0026quot;transition\u0026quot; 以 transition 的時間為準。反之動畫時間大於轉場就以動畫時間為準。\nSee the Pen Vue CSS 轉場 同时使用轉場和動畫 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3.2 顯性的轉場持續時間 上面已經提過了，在很多情況下，Vue 可以自動得出轉場效果的完成時機。預設情況下，Vue 會等待其在轉場效果的根元素的第一個 transitionend 或 animationend 事件。\n但在某些情況下，還可以自定義整個動態效果總時間長，使用的是 duration 特性搭配 v-bind。\n舉例來說，總時常為 5s：\n1  \u0026lt;transition :duration=\u0026#34;5000\u0026#34;\u0026gt;...\u0026lt;/transition\u0026gt;   也可以分別設定進入和移除持續時間：\n1  \u0026lt;transition :duration=\u0026#34;{ enter: 500, leave: 800 }\u0026#34;\u0026gt;...\u0026lt;/transition\u0026gt;   這是一個 transition 需要 5秒，但總轉場時間強制設為 1秒的範例：\nSee the Pen Vue CSS 轉場 顯性的轉場持續時間 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  4.初始渲染的轉場 透過設定 appear 特性，設置節點在初始渲染的轉場。\n1 2 3  \u0026lt;transition appear\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/transition\u0026gt;    CodePen，載入畫面時，會有進場效果。\n appear 預設使用進場的類別，如果要與進場套用不同的動畫效果，需要使用自定義的類別名稱：\n1 2 3  \u0026lt;transition appear\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/transition\u0026gt;    CodePen，載入畫面時，會有進場效果。\n appear 預設使用進場的類別，如果要與進場套用不同的動畫效果，需要使用自定義的類別名稱：\n1 2 3 4 5 6 7 8  \u0026lt;transition appear appear-class=\u0026#34;custom-appear-class\u0026#34; appear-to-class=\u0026#34;custom-appear-to-class\u0026#34; (2.1.8+) appear-active-class=\u0026#34;custom-appear-active-class\u0026#34; \u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/transition\u0026gt;   多個元素的轉場 \u0026lt;transition\u0026gt; 也可以用在多個元素的轉場。\n舉例來說：\n1 2 3 4 5 6  \u0026lt;transition\u0026gt; \u0026lt;table v-if=\u0026#34;items.length \u0026gt; 0\u0026#34;\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;p v-else\u0026gt;Sorry, no items found.\u0026lt;/p\u0026gt; \u0026lt;/transition\u0026gt;   但要注意，Vue 在切換畫面時，並不會完全置換元素，會使用一種最大限度減少動態元素並且儘可能的嘗試修復/再利用相同類型元素的算法。\n因此當有相同標籤的元素在做切換時，需要使用 key 特性設置唯一的值來標記以讓 Vue 區分它們。\n1 2 3 4 5 6 7 8  \u0026lt;transition\u0026gt; \u0026lt;button v-if=\u0026#34;isEditing\u0026#34; key=\u0026#34;save\u0026#34;\u0026gt; Save \u0026lt;/button\u0026gt; \u0026lt;button v-else key=\u0026#34;edit\u0026#34;\u0026gt; Edit \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   在一些場景中，也可以通過給同一個元素的 key 特性設置不同的狀態來代替 v-if 和 v-else，上面的範例可以重寫為：\n1 2 3 4 5  \u0026lt;transition\u0026gt; \u0026lt;button v-bind:key=\u0026#34;isEditing\u0026#34;\u0026gt; {{ isEditing ? \u0026#39;Save\u0026#39; : \u0026#39;Edit\u0026#39; }} \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   使用多個 v-if 的多個元素的轉場可以重寫為綁定了動態屬性的單個元素轉場。例如：\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;transition\u0026gt; \u0026lt;button v-if=\u0026#34;docState === \u0026#39;saved\u0026#39;\u0026#34; key=\u0026#34;saved\u0026#34;\u0026gt; Edit \u0026lt;/button\u0026gt; \u0026lt;button v-if=\u0026#34;docState === \u0026#39;edited\u0026#39;\u0026#34; key=\u0026#34;edited\u0026#34;\u0026gt; Save \u0026lt;/button\u0026gt; \u0026lt;button v-if=\u0026#34;docState === \u0026#39;editing\u0026#39;\u0026#34; key=\u0026#34;editing\u0026#34;\u0026gt; Cancel \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   可以重寫為：\n1 2 3 4 5 6  \u0026lt;!-- .html --\u0026gt; \u0026lt;transition\u0026gt; \u0026lt;button :key=\u0026#34;docState\u0026#34;\u0026gt; {{ buttonMessage }} \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   1 2 3 4 5 6 7 8 9 10  // ... computed: { buttonMessage: function () { switch (this.docState) { case \u0026#39;saved\u0026#39;: return \u0026#39;Edit\u0026#39; case \u0026#39;edited\u0026#39;: return \u0026#39;Save\u0026#39; case \u0026#39;editing\u0026#39;: return \u0026#39;Cancel\u0026#39; } } }   1. 轉場模式 請考慮以下程式碼：\n1 2 3 4 5  \u0026lt;transition\u0026gt; \u0026lt;button :key=\u0026#34;isEditing\u0026#34; @click=\u0026#34;isEditing = !isEditing\u0026#34;\u0026gt; {{ isEditing ? \u0026#39;On\u0026#39; : \u0026#39;Off\u0026#39; }} \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   See the Pen Vue CSS 轉場 轉場模式 問題 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  在 on 按鈕和 off 按鈕的轉場中，兩個按鈕都被重繪了，一個離開轉場的時候另一個開始進入轉場。這是 \u0026lt;transition\u0026gt; 的預設行為，進入和離開同時發生。\n你可能會想到，可以加上 position: absolute，因為兩者重疊了，所以不會產生元素位移的情況：\n1 2 3  button { position: absolute; }   See the Pen Vue CSS 轉場 轉場模式 絕對定位 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  但如果加上 translate 讓它們運動像滑動，還是會有兩個元素同時出現的破綻：\n1 2 3 4 5  .v-enter, .v-leave-to { opacity: 0; transform: translateX(100%); }   See the Pen Vue CSS 轉場 轉場模式 絕對定位 + 滑動 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  同時生效的進入和離開的轉場不能滿足所有要求，所以 Vue 提供了轉場模式：\n in-out：新元素先進行轉場，完成之後當前元素轉場離開。 out-in：當前元素先進行轉場，完成之後新元素轉場進入。  加上 mode=\u0026quot;out-in\u0026quot; 的效果：\n1 2 3 4 5  \u0026lt;transition mode=\u0026#34;out-in\u0026#34;\u0026gt; \u0026lt;button :key=\u0026#34;isEditing\u0026#34; @click=\u0026#34;isEditing = !isEditing\u0026#34;\u0026gt; {{ isEditing ? \u0026#39;On\u0026#39; : \u0026#39;Off\u0026#39; }} \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   1 2 3  .v-enter-active, .v-leave-active { transition: 1.5s opacity; }   See the Pen Vue CSS 轉場 轉場模式 out-in by CHUPAIWANG (@CHUPAIWANG) on CodePen.  in-out 模式的範例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  button { position: absolute; } .v-enter,.v-leave-to { opacity: 0; } .v-enter { transform: translateX(100%); } .v-leave-to { transform: translateX(-100%); }   See the Pen Vue CSS 轉場 轉場模式 in-out by CHUPAIWANG (@CHUPAIWANG) on CodePen.  多個元件的轉場 多個元件的轉場簡單很多，我們不需要使用 key 特性。只需要使用 動態切換 元件：\n1 2 3 4 5 6 7 8  \u0026lt;!-- .html --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; value=\u0026#34;v-a\u0026#34; v-model=\u0026#34;view\u0026#34; /\u0026gt;A \u0026lt;input type=\u0026#34;radio\u0026#34; value=\u0026#34;v-b\u0026#34; v-model=\u0026#34;view\u0026#34; /\u0026gt;B \u0026lt;transition name=\u0026#34;component-fade\u0026#34; mode=\u0026#34;out-in\u0026#34;\u0026gt; \u0026lt;component v-bind:is=\u0026#34;view\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10  .component-fade-enter, .component-fade-leave-to { opacity: 0; } .component-fade-enter-active, .component-fade-leave-active { transition: opacity 0.3s ease; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14  const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { view: \u0026#39;v-a\u0026#39;, }, components: { \u0026#39;v-a\u0026#39;: { template: \u0026#39;\u0026lt;div\u0026gt;Component A\u0026lt;/div\u0026gt;\u0026#39;, }, \u0026#39;v-b\u0026#39;: { template: \u0026#39;\u0026lt;div\u0026gt;Component B\u0026lt;/div\u0026gt;\u0026#39;, }, }, });   transition-group 元件 1. 大量元素的轉場 目前為止，都是針對單個節點，或是同一時間渲染多個節點中的一個。如果要針對由 v-for 產生的大量元素（例如：列表），就要改為使用 transition-group 元件。\ntransition-group 元件有以下幾個特點：\n 不同於 \u0026lt;transition\u0026gt;，它會以一個真實元素呈現：預設為一個 \u0026lt;span\u0026gt;。可以通過 tag 特性更換為其他元素。 轉場模式（in-out 與 out-in）不可用，因為我們不再相互切換特有的元素。 內部元素 總是需要 提供唯一的 key 屬性值。 CSS 轉場的類將會應用在內部的元素中，而不是這個組/容器本身。  1.1 進入/離開的轉場 首先我們看一段程式碼：\n1 2 3 4 5 6 7  \u0026lt;button v-on:click=\u0026#34;add\u0026#34;\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;button v-on:click=\u0026#34;remove\u0026#34;\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item\u0026#34; class=\u0026#34;list-item\u0026#34;\u0026gt; {{ item }} \u0026lt;/ul\u0026gt;   按下 Add 會隨機插入數字，按下 Remove 會隨機移除數字。\nSee the Pen Vue 大量元素的轉場  by CHUPAIWANG (@CHUPAIWANG) on CodePen.  接下來我們改用 transition-group 元件，增加轉場效果。\ntransition-group 元件預設會有一個 \u0026lt;span\u0026gt; 的根元素，它會包住由 v-for 產生的多個元素當成其子元素。\n我們透過 tag 特性，將其改成 \u0026lt;ul\u0026gt;：\n1 2 3 4 5  \u0026lt;transition-group name=\u0026#34;list\u0026#34; tag=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;item in items\u0026#34; v-bind:key=\u0026#34;item\u0026#34; class=\u0026#34;list-item\u0026#34;\u0026gt; {{ item }} \u0026lt;/li\u0026gt; \u0026lt;/transition-group\u0026gt;   並加上 CSS：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  .list-enter, .list-leave-to { opacity: 0; transform: translateY(100%); } .list-leave, .list-enter-to { opacity: 1; } .list-enter-active, .list-leave-active { transition: all 1s; }   See the Pen Vue 大量元素的轉場 - transition-group by CHUPAIWANG (@CHUPAIWANG) on CodePen.  不過這個範例有一個明顯問題，當新增和移除元素的時候，周圍的元素會瞬間移動到他們的新佈局的位置，這會顯得不自然，我們將會在之後解決這個問題。\n1.2 排序轉場 transition-group 元件還有一個特殊之處。不僅可以進入和離開動畫，還可以改變定位。\nv-move 特性，它會在元素的改變定位的過程中應用。像之前的列別名稱一樣，可以通過 name 屬性來自定義前綴，也可以通過 move-class 屬性手動設置。\nv-move 對於設置轉場的切換時機和轉場曲線非常有用。\n1 2 3 4 5 6 7 8 9  \u0026lt;button v-on:click=\u0026#34;items.reverse()\u0026#34;\u0026gt;Reverses\u0026lt;/button\u0026gt; \u0026lt;transition-group name=\u0026#34;flip-list\u0026#34; tag=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item\u0026#34; class=\u0026#34;list-item\u0026#34;\u0026gt;{{ item }} \u0026lt;/li\u0026gt; \u0026lt;/transition-group\u0026gt;   1 2 3  .flip-list-move { transition: transform 1s; }   1 2 3 4 5 6  const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { items: [1, 2, 3, 4, 5, 6, 7, 8, 9], }, });   See the Pen Vue 大量元素的轉場 - v-move by CHUPAIWANG (@CHUPAIWANG) on CodePen.  Vue 使用了一個叫 FLIP 簡單的動畫隊列。使用 transforms 將元素從之前的位置平滑轉場新的位置。\n讓我們修正上節不自然的的程式碼：\n1 2 3 4 5 6 7  .list-leave-active { position: absolute; } .list-move { transition: 1s; }   See the Pen Vue 大量元素的轉場 - 進入/離開的轉場 v-move by CHUPAIWANG (@CHUPAIWANG) on CodePen.  另外要注意，FLIP 轉場的元素不能設置為 display: inline。作為替代方案，可以設置為 display: inline-block、display: flex-block 或者放置於 FlexBox 父容器中\rSee the Pen Vue 大量元素的轉場 - 打亂 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  JavaScript 鉤子 transition/animation 的核心概念，就是在對應的時間點新增、移除類別。除了這種在被動的時間點加上類別的方式外，Vue 也提供對應時間的 JavaScript 鉤子讓我們在該時間點使用 JavaScript。\n事件鉤子：\n before-enter：進場前啟動。 enter：進場時啟動。 after-enter：進場結束後啟動。 enter-cancelled：在未完成進場時取消動作。 before-leave：離場前啟動。 leave：離場時啟動。 after-leave：離場結束後啟動。 leave-cancelled：在未完成離場時取消動作。（只用於 v-show 中）  1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;transition v-on:before-enter=\u0026#34;beforeEnter\u0026#34; v-on:enter=\u0026#34;enter\u0026#34; v-on:after-enter=\u0026#34;afterEnter\u0026#34; v-on:enter-cancelled=\u0026#34;enterCancelled\u0026#34; v-on:before-leave=\u0026#34;beforeLeave\u0026#34; v-on:leave=\u0026#34;leave\u0026#34; v-on:after-leave=\u0026#34;afterLeave\u0026#34; v-on:leave-cancelled=\u0026#34;leaveCancelled\u0026#34; \u0026gt; \u0026lt;/transition\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  methods: { beforeEnter: function(el) {}, enter: function(el, done) { done(); }, afterEnter: function(el) {}, enterCancelled: function(el) {}, beforeLeave: function(el) {}, leave: function(el, done) { done(); }, afterLeave: function(el) {}, leaveCancelled: function(el) {}, }    如果只要單獨使用 JS 鉤子轉場，可以設置 v-bind:css=\u0026quot;false\u0026quot;，Vue 會跳過 CSS 的檢測，避免轉場過程受到 CSS 的影響。 enter 和 leave 的回呼函式 done 是可選的：  參數不注入 done 時，預設為同步呼叫，會自動呼叫 done()。 如果有 done 參數，就需要手動呼叫 done()，沒呼叫就不會進入　after-enter／after-leave。 如果想要搭配 CSS 同步自動 call done 的話，就不要帶 done 參數 只使用 JavaScript 鉤子的時候，要記得呼叫 done()。    初始渲染也有事件鉤子：\n before-appear：載入前。 appear：載入時。 after-appear：載入後。 appear-cancelled：載入開始後，執行取消載入。  路由轉場 \u0026lt;router-view\u0026gt; 一樣可以使用 \u0026lt;transition\u0026gt; 元件：\n1 2 3  \u0026lt;transition\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/transition\u0026gt;   1. 單個路由的轉場 如果要讓每個路由元件有各自的轉場效果，可以在元件內使用 \u0026lt;transition\u0026gt; 元件並設置不同的 name。\n1 2 3 4 5 6  \u0026lt;!-- Views1.vue --\u0026gt; \u0026lt;template \u0026gt; \u0026lt;transition name=\u0026#34;slide\u0026#34;\u0026gt; ... \u0026lt;/transition\u0026gt; \u0026lt;/template\u0026gt;   1 2 3 4 5 6  \u0026lt;!-- Views2.vue --\u0026gt; \u0026lt;template \u0026gt; \u0026lt;transition name=\u0026#34;fade\u0026#34;\u0026gt; ... \u0026lt;/transition\u0026gt; \u0026lt;/template\u0026gt;   2. 動態轉場 1 2 3  \u0026lt;transition :name=\u0026#34;transitionName\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/transition\u0026gt;   在接著在父元件內，監聽 $route 決定使用哪種轉場效果：\n1 2 3 4 5 6 7  watch: { \u0026#39;$route\u0026#39; (to, from) { const toDepth = to.path.split(\u0026#39;/\u0026#39;).length const fromDepth = from.path.split(\u0026#39;/\u0026#39;).length this.transitionName = toDepth \u0026lt; fromDepth ? \u0026#39;slide-right\u0026#39; : \u0026#39;slide-left\u0026#39; } }   3. Vueg  Vueg\n為 vue-router 添加轉場效果的開源 Vue 套件。\n 交錯轉場 這裡有一段程式碼：\n1 2 3 4 5 6  \u0026lt;button @click=\u0026#34;show = !show\u0026#34;\u0026gt;show\u0026lt;/button\u0026gt; \u0026lt;ul v-if=\u0026#34;show\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;n in num\u0026#34; :key=\u0026#34;n\u0026#34;\u0026gt; {{ n }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;   1 2 3 4  data: { num: 5, show: false, },   See the Pen 交錯轉場 範例 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  我們要如何將它改成交錯轉場？\n1. transition-delay 最簡單的方式，就是透過 transition-delay 來實現列表的交錯轉場。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  .custom-appear-active-class { transition: opacity 0.3s; } .custom-appear-active-class:nth-child(5n + 2) { transition-delay: 0.3s; } .custom-appear-active-class:nth-child(5n + 3) { transition-delay: 0.5s; } .custom-appear-active-class:nth-child(5n + 4) { transition-delay: 0.7s; } .custom-appear-active-class:nth-child(5n + 5) { transition-delay: 0.9s; }   但缺點也很明顯，要寫大量的 CSS，修改起來也不靈活。\nSee the Pen 交錯轉場 transition-delay by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 透過 data 屬性與 JavaScript 交流 透過 data 屬性取得元素的 index，所以補上 :data-index = index：\n1 2 3 4 5 6 7 8 9  \u0026lt;transition-group tag=\u0026#34;ul\u0026#34; v-if=\u0026#34;show\u0026#34; v-bind:css=\u0026#34;false\u0026#34; @appear=\u0026#34;appear\u0026#34; appear \u0026gt; \u0026lt;li v-for=\u0026#34;(n,index) in num\u0026#34; :key=\u0026#34;n\u0026#34; :data-index = index \u0026gt; {{ n }} \u0026lt;/li\u0026gt; \u0026lt;/transition-group\u0026gt;   利用 el.dataset 取取得元素的 data 屬性。\n1 2 3 4 5 6 7 8 9 10 11 12  methods:{ appear(el, done) { const index = el.dataset.index; // 取得 index  const delay = index * 0.3; gsap.from(el,{ duration: 0.3, opacity: 0, delay: delay, }) done(); }, },   我這裡使用 GSAP3 動畫來設置動畫。\nSee the Pen 交錯轉場 GSAP3 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  或是使用 Velocity.js 搭配 setTimeout：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  methods:{ beforeAppear(el) { el.style.opacity = 0; }, appear(el, done) { const index = el.dataset.index; const delay = index * 300; setTimeout(function () { Velocity( el, { opacity: 1 }, { complete: done } ); }, delay); }, },   See the Pen 交錯轉場 Velocity by CHUPAIWANG (@CHUPAIWANG) on CodePen. ","description":"這週是 六角鼠年鐵人賽 第五週，紀錄一下 Vue Transition 用法。","id":107,"section":"posts","tags":["Vue Transition","Vue","w3HexSchool"],"title":"Vue筆記 - Transition","uri":"https://chupai.github.io/posts/200307_vue-transition/"},{"content":"這週是 六角鼠年鐵人賽 第四週，之前沒碰過 TweenMax，但 GSAP 已經升級 GSAP3，就簡單研究一下 GSAP3。\nGSAP3 GSAP 是 GreenSock Animation Platform 的簡稱，是一套專門處理動畫與特效的 JS 套件。\nGSAP 採用模組化與插件式的結構，保持了核心引擎的輕量。有四個核心 API，TweenLite、TimelinLite、TimelineMax、TweenMax，而 TweenMax 是所有 API 與 Plugin 的集合。\n但 2019年底 GSAP 從 GSAP2 升級到 GSAP3，不再區分 TweenLite、TimelineLite、TimelineMax、TweenMax，全部合並為 gsap 物件。\nGSAP3 的優點：\n 檔案大小為 TweenMax 的一半，但新增了 50多個功能。 全部合並為 gsap 物件，不用在區分 TweenLite 和 TimelineMax 物件。 新版本相容舊版本寫法，所以可以沿用，新寫法提供更好的可讀性。  官網：\n GreenSock 英文官網 TweenMax 中文官網  下載安裝  GSAP Installation\n npm install gsap // or yarn add gsap CDN\nhttps://cdnjs.cloudflare.com/ajax/libs/gsap/3.1.1/gsap.min.js 版本差異 1. gsap 物件 原本須要用 Tweens（補間），就要使用 TweenLite/TweenMax 物件。要用到 Timelines（時間軸），就要使用 TimelineLite/TimelineMax 物件。\nGSAP3 統一使用 gsap 物件。gsap 物件，具有各種方法和屬性，可用來創建 Tweens（補間）和 Timelines（時間軸）。\n舊的 Tween 的創建方式：\n1 2 3  TweenMax.method(\u0026#39;selector\u0026#39;, {}); // or TweenLite.method(\u0026#39;selector\u0026#39;,{});   現在統一使用 gsap 物件：\n1  gsap.method(\u0026#39;selector\u0026#39;, {});   舊的 Timeline 的創建方式：\n1 2 3 4 5 6 7  const tl = new TimelineMax(); tl.method(\u0026#39;selector\u0026#39;, {}); // or const tl = new TimelineLite(); tl.method(\u0026#39;selector\u0026#39;, {});   現在 Timeline 一樣也只需要使用 gsap 物件：\n1 2 3  const tl = gsap.timeline(); tl.method(\u0026#39;selector\u0026#39;, {});   2. duration 參數 原來的寫法 duration 為方法的參數：\n1  TweenMax.to(\u0026#39;.box\u0026#39;, 1, { x: 100 });   新寫法被整合到了 vars 物件中了：\n1 2 3 4  gsap.to(\u0026#39;.box\u0026#39;, { duration: 1, x: 100, });   擁有更佳的可讀性。\n3. Timeline 預設值 原本的 Timeline 寫法：\n1 2 3 4 5 6 7 8 9  const t = new TimelineMax(); t.to(\u0026#39;.box1\u0026#39;, 1, { x: 100, ease: \u0026#39;elastic\u0026#39; }).to(\u0026#39;.box2\u0026#39;, 1, { y: 100, ease: \u0026#39;elastic\u0026#39; });   使用新的寫法，如有有相同的參數，可以設定預設值：\n1 2 3 4 5 6 7 8 9  const t = gsap.timeline({ defaults: { duration: 1, ease: \u0026#39;elastic\u0026#39; } }); t.to(\u0026#39;.box1\u0026#39;, { x: 100 }) .to(\u0026#39;.box2\u0026#39;, { y: 100 });   4. 交錯屬性 原本交錯動畫，要使用到額外的方法創建 Tween 實體，例如staggerTo()、staggerFrom()、staggerFromTo()：\n1  TweenMax.staggerTo(\u0026#39;.box\u0026#39;, 1, {rotation:360, x:100}, 0.5);   現在只需要設置 stagger 屬性即可：\n1 2 3 4 5 6  gsap.to(\u0026#39;.box\u0026#39;, { duration: 1, stagger: 0.5, rotation: 360, x: 100 });   5. 全新的亂數功能 1 ~ 400 之間：\n1 2 3  gsap.to(\u0026#39;.box\u0026#39;, { x: \u0026#39;random(100, 400)\u0026#39;, });   隨機選擇一個數字，可以使用陣列表示：\n1 2 3  gsap.to(\u0026#39;.box\u0026#39;, { x: \u0026#39;random([0，100，400，500])\u0026#39;, });   6. 全新的影格功能 Keyframes 大家一定都知道 CSS 動畫的 keyframes。那 GSAP 中的 keyframes 是什麼？\n原本要建立一連串的動畫（例如，先移動，再下移，最後旋轉），需要為每個動作建立 Tween 或使用 Timeline。而 keyframes 可以在同一個 Tween 內完成。\n1 2 3 4 5 6 7  gsap.to(\u0026#39;.box\u0026#39;, { keyframes: [ { duration: 1, x: 100, }, { duration: 1, y: 100 }, { duration: 1, rotation: 360 }, ] });   7. 全新的 repeatRefresh 開啟 repeatRefresh: true，會在重複執行時（設定 repeat），紀錄當前狀態再執行，而不會回到初始狀態。\n1 2 3 4 5 6  gsap.to(\u0026#39;.box\u0026#39;, { duration: 1, repeat: 5, repeatRefresh: true, x: \u0026#39;random(100, 400)\u0026#39;, });   8. 全新的全域動畫 Global timeline 可以控制全部的動畫實體。\n1 2 3 4  gsap.globalTimeline.timeScale(0.1); // 控制所有動畫的速率 0 ~ 1 gsap.globalTimeline.pause(); // 停止目前所有動畫 gsap.globalTimeline.play(); // 播放目前所有動畫 gsap.globalTimeline.paused(); // 回傳目前動畫狀態 true:暫停 / false:播放   9. 新的動畫輔助工具  Utility Methods\n  gsap.utils.checkPrefix() gsap.utils.clamp() gsap.utils.distribute() gsap.utils.getUnit() gsap.utils.interpolate() gsap.utils.mapRange() gsap.utils.normalize() gsap.utils.pipe() gsap.utils.random() gsap.utils.snap() gsap.utils.splitColor() gsap.utils.toArray() gsap.utils.unitize() gsap.utils.wrap() gsap.utils.wrapYoyo()  10. 相對動畫時間 原本會需要標籤來添加相對動畫時間：\n1 2 3 4 5 6  gsap.timeline() .add(\u0026#39;s\u0026#39;) .to(\u0026#39;.box1\u0026#39;, { ... }, \u0026#39;s\u0026#39;) .to(\u0026#39;.box2\u0026#39;, { ... }, \u0026#39;s\u0026#39;) .to(\u0026#39;.box3\u0026#39;, { ... }, \u0026#39;s+=0.8\u0026#39;) .to(\u0026#39;.box4\u0026#39;, { ... }, \u0026#39;s+=0.8\u0026#39;);   GSAP3 新增了最近的動畫時間：\n \u0026gt;：最近添加的動畫的開始時間 \u0026lt;：最近添加的動畫的結束時間  1 2 3 4 5  gsap.timeline() .to(\u0026#39;.box1\u0026#39;, { ... }) .to(\u0026#39;.box2\u0026#39;, { ... }, \u0026#39;\u0026lt;\u0026#39;) .to(\u0026#39;.box3\u0026#39;, { ... }, \u0026#39;\u0026lt;0.8\u0026#39;) .to(\u0026#39;.box4\u0026#39;, { ... }, \u0026#39;\u0026lt;\u0026#39;);   補間動畫 Tween 補間是 flash 時代的專業詞彙，意思是在起始狀態和終點狀態之間補全中間過程。\n包含四個要素：\n 動畫目標（target） 起始狀態 終點狀態 補間效果  1. 創建 Tween 創建 Tween 的常用方法（所有這些方法都會回傳 Tween 實體）：\n gsap.to(target, vars) gsap.from(target, vars) gsap.fromTo(target, fromVars , toVars )  參數說明：\n target：需要動畫的元素  target 使用 document.querySelectorAll()，所有符合的 CSS 選擇器都會是設置動畫的對象。 如果有多個元素對象，則使用陣列 [element1, element2]   vars：設置補間效果及屬性狀態  Timeline Timeline 就是「時間軸」，可以用來控制、管理一連串的動畫。\n 控制多段動畫 / 序列動畫 自由與重疊排序 添加 Tag 掌握動畫片段  舉例來說，我們要對多個元素作一連串的動畫，需要建立多個 Tween 並用 delay 設置延遲時間，非常麻煩：\n1 2 3  gsap.to(\u0026#39;.box1\u0026#39;, { duration: 1, x: 100, }); gsap.to(\u0026#39;.box2\u0026#39;, { delay: 1, duration: 1, y: 100 }); gsap.to(\u0026#39;.box1\u0026#39;, { delay: 2, duration: 1, rotation: 360 });   而且還無法對這一連串的動畫做控制。點我看範例。\n這時候可以使用 Timeline，建立一個時間軸，來管理這些動畫。\n1 2 3 4 5  const t1 = gsap.timeline(); t1.to(\u0026#39;.box1\u0026#39;, { duration: 1, x: 100, }) .to(\u0026#39;.box2\u0026#39;, { duration: 1, y: 100 }) .to(\u0026#39;.box1\u0026#39;, { duration: 1, rotation: 360 });   點我看範例。\n如果有相同動畫狀態，可以設定預設值，使程式碼更簡潔：\n1 2 3 4 5 6 7 8 9  const t1 = gsap.timeline({ defaults: { duration: 1, }, }); t1.to(\u0026#39;.box1\u0026#39;, { x: 100, }) .to(\u0026#39;.box2\u0026#39;, { y: 100, }) .to(\u0026#39;.box1\u0026#39;, { rotation: 360, });   1. 在時間軸中放置動畫 在時間軸建立動畫：\n to() from fromTo set()  1 2 3  const tl = gsap.timeline(); tl.to(element, {duration: 1, x: 100, opacity: 0.5});   Timeline 可以鏈式呼叫：\n1 2 3 4  const tl = gsap.timeline(); tl.from(element, {duration: 1, x: -100}) .to(element, {duration: 1, y: 50});   在時間軸中，加入一段已建立的動畫，使用 add()：\n1 2 3 4  const tween = tween = gsap.to(element, {duration: 1, x: 100, opacity: 0.5}); const tl = gsap.timeline(); tl.add(tween);   Timeline 許多方法都多 position 參數，可用來控制動畫插入點：\n 無設置：時間軸末尾 1：絕對時間，指定時間處 '+=1'、-=1：相對時間，相對於時間軸的結尾 'someLabel'：指定標籤處（建立標籤使用 addLabel()） ‵someLabel+=1'、‵someLabel-=1'：相對於指定標籤 \u0026lt;：最近動畫的開頭 \u0026gt;：最近動畫的結尾 \u0026lt;1、\u0026lt;-1：相對於最近動畫的開頭 \u0026gt;1、\u0026gt;-1：相對於最近動畫的結尾  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 插入至時間軸末尾 tl.to(element, 1, {}); // 插入至時間軸2秒處 tl.to(element, 1, {}, 2); // 在時間軸結束後2秒鐘插入 tl.to(element, 1, {}, \u0026#39;+=2\u0026#39;); // 在時間軸結束前2秒鐘插入 tl.to(element, 1, {}, \u0026#39;-=2\u0026#39;); // 在3秒處建立spin標籤 t1.addLabel(\u0026#39;spin\u0026#39;, 3); // 在spin標籤處插入動畫 tl.to(element, 1, {}, \u0026#39;spin\u0026#39;); // 在spin標籤處前三秒入動畫 tl.to(element, 1, {}, \u0026#39;spin+=3\u0026#39;); // 在最近一次動畫的開頭插入 tl.to(element, {x: 100}, \u0026#39;\u0026lt;\u0026#39;); // 在最近一次動畫的開始後1秒插入 tl.to(element, {x: 100}, \u0026#39;\u0026lt;1\u0026#39;);   基本用法 1. 數字動畫 0~100 最基本的用法，對物件的屬性去做變化。\nSee the Pen GSAP3 Demo - 基本數字動畫 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. CSS 動畫 See the Pen GSAP3 Demo - CSS 動畫 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 動畫控制  .play()：播放動畫 .pause()：暫停動畫播放 .paused()：獲取或設置動畫暫停狀態  myAnimation.paused(!myAnimation.paused()) 暫停動畫切換   .resume()：繼續動畫播放 .restart()：重新開始動畫 .reverse()：反轉播放動畫 .reversed()：獲取或設置動畫反轉狀態  myAnimation.reversed( !myAnimation.reversed() ) 動畫撥放方向切換。   .seek()：不改變狀態下，跳至動畫某個時間點  See the Pen GSAP3 Demo - 動畫控制 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  4. 重複撥放、來回撥放 1 2 3  repeat: 10, // 設置動畫重複次數 repeatDelay: 0.5, // 設置重複的間隔時間(秒) yoyo: true, // 設為true時，動畫會反轉重複   See the Pen GSAP3 Demo - 重複、來回 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  5. 錯開動畫 1  stagger: 0.5, // 設置錯開時間   See the Pen GSAP3 Demo - 重複、來回 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  6. 週期 GSAP2 的 cycle 屬性，被 GSAP3 的 gsap.utils.wrap() 給取代，而且更加靈活。\nSee the Pen GSAP3 Demo - 週期 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  簡易應用 Mousemove Event 1. Image Trail Effects See the Pen GSAP3 - Image Trail Effects by Chupai@Design (@chupai) on CodePen.  2. Slinky Text See the Pen GSAP3 - Slinky Text by Chupai@Design (@chupai) on CodePen.  Image Block Reveal See the Pen GSAP3 - Image Block Reveal by Chupai@Design (@chupai) on CodePen.  Text Animation  SplitText 商業插件\n 1. 重組文字 See the Pen GSAP3 - 重組文字 by Chupai@Design (@chupai) on CodePen. ","description":"這週是 六角鼠年鐵人賽 第四週，之前沒碰過 TweenMax，但 gsap 已經升級 GSAP3，就簡單研究一下 GSAP3。","id":108,"section":"posts","tags":["GSAP3","TweenMax","w3HexSchool"],"title":"GSAP3 - 專門處理動畫與特效的 JS 套件","uri":"https://chupai.github.io/posts/200229_gsap3/"},{"content":"這週是 六角鼠年鐵人賽 第三週，不知道要寫啥，就重新整理了一下 Flexbox 的筆記。\nFlexbox 概述 Flexbox 全稱為 CSS Flexible Box Layout，也就是 CSS 彈性盒子佈局。是一種新的 CSS3 佈局模式，在彈性盒子佈局中，彈性容器的子項目們可以伸展到任何方向、並讓他們的尺寸更加「彈性」、或者持續增大，以填補未使用的空間，抑或縮小，以避免父元素溢出。子元素的橫向或縱向對齊都很容易操作。\n1. 為何流行？ 為何開始流行了呢？最主要也是因為 CSS3 的規範終於普及，加上行動裝置的發展促成了響應式佈局興起，自適應長寬彈性相當大的 Flexbox 就趁勢而起了。\n 非常適合單向排版，例如導覽列、Gird-Layout 許多 CSS 框架也使用（Bootstrap、Foundation 等）  跟毒品一樣，用過就回不去了。\n2. 瀏覽器的支援 瀏覽器支援高達 97%。\n Can I use CSS Flexible Box Layout Module ?\n 3. Flexbox 規格歷史  2009 年的版本：display: box 現在已經不再跟 Flexbox 有任何關係。 2011 過渡期版本：display: flexbox 只是草稿，只被 IE10 實作, 如果可能的話應該避免使用。 2012 最終版：display: flex  模型概念 來源：CSS彈性盒子用法｜MDN \n容器與項目：\n 彈性容器（Flex container）\n將元素的 display 屬性設為 flex 或 inline-flex，就會變彈性容器。 彈性項目（Flex item）\n所有彈性容器的子元素都會變成彈性項目，包含文字。  彈性容器具有主軸與交錯軸：\n 主軸（main axis） 交錯軸（cross axis）  方向：\n 主軸起點與終點（main start/main end） 交錯軸點與終點（cross start/cross end）  彈性項目具有：\n 水平尺寸與垂直尺寸（main size、cross size）  屬性介紹 Flexbox 可分成外層元素（彈性容器）與內層元素（彈性項目）。\n外容器屬性：\n display：flex、inline-flex，啟用 Flexbox 的必備屬性 flex-flow  flex-direction：決定主軸線的方向 flex-wrap：決定是否換行   justify-content：主軸線的對齊 align-items：交錯軸的對齊 align-content：整體的對齊  內層元素屬性：\n align-self：單一個物件的交錯軸對齊 order：排序 flex  flex-grow：伸展比，其數值與其它物件可分配伸展比有關 flex-shrink：收縮比 flex-basis：絕對值    1. Emmet 速寫格式 Flexbox 相關屬性的 Emmet 速寫格式：\ndisplay\n d:f：display:flex; d:if：display:inline-flex;  flex-direction\n fxd：flex-direction:; fxd:c：flex-direction:column; fxd:cr：flex-direction:column-reverse; fxd:r：flex-direction:row; fxd:rr：flex-direction:row-reverse;  justify-content\n jc：justify-content:; jc:c：justify-content:center; jc:fe：justify-content:flex-end; jc:fs：justify-content:flex-start; jc:sa：justify-content:space-around; jc:sb：justify-content:space-between;  flex-wrap\n fxw：flex-wrap: ; fxw:n：flex-wrap:nowrap; fxw:w：flex-wrap:wrap; fxw:wr：flex-wrap:wrap-reverse;  align-items\n ai：align-items:; ai:b：align-items:baseline; ai:c：align-items:center; ai:fe：align-items:flex-end; ai:fs：align-items:flex-start; ai:s：align-items:stretch;  align-content\n ac：align-content:; ac:c：align-content:center; ac:fe：align-content:flex-end; ac:fs：align-content:flex-start; ac:s：align-content:stretch; ac:sa：align-content:space-around; ac:sb：align-content:space-between;  align-self\n as：align-self:; as:a：align-self:auto; as:b：align-self:baseline; as:c：align-self:center; as:fe：align-self:flex-end; as:fs：align-self:flex-start; as:s：align-self:stretch;  order\n ord：order:;  flex\n fx：flex:; fxb：flex-basis:; fxd：flex-direction:; fxd:c：flex-direction:column; fxd:cr：flex-direction:column-reverse; fxd:r：flex-direction:row; fxd:rr：flex-direction:row-reverse; fxf：flex-flow:; fxg：flex-grow:; fxsh：flex-shrink:; fxw：flex-wrap: ; fxw:n：flex-wrap:nowrap; fxw:w：flex-wrap:wrap; fxw:wr：flex-wrap:wrap-reverse;  外容器屬性 1. 必備屬性 使用 Flexbox 就是要將 display 設為 flex 或 inline-block。\n display: flex 其布局方式與 block 一樣，都會強迫換行； 而 inline-flex 和 inline-block 也 一樣，在後方的元素不會換行。  唯一不同的是，flex 與 inline-flex 的子元素具備了更多彈性的設定。\n1 2 3 4  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;text\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9  .container { display: block; } .box { display: flex; /* or inline-flex */ width: 100px; height: 100px; }   See the Pen Flex - demo1 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 主軸方向 flex-direction 可以決定主軸的方向，主軸的方向將會影響容器內的元素排序順序、方向。\nflex-direction 設定值共有以下四種：\n row：預設值，由左到右，從上到下 row-reverse：與 row 相反 column：從上到下，再由左到右 column-reverse：與 column 相反  1 2 3 4 5  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9  .container { display: flex; flex-direction: row; } .item { width: 50px; height: 50px; }   See the Pen flex-direction demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 主軸對齊 justify-content 決定了內容元素與整個 Flexbox 的「主軸對齊」位置，設定值共有以下五種：\n flex-start：預設值，對齊主軸線最前端 flex-end：對齊主軸線最終端 center：對齊主軸線中央 space-between：平均分配寬度，第一項和最後一項貼齊邊緣 space-around：平均分配寬度、間距  1 2 3 4 5  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9  .container { display: flex; justify-content: flex-start; } .item { width: 50px; height: 50px; }   See the Pen justify-content demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  4. 交錯軸對齊 align-items 剛好和 justify-content 相反，align-items 決定了內容元素與整個 Flexbox 的「交錯軸對齊」位置，設定值總共有下列五個：\n stretch：預設值，如果子元素 height: auto，會將撐開至父元素的高度 flex-start：對齊交錯軸線最前端 flex-end：對齊交錯軸線最末端 center：對齊交錯軸線中央 baseline：對齊子元素的基線  1 2 3 4 5  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item h100\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item h-auto\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  .container { display: flex; justify-content: flex-start; } .item { width: 50px; height: 50px; } .h-100 { height: 100px; } .h-auto { height: auto; }   See the Pen align-items demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  5. 換行 當我們把父容器的 display 設定為 flex 或 inline-flex 的時候，子元素就是以單行的方式排列，因為預設不會行，因此當遇到邊界會彈性調整元素。\nflex-wrap 可以調整元素是否換行，共有三個設定值：\n nowrap：預設值，不斷行 wrap：多行 wrap-reverse：多行，但主軸線起點與終點相反  1 2 3 4 5 6  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9  .container { display: flex; flex-wrap: nowrap; } .item { width: 50px; height: 50px; }   See the Pen flex-wrap by CHUPAIWANG (@CHUPAIWANG) on CodePen.  6. 多行交錯軸對齊 align-items 是針對內容為單行的子元素進行處理，如果遇到多行的子元素（flex-wrap: wrap），就要使用 align-content 這個屬性，這個屬性總共有六個設定值：\n stretch：預設值，會平均分配行距，height: auto 會撐開填滿整行。 flex-start：對齊交錯軸線最前端 flex-end：對齊交錯軸線最末端 center：對齊交錯軸線中央 space-between：第一行與最後一行分別對齊交錯軸線最上方與最下方 space-around：平均分配行距，兩端會有行距一半的間距  1 2 3 4 5 6  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10  .container { display: flex; flex-wrap: wrap; align-content: stretch, } .item { width: 50px; height: 50px; }   See the Pen align-content demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  內層元素屬性 1. 交錯軸位置 align-self 作用於內層容器，也就是子元素本身，會覆蓋外層容器的 align-items。\n設定值與 align-items 相同：\n stretch：預設值，如果子元素 height: auto，會將撐開至父元素的高度 flex-start：對齊交錯軸線最前端 flex-end：對齊交錯軸線最末端 center：對齊交錯軸線中央 baseline：對齊子元素的基線  1 2 3 4 5 6  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt;   1 2 3  .item { align-self: stretch; }   See the Pen align-self demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 排序 order 屬性可以直接指定一個數字，就可以由小到大的排列順序。\n 預設值為 0，只給一個元素設置會跑到最後面 要設置到最前頭，可以設值負值 相同的數字，看元素排序  注意，order 僅僅對元素的視覺順序 (visual order) 產生作用，並不會影響元素的邏輯或順序。\n1 2 3 4 5 6  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item item1\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item2\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item3\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item4\u0026#34;\u0026gt;4\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3  .item1 { order: 2; }   See the Pen align-self demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 伸縮比 FlexBox 最重要的屬性「flex」，個別調整子元素長度「伸展」、「壓縮」的比例以及基本大小。\nflex 是簡寫，裡面依序包含三個屬性：\n flex-grow：預設值為 0，負值無效 flex-shrink：預設值為 1，負值無效 flex-basis：預設值為 auto，若值為 0，則必須加上單位，以免被視作伸縮性  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /* 單值語法 無單位數值 unitless number: flex-grow */ flex: 2; /* 單值語法 有效寬高單位 width/height: flex-basis */ flex: 10em; flex: 30px; /* 雙值語法 flex-grow | flex-basis */ flex: 2 2; /* 三值語法 flex-grow | flex-shrink | flex-basis */ flex: 2 2 10%;   三個屬性可以分開設定，也可以合在一起用一個 flex 統一設定。\n3.1 伸展比 flex-grow 元素的伸展性，是一個數值，當子元素的寬度「小」於它自己在父元素分配到的寬度，按照數字做相對應的「伸展」比例分配（剩餘空間）。\n預設值為 0，不會進行彈性變化，不可為負值，設為 1 則會進行彈性變化。\nSee the Pen flex-grow  by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3.2 壓縮比 flex-shrink 元素收縮性，是一個數值，當子元素的寬度「大」於它自己在父元素分配到的寬度時，會進行壓縮。\n預設值為 1，設為 0 的話不會進行彈性變化（全部都 0 可能超出邊界），不可為負值。\nSee the Pen flex-shrink by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3.3 基本大小 flex-basis flex-basis 為子元素的基本大小，作為父容器的大小比較基準，預設值為 auto。\n在分配空間之前，子元素會依 flex-basis 或者 width/height，預約空間，剩餘空間會依 flex-grow 分配。\n主軸方向 flex-direction：\n 水平 row： flex-basis 為 width 的替代 垂直 column：flex-basis 為 height 的替代  優先級：\n 如果同時設置，那麼 width/height 會被覆蓋（flex-basis 的優先級較高）； 其中有一個是 auto，那麼另外一個非 auto 的屬性優先級會更高。  一些常見問題 一些新手使用 FlexBox，沒注意到的問題。\n1. 子元素高度被強制拉伸對齊 常見的情況是，當子元素 col 內，放置不同高度的元素 box，每個子元素 col 都會被強制拉伸對齊。\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box3\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3  .container { display: flex; }   See the Pen 子元素高度被強制拉伸對齊 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  這是因為 align-items 預設 stretch。因此可以透過改變 align-items 的值解決，或是使用 align-self 個別調整。\n2. 元素被壓縮 我們都知道 FlexBox 預設不換行，因此當容器大小不足時，各個子元素會被壓縮。會被壓縮的原因是 flex-shrink 預設為 1。\n所以如果不希望元素被壓縮，可以將 flex-shrink 設為 0。\n1 2 3 4 5 6 7  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col flex-shrink-0\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://picsum.photos/300/300\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   See the Pen 子元素高度被強制拉伸對齊 by CHUPAIWANG (@CHUPAIWANG) on CodePen. ","description":"這週是 六角鼠年鐵人賽 第三週，不知道要寫啥，就重新整理了一下 Flexbox 的筆記。","id":109,"section":"posts","tags":["Flex","CSS排版","w3HexSchool"],"title":"CSS筆記 - Flexbox","uri":"https://chupai.github.io/posts/200220_flex/"},{"content":"這週是 六角鼠年鐵人賽 第二週，就簡單的整理 Swiper 如何使用。\n簡介 Swiper 是一款免費以及輕量級的 JS 框架，常用於移動設備的內容觸摸滑動。\n最重要的是 「不需要使用到 jQuery」。\n更詳細介紹，請見官方：\n Swiper Swiper 中文網  目前 Swiper 版本為 Swiper5，Swiper5 對比 Swiper4 的 API 並無太大變化。Swiper5 增加了 cssMode，並且可以通過 CSS 修改 Swiper 顏色風格。\n 一些基本範例，可以參考 Swiper Demos。\n 安裝 需要用到的檔案有 swiper.min.js 和swiper.min.css 檔案。\n下載：\n Swiper GitHub repository NPM：  $ npm install swiper CDN：\n1 2 3 4 5  \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/swiper/css/swiper.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/swiper/css/swiper.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/swiper/js/swiper.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/swiper/js/swiper.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;    cdnjs - Swiper\n 配置：\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; ... \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/swiper/css/swiper.min.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ... \u0026lt;script src=\u0026#34;https://unpkg.com/swiper/js/swiper.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   初始化 Swiper 1  new Swiper(swiperContainer, parameters);    swiperContainer：要控制的 Swiper 容器，可以是 DOM 元素 或 字串（CSS 選擇器） parameters：一個物件，為 Swiper 的配置參數  1 2 3  var mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { // 配置參數 });    詳細配置參數，可以參考 Swiper API。\n 假設初始化時，沒有定義 Swiper 實體，可以透過 Swiper 的HTML 元素來獲取該實體。\n1 2 3  new Swiper(\u0026#39;.swiper-container\u0026#39;); var mySwiper = document.querySelector(\u0026#39;.swiper-container\u0026#39;).swiper;   Swiper 實體有屬性與方法可以使用，還可以監聽事件。\nLayout 1. Swiper 容器 一個 Swiper 就對應到一個 container。\n1 2  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;/div\u0026gt;   1  var mySwiper = new Swiper (\u0026#39;.swiper-container\u0026#39;);   如果一個頁面有很多個 Swiper，可以給每個容器加上 ID 或 Class 區分。\n1 2 3  \u0026lt;div class=\u0026#34;swiper-container\u0026#34; id=\u0026#34;swiper1\u0026#34;\u0026gt;....\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-container\u0026#34; id=\u0026#34;swiper2\u0026#34;\u0026gt;....\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-container\u0026#34; id=\u0026#34;swiper3\u0026#34;\u0026gt;....\u0026lt;/div\u0026gt;   1 2 3  var swiper1 = new Swiper(\u0026#39;#swiper1\u0026#39;); var swiper2 = new Swiper(\u0026#39;#swiper2\u0026#39;); var swiper3 = new Swiper(\u0026#39;#swiper3\u0026#39;);   我們可以為這個容器設置大小：\n1 2 3 4  .swiper-container { width: 600px; height: 300px; }   2. slide 元件 Swiper 的每個展示區塊為一個 slide，全部的 slide 會放在一個 wrapper 中。\n1 2 3 4 5 6 7  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   See the Pen Swiper - 基本範例 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 控制元件 除了 slide 外，還可以包含其他控制元件，可以自由選擇你需要的。。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- Pagination --\u0026gt; \u0026lt;div class=\u0026#34;swiper-pagination\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- Navigation --\u0026gt; \u0026lt;div class=\u0026#34;swiper-button-prev\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-button-next\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- Scrollbar --\u0026gt; \u0026lt;div class=\u0026#34;swiper-scrollbar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  var mySwiper = new Swiper (\u0026#39;.swiper-container\u0026#39;, { // Pagination  pagination: { el: \u0026#39;.swiper-pagination\u0026#39;, }, // Navigation  navigation: { nextEl: \u0026#39;.swiper-button-next\u0026#39;, prevEl: \u0026#39;.swiper-button-prev\u0026#39;, }, // Scrollbar  scrollbar: { el: \u0026#39;.swiper-scrollbar\u0026#39;, }, });   See the Pen Swiper - 控制元件 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  控制元件可以放在 container 之外，但需要設置 uniqueNavElements: false。\n3. 對應的 class 名稱 容器、元件、狀態，對應的 class 名稱，都可以透過選項更改。\n舉例來說，將預設的 swiper-wrapper 替換成 my-wrapper：\n1 2 3  var mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;,{ wrapperClass : \u0026#39;my-wrapper\u0026#39;, });   容器：\n swiper-container：Swiper 容器  選項：containerModifierClass   swiper-wrapper：slide 容器  選項：wrapperClass    slide 元件：\n swiper-container：slide 元件  選項：slideClass   swiper-slide-active：active 狀態的 slide 元件  選項：slideActiveClass   swiper-slide-visible：可視區塊的 slide 元件  選項：slideVisibleClass   swiper-slide-next：active slide 的下一個 slide 元件  選項：slideNextClass   swiper-slide-prev：active slide 的上一個 slide 元件  選項：slidePrevClass    基本配置 1. background-img 1 2 3 4 5 6  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34; style=\u0026#34;background-image:url(\u0026#39;\u0026#39;)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10  .swiper-container { width: 600px; height: 300px; } .swiper-slide { background-repeat: no-repeat; background-position: center center; background-size: cover; }   See the Pen Swiper Demos - background-img by Chupai@Design (@chupai) on CodePen.  2. \u0026lt;img\u0026gt; 1 2 3 4 5 6 7 8  \u0026lt;div id=\u0026#34;swiper1\u0026#34; class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11  .swiper-container { width: 600px; height: 300px; } .swiper-slide \u0026gt; img { display: block; width: 100%; height: 100%; object-fit: cover; }   1  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;);   See the Pen Swiper Demos - img by Chupai@Design (@chupai) on CodePen.  3. slidesPerView slidesPerView 能設置同時顯示的 slide 數量，slide 的大小由 container 寬去等分。\n1 2 3  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { slidesPerView: 2, });   See the Pen Swiper Demos - slidesPerView by Chupai@Design (@chupai) on CodePen.  4. 依 slide 大小顯示 如果想要依 slide 大小來顯示，可以將 slidesPerView 設為 'auto'。\n1 2 3 4 5 6 7 8 9 10  .swiper-slide { width: 300px; height: 200px; } .swiper-slide \u0026gt; img { width: 100%; height: 100%; object-fit: cover; }   1 2 3  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { slidesPerView: \u0026#39;auto\u0026#39;, });   See the Pen Swiper Demos - 依 slide 大小顯示 by Chupai@Design (@chupai) on CodePen.  3D Cube Effect 3D Cube Effect：effect: 'cube'。\ncubeEffect 參數：\n slideShadows：slide 陰影。預設為 true。 shadow：投影。預設為 true。 shadowOffset：投影距離（px）。預設為 20。 shadowScale： 投影縮放比例。預設為 0.94。  1 2 3 4 5 6 7 8 9  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;cube\u0026#39;, cubeEffect: { slideShadows: true, // slide 陰影  shadow: true, // 投影  shadowOffset: 20, // 投影距離（px）  shadowScale: 0.94, // 投影縮放比例  }, });   1. 基本 將 container 設為方塊大小。\n1 2 3 4 5 6 7  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34; style=\u0026#34;background-image:url(\u0026#39;\u0026#39;)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34; style=\u0026#34;background-image:url(\u0026#39;\u0026#39;)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10  .swiper-container { width: 300px; height: 300px; } .swiper-slide { background-repeat: no-repeat; background-position: center center; background-size: cover; }   1 2 3  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;cube\u0026#39;, });   See the Pen 3D Cube Effect - Basic by Chupai@Design (@chupai) on CodePen.  2. 卡片 slide 內放置 card 元件，將 container 的寬設為 card 的寬，card 不需設置寬度：。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card__img\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card__body\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;card__title\u0026#34;\u0026gt; Lorem ipsum \u0026lt;span\u0026gt;Web Designer\u0026lt;/span\u0026gt; \u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9  .swiper-container { width: 300px; height: auto; } .card { background-color: white; } .card ...   See the Pen 3D Cube Effect - Card by Chupai@Design (@chupai) on CodePen.  3D Coverflow Effect 3D Coverflow：effect : 'coverflow'。\ncoverflowEffect 參數：\n slideShadows：slide 陰影。預設為 true。 rotate：slide 做 3D 旋轉時 Y 軸的旋轉角度。預設為 50。 stretch：每個 slide 之間的拉伸直，越大 slide 靠得越緊。預設為 0。 depth：slide 的位置深度值，值越大 z 軸距離越遠，看起來越小。預設為 100。 modifier：depth 和 rotate 和 stretch 的倍率。預設為 1。  1 2 3 4 5 6 7 8 9 10 11 12  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;,{ slidesPerView: \u0026#39;auto\u0026#39;, centeredSlides: true, effect : \u0026#39;coverflow\u0026#39;, coverflowEffect: { slideShadows : true, rotate: 50, stretch: 0, depth: 100, modifier: 1, }, });   1. 基本 1 2 3 4 5 6 7  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34; style=\u0026#34;background-image:url(\u0026#39;\u0026#39;)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34; style=\u0026#34;background-image:url(\u0026#39;\u0026#39;)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11  .swiper-container { width: 100%; } .swiper-slide { width: 200px; height: 200px; background-repeat: no-repeat; background-position: center center; background-size: cover; }   1 2 3 4 5  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;coverflow\u0026#39;, slidesPerView: \u0026#39;auto\u0026#39;, centeredSlides: true, });   必設參數：\n slidesPerView: 'auto'，根據 slide 的寬度來設定 slide 可視數量。 centeredSlides，active slide 會置中，而不是預設狀態下的靠左。  See the Pen coverflowEffect - Basic by Chupai@Design (@chupai) on CodePen.  2. Card 將 card 元件加上 swiper-slide，並設置寬度：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;div id=\u0026#34;mySwiper\u0026#34; class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card swiper-slide\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34; class=\u0026#34;card__img\u0026#34;/\u0026gt; \u0026lt;div class=\u0026#34;card__body\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Lorem ipsum0\u0026lt;/h3\u0026gt; \u0026lt;span\u0026gt;Web Designer\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card swiper-slide\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card swiper-slide\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card swiper-slide\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10  .swiper-container { width: 100%; } .card { width: 240px; border-radius: 8px; background: white; overflow: hidden; }   如果 Card 元件要放在 swiper-slide 內有兩種做法：\n 將 slide 的寬設為 card 寬度，card 寬度設為 100%。 將 slide 的寬設為 auto !important，並設置 card 寬度。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;div id=\u0026#34;mySwiper\u0026#34; class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34; class=\u0026#34;card__img\u0026#34;/\u0026gt; \u0026lt;div class=\u0026#34;card__body\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Lorem ipsum0\u0026lt;/h3\u0026gt; \u0026lt;span\u0026gt;Web Designer\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /* 作法一 */ .swiper-slide { width: 240px; } .card { width: 100%; /* ... */ } /* 作法二 */ .swiper-slide { width: auto !important; } .card { width: 240px; /* ... */ }   這個範例稍微修改一下 coverflow 參數：\n1 2 3 4 5 6 7 8 9 10 11 12  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;coverflow\u0026#39;, slidesPerView: \u0026#39;auto\u0026#39;, centeredSlides: true, coverflowEffect: { slideShadows: true, rotate: 20, stretch: 0, depth: 350, modifier: 1, }, });   See the Pen coverflowEffect - Card by Chupai@Design (@chupai) on CodePen.  3D Flip Effect 3D Flip Effect：effect: 'cube'。\nflipEffect 參數：\n slideShadows：slide 的陰影。預設為 true。 limitRotation：限制最大旋轉角度為 180 度。預設為 true。  1 2 3 4 5 6 7  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;,{ effect : \u0026#39;flip\u0026#39;, flipEffect: { slideShadows : true, limitRotation : true, } });   1. 基本 配置跟 3D Cube Effect 配置一樣：\n1 2 3  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;,{ effect : \u0026#39;flip\u0026#39;, });   See the Pen 3D Flip Effect - Basic by Chupai@Design (@chupai) on CodePen.  2. 卡片 See the Pen 3D Flip Effect - Card by Chupai@Design (@chupai) on CodePen.  Fade Effect Fade Effect effect: 'fade'。\nfadeEffect 效果參數：\n crossFade：淡出效果，預設為 false。  預設 crossFade 是關閉的，也就是所有 slide 是重疊在一起的。\n1 2 3 4 5 6  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;fade\u0026#39;, fadeEffect: { crossFade: false }, });   1. 基本 配置跟 3D Cube Effect 配置一樣：\n1 2 3  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;fade\u0026#39;, });   See the Pen Fade Effect - Basic by Chupai@Design (@chupai) on CodePen.  Thumbs Thumbs 元件為專門用於製作帶縮略圖的 Swiper，比使用 Controller 更為簡便，且在 loop 狀態下更友好。\n有兩種寫法：\n1 2 3 4 5 6 7 8 9 10  var thumbsSwiper = new Swiper(\u0026#39;.swiper-container-thumbs\u0026#39;, { slidesPerView: 5, }); var mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { ... thumbs: { swiper: thumbsSwiper } });   或是：\n1 2 3 4 5 6 7 8 9 10  var mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { ... thumbs: { swiper: { el: \u0026#39;.swiper-container-thumbs\u0026#39;, slidesPerView: 5, ... } } });   縮圖的 Swiper active 狀態 slide 會被加上 .swiper-slide-thumb-active 的類名。\n但不知道為什麼，我使用 4.5.1 版本的 CDN，.swiper-slide-thumb-active 不會加上去。\n1. Thumbs Gallery 1 2 3 4 5 6 7 8  \u0026lt;div class=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-container gallery-top\u0026#34;\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-container gallery-thumbs\u0026#34;\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  .wrapper { width: 600px; } .swiper-slide { background-repeat: no-repeat; background-size: cover; background-position: center center; } .gallery-top { width: 100%; height: 400px; bottom: 10px; } .gallery-thumbs { width: 100%; height: 100px; } .gallery-thumbs .swiper-slide { opacity: 0.4; } .gallery-thumbs .swiper-slide-thumb-active { opacity: 1; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const mySwiper = new Swiper(\u0026#39;.gallery-top\u0026#39;, { spaceBetween: 10, thumbs: { swiper: { el: \u0026#39;.gallery-thumbs\u0026#39;, spaceBetween: 10, slidesPerView: 4, freeMode: true, }, }, navigation: { nextEl: \u0026#39;.swiper-button-next\u0026#39;, prevEl: \u0026#39;.swiper-button-prev\u0026#39;, }, });   See the Pen Thumbs Gallery by Chupai@Design (@chupai) on CodePen.  總結 這週就先整理到這，有空補上自動撥放、循環模式，我們下週見。\n2020-03-04\n被分享了，有點驚訝，是不是要來加上封面圖了 🤣。\n","description":"這週是 六角鼠年鐵人賽 第二週，就簡單的整理 Swiper 如何使用。","id":110,"section":"posts","tags":["Swiper.js","w3HexSchool"],"title":"Swiper - 不需要使用到 jQuery 的輪播套件","uri":"https://chupai.github.io/posts/200212_swiper/"},{"content":"前言 之前都是使用 Blogger 來放筆記，但 Blogger 沒辦法使用 Markdown 語法，所以筆記幾乎都使用 HackMD 來寫作，有空時才會將文章轉好丟到 Blogger 上，如果文章作修改要同步很麻煩。\n最近六角學院舉辦的 w3HexSchool 鼠年全馬鐵人挑戰 開跑了，有想過使用 Hexo + GitHub pages 建立 Blog，但實在是沒空。\n就在不知道要將文章丟哪時，發現了支援 Markdown 語法的簡易部落格「Bloggi」。\n2020-03-16 第七週已經找時間將全部文章搬到 Hugo 了，可以參考 第七週的文章。\n 原 Blog 新 Blog  有空再把 Blogger 的文章全部搬過來。\n\rBloggi Bloggi 是一個免費的網誌網誌寫作平台，支援 Markdown 語法，介面簡潔、無廣告，只需要簡單的註冊就可以立即使用。\n Bloggi 官網\n 1. 簡單註冊  部落格名稱 電子郵件 密碼  2. 教學手冊 帳號註冊完成後，進到「Posts」，會兩篇預設文章，為教學手冊及 Bloggi 的介紹。看完之後就可以刪除了。\n3. 設定 接下來進到「Settings」，可以編輯部落格名稱、簡介、LOGO、網址名稱等等資訊。\n部分功能則需要付費才使用，例如自訂網域名稱、Favicon、Navigation 等等。\n4. 新增文章 接下來回到「Posts」，如果要新增文章點選「New post」即可。\n編輯器很簡易，只有標題和內文，寫作格式為 Markdown 語法。\n左上分別是：\n Publish 發布文章 Preview 預覽文章 Settimgs 文章設定  5. 預覽  我的 Bloggi\n 總結 優點：\n 支援 Markdown 語法 免費、無廣告 簡單好懂的介面 簡易客製化與設定  缺點：\n 需要第三方圖片空間，管理上略麻煩 匯入匯出功能，期待未來加入  ","description":"這週是 六角鼠年鐵人賽 第一週，支援 Markdown 語法的簡易部落格「Bloggi」。","id":111,"section":"posts","tags":["Bloggi","w3HexSchool"],"title":"Bloggi - 支援 Markdown 語法的簡易部落格","uri":"https://chupai.github.io/posts/200205_bloggi/"},{"content":"\r基本語法與文法  變數 註解 \u0026amp; 型別檢查  資料操作  陣列 迭代陣列 Slice、Splice、Split 的區別 陣列資料過濾查詢 連續的數字陣列 日期時間 物件字面值擴充功能 展開／其餘運算子 解構指定  函式  函式呼叫與 this  非同步  非同步 回呼函式 Promise Async/Await  AJAX  AJAX JSON XMLHttpRequest Fetch  BOM  window.location 剪貼簿複製操作  模組  ES6 Module ","description":"JavaScript筆記 目錄","id":112,"section":"posts","tags":["JavaScript"],"title":"JavaScript筆記 目錄","uri":"https://chupai.github.io/posts/190620_javascript/"},{"content":"切版練習，使用 BEM 命名 + Sass 模組化 + Bootstrap4 Grid System。\n 舊 Blog 原文\n \r位置  網頁 Github 設計稿  CSS 排序  Concentric-CSS  命名規範  前綴  l- layout m- modules e- element p- pages h- helpers   BEM  Block__Element_Modifier    Grid System  Bootstrap4  其他  使用rem 單位 flex 排版 ","description":"切版練習，使用 BEM 命名 + Sass 模組化 + Bootstrap4 Grid System。","id":113,"section":"posts","tags":["舊文章搬運","SASS","BEM"],"title":"甜點電商 - 切版練習","uri":"https://chupai.github.io/posts/old/1905/190524_sweetaste/"},{"content":"切版練習，使用 BEM 命名 + Sass 模組化 + Bootstrap4 Grid System。\n 舊 Blog 原文\n \r位置  網頁 Github 設計稿  CSS 排序  Concentric-CSS  命名規範  前綴  l- layout m- modules e- element p- pages h- helpers   BEM  Block__Element_Modifier    Grid System  Bootstrap4  其他  使用rem 單位 flex 排版  後記 第一次切版就獲得高評價，有點驚嚇 😱😱\n","description":"切版練習，使用 BEM 命名 + Sass 模組化 + Bootstrap4 Grid System。","id":114,"section":"posts","tags":["舊文章搬運","SASS","BEM"],"title":"六角西餐廳 - 切版練習","uri":"https://chupai.github.io/posts/old/1905/190518_hex-restaurant/"}]