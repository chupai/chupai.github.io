[{"content":"這週是 六角鼠年鐵人賽 第八週，紀錄 Vue 表單驗證套件 - Vee Validate 操作方法。\n前言  VeeValidate 官網\n VeeValidate 是專用於 Vue.js 的表單驗證套件。它有很多預設驗證規則，也支持自定義驗證規則。\n由於 2.x版本 與 3.x版本 的操作非常不同，所以簡單紀錄一下。\nVeeValidate 2 1. 安裝 安裝舊版本：\nnpm install vee-validate@2.2.15 --save 導入：\n1 2 3  // main.js import VeeValidate from \u0026#39;vee-validate\u0026#39;; Vue.use(VeeValidate);   1.1 會遇到的問題 如果 Focus 到 input 標籤再點外面，不會進行驗證，可以修改 events，加上 blur：\n1 2 3 4 5  // main.js  Vue.use(VeeValidate, { events: \u0026#39;input|blur\u0026#39;, });   1.2 中文化 舊方法 2.1.0-beta.24版之前：\n1 2 3 4 5 6 7  // main.js  import VeeValidate from \u0026#39;vee-validate\u0026#39;; import zhTW from \u0026#39;vee-validate/dist/locale/zh_TW\u0026#39;; VeeValidate.Validator.localize(\u0026#39;zhTW\u0026#39;, zhTW); Vue.use(VeeValidate);   新方法，必須先安裝 vue-i18n：\nnpm install vue-i18n --save 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // main.js import VeeValidate from \u0026#39;vee-validate\u0026#39;; import zhTW from \u0026#39;vee-validate/dist/locale/zh_TW\u0026#39;; import VueI18n from \u0026#39;vue-i18n\u0026#39;; Vue.use(VueI18n); const i18n = new VueI18n({ locale: \u0026#39;zhTW\u0026#39;, }); Vue.use(VeeValidate, { events: \u0026#39;input|blur\u0026#39;, i18n, dictionary: { zhTW, }, }); // 記得載入 i18n new Vue({ i18n, router, render: (h) =\u0026gt; h(App), }).$mount(\u0026#39;#app\u0026#39;);   2. 基本用法 1 2 3 4 5 6 7 8  \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34; placeholder=\u0026#34;輸入姓名\u0026#34; v-validate=\u0026#34;\u0026#39;required\u0026#39;\u0026#34; :class=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: errors.has(\u0026#39;name\u0026#39;) }\u0026#34; /\u0026gt; \u0026lt;span v-if=\u0026#34;errors.has(\u0026#39;name\u0026#39;)\u0026#34;\u0026gt;請輸入姓名\u0026lt;/span\u0026gt;    input 標籤內要設定 name 這個特性，特性值的部分則是根據該欄位性質做設定，例：姓名就是 name，地址就是 address。 加上 v-validate=\u0026quot;'required'\u0026quot;，表示這一個欄位是必填的。 errors.has('name') ，填入 name 特性值。初始值為 fasle，當觸發 input 標籤時，就會開始驗證，如果欄位未填寫值為 true。  可以配合 v-if 顯示提式字； 或是搭配 :class 加入提式樣式。    假設要驗證 email 格式，則可以使用 v-validate=\u0026quot;'required|email'\u0026quot;。\n而 errors.first('email') 它會根據 email 驗證的各種狀態來顯示不同的提示文字。\n2.1 獲取錯誤訊息  errors.first('field')：獲取關於當前 field 的第一個錯誤訊息 collect('field')：獲取關於當前 field 的所有錯誤訊息 has('field')：當前 filed 是否有錯誤 all()：當前表單所有錯誤 any()：當前表單是否有任何錯誤  ３. 表單提交前的處理 最後我們還需要設定表單驗證方法，來避免送出錯誤的資料格式：\n1 2 3 4 5 6 7  this.$validator.validate().then((result) =\u0026gt; { if (result) { // 當驗證成功時執行 AJAX 的行為  } else { // 驗證失敗產生的行為  } });   VeeValidate 3 VeeValidate 在 v3.x版本之後的使用方法與之前完全不同。\n1. 安裝 安裝最新版本 vee-validate：\nnpm install vee-validate --save 導入：\n1 2 3 4 5 6 7 8 9 10 11 12 13  // main.js import { ValidationObserver, ValidationProvider, extend, localize} from \u0026#39;vee-validate\u0026#39;; import * as rules from \u0026#39;vee-validate/dist/rules\u0026#39;; import TW from \u0026#39;vee-validate/dist/locale/zh_TW.json\u0026#39;; Object.keys(rules).forEach((rule) =\u0026gt; { extend(rule, rules[rule]); }); localize(\u0026#39;zh_TW\u0026#39;, TW); Vue.component(\u0026#39;ValidationObserver\u0026#39;, ValidationObserver); Vue.component(\u0026#39;ValidationProvider\u0026#39;, ValidationProvider);   安裝內容會在下方依序說明。\n2. 添加規則 預設情況下，VeeValidate 不附帶任何驗證規則，這是為了使檔案輕量。\n首先導入定義規則所需的 extend 函式：\n1 2 3  import { extend } from \u0026#39;vee-validate\u0026#39;; // rules   接下來，就是加入規則。\n2.1 安裝所有規則 安裝所有規則有兩種遍歷作法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  import { extend } from \u0026#39;vee-validate\u0026#39;; import * as rules from \u0026#39;vee-validate/dist/rules\u0026#39;; // 作法一 Object.keys(rules).forEach((rule) =\u0026gt; { extend(rule, rules[rule]); }); // 作法二(with typescript) for (let [rule, validation] of Object.entries(rules)) { extend(rule, { ...validation, }); }   除了上述方法，另一種方法是安裝 vee-validate 的完整捆綁包，而不是預設捆綁包，該捆綁包預裝了所有驗證規則及其英文消息。\n將 'vee-validate' 替換成 'vee-validate/dist/vee-validate.full.esm'，就可以一次安裝所有驗證規則，而不用導入 extend 函式。\n1  import { ValidationObserver, ValidationProvider } from \u0026#39;vee-validate/dist/vee-validate.full.esm\u0026#39;;   但不建議一次安裝全部規則，應該使用下面的方式，按照需求安裝。\r 2.2 導入規則 為了避免一次加載全部規則，我們可以選擇需求來導入規則：\n1 2 3 4 5  import { extend } from \u0026#39;vee-validate\u0026#39;; import { required, email } from \u0026#39;vee-validate/dist/rules\u0026#39;; // 按需求導入規則  extend(\u0026#39;required\u0026#39;, required); extend(\u0026#39;email\u0026#39;, email);   更多可用規則可以參考 官方文件。\n3. 基本用法 導入 ValidationProvider 元件：\n1 2 3 4 5 6 7 8 9 10 11  import { ValidationProvider } from \u0026#39;vee-validate\u0026#39;; // 在 main.js 全域註冊元件 Vue.component(\u0026#39;ValidationProvider\u0026#39;, ValidationProvider); // 區域註冊元件（推薦） export default { components: { ValidationProvider, }, };   2.X 版原本是添加 v-validate，而 3.X版則改用 ValidationProvider 元件進行包裹：\n1 2 3 4 5 6 7 8 9 10  \u0026lt;ValidationProvider v-slot=\u0026#34;{ failed, errors }\u0026#34; name=\u0026#34;name\u0026#34; rules=\u0026#34;required\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34;\u0026gt;*收件人姓名\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34; :class=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: failed }\u0026#34; placeholder=\u0026#34;輸入姓名\u0026#34; /\u0026gt; \u0026lt;span v-if=\u0026#34;failed\u0026#34; class=\u0026#34;text-danger\u0026#34;\u0026gt;{{ errors[0] }}\u0026lt;/span\u0026gt; \u0026lt;/ValidationProvider\u0026gt;    name 為報錯時，顯示的名稱。 在 rules 上，添加要驗證的規則。 插槽範圍內可用的屬性，可以參考 官方文件。  errors：錯誤訊息列表，errors[0] 則代表驗證錯誤規則底下定義的 messages failed：如果經過驗證且無效，則值為 false    預設情況下，ValidationProvider 渲染器為 span 標籤，可以使用套件提供的 prop 來改變呈現標籤：\n1  \u0026lt;ValidationProvider tag=\u0026#34;div\u0026#34;\u0026gt;\u0026lt;/ValidationProvider\u0026gt;   3.3 更詳細 更多可用 prop 可以參考 官方文件。\n另外還提供了許多方法可以使用，可以參考 官方文件。\n4. 表單提交前的處理 1 2 3 4 5 6 7 8 9 10 11  import { ValidationObserver } from \u0026#39;vee-validate\u0026#39;; // 在 main.js 全域註冊元件 Vue.component(\u0026#39;ValidationObserver\u0026#39;, ValidationObserver); // 區域註冊元件（推薦） export default { components: { ValidationObserver, }, };   詳細的處理表單範例，可以參考 官方文件。\n基本範例：\n1 2 3 4 5 6  \u0026lt;ValidationObserver v-slot=\u0026#34;{ invalid }\u0026#34;\u0026gt; \u0026lt;form @submit.prevent=\u0026#34;onSubmit\u0026#34;\u0026gt; \u0026lt;!-- .... --\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; :disabled=\u0026#34;invalid\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/ValidationObserver\u0026gt;   提交按鈕目前為禁用，只有當表單通過驗證才可以送出。\n提交前驗證：\n1 2 3 4 5  \u0026lt;ValidationObserver v-slot=\u0026#34;{ handleSubmit }\u0026#34;\u0026gt; \u0026lt;form @submit.prevent=\u0026#34;handleSubmit(onSubmit)\u0026#34;\u0026gt; \u0026lt;!-- .... --\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/ValidationObserver\u0026gt;   ValidationObserver 提供了一個 handleSubmit 可用於保護表單提交的 handleSubmit 功能。\n重置表單：\n1 2 3 4 5 6  \u0026lt;ValidationObserver v-slot=\u0026#34;{ reset }\u0026#34;\u0026gt; \u0026lt;form @reset.prevent=\u0026#34;reset\u0026#34;\u0026gt; \u0026lt;!-- .... --\u0026gt; \u0026lt;button type=\u0026#34;reset\u0026#34;\u0026gt;Reset\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/ValidationObserver\u0026gt;   4.1 使用 $refs 先通過 $refs 找到 ValidationObserver 元件，呼叫組件中的方法 validate()，如果所有條件都為真（就是說所有的校驗都通過了）回傳 true，否則回傳 false。\n1 2 3 4 5  \u0026lt;ValidationObserver ref=\u0026#34;form\u0026#34;\u0026gt; \u0026lt;form @submit.prevent=\u0026#34;onSubmit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/ValidationObserver\u0026gt;   1 2 3 4 5 6 7 8 9  onSubmit () { this.$refs.form.validate().then((success) =\u0026gt; { if (success) { // 證成功後的行為包含 AJAX傳送、重製表單等等  } else { // 驗證失敗產生的行為  } }); },    官方文件。\n 4.2 顯示初始驗證狀態 使用 immediate顯示　初始驗證狀態：\n1 2 3  \u0026lt;ValidationObserver rules=\u0026#34;required\u0026#34; v-slot=\u0026#34;{ errors }\u0026#34;　immediate\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/ValidationObserver\u0026gt;   詳細的互動和用戶體驗範例，可以參考 官方文件。\n4.3 更詳細 插槽範圍內可用的屬性，可以參考 官方文件。\n更多可用 prop 可以參考 官方文件。\n5. 驗證狀態 驗證狀態\n6. 中文化 vee-validate 附帶了一個很小的 i18n 字典，可滿足基本的 i18n 需求。vee-validate 的預設語言是 en。\n雖然 vee-validate 具有 40 多個可用於互動的驗證的語言環境，但是預設情況下不會安裝它們，因此我們需要導入所需的語言環境。\n導入安裝語言環境所需的 localize 函式：\n1  import { localize } from \u0026#39;vee-validate\u0026#39;;   安裝需要的使用語言環境，並使用 localize() 增加新的語言環境：\n1 2 3  import TW from \u0026#39;vee-validate/dist/locale/zh_TW.json\u0026#39;; localize(\u0026#39;zh_TW\u0026#39;, TW);   ","description":"這週是 六角鼠年鐵人賽 第八週，紀錄 Vue 表單驗證套件 - Vee Validate 操作方法。","id":0,"section":"posts","tags":["VeeValidate","Vue"],"title":"Vue筆記 - 表單驗證套件 VeeValidate","uri":"https://chupai.github.io/posts/200328_vee-validate/"},{"content":"這週是 六角鼠年鐵人賽 第七週，挑戰剛開始時，我的文章是放在 Bloggi，而且第一週文章就是 Bloggi 如何使用（明顯混分😂），但後來想想，Bloggi 沒有留言、沒有備份、嵌入 CodePen 會跑版，為了避免之後不必要的麻煩，還是用自己建立一個 Blog 吧。\n\rGitHub Pages 架設部落格最頭痛的問題就是放網站的空間，通常架設網站不是自己用 NAS 來架設，就是花錢租主機空間。\n以上兩種方法都是需要一定的花費，但是透過 GitHub Pages 來架站，則完全免費，但也有一定的 條件：\n 網站大小不能超過 1 GB 網站每月流量不能超過 100 GB 一小時內的網站更新不得超過 10 次  以上限制對一般需求一定夠用，而且 GitHub 是著名的軟體原始碼代管服務，有一定的穩定性。\n要說唯一的缺點，就是 GitHub Pages 只能架設「靜態網站」，因此無法架設 Wordpress 之類的部落格。\n這時候就需要使用到 靜態網頁產生器 來建立 Blog。\n1. 熱門靜態網頁產生器  Top 5 Static Site Generators for 2020 10 best static site generators  Hugo 簡介  Hugo 官網\n Hugo 是一個用 Go 語言編寫的靜態網站生成器，最大的優點就是編譯速度相對於 Jekyll、Hexo 簡直是飛快。\n 基於 go 語言開發，沒有錯綜複雜的依賴關係 社區活躍 功能完善 前端語言支持的種類豐富 整體框架靈活易懂 修改即時預覽  近期有越來越多人因為 Hugo 的編譯速度，將部落格從 Hexo 搬移到 Hugo，不過 Hugo 也有一個很大的缺點，就是相對 Hexo 來說，Blog 的主題太少，也是有人因為 Hexo 有喜歡的主題而捨棄 Hugo。\n搭建 Hugo 1. 前置作業 MacOS 可以直接使用 Homebrew 安裝 Hugo。\nbrew install hugo 在 Windsow 環境必須先下載 hugo_extended_0.67.0_Windows-64bit.zip。\n解壓縮後，會有一個 hugo.exe 檔案。創建一個新資料夾：C:\\hugo，並將 hugo.exe 檔案放到裡面。\n接下來配置環境變數，點選本機（右鍵） \u0026gt; 內容 \u0026gt; 進階系統設定 \u0026gt; 環境變數 \u0026gt; Path \u0026gt; 編輯 \u0026gt; 新增路徑：C:\\hugo。\n2. 建立一個專案 開啟終端機並切換到 hugo/ 資料夾下，執行以下命令：\nhugo new site myBlog myblog 可以替換成任意名稱。\n機器上會產生一個 myBlog 資料夾，結構如下：\nmyBlog/ │ ├── archetypes/ │ │ │ └─ default.md # 預設 markdown ├── content/ # 頁面、文章（markdown） ├── data/ # 資料庫 ├── layouts/ # 自定義的樣板 ├── static/ # 靜態資源 ├── themes/ # 網站的主題 └── config.toml # 網站的配置 3. 加入主題 因為 Hugo 預設沒有任何主題的，因此必須在 Hugo Themes 選擇一個來套用。\n記得先安裝 git 工具，接下來在 myBlog/ 資料夾下加入 git 版控：\ngit init 從 Github 下載主題並將其添加到 theme 目錄中：\ngit submodule add https://github.com/AmazingRise/hugo-theme-diary.git themes/diary 如果沒安裝 git：\n 可以直接下載該主題最新版本，並解壓縮； 將資料夾重新命名 並將其移至 themes 資料夾。  最後開啟跟目錄下的 config.toml 檔案，設定使用主題：\ntheme = \u0026quot;diary\u0026quot; 或是將 theme/ 內的 config.toml 取代根目錄的。\n最基本的主題安裝流程大概是這樣。\n但要注意，因為 config 配置檔，支援 toml、yaml、json 三種格式，也可以放在 config/ 資料夾內，然後拆分不同模組的配置。所以並不是每個主題的安裝方式都相同，因此最好詳細閱讀每個主題下方的說明。\n4. 新增頁面 hugo new 會根據 archetypes/ 資料夾下的 default.md 產生在 content/ 資料夾下。\nhugo new [路徑]頁面名.md 單頁面，一般會放在 content/ 資料夾下，例如：\nhugo new about.md 文章一般會放在 content/posts/ 內，例如：\nhugo new posts/my-first-post.md 不同的主題，會有不同的資料夾結構，單頁面與文章的 Front Matter 設定也都不相同，因此可以查看主題文件說明。\n5. 本地端測試 預覽草稿 Draft：\nhugo server -D 預覽（不包含草稿）：\nhugo server 預覽網址：http://localhost:1313/\n建議在本地測試時，config.toml 設定檔內的 baseURL 先設為空值。\n自定義 1. Front Matter Front-matter 是 md 檔案最上方的分隔區域，用於指定個別檔案的變數。\n預設使用 yaml 格式，使用 --- 分隔：\n1 2 3 4 5  --- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true ---   另外還支持 toml、json 格式，分別使用 +++ 與 {} 分隔。\n預設屬性分別為：\n title：標題名，使用 hugo new 建立會與檔名相同。 date：日期，使用 hugo new 建立為目前時間。 draft：草稿，如果是 true 生成網站時，不包括此頁面。  1.1 常用 Front Matter 屬性 另外，列出其他 Hugo 支持的常用 Front Matter 屬性：\n description：內容描述，主要用於 SEO 優化。 tags：標籤。 categories：分類。 keywords：關鍵字。 url：文章 url 名稱，預設使用檔案名稱。 weight：列表頁的文章排序，越小越靠前，無設定則依照時間排序。  其他屬性，主要看你用的主題所對應到板模上的變數，主題的文件都會詳細說明。\n1.2 Archetypes Archetypes 意思為原型，可以當作是生成 md 檔案的模板。\n當我們使用 hugo new 建立 md 檔案時，會根據 archetypes/ 資料夾下的模板來建立。\n舉例來說，如果 archetypes/ 下有一個 about.md，那麼以下指令就會根據它來產生檔案。\nhugo new about.md 如果沒有相同的檔名，會根據 default.md 來產生檔案。\n2. Config Hugo 將整個網站的設定配置都集中在 config.toml 檔中，預設為 toml 格式，一樣支持另外兩種格式（yaml、json）。\n 完整 Hugo Config 可以詳閱官方文件 Configure Hugo。\n 發佈到 Github Pages 上  Host on GitHub\n 事前準備：\n 安裝 Git 2.8 以上 GitHub 帳號 Hugo 網站  1. 建立 repository 在 GitHub 建立一個 repository，命名為：帳號.github.io。\n2. 設定 baseURL 將 config.toml 配置檔內的 baseURL 設為：\n1  baseURL = \u0026#34;http://帳號.github.io/\u0026#34;   3. 建立 public 資料夾 hugo 執行 hugo 就會產生 public/ 的資料夾。\n4. 上傳 在 public/ 資料夾下執行以下命令：\ngit init git remote add origin https://github.com/帳號/帳號.github.io.git git add . git commit -m \u0026quot;my Blog\u0026quot; git push -u origin master 接下來可能會讓你輸入你的 Github 帳號和密碼，之後就可以去 Github 和 http://帳號.github.io 查看是否成功。\n5. 更新 之後添加文章，只需要重新編譯 Hugo，重新提交到 Github 即可。\ngit add . git commit -m \u0026quot;本次更新的說明\u0026quot; git push origin master 新增留言板 因為是靜態網頁，所以留言板就區要依賴第三方。\nDisqus 是整合性留言管理系統，用來管理各種社群的留言平台。\n1. 註冊帳號 註冊帳號並取得 shortname。\n流程蠻簡單的，如果不清楚，可以自行搜尋一下教學流程，這裡就不多做說明。\nLanguage 如果選擇 Chinese 只有簡體。\n2. 在 Hugo 啟用 假設你的主題已經預設 Disqus 留言板了，那麼只需要在config.toml 配置檔填入 Disqus 的 shortname。\n1  disqusShortname = \u0026#34;yourdiscussshortname\u0026#34;   如果沒有，就需要將官方提供的檔案加到你的網站中。\n在 layouts/partials/ 資料夾下，加入 disqus.html 檔案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026lt;div id=\u0026#34;disqus_thread\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; (function() { // Don\u0026#39;t ever inject Disqus on localhost--it creates unwanted  // discussions from \u0026#39;localhost:1313\u0026#39; on your Disqus account...  if (window.location.hostname == \u0026#34;localhost\u0026#34;) return; var dsq = document.createElement(\u0026#39;script\u0026#39;); dsq.type = \u0026#39;text/javascript\u0026#39;; dsq.async = true; var disqus_shortname = \u0026#39;{{ .Site.DisqusShortname }}\u0026#39;; dsq.src = \u0026#39;//\u0026#39; + disqus_shortname + \u0026#39;.disqus.com/embed.js\u0026#39;; (document.getElementsByTagName(\u0026#39;head\u0026#39;)[0] || document.getElementsByTagName(\u0026#39;body\u0026#39;)[0]).appendChild(dsq); })(); \u0026lt;/script\u0026gt; \u0026lt;noscript\u0026gt;Please enable JavaScript to view the \u0026lt;a href=\u0026#34;https://disqus.com/?ref_noscript\u0026#34;\u0026gt;comments powered by Disqus.\u0026lt;/a\u0026gt;\u0026lt;/noscript\u0026gt; \u0026lt;a href=\u0026#34;https://disqus.com/\u0026#34; class=\u0026#34;dsq-brlink\u0026#34;\u0026gt;comments powered by \u0026lt;span class=\u0026#34;logo-disqus\u0026#34;\u0026gt;Disqus\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;   如果要在本地端測試 Disqus，可以將 if (window.location.hostname == \u0026quot;localhost\u0026quot;) return; 註解掉。\n最後開啟你主題內的 layouts/_default/ 資料夾中的 single.html 在適當位置貼上下面這段：\n1  {{ partial \u0026#34;disqus.html\u0026#34; . }}   這樣就完成了。\nGoogle Analytics 1. 建立帳戶 前往 Google Analytics，可以使用 Google 帳號，直接註冊。\n建立帳戶取得 Tracking ID。\n2. Hugo 設定 在 config.toml 加入 Tracking ID：\ngoogleAnalytics = \u0026quot;UA-XXXXX-Y\u0026quot; 在主題內的 layouts/partials/ 資料夾中的 head.html 在適當位置貼上下面這段：\n1  {{ template \u0026#34;_internal/google_analytics_async.html\u0026#34; . }}   容易遇到的問題 1. Markdown 圖片路徑 在 Markdown 圖片路徑中，是以 static/ 為根目錄寫全路徑。\n圖片位置：/static/imgae/cover/post1.png，那麼在 Markdown 中寫作：\n1  ![圖片說明](/imgae/cover/post1.png)   總結 目前就先記錄到這，之後如果有用到 Hugo 其他功能再補上。\n文章部分，之後會慢慢把 Blogger 的舊文搬過來，還有 Hackmd 的筆記整理後丟過來 🙂\n","description":"這週是 六角鼠年鐵人賽 第七週，Hugo 建立 Blog。","id":1,"section":"posts","tags":["Hugo","w3HexSchool"],"title":"Hugo 建立 Blog","uri":"https://chupai.github.io/posts/200316_hugo/"},{"content":"這週是 六角鼠年鐵人賽 第六週，上週剛好接觸到 Lodash，就簡單紀錄一下。\n\r簡介 你很可能需要經常重複寫一些工具函式，尤其是處理字串與陣列或是物件。為了使開發專案更有效率且好維護，Lodash 可能是你好選擇。\nLodash 是一個一致性、模組化、高性能的 JavaScript 實用工具函式庫，包含對字串、陣列、物件等常見型別的處理函式。\n其中部分是目前 ECMAScript 尚未制訂的規範，但同時被業界所認可的輔助函式。\n Lodash Lodash 中文網  目前在寫這篇文章時，Lodash 在 github 上星數高達 43.8k，版本為 4.17.15。\n另外，在 npm 中依賴 Lodash 的 package 非常多：packages depending on lodash。\nAPI Lodash 提供了非常多的工具方法，包含\n Array：適用於 陣列，例如分割、合併、刪除、查詢、重組等操作。 Collection：適用於 陣列 和 物件，部分可用於字串，例如遍歷、分組、查詢、過濾等操作。 Date：只有一個 now 方法。 Function：函式的操作。 Lang：各種型別的轉換、判斷或是深拷貝。 Math：基本的數學運算，例如數值的四捨五入、數組的最大、最小值等等。 Number：取得隨機數、判斷數值區間、求中間值。 Object：適用於 物件，例如物件的創建、擴展、轉換、搜索、集合等操作。 Seq：常用於創建鏈式呼叫，提高執行性能（惰性計算）。 String：適用於 字串 操作。 Util：實用工具函式。  1. 為什麼不用 ES6 語法就好？ Lodash 有很多方法 ES6 已經封裝好了，而且部分方法也可以使用 ES6 語法替換。加上 ES6 越來越多主流瀏覽器支持，另外還可以使用 Babel 將 ES6 編譯成 ES5。那麼我們還需要使用 Lodash 嗎？\n可以參考以下兩篇文章：\n 在 ES6 大行其道的今天，還有必要使用 lodash 之類的庫嗎？ 為什麼不用 ES6 完全替換 Lodash  2. 惰性求值 Lodash 另一個優勢就是其優異的計算性能。很大部分就來源於其使用的算法「惰性求值」。\n關於 惰性求值 可以參考以下文章：\n 惰性求值——lodash源碼解讀  3. SameValueZero 相等比 部分方法使用 SameValueZero 相等比，關於 SameValueZero 可以看這篇文章： ECMAScript 6相等演算 。\n安裝 1. 瀏覽器 下載檔案，直接引入：\n1  \u0026lt;script src=\u0026#34;lodash.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   或是使用 CDN。\n2. 在專案中使用 lodash 透過 npm 安裝：\nnpm i --save lodash 接著在你的程式碼中 import 即可：\n1  import _ from \u0026#39;lodash\u0026#39;;   但這樣做會將整包 Lodash 打包進去。如果只使用 Lodash 其中一兩個方法，會造成了不必要的資源浪費。\n解決辦法有三種：\n 單獨引入：lodash 每個函式都具有單獨的模組，可以只引入需要的模組。  1 2 3 4 5  import _map from \u0026#39;lodash.map\u0026#39;; import _random from \u0026#39;lodash.random\u0026#39;; // or import _map from \u0026#39;lodash/map\u0026#39;; import _random from \u0026#39;lodash/random\u0026#39;;    使用套件優化：  lodash-webpack-plugin babel-plugin-lodash   使用 lodash-es：  1  import { mapm , random } from \u0026#39;lodash-es\u0026#39;;   不過，是否需要對 Lodash 優化，可以參考這篇文章：lodash 在 webpack 中的各項優化的嘗試。\n2. Vue Cli Vue 除了上述方式，還可以使用 vue-lodash 套件：\n1 2 3 4 5  // main.js import Vue from \u0026#39;vue\u0026#39;; import VueLodash from \u0026#39;vue-lodash\u0026#39;; import lodash from \u0026#39;lodash\u0026#39;; Vue.use(VueLodash, { name: \u0026#39;custom\u0026#39;, lodash: lodash });   1 2 3 4 5 6 7 8 9 10 11 12 13  export default { methods: { test() { console.log( this.lodash.random(20) ); console.log( this._.random(20) ); console.log( this.custom.random(20) ); }, } }; console.log( Vue.lodash.random(20) ); console.log( Vue._.random(20) ); console.log( Vue.custom.random(20) );   常用方法 由於 Lodash 中 API 太多了，這裡只會列幾個會常用到的方法並簡單說明。更詳細的用法、參數可以看官方 API 文件。\n1. Array _.union() 將陣列合併，並去除重複的元素（SameValueZero 相等比較），會回傳一個新陣列。\n1  _.union([arrays])    [arrays] (...Array): 陣列組 回傳值：回傳新的陣列  1 2 3 4 5  let arr1 = [1, 2, 3, 4]; let arr2 = [2, 4, 6, 8]; let arr3 = [3, 5, 7, 9]; console.log( _.union(arr1, arr2, arr3) );   如果元素是物件，可使用 _.unionBy，另外還有 _.unionWith() 可以呼叫一個比較函式。\n_.intersection() 取得陣列組的交集元素（使用 SameValueZero 相等比較）。\n1  _.intersection([arrays])    [arrays] (...Array)：陣列組 回傳值：交集元素陣列  1 2 3 4 5 6 7  let arr1 = [0, 1, 2, 3, 4]; let arr2 = [0, 2, 4, 6, 8]; let arr3 = [0, 2, 3, 5, 7, 9]; console.log( _.intersection(arr1, arr2, arr3) ); // [0, 2]   如果元素是物件，可使用 _.intersectionBy()，另外還有 _.intersectionWith() 可以呼叫一個比較函式。\n_.difference() 檢查一個陣列，並將指定的值排除（SameValueZero 相等比較），會回傳一個新陣列。\n與 _.difference() 類似的方法還有 _.without() 與 _.pull()。\n1  _.difference(array, [values])    array (Array)：需要被檢查的陣列 [values] (...Array)：需要排除的值（放在陣列中） 回傳值：回傳新的陣列  1 2 3  let arr = [0, 1, 2, 3, 4]; console.log( _.difference(arr, [2, 4, 6, 8]) ); // [0, 1, 3]   如果元素是物件，可使用 _.differenceBy()，另外還有 _.differenceWith() 可以呼叫一個比較函式。\n_.uniq() 陣列重組，去除重複的元素（SameValueZero 相等比較），會回傳一個新陣列。\n1  _.uniq(array)    array (Array): 要檢查的陣列 回傳值：回傳新的陣列  1 2  console.log( _.uniq([1, 2, 2, 4, 1, 5]) ); // [1, 2, 4, 5]   如果元素是物件，可使用 _.uniqBy()，另外還有 _.uniqWith() 可以呼叫一個比較函式。\n_.indexOf() 搜尋陣列是否有值為 value 的元素（使用 SameValueZero 等值比較），並回傳第一個符合的索引值。\n1  _.indexOf(array, value, [fromIndex=0])    array (Array)：要查詢的陣列 value (*)：條件值 [fromIndex=0] (number)：初始位置  預設值為 0 也就是開頭 如果 fromIndex 為負值，則從陣列結尾數過來   回傳值：匹配值的索引值，否則回傳 -1  1 2 3 4 5  let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; console.log( _.indexOf(arr, \u0026#39;b\u0026#39;) ); // 1 console.log( _.indexOf(arr, \u0026#39;b\u0026#39;, -1) ); // -1 console.log( _.indexOf(arr, \u0026#39;b\u0026#39;, -2) ); // 4   _.lastIndexOf() 這個方法類似 indexOf ，區別是它是從右到左遍歷陣列的元素，預設起始位置為結尾。\n1  _.lastIndexOf(array, value, [fromIndex=array.length-1])    array (Array)：要查詢的陣列 value (*)：條件值 [fromIndex=array.length-1](number)：初始位置  預設值為 array.length-1 也就是結尾 如果 fromIndex 為負值，則從陣列結尾數過來   回傳值：匹配值的索引值，否則回傳 -1  1 2 3 4 5 6  let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; console.log( _.lastIndexOf(arr, \u0026#39;b\u0026#39;) ); // 4 console.log( _.lastIndexOf(arr, \u0026#39;b\u0026#39;, 0) ); // -1 console.log( _.lastIndexOf(arr, \u0026#39;b\u0026#39;, 2) ); // 1 console.log( _.lastIndexOf(arr, \u0026#39;b\u0026#39;, -2) ); // 4   2. Collection Collection（集合）的方法 陣列 或 物件 都可以使用，部分方法字串也可以。\n其中 map 及 filter 方法最常使用，因為原生 JavaScrtip 中是不支援物件的，因此當需要迭代物件時，會使用 for in 或 Object.keys。\n_.map() 迭代的集合的方法，回傳一個新陣列。\n1  _.map(collection, [iteratee=_.identity])    collection (Array|Object)：用來迭代的集合。 [iteratee=_.identity] (Array|Function|Object|string)：每次迭代呼叫的函式。  參數：(value, index|key, collection)   回傳值：新陣列  Lodash 中有許多方法是防止作為其他方法的迭代函式（註：即不能作為 iteratee 參數傳遞給其他方法），例如： _.every、 _.filter、 _.map、 _.mapValues、 _.reject 和 _.some。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  console.log( _.map([4, 8], (n) =\u0026gt; n * n) ); // [16, 64]  const square = (n) =\u0026gt; n * n; let arr = [2, 4]; let obj = { a: 2, b: 4 }; console.log( _.map(arr, square) ); // [4, 16]  console.log( _.map(obj, square) ); // [4, 16]  let users = [{ user: \u0026#39;barney\u0026#39; }, { user: \u0026#39;fred\u0026#39; }]; console.log( _.map(users, \u0026#39;user\u0026#39;) ); // [\u0026#39;barney\u0026#39;, \u0026#39;fred\u0026#39;]   另外可以參考這篇文章：map () 誰比較快和輕量？ Lodash vs ES6。\n_.filter() 根據條件過濾出符合條件的元素。\n1  _.filter(collection, [predicate=_.identity])    collection (Array|Object)：一個用來迭代的集合。 [predicate=_.identity] (Array|Function|Object|string)：每次迭代呼叫的函式。 回傳值：回傳新的陣列  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  let users = [ { user: \u0026#39;barney\u0026#39;, age: 36, active: true }, { user: \u0026#39;fred\u0026#39;, age: 40, active: false }, ]; _.filter(users, function(o) { return !o.active; }); // =\u0026gt; objects for [\u0026#39;fred\u0026#39;]  // The `_.matches` iteratee shorthand. _.filter(users, { age: 36, active: true }); // =\u0026gt; objects for [\u0026#39;barney\u0026#39;]  // The `_.matchesProperty` iteratee shorthand. _.filter(users, [\u0026#39;active\u0026#39;, false]); // =\u0026gt; objects for [\u0026#39;fred\u0026#39;]  // The `_.property` iteratee shorthand. _.filter(users, \u0026#39;active\u0026#39;); // =\u0026gt; objects for [\u0026#39;barney\u0026#39;]   _.includes() 檢查 value 是否在 collection中。\n1  _.includes(collection, value, [fromIndex=0])   collection (Array|Object|string)：要檢索的集合。\nvalue (*)：要檢索的值。\n[fromIndex=0] (number)：要檢索的索引位置。\n 回傳值：布林值  如果 collection 是一串，value 就是字元，否則使用 SameValueZero 做等值比較。\n1 2 3 4 5 6 7 8 9 10 11  _.includes([1, 2, 3], 1); // =\u0026gt; true  _.includes([1, 2, 3], 1, 2); // =\u0026gt; false  _.includes({ user: \u0026#39;fred\u0026#39;, age: 40 }, \u0026#39;fred\u0026#39;); // =\u0026gt; true  _.includes(\u0026#39;pebbles\u0026#39;, \u0026#39;eb\u0026#39;); // =\u0026gt; true   _.shuffle() 將集合打亂（使用 Fisher-Yates shuffle 洗牌算法）。\n1  _.shuffle(collection)    collection (Array|Object)：要打亂的集合 回傳值：回傳隨機元素的陣列  1 2 3 4 5 6 7 8 9  let arr = [0, 1, 2, 3, 4]; console.log( _.shuffle(arr) ); // [ 3, 4, 1, 0, 2 ] console.log( _.shuffle(arr) ); // [ 3, 0, 2, 4, 1 ]  let obj = { a: 1, b: 2, c: 3 }; console.log( _.shuffle(obj) ); // [ 2, 3, 1 ] console.log( _.shuffle(obj) ); // [ 1, 3, 2 ]   _.sampleSize() 從集合中獲得 n 個隨機元素。\n1  _.sampleSize(collection, [n=1])    collection (Array|Object)：要取樣的集合 [n=1] (number)：取樣的元素個數。 回傳值：回傳隨機元素的陣列  1 2 3 4 5 6  let arr = [0, 1, 2, 3, 4]; console.log( _.sampleSize(arr, 1) ); // [2] console.log( _.sampleSize(arr, 1) ); // [0] console.log( _.sampleSize(arr, 2) ); // [2, 1] console.log( _.sampleSize(arr, 2) ); // [0, 4]   _.sortBy() 創建一個元素陣列。以 iteratee 處理的結果升序排序。這個方法執行穩定排序，也就是說相同元素會保持原始排序\n1  _.sortBy(collection, [iteratees=[_.identity]])    collection (Array|Object)：用來迭代的集合。 [iteratees=[_.identity]] (...* (Array|Array[]|Function|Function[]|Object|Object[]|string|string[]))：這個函式決定排序。 回傳值：排序後的陣列  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  let arr = [1, 65, 44, 2, 3, 55]; console.log( _.sortBy(arr) ); let users = [ { user: \u0026#39;fred\u0026#39;, age: 48 }, { user: \u0026#39;barney\u0026#39;, age: 36 }, { user: \u0026#39;fred\u0026#39;, age: 40 }, { user: \u0026#39;barney\u0026#39;, age: 34 }, ]; console.log(_.sortBy(users, (item) =\u0026gt; item.user)); // [ { user: \u0026#39;barney\u0026#39;, age: 36 }, // { user: \u0026#39;barney\u0026#39;, age: 34 }, // { user: \u0026#39;fred\u0026#39;, age: 48 }, // { user: \u0026#39;fred\u0026#39;, age: 40 } ]  console.log(_.sortBy(users, \u0026#39;age\u0026#39;)); // [ { user: \u0026#39;barney\u0026#39;, age: 34 }, // { user: \u0026#39;barney\u0026#39;, age: 36 }, // { user: \u0026#39;fred\u0026#39;, age: 40 }, // { user: \u0026#39;fred\u0026#39;, age: 48 } ]  console.log(_.sortBy(users, [\u0026#39;user\u0026#39;, \u0026#39;age\u0026#39;])); // [ { user: \u0026#39;barney\u0026#39;, age: 34 }, // { user: \u0026#39;barney\u0026#39;, age: 36 }, // { user: \u0026#39;fred\u0026#39;, age: 40 }, // { user: \u0026#39;fred\u0026#39;, age: 48 } ]   3. Object _.get() 根據物件的路徑取值，沒有則回傳 undefined，可以設定預設值。\n1  _.get(object, path, [defaultValue])    object (Object)：要檢索的物件。 path (Array|string)：要獲取屬性的路徑，可以是字串或陣列。 [defaultValue] (*)：預設值。 回傳值：解析的值  1 2 3 4 5 6 7  let obj = { id: \u0026#39;1234\u0026#39;, list: [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;] }; console.log( _.get(obj, \u0026#39;id\u0026#39;) ); // \u0026#39;1234\u0026#39; console.log( _.get(obj, \u0026#39;list[0]\u0026#39;) ); // \u0026#39;a\u0026#39; console.log( _.get(obj, [\u0026#39;list\u0026#39;, \u0026#39;3\u0026#39;]) ); // \u0026#39;d\u0026#39; console.log( _.get(obj, \u0026#39;name\u0026#39;); // undefined console.log( _.get(obj, \u0026#39;name\u0026#39;, \u0026#39;no-find\u0026#39;) ); // \u0026#39;no-find\u0026#39;   _.pick() 創建一個從 object 中選中的屬性的物件。\n1  _.pick(object, [props])    object (Object)：來源物件。 [props] (...(string|string[]))：選中的屬性。（註：單獨指定或指定在陣列中。） 回傳值：回傳新物件  1 2 3  let object = { a: 1, b: \u0026#39;2\u0026#39;, c: 3 }; console.log( _.pick(object, [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;]) ); // { a:1, c:3 }   _.omit 為反向版的 _.pick。\n_.pickBy() 創建一個物件，這個物件組成為從 object 中經 predicate 判斷為真值的屬性。\n1  _.pickBy(object, [predicate=_.identity])    object (Object)：來源物件。 [predicate=_.identity] (Function)：呼叫每一個屬性的函式。  有 2個參數：(value, key)。   回傳值：回傳新物件  1 2 3 4  let obj = { a: 1, b: \u0026#39;2\u0026#39;, c: 3 }; console.log( _.pickBy(obj, _.isNumber) ); // { \u0026#39;a\u0026#39;: 1, \u0026#39;c\u0026#39;: 3 }   _.omitBy 為反向版的 _.pickBy。\n_.defaults() 安全的合併物件，遇到重複的屬性則忽略。\n1  _.defaults(object, [sources])    object (Object)：目標物件。 [sources] (...Object)：來源物件。 回傳值：這方法會改變目標物件，回傳目標物件  1 2 3 4 5 6 7 8  let obj1 = { foo: 1, boo: 2 }; let obj2 = { foo: 3, zoo: 4 }; let r = _.defaults(obj1, obj2); console.log(r); // { foo: 1, boo: 2, zoo: 4 } console.log(obj1); // { foo: 1, boo: 2, zoo: 4 } console.log(obj1 === r); // true   4. Lang _.cloneDeep() 資料的深拷貝。\n1  _.cloneDeep(value)    value (*)：要拷貝的資料。 回傳值：回傳拷貝的資料。  1 2 3 4  let obj = { a: { b: 1 } }; let newObj = _.cloneDeep(obj); console.log( obj.a === newObj.a ); // false   另外，可以參考以下文章：\n lodash源碼分析——deepclone，基於4.17.10版本\n Lodash 是如何實現深拷貝的  _.isEqual() 執行深比較來確定兩者的值是否相等。\n1  _.isEqual(value, other)    value (*)：用來比較的值。 other (*)：另一個用來比較的值。 回傳值：布林值  如果是物件，則比較自身的屬性，不包括繼承的和可列舉的屬性。不支持函式和DOM 節點比較。\n1 2 3 4 5 6 7  let object = { a: 1 }; let other = { a: 1 }; console.log(object === other); // false console.log(_.isEqual(object, other)); // true   5. Number _.clamp() 設定數值上下限，超出範圍，回傳上限或下限，否則回傳數值本身。\n1  _.clamp(number, [lower], upper)    number (number)：被限制的值。 [lower] (number)：可選，下限值。 upper (number)：上限值。 回傳值：  number 大於 upper 回傳 lower number 小於 lower 回傳 lower 在 upper 之間 lower 回傳 number 本身    1 2 3 4 5 6  console.log( _.clamp(5, 10) ); // 5 console.log( _.clamp(11, 10) ); // 10  console.log( _.clamp(11, -10, 10) ); // 10 console.log( _.clamp(-11, -10, 10) ); // -10 console.log( _.clamp(0, -10, 10) ); // 0   _.random() 隨機產生一個包括 lower 與 upper 之間的數，如果只設置一個參數則回傳 0 到該數之間的數值。\n1  _.random([lower=0], [upper=1], [floating])    [lower=0] (number)：下限。 [upper=1] (number)：上限。 [floating] (boolean)：指定是否回傳浮點數。  lower 與 upper 非浮點數預設為 false    1 2 3 4 5 6 7 8 9 10  _.random(5); // between 0 and 5 _.random(-5); // between -5 and 0 _.random(5, 10); // between 5 and 10 _.random(5, true); // a floating-point number between 0 and 5 _.random(1.2, 5.2); // a floating-point number between 1.2 and 5.2   _.inRange() 檢查 number 是否在 start 與 end 之間（但不包括 end）。\n1  _.inRange(number, [start=0], end)    number (number)：要檢查的值。 [start=0] (number)：開始範圍。  可選，沒設置預設值為 0。   end (number)：結束範圍。  如果第二個參數大於第三個參數，大的為 end。    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  _.inRange(3, 2, 4); // 3 是否在 2~3 之間 =\u0026gt; true _.inRange(4, 8); // 4 是否在 0~7 之間 =\u0026gt; true _.inRange(4, 2); // 4 是否在 0~1 之間 =\u0026gt; false _.inRange(2, 2); // 2 是否在 0~1 之間 =\u0026gt; false _.inRange(1.2, 2); // 1.2 是否在 0~1 之間 =\u0026gt; true _.inRange(3.2, 4); // 3.2 是否在 0~3 之間 =\u0026gt; false _.inRange(0, 4, 0); // 0 是否在 0~3 之間 =\u0026gt; true _.inRange(-3, -2, -6); // -3 是否在 -6~-2 之間 =\u0026gt; true   6. Util _.range() 建立一個指定範圍的數值陣列。\n1  _.range([start=0], end, [step=1])    [start=0] (number：開始的範圍。 end (number)：結束的範圍（不包括自己）。 [step=1] (number)：範圍的增量 或者 減量。  只有一個參數 _.range(n) 等同 _.range(0, n, 1)，如果是負數 _.range(-n) 等同 _.range(0, n, -1)。\nend 小於 start 而且 step 非負數，會創建一個空陣列。\n1 2 3 4 5 6  console.log( _.range(4) ); // [0, 1, 2, 3, 4] console.log( _.range(-4) ); // [0, -1, -2, -3] console.log( _.range(1, 4) ); // [1, 2, 3] console.log( _.range(0, 10, 5) ); // [0, 5, 10] console.log( _.range(0, -4, -1) ); // [0, -1, -2, -3] console.log( _.range(1, 4, 0) ); // [1, 1, 1]   _.times() 呼叫 iteratee 函式 n 次，並將結果存到陣列中，並回傳該陣列。\n1  _.times(n, [iteratee=_.identity])    n (number)：呼叫 iteratee 的次數。 [iteratee=_.identity] (Function)：每次迭代呼叫的函式，參數為 index。  1 2 3 4  console.log(_.times(3, String)); // [\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;] console.log(_.times(3, (index) =\u0026gt; index * index)); // [0, 1, 4]   _.uniqueId() 生成唯一 ID，可以添加前綴。\n1  _.uniqueId([prefix=\u0026#39;\u0026#39;])    [prefix=''] (string)：要添加到 ID 前綴的值。 回傳值：回傳生成的唯一 ID 字串。  1 2 3  console.log( _.uniqueId() ); // \u0026#39;1\u0026#39; console.log( _.uniqueId() ); // \u0026#39;2\u0026#39; console.log( _.uniqueId(\u0026#39;book\u0026#39;) ); // \u0026#39;book3\u0026#39;   7. Math _.sum() 陣列的總和。\n1  _.sum(array)   1 2  _.sum([4, 2, 8, 6]); // =\u0026gt; 20   如果元素是物件，可以使用 _.sumBy()。\n總結 這週先記錄到這邊，有空慢慢補上，下週見。\n","description":"這週是 六角鼠年鐵人賽 第六週，上週剛好接觸到 Lodash，就簡單紀錄一下。","id":2,"section":"posts","tags":["Lodash","w3HexSchool"],"title":"Lodash - JS 實用工具函式庫","uri":"https://chupai.github.io/posts/200315_lodash/"},{"content":"這週是 六角鼠年鐵人賽 第五週，紀錄一下 Vue Transition 用法。\n前言 在日常開發中，網頁動態效果是必不可少的一部分，不僅能讓元素直接的切換顯得更加自然，同時也能極大的增強用戶體驗。\n雖然我們可以使用原生 CSS 或 JS 來實現動態效果，但 Vue 提供了更簡單和高效的方式。\n1. Vue 的轉場工具 Vue 在插入、更新或者移除 DOM 時，提供多種不同方式的應用轉場效果。包括以下工具：\n 在 CSS transition 和 animation 中自動應用 class 名稱； 也可以配合使用第三方 CSS 動畫庫，例如 Animate.css。 在轉場鉤子函式中使用 JavaScript 直接操作 DOM； 也可以配合使用第三方 JavaScript 動畫庫，例如 Velocity.js。  transition 元件 Vue 提供了 transition 的封裝元件，在下列情形中，可以給任何元素和元件添加進入/離開的轉場效果：\n 元素或元件初始渲染時 元素或元件顯示/隱藏時（使用 v-if 或 v-show） 元素或元件切換時  先看一個簡單的基本範例：\n1 2 3 4  \u0026lt;button v-on:click=\u0026#34;show = !show\u0026#34;\u0026gt;Toggle\u0026lt;/button\u0026gt; \u0026lt;transition\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   1 2 3  data: { show: true, },   1 2 3 4 5 6 7 8 9 10 11  .v-enter, .v-leave-to { opacity: 0; } .v-leave, .v-enter-to { opacity: 1; } .v-enter-active, .v-leave-active { transition: opacity 1s; }   當我們使用 transition 元件將元素包住，Vue 會做以下處理：\n 自動偵測目標元素是否應用 CSS transition/animation 如果是，在恰當的時機添加/刪除 CSS 類別名稱。 如果 transition 元件提供了 JavaScript 鉤子函式，這些鉤子函式將在恰當的時機被呼叫。 如果沒有找到 JavaScript 鉤子並且也沒有檢測到 CSS transition/animation，DOM 操作 (插入/刪除) 在下一幀中立即執行。  See the Pen Vue CSS 轉場 基本範例 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  1. CSS 轉場的類別名稱 transition 元件共提供了，六種類別名稱提供切換。\n進場：\n v-enter：定義進場的開始狀態。  在元素被插入之前生效，插入之後的下一幀被移除   v-enter-active：定義進場生效時的狀態，在整個進場的階段中應用。  在元素被插入之前生效，在 transition/animation 完成之後移除 可用來定義進場的過程時間，延遲和曲線函數   v-enter-to：2.1.8版及以上 定義進場的結束狀態。  在元素被插入之後下一幀生效（與此同時 v-enter 被移除），在 transition/animation 完成之後移除    離場：\n v-leave：定義離場的開始狀態。  在離場被觸發時立刻生效，下一幀被移除   v-leave-active：定義離場生效時的狀態，在整個離場的階段中應用。  在離場被觸發時立刻生效，在 transition/animation 完成之後移除 這個類可以被用來定義離場的過程時間，延遲和曲線函數   v-leave-to：2.1.8版及以上 定義離場的結束狀態。  在離開轉場被觸發之後下一幀生效（與此同時 v-leave 被移除），在 transition/animation 完成之後移除    通常會設定 v-enter 與 v-leave-active 相同的效果、v-leave 與 v-enter-to 相同的效果，達到同尾相接形成一個循環，而 v-enter-to 與 v-leave-to 會用來設定轉場時間或動畫。\nenter-to 預設 opacity: 1、transform: none，所以不一定要設定。\r1.1 CSS transition transition 元件預設使用上述 v- 前綴的類別名稱。請參考一開始基本範例。\n因為不可能只用一種動態效果，因此使用自訂義的前綴，需要加上 name 特性，舉例來說，\u0026lt;transition name=\u0026quot;fade\u0026quot;\u0026gt;，套用的那麼類別名稱的前綴就會是 fade-enter。\n1 2 3 4 5 6  \u0026lt;button v-on:click=\u0026#34;show = !show\u0026#34;\u0026gt; Toggle \u0026lt;/button\u0026gt; \u0026lt;transition name=\u0026#34;fade\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   設定一個進場由透明度 0 變 1 並由右測 100px 處滑入，並且進場、離場分別設定不同的曲線函數：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  .fade-enter, .fade-leave-to { opacity: 0; transform: translateX(100px); } .fade-leave, .fade-enter-to { opacity: 1; } .fade-enter-active { transition: all 0.3s ease; } .fade-leave-active { transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1); }   See the Pen Vue CSS 轉場 轉場範例 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  再舉一個例子，由下往上進場，由右出場：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  .fade-enter { opacity: 0; transform: translateY(100%); } .fade-enter-to, .fade-leave { opacity: 1; } .fade-leave-to { opacity: 0; transform: translateX(100%); } .fade-enter-active,.fade-leave-active { transition: all 0.8s ease; }   See the Pen Vue CSS 轉場 轉場範例2 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  1.2 CSS animation CSS animation 用法同 CSS transition，區別是在動畫中 v-enter 類名在節點插入 DOM 後不會立即刪除，而是在 animationend 事件觸發時刪除。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  .bounce-enter-active { animation: bounce-in 0.5s; } .bounce-leave-active { animation: bounce-in 0.5s reverse; } @keyframes bounce-in { 0% { transform: scale(0); } 50% { transform: scale(1.5); } 100% { transform: scale(1); } }   See the Pen Vue CSS 轉場 動畫範例 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 使用自訂義類別名稱 我們可以通過以下 transition 元件特性來使用自訂義類別名稱：\n enter-class enter-active-class enter-to-class 2.1.8+ leave-class leave-active-class leave-to-class 2.1.8+  他們的優先級高於普通的類別名稱。\n舉個簡單得範例，來說明使用方式：\n1 2 3 4 5 6 7  .opacity-0 { opacity: 0; } .trs-time-3 { transition-duration: 3s; }   1 2 3 4 5 6 7 8  \u0026lt;transition enter-class=\u0026#34;opacity-0\u0026#34; leave-to-class=\u0026#34;opacity-0\u0026#34; enter-active-class=\u0026#34;trs-time-3\u0026#34; leave-active-class=\u0026#34;trs-time-3\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   See the Pen Vue CSS 轉場 自訂義 class by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2.1 第三方 CSS 動畫庫 自訂義類別名稱，對於套用第三方 CSS 動畫庫結合非常方便。\n舉例來說，使用 Animate.css 的動畫效果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;button v-on:click=\u0026#34;show = !show\u0026#34;\u0026gt; Toggle \u0026lt;/button\u0026gt; \u0026lt;transition enter-active-class=\u0026#34;animated tada\u0026#34; leave-active-class=\u0026#34;animated bounceOutRight\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;transition enter-active-class=\u0026#34;animated fadeInUp\u0026#34; leave-active-class=\u0026#34;animated flipInY\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   See the Pen Vue CSS 轉場 Animate.css by CHUPAIWANG (@CHUPAIWANG) on CodePen.  或者是 magic.css：\n1 2 3 4 5 6 7 8 9  \u0026lt;button v-on:click=\u0026#34;show = !show\u0026#34;\u0026gt; Toggle \u0026lt;/button\u0026gt; \u0026lt;transition enter-active-class=\u0026#34;magictime foolishIn\u0026#34; leave-active-class=\u0026#34;magictime tinDownOut\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   See the Pen Vue CSS 轉場 magic by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 轉場時間 3.1 同時使用 transition/animation Vue 為了知道轉場的完成，必須設置相應的事件監聽器。它可以是 transitionend 或 animationend，這取決於給元素應用的 CSS 規則。如果你使用其中任何一種，Vue 能自動識別類型並設置監聽。\n但有時候會遇到需要同時設置的情況，但兩邊的完成時間不一致，這時候就需要手動設置 transitionend 或 animationend 來明確告知 Vue 要監聽的類型。\n舉例來說，假設你分別使用自訂義的類別名稱和 Animate.css ：\n1 2 3 4 5 6 7 8 9 10 11  .fade-enter,.fade-leave-to { opacity: 0; } .fade-enter-to, .fade-leave { opacity: 1; } .fade-enter-active,.fade-leave-active { transition: opacity 3s; }   1 2 3 4 5 6 7 8  \u0026lt;transition name=\u0026#34;fade\u0026#34; type=\u0026#34;transition\u0026#34; enter-active-class=\u0026#34;animated swing fade-enter-active\u0026#34; leave-active-class=\u0026#34;animated bounce fade-leave-active\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   這裡要注意，使用自訂義類別名稱優先度大於普通的類別名稱，所以fade-enter-active 和 fade-leave-active 記得要補上。\nAnimate.css 預設動畫時間為 1s，而我們設置的 transition 時間為 3s，Animate.css 的動畫很外就觸發完成了，而轉場還沒結束。在很多情況下，Vue 可以自動得出轉場效果的完成時機，但還是有可能出現例外。\n為了避免出現例外，你就需要手動設定 type=\u0026quot;transition\u0026quot; 以 transition 的時間為準。反之動畫時間大於轉場就以動畫時間為準。\nSee the Pen Vue CSS 轉場 同时使用轉場和動畫 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3.2 顯性的轉場持續時間 上面已經提過了，在很多情況下，Vue 可以自動得出轉場效果的完成時機。預設情況下，Vue 會等待其在轉場效果的根元素的第一個 transitionend 或 animationend 事件。\n但在某些情況下，還可以自定義整個動態效果總時間長，使用的是 duration 特性搭配 v-bind。\n舉例來說，總時常為 5s：\n1  \u0026lt;transition :duration=\u0026#34;5000\u0026#34;\u0026gt;...\u0026lt;/transition\u0026gt;   也可以分別設定進入和移除持續時間：\n1  \u0026lt;transition :duration=\u0026#34;{ enter: 500, leave: 800 }\u0026#34;\u0026gt;...\u0026lt;/transition\u0026gt;   這是一個 transition 需要 5秒，但總轉場時間強制設為 1秒的範例：\nSee the Pen Vue CSS 轉場 顯性的轉場持續時間 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  4.初始渲染的轉場 透過設定 appear 特性，設置節點在初始渲染的轉場。\n1 2 3  \u0026lt;transition appear\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/transition\u0026gt;    CodePen，載入畫面時，會有進場效果。\n appear 預設使用進場的類別，如果要與進場套用不同的動畫效果，需要使用自定義的類別名稱：\n1 2 3  \u0026lt;transition appear\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/transition\u0026gt;    CodePen，載入畫面時，會有進場效果。\n appear 預設使用進場的類別，如果要與進場套用不同的動畫效果，需要使用自定義的類別名稱：\n1 2 3 4 5 6 7 8  \u0026lt;transition appear appear-class=\u0026#34;custom-appear-class\u0026#34; appear-to-class=\u0026#34;custom-appear-to-class\u0026#34; (2.1.8+) appear-active-class=\u0026#34;custom-appear-active-class\u0026#34; \u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/transition\u0026gt;   多個元素的轉場 \u0026lt;transition\u0026gt; 也可以用在多個元素的轉場。\n舉例來說：\n1 2 3 4 5 6  \u0026lt;transition\u0026gt; \u0026lt;table v-if=\u0026#34;items.length \u0026gt; 0\u0026#34;\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;p v-else\u0026gt;Sorry, no items found.\u0026lt;/p\u0026gt; \u0026lt;/transition\u0026gt;   但要注意，Vue 在切換畫面時，並不會完全置換元素，會使用一種最大限度減少動態元素並且儘可能的嘗試修復/再利用相同類型元素的算法。\n因此當有相同標籤的元素在做切換時，需要使用 key 特性設置唯一的值來標記以讓 Vue 區分它們。\n1 2 3 4 5 6 7 8  \u0026lt;transition\u0026gt; \u0026lt;button v-if=\u0026#34;isEditing\u0026#34; key=\u0026#34;save\u0026#34;\u0026gt; Save \u0026lt;/button\u0026gt; \u0026lt;button v-else key=\u0026#34;edit\u0026#34;\u0026gt; Edit \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   在一些場景中，也可以通過給同一個元素的 key 特性設置不同的狀態來代替 v-if 和 v-else，上面的範例可以重寫為：\n1 2 3 4 5  \u0026lt;transition\u0026gt; \u0026lt;button v-bind:key=\u0026#34;isEditing\u0026#34;\u0026gt; {{ isEditing ? \u0026#39;Save\u0026#39; : \u0026#39;Edit\u0026#39; }} \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   使用多個 v-if 的多個元素的轉場可以重寫為綁定了動態屬性的單個元素轉場。例如：\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;transition\u0026gt; \u0026lt;button v-if=\u0026#34;docState === \u0026#39;saved\u0026#39;\u0026#34; key=\u0026#34;saved\u0026#34;\u0026gt; Edit \u0026lt;/button\u0026gt; \u0026lt;button v-if=\u0026#34;docState === \u0026#39;edited\u0026#39;\u0026#34; key=\u0026#34;edited\u0026#34;\u0026gt; Save \u0026lt;/button\u0026gt; \u0026lt;button v-if=\u0026#34;docState === \u0026#39;editing\u0026#39;\u0026#34; key=\u0026#34;editing\u0026#34;\u0026gt; Cancel \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   可以重寫為：\n1 2 3 4 5 6  \u0026lt;!-- .html --\u0026gt; \u0026lt;transition\u0026gt; \u0026lt;button :key=\u0026#34;docState\u0026#34;\u0026gt; {{ buttonMessage }} \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   1 2 3 4 5 6 7 8 9 10  // ... computed: { buttonMessage: function () { switch (this.docState) { case \u0026#39;saved\u0026#39;: return \u0026#39;Edit\u0026#39; case \u0026#39;edited\u0026#39;: return \u0026#39;Save\u0026#39; case \u0026#39;editing\u0026#39;: return \u0026#39;Cancel\u0026#39; } } }   1. 轉場模式 請考慮以下程式碼：\n1 2 3 4 5  \u0026lt;transition\u0026gt; \u0026lt;button :key=\u0026#34;isEditing\u0026#34; @click=\u0026#34;isEditing = !isEditing\u0026#34;\u0026gt; {{ isEditing ? \u0026#39;On\u0026#39; : \u0026#39;Off\u0026#39; }} \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   See the Pen Vue CSS 轉場 轉場模式 問題 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  在 on 按鈕和 off 按鈕的轉場中，兩個按鈕都被重繪了，一個離開轉場的時候另一個開始進入轉場。這是 \u0026lt;transition\u0026gt; 的預設行為，進入和離開同時發生。\n你可能會想到，可以加上 position: absolute，因為兩者重疊了，所以不會產生元素位移的情況：\n1 2 3  button { position: absolute; }   See the Pen Vue CSS 轉場 轉場模式 絕對定位 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  但如果加上 translate 讓它們運動像滑動，還是會有兩個元素同時出現的破綻：\n1 2 3 4 5  .v-enter, .v-leave-to { opacity: 0; transform: translateX(100%); }   See the Pen Vue CSS 轉場 轉場模式 絕對定位 + 滑動 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  同時生效的進入和離開的轉場不能滿足所有要求，所以 Vue 提供了轉場模式：\n in-out：新元素先進行轉場，完成之後當前元素轉場離開。 out-in：當前元素先進行轉場，完成之後新元素轉場進入。  加上 mode=\u0026quot;out-in\u0026quot; 的效果：\n1 2 3 4 5  \u0026lt;transition mode=\u0026#34;out-in\u0026#34;\u0026gt; \u0026lt;button :key=\u0026#34;isEditing\u0026#34; @click=\u0026#34;isEditing = !isEditing\u0026#34;\u0026gt; {{ isEditing ? \u0026#39;On\u0026#39; : \u0026#39;Off\u0026#39; }} \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   1 2 3  .v-enter-active, .v-leave-active { transition: 1.5s opacity; }   See the Pen Vue CSS 轉場 轉場模式 out-in by CHUPAIWANG (@CHUPAIWANG) on CodePen.  in-out 模式的範例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  button { position: absolute; } .v-enter,.v-leave-to { opacity: 0; } .v-enter { transform: translateX(100%); } .v-leave-to { transform: translateX(-100%); }   See the Pen Vue CSS 轉場 轉場模式 in-out by CHUPAIWANG (@CHUPAIWANG) on CodePen.  多個元件的轉場 多個元件的轉場簡單很多，我們不需要使用 key 特性。只需要使用 動態切換 元件：\n1 2 3 4 5 6 7 8  \u0026lt;!-- .html --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; value=\u0026#34;v-a\u0026#34; v-model=\u0026#34;view\u0026#34; /\u0026gt;A \u0026lt;input type=\u0026#34;radio\u0026#34; value=\u0026#34;v-b\u0026#34; v-model=\u0026#34;view\u0026#34; /\u0026gt;B \u0026lt;transition name=\u0026#34;component-fade\u0026#34; mode=\u0026#34;out-in\u0026#34;\u0026gt; \u0026lt;component v-bind:is=\u0026#34;view\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10  .component-fade-enter, .component-fade-leave-to { opacity: 0; } .component-fade-enter-active, .component-fade-leave-active { transition: opacity 0.3s ease; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14  const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { view: \u0026#39;v-a\u0026#39;, }, components: { \u0026#39;v-a\u0026#39;: { template: \u0026#39;\u0026lt;div\u0026gt;Component A\u0026lt;/div\u0026gt;\u0026#39;, }, \u0026#39;v-b\u0026#39;: { template: \u0026#39;\u0026lt;div\u0026gt;Component B\u0026lt;/div\u0026gt;\u0026#39;, }, }, });   transition-group 元件 1. 大量元素的轉場 目前為止，都是針對單個節點，或是同一時間渲染多個節點中的一個。如果要針對由 v-for 產生的大量元素（例如：列表），就要改為使用 transition-group 元件。\ntransition-group 元件有以下幾個特點：\n 不同於 \u0026lt;transition\u0026gt;，它會以一個真實元素呈現：預設為一個 \u0026lt;span\u0026gt;。可以通過 tag 特性更換為其他元素。 轉場模式（in-out 與 out-in）不可用，因為我們不再相互切換特有的元素。 內部元素 總是需要 提供唯一的 key 屬性值。 CSS 轉場的類將會應用在內部的元素中，而不是這個組/容器本身。  1.1 進入/離開的轉場 首先我們看一段程式碼：\n1 2 3 4 5 6 7  \u0026lt;button v-on:click=\u0026#34;add\u0026#34;\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;button v-on:click=\u0026#34;remove\u0026#34;\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item\u0026#34; class=\u0026#34;list-item\u0026#34;\u0026gt; {{ item }} \u0026lt;/ul\u0026gt;   按下 Add 會隨機插入數字，按下 Remove 會隨機移除數字。\nSee the Pen Vue 大量元素的轉場  by CHUPAIWANG (@CHUPAIWANG) on CodePen.  接下來我們改用 transition-group 元件，增加轉場效果。\ntransition-group 元件預設會有一個 \u0026lt;span\u0026gt; 的根元素，它會包住由 v-for 產生的多個元素當成其子元素。\n我們透過 tag 特性，將其改成 \u0026lt;ul\u0026gt;：\n1 2 3 4 5  \u0026lt;transition-group name=\u0026#34;list\u0026#34; tag=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;item in items\u0026#34; v-bind:key=\u0026#34;item\u0026#34; class=\u0026#34;list-item\u0026#34;\u0026gt; {{ item }} \u0026lt;/li\u0026gt; \u0026lt;/transition-group\u0026gt;   並加上 CSS：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  .list-enter, .list-leave-to { opacity: 0; transform: translateY(100%); } .list-leave, .list-enter-to { opacity: 1; } .list-enter-active, .list-leave-active { transition: all 1s; }   See the Pen Vue 大量元素的轉場 - transition-group by CHUPAIWANG (@CHUPAIWANG) on CodePen.  不過這個範例有一個明顯問題，當新增和移除元素的時候，周圍的元素會瞬間移動到他們的新佈局的位置，這會顯得不自然，我們將會在之後解決這個問題。\n1.2 排序轉場 transition-group 元件還有一個特殊之處。不僅可以進入和離開動畫，還可以改變定位。\nv-move 特性，它會在元素的改變定位的過程中應用。像之前的列別名稱一樣，可以通過 name 屬性來自定義前綴，也可以通過 move-class 屬性手動設置。\nv-move 對於設置轉場的切換時機和轉場曲線非常有用。\n1 2 3 4 5 6 7 8 9  \u0026lt;button v-on:click=\u0026#34;items.reverse()\u0026#34;\u0026gt;Reverses\u0026lt;/button\u0026gt; \u0026lt;transition-group name=\u0026#34;flip-list\u0026#34; tag=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item\u0026#34; class=\u0026#34;list-item\u0026#34;\u0026gt;{{ item }} \u0026lt;/li\u0026gt; \u0026lt;/transition-group\u0026gt;   1 2 3  .flip-list-move { transition: transform 1s; }   1 2 3 4 5 6  const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { items: [1, 2, 3, 4, 5, 6, 7, 8, 9], }, });   See the Pen Vue 大量元素的轉場 - v-move by CHUPAIWANG (@CHUPAIWANG) on CodePen.  Vue 使用了一個叫 FLIP 簡單的動畫隊列。使用 transforms 將元素從之前的位置平滑轉場新的位置。\n讓我們修正上節不自然的的程式碼：\n1 2 3 4 5 6 7  .list-leave-active { position: absolute; } .list-move { transition: 1s; }   See the Pen Vue 大量元素的轉場 - 進入/離開的轉場 v-move by CHUPAIWANG (@CHUPAIWANG) on CodePen.  另外要注意，FLIP 轉場的元素不能設置為 display: inline。作為替代方案，可以設置為 display: inline-block、display: flex-block 或者放置於 FlexBox 父容器中\rSee the Pen Vue 大量元素的轉場 - 打亂 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  JavaScript 鉤子 transition/animation 的核心概念，就是在對應的時間點新增、移除類別。除了這種在被動的時間點加上類別的方式外，Vue 也提供對應時間的 JavaScript 鉤子讓我們在該時間點使用 JavaScript。\n事件鉤子：\n before-enter：進場前啟動。 enter：進場時啟動。 after-enter：進場結束後啟動。 enter-cancelled：在未完成進場時取消動作。 before-leave：離場前啟動。 leave：離場時啟動。 after-leave：離場結束後啟動。 leave-cancelled：在未完成離場時取消動作。（只用於 v-show 中）  1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;transition v-on:before-enter=\u0026#34;beforeEnter\u0026#34; v-on:enter=\u0026#34;enter\u0026#34; v-on:after-enter=\u0026#34;afterEnter\u0026#34; v-on:enter-cancelled=\u0026#34;enterCancelled\u0026#34; v-on:before-leave=\u0026#34;beforeLeave\u0026#34; v-on:leave=\u0026#34;leave\u0026#34; v-on:after-leave=\u0026#34;afterLeave\u0026#34; v-on:leave-cancelled=\u0026#34;leaveCancelled\u0026#34; \u0026gt; \u0026lt;/transition\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  methods: { beforeEnter: function(el) {}, enter: function(el, done) { done(); }, afterEnter: function(el) {}, enterCancelled: function(el) {}, beforeLeave: function(el) {}, leave: function(el, done) { done(); }, afterLeave: function(el) {}, leaveCancelled: function(el) {}, }    如果只要單獨使用 JS 鉤子轉場，可以設置 v-bind:css=\u0026quot;false\u0026quot;，Vue 會跳過 CSS 的檢測，避免轉場過程受到 CSS 的影響。 enter 和 leave 的回呼函式 done 是可選的：  參數不注入 done 時，預設為同步呼叫，會自動呼叫 done()。 如果有 done 參數，就需要手動呼叫 done()，沒呼叫就不會進入　after-enter／after-leave。 如果想要搭配 CSS 同步自動 call done 的話，就不要帶 done 參數 只使用 JavaScript 鉤子的時候，要記得呼叫 done()。    初始渲染也有事件鉤子：\n before-appear：載入前。 appear：載入時。 after-appear：載入後。 appear-cancelled：載入開始後，執行取消載入。  路由轉場 \u0026lt;router-view\u0026gt; 一樣可以使用 \u0026lt;transition\u0026gt; 元件：\n1 2 3  \u0026lt;transition\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/transition\u0026gt;   1. 單個路由的轉場 如果要讓每個路由元件有各自的轉場效果，可以在元件內使用 \u0026lt;transition\u0026gt; 元件並設置不同的 name。\n1 2 3 4 5 6  \u0026lt;!-- Views1.vue --\u0026gt; \u0026lt;template \u0026gt; \u0026lt;transition name=\u0026#34;slide\u0026#34;\u0026gt; ... \u0026lt;/transition\u0026gt; \u0026lt;/template\u0026gt;   1 2 3 4 5 6  \u0026lt;!-- Views2.vue --\u0026gt; \u0026lt;template \u0026gt; \u0026lt;transition name=\u0026#34;fade\u0026#34;\u0026gt; ... \u0026lt;/transition\u0026gt; \u0026lt;/template\u0026gt;   2. 動態轉場 1 2 3  \u0026lt;transition :name=\u0026#34;transitionName\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/transition\u0026gt;   在接著在父元件內，監聽 $route 決定使用哪種轉場效果：\n1 2 3 4 5 6 7  watch: { \u0026#39;$route\u0026#39; (to, from) { const toDepth = to.path.split(\u0026#39;/\u0026#39;).length const fromDepth = from.path.split(\u0026#39;/\u0026#39;).length this.transitionName = toDepth \u0026lt; fromDepth ? \u0026#39;slide-right\u0026#39; : \u0026#39;slide-left\u0026#39; } }   3. Vueg  Vueg\n為 vue-router 添加轉場效果的開源 Vue 套件。\n 交錯轉場 這裡有一段程式碼：\n1 2 3 4 5 6  \u0026lt;button @click=\u0026#34;show = !show\u0026#34;\u0026gt;show\u0026lt;/button\u0026gt; \u0026lt;ul v-if=\u0026#34;show\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;n in num\u0026#34; :key=\u0026#34;n\u0026#34;\u0026gt; {{ n }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;   1 2 3 4  data: { num: 5, show: false, },   See the Pen 交錯轉場 範例 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  我們要如何將它改成交錯轉場？\n1. transition-delay 最簡單的方式，就是透過 transition-delay 來實現列表的交錯轉場。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  .custom-appear-active-class { transition: opacity 0.3s; } .custom-appear-active-class:nth-child(5n + 2) { transition-delay: 0.3s; } .custom-appear-active-class:nth-child(5n + 3) { transition-delay: 0.5s; } .custom-appear-active-class:nth-child(5n + 4) { transition-delay: 0.7s; } .custom-appear-active-class:nth-child(5n + 5) { transition-delay: 0.9s; }   但缺點也很明顯，要寫大量的 CSS，修改起來也不靈活。\nSee the Pen 交錯轉場 transition-delay by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 透過 data 屬性與 JavaScript 交流 透過 data 屬性取得元素的 index，所以補上 :data-index = index：\n1 2 3 4 5 6 7 8 9  \u0026lt;transition-group tag=\u0026#34;ul\u0026#34; v-if=\u0026#34;show\u0026#34; v-bind:css=\u0026#34;false\u0026#34; @appear=\u0026#34;appear\u0026#34; appear \u0026gt; \u0026lt;li v-for=\u0026#34;(n,index) in num\u0026#34; :key=\u0026#34;n\u0026#34; :data-index = index \u0026gt; {{ n }} \u0026lt;/li\u0026gt; \u0026lt;/transition-group\u0026gt;   利用 el.dataset 取取得元素的 data 屬性。\n1 2 3 4 5 6 7 8 9 10 11 12  methods:{ appear(el, done) { const index = el.dataset.index; // 取得 index  const delay = index * 0.3; gsap.from(el,{ duration: 0.3, opacity: 0, delay: delay, }) done(); }, },   我這裡使用 GSAP3 動畫來設置動畫。\nSee the Pen 交錯轉場 GSAP3 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  或是使用 Velocity.js 搭配 setTimeout：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  methods:{ beforeAppear(el) { el.style.opacity = 0; }, appear(el, done) { const index = el.dataset.index; const delay = index * 300; setTimeout(function () { Velocity( el, { opacity: 1 }, { complete: done } ); }, delay); }, },   See the Pen 交錯轉場 Velocity by CHUPAIWANG (@CHUPAIWANG) on CodePen. ","description":"這週是 六角鼠年鐵人賽 第五週，紀錄一下 Vue Transition 用法。","id":3,"section":"posts","tags":["Vue Transition","Vue"],"title":"Vue筆記 - Transition","uri":"https://chupai.github.io/posts/200307_vue-transition/"},{"content":"這週是 六角鼠年鐵人賽 第四週，之前沒碰過 TweenMax，但 GSAP 已經升級 GSAP3，就簡單研究一下 GSAP3。\nGSAP3 GSAP 是 GreenSock Animation Platform 的簡稱，是一套專門處理動畫與特效的 JS 套件。\nGSAP 採用模組化與插件式的結構，保持了核心引擎的輕量。有四個核心 API，TweenLite、TimelinLite、TimelineMax、TweenMax，而 TweenMax 是所有 API 與 Plugin 的集合。\n但 2019年底 GSAP 從 GSAP2 升級到 GSAP3，不再區分 TweenLite、TimelineLite、TimelineMax、TweenMax，全部合並為 gsap 物件。\nGSAP3 的優點：\n 檔案大小為 TweenMax 的一半，但新增了 50多個功能。 全部合並為 gsap 物件，不用在區分 TweenLite 和 TimelineMax 物件。 新版本相容舊版本寫法，所以可以沿用，新寫法提供更好的可讀性。  官網：\n GreenSock 英文官網 TweenMax 中文官網  下載安裝  GSAP Installation\n npm install gsap // or yarn add gsap CDN\nhttps://cdnjs.cloudflare.com/ajax/libs/gsap/3.1.1/gsap.min.js 版本差異 1. gsap 物件 原本須要用 Tweens（補間），就要使用 TweenLite/TweenMax 物件。要用到 Timelines（時間軸），就要使用 TimelineLite/TimelineMax 物件。\nGSAP3 統一使用 gsap 物件。gsap 物件，具有各種方法和屬性，可用來創建 Tweens（補間）和 Timelines（時間軸）。\n舊的 Tween 的創建方式：\n1 2 3  TweenMax.method(\u0026#39;selector\u0026#39;, {}); // or TweenLite.method(\u0026#39;selector\u0026#39;,{});   現在統一使用 gsap 物件：\n1  gsap.method(\u0026#39;selector\u0026#39;, {});   舊的 Timeline 的創建方式：\n1 2 3 4 5 6 7  const tl = new TimelineMax(); tl.method(\u0026#39;selector\u0026#39;, {}); // or const tl = new TimelineLite(); tl.method(\u0026#39;selector\u0026#39;, {});   現在 Timeline 一樣也只需要使用 gsap 物件：\n1 2 3  const tl = gsap.timeline(); tl.method(\u0026#39;selector\u0026#39;, {});   2. duration 參數 原來的寫法 duration 為方法的參數：\n1  TweenMax.to(\u0026#39;.box\u0026#39;, 1, { x: 100 });   新寫法被整合到了 vars 物件中了：\n1 2 3 4  gsap.to(\u0026#39;.box\u0026#39;, { duration: 1, x: 100, });   擁有更佳的可讀性。\n3. Timeline 預設值 原本的 Timeline 寫法：\n1 2 3 4 5 6 7 8 9  const t = new TimelineMax(); t.to(\u0026#39;.box1\u0026#39;, 1, { x: 100, ease: \u0026#39;elastic\u0026#39; }).to(\u0026#39;.box2\u0026#39;, 1, { y: 100, ease: \u0026#39;elastic\u0026#39; });   使用新的寫法，如有有相同的參數，可以設定預設值：\n1 2 3 4 5 6 7 8 9  const t = gsap.timeline({ defaults: { duration: 1, ease: \u0026#39;elastic\u0026#39; } }); t.to(\u0026#39;.box1\u0026#39;, { x: 100 }) .to(\u0026#39;.box2\u0026#39;, { y: 100 });   4. 交錯屬性 原本交錯動畫，要使用到額外的方法創建 Tween 實體，例如staggerTo()、staggerFrom()、staggerFromTo()：\n1  TweenMax.staggerTo(\u0026#39;.box\u0026#39;, 1, {rotation:360, x:100}, 0.5);   現在只需要設置 stagger 屬性即可：\n1 2 3 4 5 6  gsap.to(\u0026#39;.box\u0026#39;, { duration: 1, stagger: 0.5, rotation: 360, x: 100 });   5. 全新的亂數功能 1 ~ 400 之間：\n1 2 3  gsap.to(\u0026#39;.box\u0026#39;, { x: \u0026#39;random(100, 400)\u0026#39;, });   隨機選擇一個數字，可以使用陣列表示：\n1 2 3  gsap.to(\u0026#39;.box\u0026#39;, { x: \u0026#39;random([0，100，400，500])\u0026#39;, });   6. 全新的影格功能 Keyframes 大家一定都知道 CSS 動畫的 keyframes。那 GSAP 中的 keyframes 是什麼？\n原本要建立一連串的動畫（例如，先移動，再下移，最後旋轉），需要為每個動作建立 Tween 或使用 Timeline。而 keyframes 可以在同一個 Tween 內完成。\n1 2 3 4 5 6 7  gsap.to(\u0026#39;.box\u0026#39;, { keyframes: [ { duration: 1, x: 100, }, { duration: 1, y: 100 }, { duration: 1, rotation: 360 }, ] });   7. 全新的 repeatRefresh 開啟 repeatRefresh: true，會在重複執行時（設定 repeat），紀錄當前狀態再執行，而不會回到初始狀態。\n1 2 3 4 5 6  gsap.to(\u0026#39;.box\u0026#39;, { duration: 1, repeat: 5, repeatRefresh: true, x: \u0026#39;random(100, 400)\u0026#39;, });   8. 全新的全域動畫 Global timeline 可以控制全部的動畫實體。\n1 2 3 4  gsap.globalTimeline.timeScale(0.1); // 控制所有動畫的速率 0 ~ 1 gsap.globalTimeline.pause(); // 停止目前所有動畫 gsap.globalTimeline.play(); // 播放目前所有動畫 gsap.globalTimeline.paused(); // 回傳目前動畫狀態 true:暫停 / false:播放   9. 新的動畫輔助工具  Utility Methods\n  gsap.utils.checkPrefix() gsap.utils.clamp() gsap.utils.distribute() gsap.utils.getUnit() gsap.utils.interpolate() gsap.utils.mapRange() gsap.utils.normalize() gsap.utils.pipe() gsap.utils.random() gsap.utils.snap() gsap.utils.splitColor() gsap.utils.toArray() gsap.utils.unitize() gsap.utils.wrap() gsap.utils.wrapYoyo()  10. 相對動畫時間 原本會需要標籤來添加相對動畫時間：\n1 2 3 4 5 6  gsap.timeline() .add(\u0026#39;s\u0026#39;) .to(\u0026#39;.box1\u0026#39;, { ... }, \u0026#39;s\u0026#39;) .to(\u0026#39;.box2\u0026#39;, { ... }, \u0026#39;s\u0026#39;) .to(\u0026#39;.box3\u0026#39;, { ... }, \u0026#39;s+=0.8\u0026#39;) .to(\u0026#39;.box4\u0026#39;, { ... }, \u0026#39;s+=0.8\u0026#39;);   GSAP3 新增了最近的動畫時間：\n \u0026gt;：最近添加的動畫的開始時間 \u0026lt;：最近添加的動畫的結束時間  1 2 3 4 5  gsap.timeline() .to(\u0026#39;.box1\u0026#39;, { ... }) .to(\u0026#39;.box2\u0026#39;, { ... }, \u0026#39;\u0026lt;\u0026#39;) .to(\u0026#39;.box3\u0026#39;, { ... }, \u0026#39;\u0026lt;0.8\u0026#39;) .to(\u0026#39;.box4\u0026#39;, { ... }, \u0026#39;\u0026lt;\u0026#39;);   補間動畫 Tween 補間是 flash 時代的專業詞彙，意思是在起始狀態和終點狀態之間補全中間過程。\n包含四個要素：\n 動畫目標（target） 起始狀態 終點狀態 補間效果  1. 創建 Tween 創建 Tween 的常用方法（所有這些方法都會回傳 Tween 實體）：\n gsap.to(target, vars) gsap.from(target, vars) gsap.fromTo(target, fromVars , toVars )  參數說明：\n target：需要動畫的元素  target 使用 document.querySelectorAll()，所有符合的 CSS 選擇器都會是設置動畫的對象。 如果有多個元素對象，則使用陣列 [element1, element2]   vars：設置補間效果及屬性狀態  Timeline Timeline 就是「時間軸」，可以用來控制、管理一連串的動畫。\n 控制多段動畫 / 序列動畫 自由與重疊排序 添加 Tag 掌握動畫片段  舉例來說，我們要對多個元素作一連串的動畫，需要建立多個 Tween 並用 delay 設置延遲時間，非常麻煩：\n1 2 3  gsap.to(\u0026#39;.box1\u0026#39;, { duration: 1, x: 100, }); gsap.to(\u0026#39;.box2\u0026#39;, { delay: 1, duration: 1, y: 100 }); gsap.to(\u0026#39;.box1\u0026#39;, { delay: 2, duration: 1, rotation: 360 });   而且還無法對這一連串的動畫做控制。點我看範例。\n這時候可以使用 Timeline，建立一個時間軸，來管理這些動畫。\n1 2 3 4 5  const t1 = gsap.timeline(); t1.to(\u0026#39;.box1\u0026#39;, { duration: 1, x: 100, }) .to(\u0026#39;.box2\u0026#39;, { duration: 1, y: 100 }) .to(\u0026#39;.box1\u0026#39;, { duration: 1, rotation: 360 });   點我看範例。\n如果有相同動畫狀態，可以設定預設值，使程式碼更簡潔：\n1 2 3 4 5 6 7 8 9  const t1 = gsap.timeline({ defaults: { duration: 1, }, }); t1.to(\u0026#39;.box1\u0026#39;, { x: 100, }) .to(\u0026#39;.box2\u0026#39;, { y: 100, }) .to(\u0026#39;.box1\u0026#39;, { rotation: 360, });   1. 在時間軸中放置動畫 在時間軸建立動畫：\n to() from fromTo set()  1 2 3  const tl = gsap.timeline(); tl.to(element, {duration: 1, x: 100, opacity: 0.5});   Timeline 可以鏈式呼叫：\n1 2 3 4  const tl = gsap.timeline(); tl.from(element, {duration: 1, x: -100}) .to(element, {duration: 1, y: 50});   在時間軸中，加入一段已建立的動畫，使用 add()：\n1 2 3 4  const tween = tween = gsap.to(element, {duration: 1, x: 100, opacity: 0.5}); const tl = gsap.timeline(); tl.add(tween);   Timeline 許多方法都多 position 參數，可用來控制動畫插入點：\n 無設置：時間軸末尾 1：絕對時間，指定時間處 '+=1'、-=1：相對時間，相對於時間軸的結尾 'someLabel'：指定標籤處（建立標籤使用 addLabel()） ‵someLabel+=1'、‵someLabel-=1'：相對於指定標籤 \u0026lt;：最近動畫的開頭 \u0026gt;：最近動畫的結尾 \u0026lt;1、\u0026lt;-1：相對於最近動畫的開頭 \u0026gt;1、\u0026gt;-1：相對於最近動畫的結尾  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 插入至時間軸末尾 tl.to(element, 1, {}); // 插入至時間軸2秒處 tl.to(element, 1, {}, 2); // 在時間軸結束後2秒鐘插入 tl.to(element, 1, {}, \u0026#39;+=2\u0026#39;); // 在時間軸結束前2秒鐘插入 tl.to(element, 1, {}, \u0026#39;-=2\u0026#39;); // 在3秒處建立spin標籤 t1.addLabel(\u0026#39;spin\u0026#39;, 3); // 在spin標籤處插入動畫 tl.to(element, 1, {}, \u0026#39;spin\u0026#39;); // 在spin標籤處前三秒入動畫 tl.to(element, 1, {}, \u0026#39;spin+=3\u0026#39;); // 在最近一次動畫的開頭插入 tl.to(element, {x: 100}, \u0026#39;\u0026lt;\u0026#39;); // 在最近一次動畫的開始後1秒插入 tl.to(element, {x: 100}, \u0026#39;\u0026lt;1\u0026#39;);   基本用法 1. 數字動畫 0~100 最基本的用法，對物件的屬性去做變化。\nSee the Pen GSAP3 Demo - 基本數字動畫 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. CSS 動畫 See the Pen GSAP3 Demo - CSS 動畫 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 動畫控制  .play()：播放動畫 .pause()：暫停動畫播放 .paused()：獲取或設置動畫暫停狀態  myAnimation.paused(!myAnimation.paused()) 暫停動畫切換   .resume()：繼續動畫播放 .restart()：重新開始動畫 .reverse()：反轉播放動畫 .reversed()：獲取或設置動畫反轉狀態  myAnimation.reversed( !myAnimation.reversed() ) 動畫撥放方向切換。   .seek()：不改變狀態下，跳至動畫某個時間點  See the Pen GSAP3 Demo - 動畫控制 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  4. 重複撥放、來回撥放 1 2 3  repeat: 10, // 設置動畫重複次數 repeatDelay: 0.5, // 設置重複的間隔時間(秒) yoyo: true, // 設為true時，動畫會反轉重複   See the Pen GSAP3 Demo - 重複、來回 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  5. 錯開動畫 1  stagger: 0.5, // 設置錯開時間   See the Pen GSAP3 Demo - 重複、來回 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  6. 週期 GSAP2 的 cycle 屬性，被 GSAP3 的 gsap.utils.wrap() 給取代，而且更加靈活。\nSee the Pen GSAP3 Demo - 週期 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  簡易應用 Mousemove Event 1. Image Trail Effects See the Pen GSAP3 - Image Trail Effects by Chupai@Design (@chupai) on CodePen.  2. Slinky Text See the Pen GSAP3 - Slinky Text by Chupai@Design (@chupai) on CodePen.  Image Block Reveal See the Pen GSAP3 - Image Block Reveal by Chupai@Design (@chupai) on CodePen.  Text Animation  SplitText 商業插件\n 1. 重組文字 See the Pen GSAP3 - 重組文字 by Chupai@Design (@chupai) on CodePen. ","description":"這週是 六角鼠年鐵人賽 第四週，之前沒碰過 TweenMax，但 gsap 已經升級 GSAP3，就簡單研究一下 GSAP3。","id":4,"section":"posts","tags":["GSAP3","TweenMax","w3HexSchool"],"title":"GSAP3 - 專門處理動畫與特效的 JS 套件","uri":"https://chupai.github.io/posts/200229_gsap3/"},{"content":"這週是 六角鼠年鐵人賽 第三週，不知道要寫啥，就重新整理了一下 Flexbox 的筆記。\nFlexbox 概述 Flexbox 全稱為 CSS Flexible Box Layout，也就是 CSS 彈性盒子佈局。是一種新的 CSS3 佈局模式，在彈性盒子佈局中，彈性容器的子項目們可以伸展到任何方向、並讓他們的尺寸更加「彈性」、或者持續增大，以填補未使用的空間，抑或縮小，以避免父元素溢出。子元素的橫向或縱向對齊都很容易操作。\n1. 為何流行？ 為何開始流行了呢？最主要也是因為 CSS3 的規範終於普及，加上行動裝置的發展促成了響應式佈局興起，自適應長寬彈性相當大的 Flexbox 就趁勢而起了。\n 非常適合單向排版，例如導覽列、Gird-Layout 許多 CSS 框架也使用（Bootstrap、Foundation 等）  跟毒品一樣，用過就回不去了。\n2. 瀏覽器的支援 瀏覽器支援高達 97%。\n Can I use CSS Flexible Box Layout Module ?\n 3. Flexbox 規格歷史  2009 年的版本：display: box 現在已經不再跟 Flexbox 有任何關係。 2011 過渡期版本：display: flexbox 只是草稿，只被 IE10 實作, 如果可能的話應該避免使用。 2012 最終版：display: flex  模型概念 來源：CSS彈性盒子用法｜MDN \n容器與項目：\n 彈性容器（Flex container）\n將元素的 display 屬性設為 flex 或 inline-flex，就會變彈性容器。 彈性項目（Flex item）\n所有彈性容器的子元素都會變成彈性項目，包含文字。  彈性容器具有主軸與交錯軸：\n 主軸（main axis） 交錯軸（cross axis）  方向：\n 主軸起點與終點（main start/main end） 交錯軸點與終點（cross start/cross end）  彈性項目具有：\n 水平尺寸與垂直尺寸（main size、cross size）  屬性介紹 Flexbox 可分成外層元素（彈性容器）與內層元素（彈性項目）。\n外容器屬性：\n display：flex、inline-flex，啟用 Flexbox 的必備屬性 flex-flow  flex-direction：決定主軸線的方向 flex-wrap：決定是否換行   justify-content：主軸線的對齊 align-items：交錯軸的對齊 align-content：整體的對齊  內層元素屬性：\n align-self：單一個物件的交錯軸對齊 order：排序 flex  flex-grow：伸展比，其數值與其它物件可分配伸展比有關 flex-shrink：收縮比 flex-basis：絕對值    1. Emmet 速寫格式 Flexbox 相關屬性的 Emmet 速寫格式：\ndisplay\n d:f：display:flex; d:if：display:inline-flex;  flex-direction\n fxd：flex-direction:; fxd:c：flex-direction:column; fxd:cr：flex-direction:column-reverse; fxd:r：flex-direction:row; fxd:rr：flex-direction:row-reverse;  justify-content\n jc：justify-content:; jc:c：justify-content:center; jc:fe：justify-content:flex-end; jc:fs：justify-content:flex-start; jc:sa：justify-content:space-around; jc:sb：justify-content:space-between;  flex-wrap\n fxw：flex-wrap: ; fxw:n：flex-wrap:nowrap; fxw:w：flex-wrap:wrap; fxw:wr：flex-wrap:wrap-reverse;  align-items\n ai：align-items:; ai:b：align-items:baseline; ai:c：align-items:center; ai:fe：align-items:flex-end; ai:fs：align-items:flex-start; ai:s：align-items:stretch;  align-content\n ac：align-content:; ac:c：align-content:center; ac:fe：align-content:flex-end; ac:fs：align-content:flex-start; ac:s：align-content:stretch; ac:sa：align-content:space-around; ac:sb：align-content:space-between;  align-self\n as：align-self:; as:a：align-self:auto; as:b：align-self:baseline; as:c：align-self:center; as:fe：align-self:flex-end; as:fs：align-self:flex-start; as:s：align-self:stretch;  order\n ord：order:;  flex\n fx：flex:; fxb：flex-basis:; fxd：flex-direction:; fxd:c：flex-direction:column; fxd:cr：flex-direction:column-reverse; fxd:r：flex-direction:row; fxd:rr：flex-direction:row-reverse; fxf：flex-flow:; fxg：flex-grow:; fxsh：flex-shrink:; fxw：flex-wrap: ; fxw:n：flex-wrap:nowrap; fxw:w：flex-wrap:wrap; fxw:wr：flex-wrap:wrap-reverse;  外容器屬性 1. 必備屬性 使用 Flexbox 就是要將 display 設為 flex 或 inline-block。\n display: flex 其布局方式與 block 一樣，都會強迫換行； 而 inline-flex 和 inline-block 也 一樣，在後方的元素不會換行。  唯一不同的是，flex 與 inline-flex 的子元素具備了更多彈性的設定。\n1 2 3 4  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;text\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9  .container { display: block; } .box { display: flex; /* or inline-flex */ width: 100px; height: 100px; }   See the Pen Flex - demo1 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 主軸方向 flex-direction 可以決定主軸的方向，主軸的方向將會影響容器內的元素排序順序、方向。\nflex-direction 設定值共有以下四種：\n row：預設值，由左到右，從上到下 row-reverse：與 row 相反 column：從上到下，再由左到右 column-reverse：與 column 相反  1 2 3 4 5  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9  .container { display: flex; flex-direction: row; } .item { width: 50px; height: 50px; }   See the Pen flex-direction demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 主軸對齊 justify-content 決定了內容元素與整個 Flexbox 的「主軸對齊」位置，設定值共有以下五種：\n flex-start：預設值，對齊主軸線最前端 flex-end：對齊主軸線最終端 center：對齊主軸線中央 space-between：平均分配寬度，第一項和最後一項貼齊邊緣 space-around：平均分配寬度、間距  1 2 3 4 5  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9  .container { display: flex; justify-content: flex-start; } .item { width: 50px; height: 50px; }   See the Pen justify-content demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  4. 交錯軸對齊 align-items 剛好和 justify-content 相反，align-items 決定了內容元素與整個 Flexbox 的「交錯軸對齊」位置，設定值總共有下列五個：\n stretch：預設值，如果子元素 height: auto，會將撐開至父元素的高度 flex-start：對齊交錯軸線最前端 flex-end：對齊交錯軸線最末端 center：對齊交錯軸線中央 baseline：對齊子元素的基線  1 2 3 4 5  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item h100\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item h-auto\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  .container { display: flex; justify-content: flex-start; } .item { width: 50px; height: 50px; } .h-100 { height: 100px; } .h-auto { height: auto; }   See the Pen align-items demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  5. 換行 當我們把父容器的 display 設定為 flex 或 inline-flex 的時候，子元素就是以單行的方式排列，因為預設不會行，因此當遇到邊界會彈性調整元素。\nflex-wrap 可以調整元素是否換行，共有三個設定值：\n nowrap：預設值，不斷行 wrap：多行 wrap-reverse：多行，但主軸線起點與終點相反  1 2 3 4 5 6  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9  .container { display: flex; flex-wrap: nowrap; } .item { width: 50px; height: 50px; }   See the Pen flex-wrap by CHUPAIWANG (@CHUPAIWANG) on CodePen.  6. 多行交錯軸對齊 align-items 是針對內容為單行的子元素進行處理，如果遇到多行的子元素（flex-wrap: wrap），就要使用 align-content 這個屬性，這個屬性總共有六個設定值：\n stretch：預設值，會平均分配行距，height: auto 會撐開填滿整行。 flex-start：對齊交錯軸線最前端 flex-end：對齊交錯軸線最末端 center：對齊交錯軸線中央 space-between：第一行與最後一行分別對齊交錯軸線最上方與最下方 space-around：平均分配行距，兩端會有行距一半的間距  1 2 3 4 5 6  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10  .container { display: flex; flex-wrap: wrap; align-content: stretch, } .item { width: 50px; height: 50px; }   See the Pen align-content demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  內層元素屬性 1. 交錯軸位置 align-self 作用於內層容器，也就是子元素本身，會覆蓋外層容器的 align-items。\n設定值與 align-items 相同：\n stretch：預設值，如果子元素 height: auto，會將撐開至父元素的高度 flex-start：對齊交錯軸線最前端 flex-end：對齊交錯軸線最末端 center：對齊交錯軸線中央 baseline：對齊子元素的基線  1 2 3 4 5 6  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt;   1 2 3  .item { align-self: stretch; }   See the Pen align-self demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 排序 order 屬性可以直接指定一個數字，就可以由小到大的排列順序。\n 預設值為 0，只給一個元素設置會跑到最後面 要設置到最前頭，可以設值負值 相同的數字，看元素排序  注意，order 僅僅對元素的視覺順序 (visual order) 產生作用，並不會影響元素的邏輯或順序。\n1 2 3 4 5 6  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item item1\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item2\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item3\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item4\u0026#34;\u0026gt;4\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3  .item1 { order: 2; }   See the Pen align-self demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 伸縮比 FlexBox 最重要的屬性「flex」，個別調整子元素長度「伸展」、「壓縮」的比例以及基本大小。\nflex 是簡寫，裡面依序包含三個屬性：\n flex-grow：預設值為 0，負值無效 flex-shrink：預設值為 1，負值無效 flex-basis：預設值為 auto，若值為 0，則必須加上單位，以免被視作伸縮性  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /* 單值語法 無單位數值 unitless number: flex-grow */ flex: 2; /* 單值語法 有效寬高單位 width/height: flex-basis */ flex: 10em; flex: 30px; /* 雙值語法 flex-grow | flex-basis */ flex: 2 2; /* 三值語法 flex-grow | flex-shrink | flex-basis */ flex: 2 2 10%;   三個屬性可以分開設定，也可以合在一起用一個 flex 統一設定。\n3.1 伸展比 flex-grow 元素的伸展性，是一個數值，當子元素的寬度「小」於它自己在父元素分配到的寬度，按照數字做相對應的「伸展」比例分配（剩餘空間）。\n預設值為 0，不會進行彈性變化，不可為負值，設為 1 則會進行彈性變化。\nSee the Pen flex-grow  by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3.2 壓縮比 flex-shrink 元素收縮性，是一個數值，當子元素的寬度「大」於它自己在父元素分配到的寬度時，會進行壓縮。\n預設值為 1，設為 0 的話不會進行彈性變化（全部都 0 可能超出邊界），不可為負值。\nSee the Pen flex-shrink by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3.3 基本大小 flex-basis flex-basis 為子元素的基本大小，作為父容器的大小比較基準，預設值為 auto。\n在分配空間之前，子元素會依 flex-basis 或者 width/height，預約空間，剩餘空間會依 flex-grow 分配。\n主軸方向 flex-direction：\n 水平 row： flex-basis 為 width 的替代 垂直 column：flex-basis 為 height 的替代  優先級：\n 如果同時設置，那麼 width/height 會被覆蓋（flex-basis 的優先級較高）； 其中有一個是 auto，那麼另外一個非 auto 的屬性優先級會更高。  一些常見問題 一些新手使用 FlexBox，沒注意到的問題。\n1. 子元素高度被強制拉伸對齊 常見的情況是，當子元素 col 內，放置不同高度的元素 box，每個子元素 col 都會被強制拉伸對齊。\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box3\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3  .container { display: flex; }   See the Pen 子元素高度被強制拉伸對齊 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  這是因為 align-items 預設 stretch。因此可以透過改變 align-items 的值解決，或是使用 align-self 個別調整。\n2. 元素被壓縮 我們都知道 FlexBox 預設不換行，因此當容器大小不足時，各個子元素會被壓縮。會被壓縮的原因是 flex-shrink 預設為 1。\n所以如果不希望元素被壓縮，可以將 flex-shrink 設為 0。\n1 2 3 4 5 6 7  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col flex-shrink-0\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://picsum.photos/300/300\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   See the Pen 子元素高度被強制拉伸對齊 by CHUPAIWANG (@CHUPAIWANG) on CodePen. ","description":"這週是 六角鼠年鐵人賽 第三週，不知道要寫啥，就重新整理了一下 Flexbox 的筆記。","id":5,"section":"posts","tags":["Flex","CSS排版","w3HexSchool"],"title":"CSS筆記 - Flexbox","uri":"https://chupai.github.io/posts/200220_flex/"},{"content":"這週是 六角鼠年鐵人賽 第二週，就簡單的整理 Swiper 如何使用。\n簡介 Swiper 是一款免費以及輕量級的 JS 框架，常用於移動設備的內容觸摸滑動。\n最重要的是 「不需要使用到 jQuery」。\n更詳細介紹，請見官方：\n Swiper Swiper 中文網  目前 Swiper 版本為 Swiper5，Swiper5 對比 Swiper4 的 API 並無太大變化。Swiper5 增加了 cssMode，並且可以通過 CSS 修改 Swiper 顏色風格。\n 一些基本範例，可以參考 Swiper Demos。\n 安裝 需要用到的檔案有 swiper.min.js 和swiper.min.css 檔案。\n下載：\n Swiper GitHub repository NPM：  $ npm install swiper CDN：\n1 2 3 4 5  \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/swiper/css/swiper.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/swiper/css/swiper.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/swiper/js/swiper.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/swiper/js/swiper.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;    cdnjs - Swiper\n 配置：\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; ... \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/swiper/css/swiper.min.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ... \u0026lt;script src=\u0026#34;https://unpkg.com/swiper/js/swiper.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   初始化 Swiper 1  new Swiper(swiperContainer, parameters);    swiperContainer：要控制的 Swiper 容器，可以是 DOM 元素 或 字串（CSS 選擇器） parameters：一個物件，為 Swiper 的配置參數  1 2 3  var mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { // 配置參數 });    詳細配置參數，可以參考 Swiper API。\n 假設初始化時，沒有定義 Swiper 實體，可以透過 Swiper 的HTML 元素來獲取該實體。\n1 2 3  new Swiper(\u0026#39;.swiper-container\u0026#39;); var mySwiper = document.querySelector(\u0026#39;.swiper-container\u0026#39;).swiper;   Swiper 實體有屬性與方法可以使用，還可以監聽事件。\nLayout 1. Swiper 容器 一個 Swiper 就對應到一個 container。\n1 2  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;/div\u0026gt;   1  var mySwiper = new Swiper (\u0026#39;.swiper-container\u0026#39;);   如果一個頁面有很多個 Swiper，可以給每個容器加上 ID 或 Class 區分。\n1 2 3  \u0026lt;div class=\u0026#34;swiper-container\u0026#34; id=\u0026#34;swiper1\u0026#34;\u0026gt;....\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-container\u0026#34; id=\u0026#34;swiper2\u0026#34;\u0026gt;....\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-container\u0026#34; id=\u0026#34;swiper3\u0026#34;\u0026gt;....\u0026lt;/div\u0026gt;   1 2 3  var swiper1 = new Swiper(\u0026#39;#swiper1\u0026#39;); var swiper2 = new Swiper(\u0026#39;#swiper2\u0026#39;); var swiper3 = new Swiper(\u0026#39;#swiper3\u0026#39;);   我們可以為這個容器設置大小：\n1 2 3 4  .swiper-container { width: 600px; height: 300px; }   2. slide 元件 Swiper 的每個展示區塊為一個 slide，全部的 slide 會放在一個 wrapper 中。\n1 2 3 4 5 6 7  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   See the Pen Swiper - 基本範例 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 控制元件 除了 slide 外，還可以包含其他控制元件，可以自由選擇你需要的。。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- Pagination --\u0026gt; \u0026lt;div class=\u0026#34;swiper-pagination\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- Navigation --\u0026gt; \u0026lt;div class=\u0026#34;swiper-button-prev\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-button-next\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- Scrollbar --\u0026gt; \u0026lt;div class=\u0026#34;swiper-scrollbar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  var mySwiper = new Swiper (\u0026#39;.swiper-container\u0026#39;, { // Pagination  pagination: { el: \u0026#39;.swiper-pagination\u0026#39;, }, // Navigation  navigation: { nextEl: \u0026#39;.swiper-button-next\u0026#39;, prevEl: \u0026#39;.swiper-button-prev\u0026#39;, }, // Scrollbar  scrollbar: { el: \u0026#39;.swiper-scrollbar\u0026#39;, }, });   See the Pen Swiper - 控制元件 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  控制元件可以放在 container 之外，但需要設置 uniqueNavElements: false。\n3. 對應的 class 名稱 容器、元件、狀態，對應的 class 名稱，都可以透過選項更改。\n舉例來說，將預設的 swiper-wrapper 替換成 my-wrapper：\n1 2 3  var mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;,{ wrapperClass : \u0026#39;my-wrapper\u0026#39;, });   容器：\n swiper-container：Swiper 容器  選項：containerModifierClass   swiper-wrapper：slide 容器  選項：wrapperClass    slide 元件：\n swiper-container：slide 元件  選項：slideClass   swiper-slide-active：active 狀態的 slide 元件  選項：slideActiveClass   swiper-slide-visible：可視區塊的 slide 元件  選項：slideVisibleClass   swiper-slide-next：active slide 的下一個 slide 元件  選項：slideNextClass   swiper-slide-prev：active slide 的上一個 slide 元件  選項：slidePrevClass    基本配置 1. background-img 1 2 3 4 5 6  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34; style=\u0026#34;background-image:url(\u0026#39;\u0026#39;)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10  .swiper-container { width: 600px; height: 300px; } .swiper-slide { background-repeat: no-repeat; background-position: center center; background-size: cover; }   See the Pen Swiper Demos - background-img by Chupai@Design (@chupai) on CodePen.  2. \u0026lt;img\u0026gt; 1 2 3 4 5 6 7 8  \u0026lt;div id=\u0026#34;swiper1\u0026#34; class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11  .swiper-container { width: 600px; height: 300px; } .swiper-slide \u0026gt; img { display: block; width: 100%; height: 100%; object-fit: cover; }   1  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;);   See the Pen Swiper Demos - img by Chupai@Design (@chupai) on CodePen.  3. slidesPerView slidesPerView 能設置同時顯示的 slide 數量，slide 的大小由 container 寬去等分。\n1 2 3  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { slidesPerView: 2, });   See the Pen Swiper Demos - slidesPerView by Chupai@Design (@chupai) on CodePen.  4. 依 slide 大小顯示 如果想要依 slide 大小來顯示，可以將 slidesPerView 設為 'auto'。\n1 2 3 4 5 6 7 8 9 10  .swiper-slide { width: 300px; height: 200px; } .swiper-slide \u0026gt; img { width: 100%; height: 100%; object-fit: cover; }   1 2 3  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { slidesPerView: \u0026#39;auto\u0026#39;, });   See the Pen Swiper Demos - 依 slide 大小顯示 by Chupai@Design (@chupai) on CodePen.  3D Cube Effect 3D Cube Effect：effect: 'cube'。\ncubeEffect 參數：\n slideShadows：slide 陰影。預設為 true。 shadow：投影。預設為 true。 shadowOffset：投影距離（px）。預設為 20。 shadowScale： 投影縮放比例。預設為 0.94。  1 2 3 4 5 6 7 8 9  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;cube\u0026#39;, cubeEffect: { slideShadows: true, // slide 陰影  shadow: true, // 投影  shadowOffset: 20, // 投影距離（px）  shadowScale: 0.94, // 投影縮放比例  }, });   1. 基本 將 container 設為方塊大小。\n1 2 3 4 5 6 7  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34; style=\u0026#34;background-image:url(\u0026#39;\u0026#39;)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34; style=\u0026#34;background-image:url(\u0026#39;\u0026#39;)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10  .swiper-container { width: 300px; height: 300px; } .swiper-slide { background-repeat: no-repeat; background-position: center center; background-size: cover; }   1 2 3  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;cube\u0026#39;, });   See the Pen 3D Cube Effect - Basic by Chupai@Design (@chupai) on CodePen.  2. 卡片 slide 內放置 card 元件，將 container 的寬設為 card 的寬，card 不需設置寬度：。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card__img\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card__body\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;card__title\u0026#34;\u0026gt; Lorem ipsum \u0026lt;span\u0026gt;Web Designer\u0026lt;/span\u0026gt; \u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9  .swiper-container { width: 300px; height: auto; } .card { background-color: white; } .card ...   See the Pen 3D Cube Effect - Card by Chupai@Design (@chupai) on CodePen.  3D Coverflow Effect 3D Coverflow：effect : 'coverflow'。\ncoverflowEffect 參數：\n slideShadows：slide 陰影。預設為 true。 rotate：slide 做 3D 旋轉時 Y 軸的旋轉角度。預設為 50。 stretch：每個 slide 之間的拉伸直，越大 slide 靠得越緊。預設為 0。 depth：slide 的位置深度值，值越大 z 軸距離越遠，看起來越小。預設為 100。 modifier：depth 和 rotate 和 stretch 的倍率。預設為 1。  1 2 3 4 5 6 7 8 9 10 11 12  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;,{ slidesPerView: \u0026#39;auto\u0026#39;, centeredSlides: true, effect : \u0026#39;coverflow\u0026#39;, coverflowEffect: { slideShadows : true, rotate: 50, stretch: 0, depth: 100, modifier: 1, }, });   1. 基本 1 2 3 4 5 6 7  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34; style=\u0026#34;background-image:url(\u0026#39;\u0026#39;)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34; style=\u0026#34;background-image:url(\u0026#39;\u0026#39;)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11  .swiper-container { width: 100%; } .swiper-slide { width: 200px; height: 200px; background-repeat: no-repeat; background-position: center center; background-size: cover; }   1 2 3 4 5  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;coverflow\u0026#39;, slidesPerView: \u0026#39;auto\u0026#39;, centeredSlides: true, });   必設參數：\n slidesPerView: 'auto'，根據 slide 的寬度來設定 slide 可視數量。 centeredSlides，active slide 會置中，而不是預設狀態下的靠左。  See the Pen coverflowEffect - Basic by Chupai@Design (@chupai) on CodePen.  2. Card 將 card 元件加上 swiper-slide，並設置寬度：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;div id=\u0026#34;mySwiper\u0026#34; class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card swiper-slide\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34; class=\u0026#34;card__img\u0026#34;/\u0026gt; \u0026lt;div class=\u0026#34;card__body\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Lorem ipsum0\u0026lt;/h3\u0026gt; \u0026lt;span\u0026gt;Web Designer\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card swiper-slide\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card swiper-slide\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card swiper-slide\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10  .swiper-container { width: 100%; } .card { width: 240px; border-radius: 8px; background: white; overflow: hidden; }   如果 Card 元件要放在 swiper-slide 內有兩種做法：\n 將 slide 的寬設為 card 寬度，card 寬度設為 100%。 將 slide 的寬設為 auto !important，並設置 card 寬度。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;div id=\u0026#34;mySwiper\u0026#34; class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34; class=\u0026#34;card__img\u0026#34;/\u0026gt; \u0026lt;div class=\u0026#34;card__body\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Lorem ipsum0\u0026lt;/h3\u0026gt; \u0026lt;span\u0026gt;Web Designer\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /* 作法一 */ .swiper-slide { width: 240px; } .card { width: 100%; /* ... */ } /* 作法二 */ .swiper-slide { width: auto !important; } .card { width: 240px; /* ... */ }   這個範例稍微修改一下 coverflow 參數：\n1 2 3 4 5 6 7 8 9 10 11 12  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;coverflow\u0026#39;, slidesPerView: \u0026#39;auto\u0026#39;, centeredSlides: true, coverflowEffect: { slideShadows: true, rotate: 20, stretch: 0, depth: 350, modifier: 1, }, });   See the Pen coverflowEffect - Card by Chupai@Design (@chupai) on CodePen.  3D Flip Effect 3D Flip Effect：effect: 'cube'。\nflipEffect 參數：\n slideShadows：slide 的陰影。預設為 true。 limitRotation：限制最大旋轉角度為 180 度。預設為 true。  1 2 3 4 5 6 7  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;,{ effect : \u0026#39;flip\u0026#39;, flipEffect: { slideShadows : true, limitRotation : true, } });   1. 基本 配置跟 3D Cube Effect 配置一樣：\n1 2 3  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;,{ effect : \u0026#39;flip\u0026#39;, });   See the Pen 3D Flip Effect - Basic by Chupai@Design (@chupai) on CodePen.  2. 卡片 See the Pen 3D Flip Effect - Card by Chupai@Design (@chupai) on CodePen.  Fade Effect Fade Effect effect: 'fade'。\nfadeEffect 效果參數：\n crossFade：淡出效果，預設為 false。  預設 crossFade 是關閉的，也就是所有 slide 是重疊在一起的。\n1 2 3 4 5 6  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;fade\u0026#39;, fadeEffect: { crossFade: false }, });   1. 基本 配置跟 3D Cube Effect 配置一樣：\n1 2 3  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;fade\u0026#39;, });   See the Pen Fade Effect - Basic by Chupai@Design (@chupai) on CodePen.  Thumbs Thumbs 元件為專門用於製作帶縮略圖的 Swiper，比使用 Controller 更為簡便，且在 loop 狀態下更友好。\n有兩種寫法：\n1 2 3 4 5 6 7 8 9 10  var thumbsSwiper = new Swiper(\u0026#39;.swiper-container-thumbs\u0026#39;, { slidesPerView: 5, }); var mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { ... thumbs: { swiper: thumbsSwiper } });   或是：\n1 2 3 4 5 6 7 8 9 10  var mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { ... thumbs: { swiper: { el: \u0026#39;.swiper-container-thumbs\u0026#39;, slidesPerView: 5, ... } } });   縮圖的 Swiper active 狀態 slide 會被加上 .swiper-slide-thumb-active 的類名。\n但不知道為什麼，我使用 4.5.1 版本的 CDN，.swiper-slide-thumb-active 不會加上去。\n1. Thumbs Gallery 1 2 3 4 5 6 7 8  \u0026lt;div class=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-container gallery-top\u0026#34;\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-container gallery-thumbs\u0026#34;\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  .wrapper { width: 600px; } .swiper-slide { background-repeat: no-repeat; background-size: cover; background-position: center center; } .gallery-top { width: 100%; height: 400px; bottom: 10px; } .gallery-thumbs { width: 100%; height: 100px; } .gallery-thumbs .swiper-slide { opacity: 0.4; } .gallery-thumbs .swiper-slide-thumb-active { opacity: 1; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const mySwiper = new Swiper(\u0026#39;.gallery-top\u0026#39;, { spaceBetween: 10, thumbs: { swiper: { el: \u0026#39;.gallery-thumbs\u0026#39;, spaceBetween: 10, slidesPerView: 4, freeMode: true, }, }, navigation: { nextEl: \u0026#39;.swiper-button-next\u0026#39;, prevEl: \u0026#39;.swiper-button-prev\u0026#39;, }, });   See the Pen Thumbs Gallery by Chupai@Design (@chupai) on CodePen.  總結 這週就先整理到這，有空補上自動撥放、循環模式，我們下週見。\n2020-03-04\n被分享了，有點驚訝，是不是要來加上封面圖了 🤣。\n","description":"這週是 六角鼠年鐵人賽 第二週，就簡單的整理 Swiper 如何使用。","id":6,"section":"posts","tags":["Swiper","w3HexSchool"],"title":"Swiper - 不需要使用到 jQuery 的輪播套件","uri":"https://chupai.github.io/posts/200212_swiper/"},{"content":"前言 之前都是使用 Blogger 來放筆記，但 Blogger 沒辦法使用 Markdown 語法，所以筆記幾乎都使用 HackMD 來寫作，有空時才會將文章轉好丟到 Blogger 上，如果文章作修改要同步很麻煩。\n最近六角學院舉辦的 w3HexSchool 鼠年全馬鐵人挑戰 開跑了，有想過使用 Hexo + GitHub pages 建立 Blog，但實在是沒空。\n就在不知道要將文章丟哪時，發現了支援 Markdown 語法的簡易部落格「Bloggi」。\n2020-03-16 第七週已經找時間將全部文章搬到 Hugo 了，可以參考 第七週的文章。\n 原 Blog 新 Blog  有空再把 Blogger 的文章全部搬過來。\n\rBloggi Bloggi 是一個免費的網誌網誌寫作平台，支援 Markdown 語法，介面簡潔、無廣告，只需要簡單的註冊就可以立即使用。\n Bloggi 官網\n 1. 簡單註冊  部落格名稱 電子郵件 密碼  2. 教學手冊 帳號註冊完成後，進到「Posts」，會兩篇預設文章，為教學手冊及 Bloggi 的介紹。看完之後就可以刪除了。\n3. 設定 接下來進到「Settings」，可以編輯部落格名稱、簡介、LOGO、網址名稱等等資訊。\n部分功能則需要付費才使用，例如自訂網域名稱、Favicon、Navigation 等等。\n4. 新增文章 接下來回到「Posts」，如果要新增文章點選「New post」即可。\n編輯器很簡易，只有標題和內文，寫作格式為 Markdown 語法。\n左上分別是：\n Publish 發布文章 Preview 預覽文章 Settimgs 文章設定  5. 預覽  我的 Bloggi\n 總結 優點：\n 支援 Markdown 語法 免費、無廣告 簡單好懂的介面 簡易客製化與設定  缺點：\n 需要第三方圖片空間，管理上略麻煩 匯入匯出功能，期待未來加入  ","description":"這週是 六角鼠年鐵人賽 第一週，支援 Markdown 語法的簡易部落格「Bloggi」。","id":7,"section":"posts","tags":["Bloggi","w3HexSchool"],"title":"Bloggi - 支援 Markdown 語法的簡易部落格","uri":"https://chupai.github.io/posts/200205_bloggi/"}]