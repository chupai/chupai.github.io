[{"content":"這週是六角鼠年鐵人賽第十七週，這週簡單說明 合併排序（Merge Sort）。\n\r合併排序（Merge Sort） 合併排序（Merge Sort） 又稱為 歸併排序，是建立在合併操作上的一種有效的排序演算法，是採用 分治法 的一個非常典型的應用。\n分治法（Divide and Conquer）簡單來說就是將問題分成兩個子問題或更多的子問題，再繼續將子問題分解成更小的子問題，直到可以簡單求解，接著將所有子問題的結果合併，就能求得元問題的解。分治法一般會使用遞迴實現。\n操作流程，採用分治法，分為兩個操作：\n 分割：將數列平均分割成兩半，重複操作直到區塊中只剩一個元素。 合併：接著再將各個子陣列合併，合併時會反覆比較第一個數，並將較小的元素移至上一層中。重複操作直到剩一個數列，排序完畢。  合併排序的實現有兩種方法：\n 遞迴結構（自頂向下 Top-down） 迭代結構（自底向上 Bottom-up）  一般來說，合併排序是使用遞迴結構來實現的，但遞迴有一個問題，就是需要使用到額外空間來儲存子陣列，而且當遞迴函式被呼叫的過於頻繁，可能導致 堆疊溢位。\n為了優化合併排序（迭代結構），我們可以跳過分割這個操作，也就是一開始就將它們視為已分割狀態，比較相鄰兩個元素進行合併操作，每輪進行合併操作的元素都會翻倍成長。\n遞迴結構實作 遞迴結構一共需要兩個函式，並透過遞迴函式的方式來處理。\n1. 分割操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function mergeSort(arr) { const n = arr.length; // 1  // 2  if (n \u0026lt; 2) { return arr; } const midIndex = Math.floor(n / 2); // 3  // 4  const leftArray = arr.slice(0, midIndex); const rightArray = arr.slice(midIndex); // 5  mergeSort(leftArray); mergeSort(rightArray); }    陣列元素數量。 遞迴停止條件：如果陣列內只剩一個元素就停止或陣列為空。 取陣列的中間索引。 使用 slice() 將陣列分割成兩個子陣列。 使用遞迴繼續分割兩個子陣列。  2. 合併操作 合併操作函式，會傳入兩個陣列，並依元素大小排序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function merge(leftArr, rightArr) { const temp = []; // 1  // 2  while (leftArr.length \u0026amp;\u0026amp; rightArr.length) { // 3  if (leftArr[0] \u0026lt; rightArr[0]) { temp.push(leftArr.shift()); } else { temp.push(rightArr.shift()); } } return temp.concat(leftArr, rightArr); // 4 }    宣告變數儲存合併結果。 while 迴圈終止條件：當一個陣列為空就跳出迴圈。 比較大小後，使用 shift() 將元素刪除，並加到結果陣列中。 將剩餘元素的陣列與結果合併。  以上實作法方邏輯上沒問題，網路上很多文章的範例也都是這樣實作的（包含 維基百科） 。\n但 shift 方法背後原理操作，在刪除第一個元素後，其餘的元素都會往前移動，其實並不高效。\n因此建議使用以下方式來實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  function merge(leftArr, rightArr) { const temp = []; // 1  let [leftIndex, rightIndex] = [0, 0]; // 2  // 3  while (leftIndex \u0026lt; leftArr.length \u0026amp;\u0026amp; rightIndex \u0026lt; rightArr.length) { if (leftArr[leftIndex] \u0026lt; rightArr[rightIndex]) { // 4  temp.push(leftArr[leftIndex]); leftIndex += 1; } else { temp.push(rightArr[rightIndex]); rightIndex += 1; } } // 5  while (leftIndex \u0026lt; leftArr.length) { temp.push(leftArr[leftIndex]); leftIndex += 1; } while (rightIndex \u0026lt; rightArr.length) { temp.push(rightArr[rightIndex]); rightIndex += 1; } return temp; }    宣告變數儲存合併結果。 宣告變數來紀錄當前索引。 while 迴圈終止條件：當前索引大於陣列長度，表示這個陣列都加到結果陣列中了。 比較大小後，將元素放進結果陣列中，並將當前索引往前（+1）。 將剩餘元素的陣列與結果合併。  更簡潔的寫法：\n1 2 3 4 5  // 4 temp.push(leftArr[leftIndex++]); // 5 return [...temp, ...leftArr.slice(leftIndex), ...rightArr.slice(rightIndex)];   以下為使用 shift() 和使用索引兩種方式的簡易的執行時間比較，你可以發現，雖然 shift() 實作簡潔好理解，但執行速度差異非常大。\nSee the Pen 合併排序（Merge Sort） by Chupai@Design (@chupai) on CodePen.  3. 完成演算法 將分割的子陣列，呼叫 merge() 合併：\n1 2 3 4 5 6 7 8 9 10 11  function mergeSort(arr) { const n = arr.length; if (n \u0026lt; 2) { return arr; } const midIndex = Math.floor(n / 2); const leftArray = arr.slice(0, midIndex); const rightArray = arr.slice(midIndex); return merge(mergeSort(leftArray), mergeSort(rightArray)); }   完整程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  function mergeSort(arr) { const n = arr.length; if (n \u0026lt; 1) { return arr; } const midIndex = Math.floor(n / 2); const leftArray = arr.slice(0, midIndex); const rightArray = arr.slice(midIndex); return merge(mergeSort(leftArray), mergeSort(rightArray)); function merge(leftArr, rightArr) { const temp = []; let [leftIndex, rightIndex] = [0, 0]; while (leftIndex \u0026lt; leftArr.length \u0026amp;\u0026amp; rightIndex \u0026lt; rightArr.length) { if (leftArr[leftIndex] \u0026lt; rightArr[rightIndex]) { temp.push(leftArr[leftIndex++]); } else { temp.push(rightArr[rightIndex++]); } } return [...temp, ...leftArr.slice(leftIndex), ...rightArr.slice(rightIndex)]; } }   這種實作方式，並不會更改原陣列，會回傳一個排序後的新陣列。\n4. 優化版本 使用 slice() 分割陣列的方式，雖然簡潔好理解，但會額外使用很多記憶體空間，因此我們可以直接在原陣列上進行分割的操作。\n要在原陣列上進行分割操作，我們會使用紀錄索引位置的方式。\n一共需要傳入 start 開頭和 end 結尾，再計算出 mid 中間位置。\n 左子陣列為 start 至 mid 右子陣列為 mid + 1 至 end  1 2 3 4 5 6 7 8 9 10 11 12 13  // 1 function mergeSort(arr, start = 0, end = arr.length - 1) { if (start === end) { return arr; } // 2  const mid = Math.floor((start + end) / 2); // 3  // 4  mergeSort(arr, start, mid); mergeSort(arr, mid + 1, end); merge(arr, start, mid, end); // 3  return arr; }    start 和 end 的參數預設值為陣列開頭和結尾。 停止歸遞條件：開頭與結尾索引相同時就停止。 計算中間的索引位置。 歸遞 合併操作  合併操作函式，基本邏輯與原本的差不多，但最後一步不回傳排序好的陣列，而是用記錄下來的索引位置，直接覆蓋掉原陣列：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  function merge(arr, start, mid, end) { let temp = []; let [leftIndex, rightIndex] = [start, mid + 1]; // 1  while (leftIndex \u0026lt;= mid \u0026amp;\u0026amp; rightIndex \u0026lt;= end) { if (arr[leftIndex] \u0026lt; arr[rightIndex]) { temp.push(arr[leftIndex++]); } else { temp.push(arr[rightIndex++]); } } while (leftIndex \u0026lt;= mid) { temp.push(arr[leftIndex++]); } while (rightIndex \u0026lt;= end) { temp.push(arr[rightIndex++]); } // 3  for (let i = start; i \u0026lt;= end; i++) { arr[i] = temp[i - start]; } }    左右陣列起始索引。 終止條件：起始索引等於結尾索引。 將排序完的元素，覆蓋掉原陣列。  完整程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  function mergeSort(arr, start = 0, end = arr.length - 1) { if (start === end) { return arr; } const mid = Math.floor((start + end) / 2); mergeSort(arr, start, mid); mergeSort(arr, mid + 1, end); merge(arr, start, mid, end); return arr; function merge(arr, start, mid, end) { let temp = []; let [leftIndex, rightIndex] = [start, mid + 1]; while (leftIndex \u0026lt;= mid \u0026amp;\u0026amp; rightIndex \u0026lt;= end) { if (arr[leftIndex] \u0026lt; arr[rightIndex]) { temp.push(arr[leftIndex++]); } else { temp.push(arr[rightIndex++]); } } while (leftIndex \u0026lt;= mid) { temp.push(arr[leftIndex++]); } while (rightIndex \u0026lt;= end) { temp.push(arr[rightIndex++]); } for (let i = start; i \u0026lt;= end; i++) { arr[i] = temp[i - start]; } } }   此作法可以減少記憶體的使用（減少空間複雜度），但會更動原陣列。\n迭代結構實作 當資料數量非常非常大時，歸遞結構的操作很容易導致 堆疊溢位，因此可以改用迭代結構。\n上面實作完成後，你可以發現，我們可以直接跳過分割這個步驟，直接將它視為已分割後的狀態，直接進行合併操作。\n流程：\n 將陣列中相鄰兩個元素進行合併操作（排序）。 每輪進行操作的元素數量會翻倍成長。 當長度大於等於陣列元素數量，排序完畢。  1 2 3 4 5 6 7 8 9 10 11 12  function mergeSort(arr) { let n = arr.length; for (let i = 1; i \u0026lt;= n; i *= 2) { for (let j = 0; j + i \u0026lt; n; j += i * 2) { const start = j; const end = Math.min(j + i * 2 - 1, n - 1); const mid = j + i - 1; merge(arr, start, mid, end); } } return arr; }    i = 1：起始元素數量為 1。 i \u0026lt;= n：當元素數量大於等於 n 表示排序完畢。 i *= 2：每輪元素數量會翻倍。 j = 0：從頭開始取元素遍歷。 j + i \u0026lt; n：當索引 j + i 超過 n 表示這輪都合併操作過了。 j += i * 2：一次操作元素的數量會是 i 兩倍。 end：若要操作的元素索引大於陣列，就取陣列的最後一個元素。  完整程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  function mergeSort(arr) { let n = arr.length; for (let i = 1; i \u0026lt;= n; i *= 2) { for (let j = 0; j + i \u0026lt; n; j += i * 2) { const start = j; const end = Math.min(j + i * 2 - 1, n - 1); const mid = j + i - 1; merge(arr, start, mid, end); } } return arr; function merge(arr, start, mid, end) { let temp = []; let [leftIndex, rightIndex] = [start, mid + 1]; while (leftIndex \u0026lt;= mid \u0026amp;\u0026amp; rightIndex \u0026lt;= end) { if (arr[leftIndex] \u0026lt; arr[rightIndex]) { temp.push(arr[leftIndex++]); } else { temp.push(arr[rightIndex++]); } } while (leftIndex \u0026lt;= mid) { temp.push(arr[leftIndex++]); } while (rightIndex \u0026lt;= end) { temp.push(arr[rightIndex++]); } for (let i = start; i \u0026lt;= end; i++) { arr[i] = temp[i - start]; } } }   分析 簡易分析，假設資料為 $n$，分割操作可以略過不計。每輪操作的資料數量固定為 $n$，共會執行 $\\log_{2}n$ 輪合併操作，整體執行時間約為 $n \\log_{2}n$。\n 穩定排序 時間複雜度  最佳：$O(n \\log n)$ 最差：$O(n \\log n)$ 平均：$O(n \\log n)$   空間複雜度為： $O(n)$ ","description":"合併排序（Merge Sort） 又稱為 歸併排序，是建立在合併操作上的一種有效的排序演算法，是採用 分治法 的一個非常典型的應用。","id":0,"section":"posts","tags":["排序演算法","排序演算法","合併排序","w3HexSchool"],"title":"JavaScript 學演算法（九）- 合併排序","uri":"https://chupai.github.io/posts/200525_sort_algorithm_merge_sort/"},{"content":"這週是六角鼠年鐵人賽第十六週，資料結構先暫停一下，換換口味，來看排序。排序演算法（Sort Algorithm）是基礎演算法之一，是一種能將一串資料依照特定排序方式進行排列的一種演算法。\n\r什麼是排序（Sort） 1. 定義 排序（Sort），將一組資料一使用者需求，予以重新排列其順序。\n一般會依資料之大小順序排序（由大至小、或由小至大）。\n2. 分類 排序演算法分類方式有以下這幾種。\n第一類：內部與外部\n 內部排序（Internal Sort） 又稱「陣列排序」  定義：排序之工作，主要在主記憶體（RAM）完成。 意指資料量小，可以直接放在記憶體內進行。   外部排序（External Sort） 又稱「檔案排序」  定義：排序之工作，主要是在輔助記憶體（Disk, File）完成。 意指資料量大，無法直接存放在記憶體，必須先存放於輔助記憶體內再處理。    第二類：穩定性與不穩定性\n 穩定性（Stable）：相同值的資料，排序後順序和排序前一樣。 不穩定性（Unstable）：相同值的資料，排序後順序不一定和排序前一樣。  第三類：簡單與高等\n 簡單排序：排序演算法簡單，但執行時間較長。 高等排序：排序演算法複雜，執行時間較短。  第四類：比較與非比較\n 比較排序：通過比較來決定元素間的相對次序。 非比較排序：不通過比較來決定元素間的相對次序。  3. 常見排序演算法 排序相關動畫影片，可以稍微的看一下：\n 如何最有效率地整理書架？ - Chand John 15 Sorting Algorithms in 6 Minutes  簡單排序：\n 氣泡排序（Bubble Sort） 選擇排序（Selection Sort） 插入排序法（Insertion Sort）  初學排序所必須知道的三個最基本排序演算法，但它們由於速度不快而不實用。\n高等排序：\n 合併排序 Merge Sort 快速排序 Quick Sort 希爾排序 Shell Sort 堆積排序 Heap Sort  高等排序通常用於高效處理大量資料（幾萬起跳），不過有些對於資料過於小（幾千幾百）可能反而比簡單排序還慢。\n簡單排序 1. 氣泡排序（Bubble Sort） 氣泡排序（Bubble Sort）又稱為冒泡排序、泡沫排序，是排序演算法中最簡單的，但運行時間是最差的。\n其排序方式為相臨資料反覆進行比較，若發現資料順序不對，就將資料互換。資料將如氣泡般，從一端漂浮到另一端。\n流程模擬動畫：\nSee the Pen Sort Algorithm - Bubble Sort with Vue.js by Chupai@Design (@chupai) on CodePen.  遞增排列運作原理：\n 第一輪\n比較相鄰的元素，如果前者大於後者就相互交換；\n從頭到尾執行比較動作，可以確保最後一個元素將會是最大的。 第二輪\n扣除最後一個元素（已排序完畢元素），針對其餘元素重複上述步驟；  每輪執行比較的元素會越來越少，執行至剩一個元素，排序完畢。\n氣泡排序的過程範例：\nnums = [4, 2, 3, 1]; 第一輪 4 2 交換 =\u0026gt; 2 4 3 1 4 3 交換 =\u0026gt; 2 3 4 1 4 1 交換 =\u0026gt; 2 3 1 4 第二輪 2 3 不換 =\u0026gt; 2 3 1 4 3 1 交換 =\u0026gt; 2 1 3 4 第三輪 2 1 交換 =\u0026gt; 1 2 3 4 氣泡排序分析：\n 穩定排序 時間複雜度  最佳：$O(n)$ 最差：$O(n^2)$ 平均：$O(n^2)$   空間複雜度為： $O(1)$  演算法實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function bubbleSort (arr) { const n = arr.length; // 1  // 2  for(let i = 0; i \u0026lt; n - 1; i++) { // 3  for(let j = 0; j \u0026lt; n - 1 - i; j++) { // 4  if(arr[j] \u0026gt; arr[j + 1]) { // 5  const temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } return arr; }    元素數量。 執行 n - 1 輪（最後一次只剩自己，所以不比較）。 交換 n - 1 - i 次（兩兩互相比較，所以 -1，並扣除每輪已經排好的元素，所以減 i）。 比較大小。 元素交換位置。  交換位置也可以使用 ES6 的解構指定（destructuring assignment）：\n1  [arr[j], arr[j+1]] = [arr[j+1], arr[j]];   你可以建立一個交換函式，之後很多排序法都會用到：\n1 2 3 4 5 6 7 8  function swap(arr, index1, index2) { const temp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = temp; // - ES6 的方式  // [array[index1], array[index2]] = [array[index2], array[index1]]; }   氣泡排序的平均與最差的時間複雜度都是 $O(n^2)$，但最佳的情況（輸入陣列已是排序好的）時間複雜度為 $O(n)$（元素不做任何的交換）。\n要讓最佳的情況時間複雜度為 $O(n)$，需要優化一下程式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function bubbleSort (arr) { const n = arr.length; let swapped = true; for(let i = 0; (i \u0026lt; n - 1) \u0026amp;\u0026amp; swapped; i++) { swapped = false; for(let j = 0; j \u0026lt; n - 1 - i; j++) { if(arr[j] \u0026gt; arr[j + 1]) { swapped = true; swap(arr, j, j + 1); } } } return arr; }   加上一個標注（flag），在新的一輪開始時，判斷上一輪是否有發生交換，如果沒有表示剩餘的元素已經排序完畢，下一輪會因為 swapped 被設為 false 就會跳出迴圈。\n2. 選擇排序（Selection Sort） 選擇排序（Selection Sort） 是一種簡單直觀的排序演算法，類似氣泡排序。\n其排序方式為反覆進行搜數列中的最小值，並與最左側的資料交互。\n流程模擬動畫：\nSee the Pen Sort Algorithm - Selection Sort with Vue.js by Chupai@Design (@chupai) on CodePen.  遞增排列運作原理：\n 第一輪\n預設第一個元素為最小值，往右側進行搜尋最小值；\n若遇到比目前最小值還小的元素就替換掉；\n搜尋至最後，將最小值與最左側元素交換位置。 第二輪\n扣除第一個元素，針對其餘元素重複以上的步驟。  持續上述步驟，每輪執行比較的元素會越來越少，直到排序完畢。\n選擇排序的過程範例：\nnums = [4, 1, 3, 2]; 第一輪 min 4 (預設) min 1 交換位置 =\u0026gt; 1 4 3 2 第二輪 min 4 (預設) min 3 min 2 交換位置 =\u0026gt; 1 2 4 3 第三輪 min 4 (預設) min 3 交換位置 =\u0026gt; 1 2 3 4 選擇排序分析：\n 不穩定排序。 時間複雜度  Best Case：$O(n^2)$ Worst Case：$O(n^2)$ Average Case：$O(n^2)$   空間複雜度為： $O(1)$  演算法實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function selectionSort(arr) { const n = arr.length; // 1  // 2  for(let i = 0; i \u0026lt; n; i++) { // 3  let minIndex = i; // 4  for(let j = 1 + i; j \u0026lt; n; j++) { // 5  if(arr[j] \u0026lt; arr[minIndex]) { minIndex = j; } } swap(arr, i, minIndex); // 6  } return arr; }    元素數量。 執行 n 輪。 minIndex 用來紀錄最小值的索引。 因為 minIndex 預設為第一元素 j 從 1 開始尋找，每輪會扣除已排好的元素，所以加 i。 比較是否為最小值。 一輪結束後就將最小值與 i 交換。  選擇排序就算陣列已經是排序好的狀態，還是要經過多輪比較，所以不論是最好、最壞、平均的時間複雜度皆為 $O(n^2)$。但跟氣泡排序比起來，執行交換操作只需要 n 次。\n3. 插入排序（Insertion Sort） 插入排序（Insertion Sort）是也一種簡單直觀的排序演算法，你如果玩過撲克牌，就都有用過。\n其排序方式為，將左側作為已排序數列，右側為未排序數列，從未排序的數列中取第一個，放到已排序數列中的適當位置。\n流程模擬動畫：\nSee the Pen Sort Algorithm - Insertion Sort with Vue.js by Chupai@Design (@chupai) on CodePen.  遞增排列運作原理：\n 第一輪\n從第一個元素開始，該元素視為已經被排序；\n取出下一個元素，判斷要插入左側元素的前面還是後面。 第二輪\n已經被排序已有兩個元素；\n取出下一個元素，判斷要插入左側元素的前面還是後面；\n如果是前面就依序往下判斷。  持續上述步驟，右側位被排序的元素會遞減，直到排序完畢。\n插入排序的過程範例：\nnums = [4, 2, 3, 1]; 第一輪 [4] [2 3 1] [ 4] 2 [2 4] 第二輪 [2 4] [3 1] [2 4] 3 [2 3 4] 第三輪 [2 3 4] [1] [2 3 4] 1 [2 3 4] 1 [ 2 3 4] 1 [1 2 3 4] 分析：\n 穩定排序。 時間複雜度  Best Case：$O(n)$ Worst Case：$O(n^2)$ Average Case：$O(n^2)$   空間複雜度為： $O(1)$  演算法實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function insertionSort(arr) { const n = arr.length; // 1  // 2  for (let i = 1; i \u0026lt; n; i++) { let temp = arr[i]; // 3  let j = i; // 4  // 5  while (j \u0026gt; 0 \u0026amp;\u0026amp; temp \u0026lt; arr[j - 1]) { arr[j] = arr[j - 1]; // 6  j -= 1; } arr[j] = temp; // 7  } return arr; }    元素數量。 從第二個元素開始，所以 i = 1。 使用一個變數儲存要判斷元素的值。 使用一個變數儲存前要判斷元素的當前索引。 只要當前索引比 0 大，並且小於左側的值，就繼續比較。 將左側的值往後移。 將要判斷元素的值插入正確位置上。  4. 總結 這三種簡單演算法複雜度基本上差不多：\n   排序方法 最佳時間 最差時間 平均時間 空間 穩定性     氣泡 Bubble $O(n)$ $O(n^2)$ $O(n^2)$ $O(1)$ 穩定   選擇 Selection $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不穩定   插入 Insertion $O(n)$ $O(n^2)$ $O(n^2)$ $O(1)$ 穩定    這是一個簡易的執行時間計時器，對 100 ~ 10000 個隨機數字進行排序。\nSee the Pen Simple Sorting Algorithm EXECUTION TIME by Chupai@Design (@chupai) on CodePen.  執行時間會根據執行環境而有所不同，不過基本上元素數量越小，看不出彼此間的差異，但你可以觀察到當元素達到 10000 時，氣泡排序明顯是最差的，而插入排序稍微快於選擇排序。\n不過這三種排序法，資料量非常大時（幾十萬起跳），基本上都要跑很久，所以實際應用上都不適合，下週來看比較實用的合併排序。\n","description":"排序演算法（Sort Algorithm）是基礎演算法之一，是一種能將一串資料依照特定排序方式進行排列的一種演算法。","id":1,"section":"posts","tags":["排序演算法","氣泡排序","插入排序","選擇排序","w3HexSchool"],"title":"JavaScript 學演算法（八）- 排序演算法","uri":"https://chupai.github.io/posts/200518_sort_algorithm/"},{"content":"這週是 六角鼠年鐵人賽 第十五週，這週來看具有不重父元素特性的資料結構，「集合」 \u0026amp;「 映射」。\n\r集合（Set） 集合（Set） 是一組無順序且唯一的資料所組成的資料結構，概念衍生自數學的「集合」。\n特性：\n 無序性：集合內各元素無特定排序或排序不重要。 互異性：集合內每個元素且只能出現一次。 確定性：給定一個集合，任給一個元素，該元素或者屬於或者不屬於該集合，二者必居其一。  基本操作：\n 檢查某元素是否在集合內 新增元素 刪除元素。  集合的基本操作，沒有取得指定元素的操作，這是因為集合是無序的資料結構，沒有索引或鍵名可以快速取得元素，必須透過迭代來查詢。\n運算：\n 聯集：將兩個集合的元素合併成一個新集合（元素不重複）。 交集：將兩個集合中共有的元素，組成一個新集合。 對稱差：將兩個集合中不重複的元素，組成一個新集合。 差集：給定兩集合，回傳一個包含存在第一個集合元素但不存在於第二集合的集合  JavaScript 實作集合 JavaScript 在 ES6 就新增了 Set 物件，但我們這裡嘗試使用物件模擬簡易的 Set。\n1. 建立類別 1 2 3 4 5 6  class MySet { constructor() { this.items = {}; } // methods }   裝資料的容器 items 使用物件而非陣列，是因為 JavaScript 的物件屬性不會重複，可以確保集合內的元素都是唯一的。\n2. 方法 基本操作：\n add(element)：新增元素。 delete(element)：移除元素。 has(element)：檢查元素是否存在。  因為 add 和 delete 方法會用到 has 方法，所以先來實現 has 方法。可以使用 in 關係運算子，來判斷元素是否是 items 物件的屬性：\n1 2 3  has(element) { return element in this.items; }   或是使用 hasOwnProperty() 來判斷物件是否有該屬性：\n1 2 3  has(element) { return this.items.hasOwnProperty(element); }   如果你有使用 ESLint 會拋出 錯誤，可以改成 Object.prototype.hasOwnProperty.call(this.items, element)。\n新增元素 add 方法，必須先檢查元素是否存在，如果元素已存在就跳出：\n1 2 3 4  add(element) { if (this.has(element)) return; this.items[element] = element; }   刪除元素 delete 方法，也要檢查元素是否存在，如果元素已存在就刪除：\n1 2 3 4 5  delete(element) { if (this.has(element)) { delete this.items[element]; } }   其餘輔助屬性方法：\n clear()：清空。 size()：元素數量。 values()：回傳一個包含所有元素的陣列。  最終程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class MySet { constructor() { this.items = {}; } has(element) { return Object.prototype.hasOwnProperty.call(this.items, element); } add(element) { if (this.has(element)) return; this.items[element] = element; } delete(element) { if (this.has(element)) { delete this.items[element]; } } clear() { this.items = {}; } size() { return Object.keys(this.items).length; } values() { return Object.values(this.items); } }   建立實體：\n1 2 3 4 5 6 7 8 9  const set = new MySet(); set.add(1); set.add(2); set.add(3); console.log(set.values()); // [1, 2, 3]  set.delete(1); console.log(set.values()); // [2, 3]   因為是簡易的 Set，所以有很多問題，例如：物件的屬性只能儲存字串，如果元素值為其他的型別都會被強制轉型成字串。\n3. ES6 原生 Set Set 只能使用建構式建立：\n1  new Set([iterable]);   能夠接受一個參數 iterable（可迭代物件）。\n1 2 3 4 5  const set1 = new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); console.log(set1); // Set {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;}  const set2 = new Set(\u0026#39;Hello\u0026#39;); console.log(set2); // Set {\u0026#39;H\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;}   屬性方法：\n add()：新增元素。 clear()：移除其所有元素。 delete()：移除指定元素。 has()：檢查員素是否存在。 values()：回傳一個 Iterator 物件，包含著 Set 物件中所有元素，由插入順序排序。 size：元素數量。 forEach()：迭代處理元素，用法等同陣列的 forEach()。  1 2 3 4 5 6 7 8 9  const set = new Set(); set.add(\u0026#39;a\u0026#39;); set.add(\u0026#39;b\u0026#39;); set.add(\u0026#39;c\u0026#39;); console.log(set); // Set {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;}  set.delete(\u0026#39;b\u0026#39;); console.log(set);    更詳細內容請參考 MDN。\n 集合操作 使用 ES6 原生 Set。\n1. 聯集 創建一個函式，回傳兩個集合中所有元素的新集合。\n最基本的作法就是迭代集合，將元素新增至新集合中：\n1 2 3 4 5 6  function uion(set1, set2) { const newSet = new Set(); set1.forEach(item =\u0026gt; newSet.add(item) ); set2.forEach(item =\u0026gt; newSet.add(item) ); return newSet; }   更簡單的的作法就是，使用展開運算子（spread operator），將兩個集合在一個陣列中展開，並建立新集合。\n1 2 3  function union(set1, set2) { return new Set([...set1, ...set2]); }   1 2 3 4  const set1 = new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); const set2 = new Set([\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;]); console.log(union(set1, set2)); // Set {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;}   2. 交集 將兩個集合中共有的元素，組成一個新集合。\n1 2 3 4 5 6 7 8 9  function intersection(set1, set2) { const temp = new Set(); set1.forEach(item =\u0026gt; { if(set2.has(item)) { temp.add(item); } }); return temp; }   使用 has() 去檢查元素。\n1 2 3 4  const set1 = new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); const set2 = new Set([\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;]); console.log(intersection(set1, set2)); // Set {\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;}   3. 對稱差 將兩個集合中不重複的元素，組成一個新集合。\n1 2 3 4 5 6 7 8 9 10 11  function difference(set1, set2) { const temp = union(set1, set2); const intersectionSet = intersection(set1, set2); intersection.forEach(item =\u0026gt; { if(temp.has(item)) { temp.delete(item); } }); return temp; }   簡單來說就是聯集減去交集。\n1 2 3 4  const set1 = new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); const set2 = new Set([\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;]); console.log(difference(set1, set2)); // Set {\u0026#39;b\u0026#39;, \u0026#39;e\u0026#39;}   4. 差集 給定兩集合，回傳一個包含存在第一個集合元素但不存在於第二集合的集合。\n1 2 3 4 5 6 7 8 9  function subtracting(set1, set2) { const temp = new Set(set1); set2.forEach((item) =\u0026gt; { if (temp.has(item)) { temp.delete(item); } }); return temp; }   先複製 set1 再減去 set2 擁有的元素。\n或者是新建一個集合，再將沒重複的元素新增至新集合中：\n1 2 3 4 5 6 7 8 9  function subtracting(set1, set2) { const temp = new Set(); set2.forEach((item) =\u0026gt; { if (!temp.has(item)) { temp.add(item); } }); return temp; }   1 2 3 4  const set1 = new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); const set2 = new Set([\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;]); console.log(subtracting(set1, set2)); // Set {\u0026#39;b\u0026#39;}   5. 子集 檢查該集合是是否為另一個集合的子集。\n1 2 3 4 5 6 7 8  function subSet(set1, set2) { if (set1.size \u0026gt; set2.size) return false; for (let item of set1) { if (!set2.has(item)) return false; } return true; }   forEach 沒辦法 return 所以我們使用 for of 來迭代 Set。\n1 2 3 4 5  console.log(subSet(new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]), new Set([\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;]))); // false  console.log(subSet(new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]), new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;]))); // true   映射（Map） 映射（Map）或稱 關聯陣列（Associative Array）、字典（Dictionary）是一種以「鍵值對 {key: value} 」形式儲存的有序資料結構，會根據不同語言有不同的名稱。\n映射，就如同電話簿中的名字和號碼一樣，先找到名字，就知道它的電話號碼。鍵（key）就是姓名，而值（value）如同電話號碼。\n定義：\n key 一定對映 value 一個映射不能包含重複的 key 每個 key 最多只能對映到一個 value  基本操作：\n 新增 刪除 查詢  JavaScript 中的映射 JavaScript 的物件物件本質上是鍵值對的資料結構，當你需要將 key 對應到 value 時，可以將字串作為 key 對應到任何型別的 value，搭配 in、delete、[] 等，能達到映射的相關操作。\n然而，物件終究不是映射類型，可能會遇到以下問題：\n 因為物件原型的特性，因此可能對應到意外的東西。 不易知道物件裡有多少對應。 物件無法使用非字串值作為 key。 無法保證 key 的順序。  請考慮以下情況，物件無法使用非字串值作為屬性名：\n1 2 3 4 5 6 7 8 9  const m = {}; const x = { id: 1 }; const y = { id: 1 }; m[x] = \u0026#39;foo\u0026#39;; m[y] = \u0026#39;bar\u0026#39;; console.log(m[x]); // bar   你可以發現 { id: 1 } 被強制轉型成字串，m[x] 與 m[y] 指向同一個屬性。\n1. ES6 原生 Map 物件 JavaScript 在 ES6 實現了 Map 物件，就是字典。\nMap 只能使用建構式建立：\n1  new Map([iterable]);   iterable 基本上為陣列（或其他元素成鍵值對的可迭代物件）。\n用法如下：\n1 2 3 4 5 6  const m = new Map([ [\u0026#39;a\u0026#39;, 1], [\u0026#39;b\u0026#39;, 2], ]); console.log(m); // Map { \u0026#39;a\u0026#39; =\u0026gt; 1, \u0026#39;b\u0026#39; =\u0026gt; 2 }   陣列的第一個項目就 key，第二個為 value。\n或是使用 Object.entries 方法，它回傳的格式就如同上面所需要的：\n1 2 3 4 5 6  const obj = { a: 1, b: 2 }; const iterable = Object.entries(obj); console.log(iterable); // [ [ \u0026#39;a\u0026#39;, 1 ], [ \u0026#39;b\u0026#39;, 2 ] ]  const m = new Map(iterable); console.log(m); // Map { \u0026#39;a\u0026#39; =\u0026gt; 1, \u0026#39;b\u0026#39; =\u0026gt; 2 }   也就是說可以使用此方法將物件轉成 Map。\n存取元素的方法為：\n set(key, value)：根據 key 存儲 value。 get(key)：根據 key 回傳 value，如果 map 中該 key 不存在，回傳 undefined。  1 2 3 4 5 6  const m = new Map(); m.set(\u0026#39;a\u0026#39;, 1); console.log( m.get(\u0026#39;a\u0026#39;) ); // 1 console.log( m.get(\u0026#39;b\u0026#39;) ); // undefined   set() 會回傳當前 map 實體，因此可以採鏈式寫法：\n1 2 3 4 5  const m = new Map(); m.set(\u0026#39;a\u0026#39;, 1) .set(\u0026#39;b\u0026#39;, 2) .set(\u0026#39;c\u0026#39;, 3);   移除元素需要使用 delete(key)，而不是 delete 運算子，而 has(key) 可以判斷 key 是否存在。\n1 2 3 4 5 6 7 8  const m = new Map([ [\u0026#39;a\u0026#39;, 1], [\u0026#39;b\u0026#39;, 2] ]); console.log( m.has(\u0026#39;a\u0026#39;) ); // true m.delete(\u0026#39;a\u0026#39;); console.log( m.has(\u0026#39;a\u0026#39;) ); // false   Map 與物件另一個最大差異就是有 forEach 方法和可以使用 for of 迭代：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const m = new Map([ [\u0026#39;a\u0026#39;, 1], [\u0026#39;b\u0026#39;, 2], [\u0026#39;c\u0026#39;, 3], ]); m.forEach((value, key) =\u0026gt; { console.log(value, key); }); // 1 \u0026#39;a\u0026#39; // 2 \u0026#39;b\u0026#39; // 3 \u0026#39;c\u0026#39;  for (let key of m) { console.log(key); } // [\u0026#39;a\u0026#39;, 1] // [\u0026#39;b\u0026#39;, 2] // [\u0026#39;c\u0026#39;, 3]    更詳細內容請參考 Map。\n 2. WeakMap 除了 Map，ES6 還新增了 WeakMap。\nWeakMap 與 Map 基本上一樣，除了以下幾點：\n WeakMap 的 key 只接受物件作為 key 。 WeakMap 的 key 所指向的物件可以被垃圾回收。 WeakMap 無法被迭代或清除。  1 2 3 4 5 6  const wm = new WeakMap(); const obj = {}; wm.set(obj, 1); // 正常 wm.set(\u0026#39;a\u0026#39;, 2); // Uncaught TypeError Invalid value used as weak map key   WeakMap 只有以下屬性方法：\n get(key) set(key, value) delete(key) has(key)  size、values()、entries()、forEach() 等皆沒有。\nWeakMap 對 key 引用是「弱引用」，這意味著若沒有其他引用存在時，垃圾回收機制就會釋放該物件所佔用的記憶體空間。因此 WeakMap 被設計成無法迭代。\n舉例來說，我們使用一個 Map 來記錄用戶的訪問次數：\n1 2 3 4  let john = { name: \u0026#39;John\u0026#39; }; const visitsCountMap = new Map(); visitsCountMap.set(john, 1);   某天這個用戶都不會來了，所以我們不需要它的訪問資料了，我們如果只有移除 john 的指向，map 內的內容還是會存在：\n1 2 3  john = null; console.log( visitsCountMap.size ); // 1   因為還需要清除 map 的內容，所以不能先移除 john 的指向，需要改成先移除 map 內的引用，再移除 john 的指向：\n1 2 3 4 5 6 7  // 上段程式碼改成這樣  visitsCountMap.delete( john ); console.log( visitsCountMap.size ); // 0  // 清除 map 的內容再移除指向 john = null;   但這樣的資料移除非常麻煩，因此就有了 WeakMap：\n1 2 3 4 5  let john = { name: \u0026#39;John\u0026#39; }; const visitsCountWeakMap = new WeakMap(); visitsCountWeakMap.set(john, 1); john = null;   { name: 'John' } 這個物件，除了 WeakMap 沒有其他引用了，所以這個物件會自動的從記憶體和 visitsCountWeakMap 中刪除。\n 更詳細內容請參考 WeakMap。\n","description":"這週是六角鼠年鐵人賽第十五週，這週來看具有不重複元素特性的資料結構，「集合」與「 映射」。","id":2,"section":"posts","tags":["資料結構","集合","映射","w3HexSchool"],"title":"JavaScript 學演算法（七）- 集合 \u0026 映射","uri":"https://chupai.github.io/posts/200517_ds_set_map/"},{"content":" JavaScript筆記 目錄\n \rDate 物件 JavaScript 沒有日期資料型態，但是它有提供 Date 物件，使用內件的日期物件與方法、可以取得與操作日期時間。\nDate 物件以世界標準時間（UTC） 1970 年 1 月 1 日為零點，範圍為前後各 1 億天（+-100,000,000），單位為毫秒。\nDate 物件只能由 new Date() 作為建構器來產生，如果 Date() 作為普通函式直接呼叫，會回傳當前時間的字串，而非 Date 物件：\n1 2  console.log( Date ); // \u0026#34;Sat Jan 11 2020 06:49:39 GMT+0800 (台北標準時間)\u0026#34;   1. 多時區  UTC 指的是世界協調時間（Coordinated Universal Time）。 GTM 指格林威治標準時間（Greenwich Mean Time）。  GMT 和 UTC 在一般使用的情況下沒有差別，你要說台灣的時區是 UTC+8 或是 GMT+8 都可以。\n 偏移（offset） 指的是某地區與 UTC 偏移的時間，例如 +08:00 表示該地區的時間比 UTC 快了 8 小時。 夏日時間（Daylight Saving Time, DST）  建立 Date 物件 new Date() 的使用方法基本為四種：\n1 2 3 4  new Date(); new Date(milliseconds); new Date(dateString); new Date(year, month, date, [hours, minutes, seconds, ms]);   1. 不帶參數 new Date() 不帶參數，表示當前日期和時間的 Date 物件。\n1 2 3 4  let now = new Date(); console.log( now ); // Sat Jan 11 2020 06:41:55 GMT+0800 (台北標準時間)   2. milliseconds new Date(milliseconds)，milliseconds 表示從 1970-01-01 00:00:00 UTC+0 開始所經過的毫秒數。\n1 2 3 4 5  console.log( new Date(0) ); // Thu Jan 01 1970 08:00:00 GMT+0800 (台北標準時間)  console.log( new Date(24 * 3600 * 1000) ); // 增加 24 小時 // Fri Jan 02 1970 08:00:00 GMT+0800 (台北標準時間)   3. datestring new Date(datestring)，datestring 表示一個日期或時間格式的字串，該參數會通過 Date.parse 算法解析字串。\n注意時間格式，你可以發現，不同的時間格式，會有不同的結果：\n1 2 3 4 5  console.log(new Date(\u0026#39;2020/01/01\u0026#39;)); // Wed Jan 01 2020 00:00:00 GMT+0800 (台北標準時間)  console.log(new Date(\u0026#39;2020-01-01\u0026#39;)); // 多了8小時 // Wed Jan 01 2020 08:00:00 GMT+0800 (台北標準時間)   這是因為 2020-01-01 方式建立的 Date 物件，會被瀏覽器解析為格林威治標準時間的日期，但台灣本地時間會多 8 個小時，因此顯示上會自動加上。\n日期或時間格式字串定義，其實有特定要求（ISO8601）：\nYYYY-MM-DDTHH:mm:ss.sssZ 遵循上述規格是最安全的用法。\n 日期 YYYY-MM-DD：年-月-日 字串 \u0026quot;T\u0026quot;：是一個分隔符 時間 HH:mm:ss.sss：小時、分鐘、秒、毫秒 可選字串 \u0026quot;Z\u0026quot;：代表時區，單個字符 Z 代表 UTC+0  4. 時間單位 new Date(year, month, [date, hours, minutes, seconds, ms])\n 必要參數：年、月  年（必須是四位數） 月（月份是從 0（一月）開始到 11（十二月））   選擇性的參數：日、時、分、秒、毫秒  日（預設為 1） 時、分、秒、毫秒（預設為 0）    1 2  console.log( new Date(2020,0) ); // Wed Jan 01 2020 00:00:00 GMT+0800 (台北標準時間)   如果超出正確範圍內的數字會自動轉換成對應時間：\n1 2  console.log( new Date(2020, 0, 31, 25) ); // Sat Feb 01 2020 01:00:00 GMT+0800 (台北標準時間)   獲取/設定 1. 獲取 從 Date 物件取的相對應的時間數值（number）：\n getFullYear()：年份（四位數） getMonth()：月份從 0 到 11 getDate()：當月的日期，從 1 到 31 getHours()：時 getMinutes()：分 getSeconds()：秒 getMilliseconds()：毫秒 getDay()：獲取一週中的第幾天，0（星期天）到 6（星期六）  1 2 3 4 5 6 7 8 9  let today = new Date(); console.log( today.getFullYear() ); // 2020 console.log( today.getMonth() ); // 0 console.log( today.getDate() ); // 11 console.log( today.getHours() ); // 8 console.log( today.getSeconds() ); // 35 console.log( today.getMilliseconds() ); // 111 console.log( today.getDay() ); // 6   以上所有的方法回傳的訊息都是基於當地時區的。\n如果要獲取標準時間，則可以加上 UTC，例如 getUTCHours()：\n1  console.log( today.getUTCHours() ); // 0   2. 設定 以下方法可以設置時間訊息：\n setFullYear(year [, month, date]) setMonth(month [, date]) setDate(date) setHours(hour [, min, sec, ms]) setMinutes(min [, sec, ms]) setSeconds(sec [, ms]) setMilliseconds(ms)  以上方法會回傳改變後的時間戳，另外，也都有對應的 UTC 版本，例如 setUTCHours()。\n3. 結合使用 獲取/設定 方法結合使用，得到相對時間：\n1 2 3 4 5 6 7 8  let d = new Date(); // 將日期向後推1000天 console.log( d.setDate(d.getDate() + 1000) ); // 將時間設為6小時後 console.log( d.setHours(d.getHours() + 6) ); // 將年份設為去年 console.log( d.setFullYear(d.getFullYear() - 1) );   時間戳（Timestamp） 時間戳（Timestamp）從 1970-1-1 00:00:00 UTC+0 開始的毫秒數。\nDate 的靜態方法：\n Date.now()：回傳當前時間的時間戳。 Date.parse()：解析日期或時間格式的字串，回傳該時間的時間戳。 Date.UTC()：需要傳入與建構器相同的參數（即年月日等等參數），回傳該時間的時間戳。  1 2 3 4  console.log( Date.now() ); // 1578705450196 console.log( Date.parse(\u0026#39;2020-01-01\u0026#39;) ); // 1577836800000 console.log( Date.parse(\u0026#39;2020/01/01\u0026#39;) ); // 1577808000000 console.log( Date.UTC(2020, 0, 1) );   Date 物件轉時間戳的方法：\n getTime()：回傳日期的時間戳  1 2 3  let time = new Date(2020, 0, 1); console.log( time.getTime() ); // 1577808000000   如果將 Date 物件轉成數值（呼叫 valueOf()），相當於 getTime() 方法：\n1  console.log( Number(time) ); // 1577808000000   1. Unix 時間戳 一般來說，後端給的時間會是以秒為單位的 Unix 時間戳，而 JavaScript 的時間戳為毫秒。\n目前取得 Unix 時間戳 最簡單和快速的方式是：\n1 2 3 4 5 6  const dateTime = Date.now(); const timestamp = Math.floor(dateTime / 1000); // 或是 const dateTime = new Date().getTime(); const timestamp = Math.floor(dateTime / 1000);   轉換格式  toString()：回傳完整的日期字串。 toUTCString()：回傳 UTC 時間。 toISOString()：回傳 ISO8601 格式。 toJSON()：回傳符合 JSON 格式的 ISO 日期字串，與 toISOString() 回傳結果相同。 toDateString()：回傳日期字串，不含小時、分和秒 toTimeString()：回傳時間字串，不含年月日  1 2 3 4 5 6 7 8  let d = new Date(2020, 0, 1); console.log( d.toString() ); // \u0026#34;Wed Jan 01 2020 00:00:00 GMT+0800 (台北標準時間) \u0026#34; console.log( d.toUTCString() ); // \u0026#34;Tue, 31 Dec 2019 16:00:00 GMT\u0026#34; console.log( d.toISOString() ); // \u0026#34;2019-12-31T16:00:00.000Z\u0026#34; console.log( d.toJSON() ); // \u0026#34;2019-12-31T16:00:00.000Z\u0026#34; console.log( d.toDateString() ); // \u0026#34;Wed Jan 01 2020\u0026#34; console.log( d.toTimeString() ); // \u0026#34;00:00:00 GMT+0800 (台北標準時間)\u0026#34;   本地時間：\n toLocaleString()：完整的本地日期時間 toLocaleDateString()：本地日期，不含小時、分和秒 toLocaleTimeString()：本地時間，不含年月日  1 2 3 4 5  let d = new Date(2020, 0, 1); console.log(d.toLocaleString()); // \u0026#34;2020-1-1 00:00:00\u0026#34; console.log(d.toLocaleDateString()); // \u0026#34;2020-1-1\u0026#34; console.log(d.toLocaleTimeString()); // \u0026#34;00:00:00\u0026#34;   這三個方法都有兩個可選的參數\n locales：字串，指定所用語言 options：選項物件，設定格式化規則 ","description":"JavaScript 沒有日期資料型態，但是它有提供 Date 物件，使用內件的日期物件與方法、可以取得與操作日期時間。","id":3,"section":"posts","tags":["JavaScript","日期時間","Date 物件"],"title":"日期時間","uri":"https://chupai.github.io/posts/200516_js_date/"},{"content":" JavaScript筆記 目錄\n \rES6 為 {} 物件字面值新增了幾個方便擴充功能，以下只提幾個常用。\n簡寫 1. 屬性值簡寫 舉一個簡單的範例來說明。\n變數與屬性名相同，這種應用場景很常見：\n1 2 3 4 5 6 7 8  function foo(a, b) { return { a: a, b: b }; } console.log(foo(1, 2)); // {a: 1, b: 2}   但在 ES6 環境下，可以這樣寫：\n1 2 3 4 5  function foo(a, b) { return { a, b }; } console.log(foo(1, 2)); // {a: 1, b: 2}   當屬性名與值名稱相同時，可以省略後面的值。\n或者是：\n1 2 3 4 5  const foo = \u0026#39;bar\u0026#39;; const baz = {foo}; // 等同於 const baz = {foo: foo};   2. 方法簡寫 定義方法時，都會有 function 宣告。\n1 2 3 4 5 6 7  const obj = { foo: function(a) { console.log(a); }, }; obj.foo(1); // 1   在 ES6 環境下，可以省略這個 function 宣告：\n1 2 3 4 5 6 7  const obj = { foo(a) { console.log(a); }, }; obj.foo(1); // 1   但使用簡寫的放式，函式為不具名，而且無法使用箭頭函式。\n屬性名稱 在 ES6 新增了可計算的功能，可以利用 [] 包裹運算式，當作鍵名。\n1 2 3 4 5 6 7 8 9  let prefix = \u0026#39;foo\u0026#39;; let myObject = { [prefix + \u0026#39;bar\u0026#39;]: \u0026#39;hello\u0026#39;, [prefix + \u0026#39;baz\u0026#39;]: \u0026#39;world\u0026#39; }; myObject.foobar; // hello myObject[\u0026#39;foobaz\u0026#39;]; // world   ","description":"ES6 為物件字面值 {} 新增了幾個重要的方便擴充功能。","id":4,"section":"posts","tags":["JavaScript","物件字面值擴充功能","ES6"],"title":"物件字面值擴充功能","uri":"https://chupai.github.io/posts/200515_js_object_literal_extension/"},{"content":" JavaScript筆記 目錄\n \r解構指定 ES6 引進了一個新語法功能，解構指定（destructuring assignment）或稱解構賦值，可以想成是一種有結構的指定。\n在 JavaScript 中最常用的兩種資料結構為陣列與物件，而解構指定用於提取陣列或物件中的資料，存放到一系列的變數中。\n請考慮以下程式碼：\n1 2 3  function foo() { return [1, 2, 3]; }   如果有一個函式回傳了一個陣列，要將陣列中的內容一一用變數儲存。\n傳統作法為：\n1 2 3 4 5 6  var tmp = foo(); var a = tmp[0]; var b = tmp[1]; var c = tmp[2]; console.log(a, b, c); // 1 2 3   必須先將函式結果儲存，在一個一個宣告變數給值。\n但如果改用新語法：\n1 2 3  let [a, b ,c] = foo(); console.log(a, b, c); // 1 2 3   就這麼麼簡單。\n1. 陣列解構 陣列解構的基本語法：\n1 2 3  let [a,b] = [1, 2]; console.log(a, b); // 1 2   2. 物件解構 物件解構的基本語法：\n1 2 3  let { a, b } = { x: 1, y: 2 }; console.log(a, b); // 1 2   左邊實際上是 **物件字面值的簡短語法：\n1 2 3 4  // 等同 let { a: a, b: b } = { a: 1, b: 2 }; console.log(a, b); // 1 2   左側的屬性值屬於變數名稱：\n1 2 3  let { a: x, b: y } = { a: 1, b: 2 }; console.log(x, y); // 1 2   必須注意，左側的必須有對應的的屬性名才能指定：\n1 2 3  let { a } = { b: 1 }; console.log(a); // undefined   屬性順序並不重要，只要有對應的屬性名即可：\n1 2 3  let { a, b } = { b: 2, a: 1 }; console.log(a, b); // 1 2   允許同一個屬性被列出多次：\n1 2 3  let { a: x, a: y } = { a: 1 }; console.log(x, y); // 1 1   這表示能夠解構一個子物件，並且捕捉那個子物件，舉例來說：\n1 2 3 4 5 6 7 8  let { a: { x: X, x: Y }, a: a, } = { a: { x: 1 } }; console.log(X); // 1 console.log(Y); // 1 console.log(a); // { x: 1 }   子陣列也可以：\n1 2 3 4 5  let { a: X, a: Y, a: [Z] } = { a: [1] }; console.log(X); // [1] console.log(Y); // [1] console.log(Z); // 1   3. 不只是宣告 指定就是使用 = 運算子，所以解構指定不一定只能用在宣告上。\n舉例來說：\n1 2 3 4  let a,b; [a, b] = [1, 2]; console.log(a, b); // 1 2   變數已宣告，解構只負責進行指定動作。\n但如果是物件就需要注意：\n1 2 3  let a,b; {a, b} = {a:1, b: 2}; // SyntaxError: Unexpected token \u0026#39;=\u0026#39;   會拋出錯誤是因為 {a, b} 的 {} 被解析成區塊，而非物件字面值，因此可以加上 ()，避免這種情況：\n1 2 3 4  let a, b; ({ a, b } = { a: 1, b: 2 }); console.log(a, b); // 1 2   應用 交換值：\n1 2 3 4 5 6  let a = 1; let b = 2; [a, b] = [b, a]; console.log(a, b); // 2 1   建立物件映射（map）：\n1 2 3 4 5 6  let o1 = { a: 1, b: 2, c: 3 }; let o2 = {}; ({ a: o2.x, b: o2.y, c: o2.z } = o1); console.log(o2); // {x: 1, y: 2, z: 3}   或是將一個物件映射至陣列，或是反過來：\n1 2 3 4 5 6 7 8 9 10 11 12 13  let o1 = { a: 1, b: 2, c: 3 }; let a2 = []; ({ a: a2[0], b: a2[1], c: a2[2] } = o1); console.log(a2); // [1, 2, 3]  // 反過來 let a1 = [1, 2, 3]; let o2 = {}; [o2.a, o2.b, o2.c] = a1; console.log(o2); // {a: 1, b: 2, c: 3}   解構指定運算式 解構指定運算式會回傳右邊完整的物件或陣列。\n1 2 3 4  let o = {a:1, b:2}; let a,b; console.log({a,b} = o); // {a: 1, b: 2}   驗證：\n1 2 3 4 5 6  let obj = { a: 1, b: 2 }; let a, b, obj2; obj2 = { a, b } = obj; console.log(obj2 === obj); // ture   陣列也是如此：\n1 2 3 4 5 6  let arr = [1, 2]; let a, b, arr2; arr2 = [a, b] = arr; console.log(arr === arr2); // ture   解構的數量 不必指定所有出現的值：\n1 2 3 4 5 6 7 8 9  let [a] = [1, 2, 3, 4]; let [, b] = [1, 2, 3, 4]; console.log(a); // 1 console.log(b); // 2  let {c} = {a:1, b:2, c: 3}; console.log(c); // 3   也可以留空來略過某些值。\n如果指定過多的值，變數沒有對應值，內容就會是 undefined。\n1 2 3 4 5 6 7  let [a, b, c] = [1, 2]; console.log(c); // undefined  let { x, y } = { x: 1 }; console.log(y); // undefined   1. 展開運算子 在解構中，使用展開運算子，將會收集那些多出來的值。\n陣列：\n1 2 3 4  let [a, ...b] = [1, 2, 3, 4]; console.log(a); // 1 console.log(b); // [2, 3, 4]   物件：\n1 2 3 4  let { a, ...b } = { a: 1, b: 2, c: 3, d: 4 }; console.log(a); // 1 console.log(b); // {b: 2, c: 3, d: 4}   預設值 使用類似預設函式引數的 = 語法，就可以給予變數預設值。\n1 2 3 4 5 6 7 8 9  let [a = 1, b = 2] = [10]; console.log(a); // 10 console.log(b); // 2  let { x = 5, y = 10 } = { x: 20 }; console.log(x); // 20 console.log(y); // 10   參數解構 一個簡單的函式與呼叫：\n1 2 3 4 5  function foo(x) { console.log(x); } foo(42);   foo(42) 執行的時候，引數 42 被指定給了參數 x。由上述可合理推論解解構指定，當然也可以用於函式參數。\n參數的解構：\n1 2 3 4 5 6 7 8 9 10  function foo([a, b]) { console.log(a, b); } function boo({ a, b }) { console.log(a, b); } foo([1, 2]); // 1 2 boo({ a: 1, b: 2 }); // 1 2   1. 預設值 上面有提到解構賦值也能給予預設值，函式參數也能給預設值，因此必須留意兩者之間的行為差異。\n1 2 3 4 5 6 7 8 9  function foo({ x = 10 }) { console.log(x); } foo(123); // 10 foo(1); // 10 foo([]); // 10 foo({}); // 10 foo(); // TypeError   輸入的引數，沒有對應的值將會使用預設值，但如果引數是空的將會拋出錯誤。\n因此可以使用參數預設值來解決，預設給予一個空物件：\n1 2 3 4 5 6 7 8  function foo({ x = 10 } = {}) { console.log(x); } foo(123); // 10 foo(1); // 10 foo([]); // 10 foo({}); // 10 foo(); // 10   別寫成這樣：\n1 2 3 4 5  function foo({ x } = { x: 10 }) { console.log(x); } foo(); // 10   雖然當引數沒有傳入，也會得到預設值，但完全是不同意思。\n1 2 3 4 5 6  // 承接上方程式碼  foo(123); // undefined foo(1); // undefined foo([]); // undefined foo({}); // undefined   第一種作法為，當引數沒輸入會套用空物件，不論引數是啥，都會套用 { x: 10 } 來解構。\n而第二種做法則是將 { x: 10 } 作為參數預設值，而非解構預設值，因此只在引數沒被輸入時適用，如果輸入的引數無法解構，都會獲得 undefined 的結果。\n1. 具名參數 有時候一個函式可能會有許多參數，舉例來說：\n1 2 3  function showMenu(title, width, height, items) { // ... }   當參數變多時，要輸入引數時，就必須記住輸入順序，才能正確輸入，而且當要插入新參數，以前所呼叫的函式會變得難以維護。\n因此這裡就可以用解構賦值語法來處理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function showMenu({ title = \u0026#39;new Title\u0026#39;, width = 200, height = 200, items = [], }) { //... } let options = { title: \u0026#39;My menu\u0026#39;, items: [\u0026#39;Item1\u0026#39;, \u0026#39;Item2\u0026#39;], }; showMenu(options);   具名參數的優點：\n 參數多的情況下，也容易理解程式意義 方便顯示可省略參數 自由變更參數順序  另外要注意，定義具名參數要記得給參數預設值空物件 {}，否則沒輸入引數會拋出錯誤。\n2. 其餘預算子 其餘預算子可以被解構，換句話說，可以把這個陣列解開，並將各個元素取出成為個別的變數。\n1 2 3 4 5 6 7  function foo(...[a, b, c]) { console.log(a, b, c); } foo(1); // 1 undefined undefined foo(1, 2, 3); // 1 2 3 foo(1, 2, 3, 4); // 1 2 3   ","description":"ES6 引進了一個新語法功能，解構指定（destructuring assignment）或稱解構賦值，可以想成是一種有結構的指定。","id":5,"section":"posts","tags":["JavaScript","解構指定","ES6"],"title":"解構指定","uri":"https://chupai.github.io/posts/200514_js_destructuring_assignment-copy/"},{"content":" JavaScript筆記 目錄\n \r\u0026hellip; 運算子 ES6 新增了 ... 運算子，但在不同位置，會有不同的功能，所以會有兩種叫法：\n 展開運算子（Spread Operator） 其餘運算子（Rest Operator）  展開運算子 展開運算子（Spread Operator）可用於陣列、類陣列、物件，但使用地點有些微差異。\n 陣列、類陣列  陣列字面值 函式呼叫時作為引數   物件  只能於物件字面值中使用    1. 基本用法 展開運算子會將陣列展開為個別的值。\n1 2 3 4 5 6 7 8 9  let number = [1, 2, 3]; let string = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; console.log(...number); // 1 2 3 console.log(...string); // \u0026#39;a\u0026#39; \u0026#39;b\u0026#39; \u0026#39;c\u0026#39;  // 等同於 console.log(1, 2, 3); console.log(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;);   主要是用在呼叫函式時的要傳入引數：\n1 2 3 4 5 6 7 8  function foo(a, b, c) { console.log(a + b + c); } foo(...[1, 2, 3]); // 6  // 等同 apply() foo.apply(null, [1, 2, 3]); // 6   ES6 之前，如果要將陣列拆開當作引數傳入都會用函式的 apply() 方法，但現在展開運算子完全可以取代它。\n展開運算子除了用在陣列本身，也可以用在陣列字面值中，將陣列展開：\n1 2 3  let number = [2, 3]; console.log([1, ...number, 5]); // [1, 2, 3, 5]   用於合併陣列非常方便，原本需要使用 concat()，現在可以使用 ... 來代替：\n1 2 3 4 5 6 7 8  let arr1 = [1, 2, 3]; let arr2 = [4, 5, 6]; let temp1 = arr1.concat(arr2); console.log(temp1); // [1, 2, 3, 4, 5, 6]  let temp2 = [...arr1, ...arr2]; console.log(temp2); // [1, 2, 3, 4, 5, 6]   也可利用它來淺拷貝陣列：\n1 2 3 4 5  let arr1 = [1, 2, 3]; let arr2 = [...arr]; console.log(arr2); // [1, 2, 3] console.log(arr1 === arr2); // false   2. 類陣列（Array-likes） 展開運算子不只是陣列可用，類陣列（Array-likes）也能使用，因為它具有索引和 length 屬性。\narguments 物件：\n1 2 3 4 5 6 7  function foo() { console.log(arguments instanceof Array); // false  let arg = [...arguments]; console.log(arg instanceof Array); // true } foo();   DOM 物件操作後所得到的串列：\n1 2 3 4  const list = document.getElementsByTagName(\u0026#39;body\u0026#39;); console.log(list instanceof Array); // false console.log([...list] instanceof Array); // true   字串：\n1 2 3  let string = \u0026#39;hello\u0026#39;; console.log([...\u0026#39;hello\u0026#39;]); // [\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;]   2. 物件 展開運算子如果直接用在物件上會拋出錯誤，因為展開運算子只能用於具有索引和 length 屬性的物件。\n1 2 3  let obj = { a: 1, b: 2 }; console.log(...obj); // Uncaught TypeError: Found non-callable @@iterator   你可以想成 a: 1, b: 2 沒東西裝。\n但如果要展開一個物件，可於物件字面值內。你可以想成 a: 1, b: 2 外面還有一個 {} 裝它。\n因此可以應用在淺拷貝物件上：\n1 2 3 4 5  let obj = { a: 1, b: 2 }; let obj2 = { ...obj }; console.log(obj2); // { a: 1, b: 2 } console.log(obj === obj2); // false   其餘運算子 在函式宣告中的最後一個參數加上 ... 運算子，會稱其為「其餘運算子（Rest Operator）」，它與展開運算子效果上剛好完全相反，其餘運算子是把許多的參數轉換成一個陣列。\n1 2 3 4 5  function foo(...args) { console.log(args); } foo(1, 2, 3); // [1, 2, 3]   其餘運算子因為是用於參數上，因此又稱為「其餘參數」，應用於參數不固定的函式上。\nES6 之前，會利用 arguments 物件來存取傳入的引數。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function foo(var_args) { for (var i = 0; i \u0026lt; arguments.length; i++) { var tmp = arguments[i]; if (typeof tmp !== \u0026#39;number\u0026#39;) { console.log(\u0026#39;輸入的值不是數字：\u0026#39; + tmp); } else { console.log(\u0026#39;輸入的值是數字：\u0026#39; + tmp); } } } foo(1, 2, 5, \u0026#39;a\u0026#39;); // \u0026#34;test.js:6 輸入的值是數字：1\u0026#34; // \u0026#34;test.js:6 輸入的值是數字：2\u0026#34; // \u0026#34;test.js:6 輸入的值是數字：5\u0026#34; // \u0026#34;test.js:4 輸入的值不是數字：a\u0026#34;   arguments 物件是類陣列，因此如果使用陣列方法需要將其轉換成陣列。\n為了程式碼的可讀性，通常會給可變長度的參數一個假名稱，讓閱讀程式碼時，知道這裡是輸入可變長度的參數。\n上段程式碼改用其餘運參數：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function foo(...args) { args.forEach(i =\u0026gt; { if (typeof i !== \u0026#39;number\u0026#39;) { console.log(\u0026#39;輸入的值不是數字：\u0026#39; + i); } else { console.log(\u0026#39;輸入的值是數字：\u0026#39; + i); } }); } foo(1, 2, 5, \u0026#39;a\u0026#39;); // \u0026#34;test.js:6 輸入的值是數字：1\u0026#34; // \u0026#34;test.js:6 輸入的值是數字：2\u0026#34; // \u0026#34;test.js:6 輸入的值是數字：5\u0026#34; // \u0026#34;test.js:4 輸入的值不是數字：a\u0026#34;   如果使用箭頭函式，其餘運算子必須以小括號標記，即使函式只有一個參數：\n1 2 3  let sumAll = (...number) =\u0026gt; number.reduce((total, next) =\u0026gt; total + next); console.log(sumAll(1, 3, 5)); // 9   ","description":"ES6 新增了... 運算子，但在不同位置，會有不同的功能，所以會有兩種叫法，分別為「展開」和「其餘」運算子。","id":6,"section":"posts","tags":["JavaScript","展開運算子","其餘運算子","ES6"],"title":"展開／其餘運算子","uri":"https://chupai.github.io/posts/200513_js_spread_and_rest_operator/"},{"content":"這週是 六角鼠年鐵人賽 第十四週，讓我們來看只關注頭尾的資料結構「堆疊」和「佇列」。\n\r堆疊（Stack） 堆疊（Stack），中國稱「栈」，是一種 後入先出（LIFO, Last In First Out） 的資料結構。\n1. 後入先出 LIFO 在 LIFO 的資料結構中，將優先處理最晚加進來的元素（最新）。\n堆疊使用兩種基本操作：\n push：將資料放入堆疊頂端（新增） pop：拿出疊頂端的資料（刪除）  簡單來說，就是先進去資料的最後出來、最後進去的資料最先出來。可以將堆疊想像成疊盤子，不論放盤子或取盤子，都只能從最上方，最先拿的盤子一定是最後一個放上來的。\n也就是說，在堆疊中，越底層的資料越舊，越靠近頂層越新，而且只能讀取最上層的資料（最新的）。\n2. JavaScript 實作堆疊 大部分的程式語言都提供內置的堆疊，但 JavaScript 沒有，所以我們用陣列來實作一個。\n2.1 宣告類別 宣告一個 Stack 類別：\n1 2 3 4 5 6  class Stack { constructor() { this.items = []; } // methods }   我們需要一個能夠存儲堆疊裡的元素的資料結構，因此我們可以使用陣列來實作。\n2.2 屬性方法 主要方法：\n push(element(s))：新增一個或多個元素到堆疊頂部。 pop()：移除堆疊頂部元素，同時回傳被移除的元素。  為了符合 LIFO 原則，我們使用陣列的 push 和 pop 方法實作。\n1 2 3 4 5 6 7  push(element) { this.items.push(element); } pop() { return this.items.pop(); }   輔助工具：\n peek() 或 top()：僅回傳堆疊頂端的元素。 isEmpty()：檢查堆疊內是否有元素，是空的回傳 true，否則回傳 false。 clear()：移除堆疊內的所有元素。 size()：回傳堆疊裡的元素個數，也就是資料長度。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 獲取最後一個元素 peek() { return this.items[this.items.length - 1]; } // 判斷儲存堆疊資料的陣列長度是否為 0 isEmpty() { return this.items.length === 0; } // 最簡單的清空，給一個新的空陣列 clear() { this.items = []; } // 回傳儲存堆疊資料的陣列長度 size() { return this.items.length; }   最終程式碼如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Stack { constructor() { this.items = []; } push(element) { this.items.push(element); } pop() { return this.items.pop(); } peek() { return this.items[this.items.length - 1]; } isEmpty() { return this.items.length === 0; } clear() { this.items = []; } size() { return this.items.length; } }   2.3 建立實體 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  const stack1 = new Stack(); // 新增元素 stack1.push(\u0026#39;盤子1\u0026#39;); stack1.push(\u0026#39;盤子2\u0026#39;); // 印出長度 console.log(stack1.size()); // 2  // 移除最上方元素 console.log(stack1.pop()); // \u0026#39;盤子2\u0026#39;  // 最上方元素 console.log(stack1.peek()); // \u0026#39;盤子1\u0026#39;  // 清除 stack1.clear(); // 是否為空 console.log(stack1.isEmpty()); // true   2.4 基於物件的堆疊 除了使用陣列來儲存堆疊元素，也可以改用物件來儲存堆疊裡的元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class Stack { constructor() { this.items = {}; this.count = 0; } push(element) { this.items[this.count] = element; this.count += 1; } pop() { if (this.isEmpty()) { return undefined; } this.count -= 1; const result = this.items[this.count]; delete this.items[this.count]; return result; } isEmpty() { return this.count === 0; } clear() { this.items = {}; this.count = 0; } size() { return this.count; } }   佇列（Queue） 佇列（Queue），中國稱「队列」，特性是 先進先出（FIFO, First-In-First-Out） 的資料結構。\n1. 先入先出 FIFO 在 FIFO 的資料結構中，會優先處理最早加進來的元素（最舊）。\n佇列使用兩種基本操作：\n enqueue：由佇列的後端（Rear / Back）添加新資料。 dequeue：由佇列的前端（Front）移除資料。  舉個生活上的例子，排隊上廁所：先到的人先上，後來的排後面。\n當你想要按順序處理元素時，使用佇列會是一個很好的選擇。\n2. JavaScript 實作佇列 大部分的程式語言都提供內置的佇列，但 JavaScript 沒有，所以我們用陣列來實作一個。\n2.1 宣告類別 宣告一個 Queue 類別：\n1 2 3 4 5 6  class Queue { constructor() { this.items = []; } // methods }   並用陣列來儲存佇列裡的元素。\n2.2 屬性方法 佇列的兩種主要操作方法：\n enqueue(element(s))：新增一個或多個元素到佇列尾部。 dequeue()：移除佇列的第一個元素，並回傳被移除的元素。  1 2 3 4 5 6 7 8  enqueue(element) { this.items.push(element); } dequeue() { return this.items.shift(); }   輔助工具：\n front() 或 head()：僅回傳佇列的第一個元素。 rear() 或 tail()：僅回傳佇列的最一個元素。 isEmpty()：檢查佇列內是否有元素，是空的回傳 true，否則回傳 false。 clear()：移除佇列內的所有元素。 size()：回傳佇列裡的元素個數，也就是資料長度。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  front() { return this.items[0]; } rear() { return this.items[this.items.length - 1]; } isEmpty() { return this.items.length === 0; } clear() { this.items = []; } size() { return this.items.length; }   最終程式碼如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class Queue { constructor() { this.items = []; } enqueue(element) { this.items.push(element); } dequeue() { return this.items.shift(); } front() { return this.items[0]; } rear() { return this.items[this.items.length - 1]; } isEmpty() { return this.items.length === 0; } clear() { this.items = []; } size() { return this.items.length; } }   2.3 建立實體 模擬排隊：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const queue = new Queue(); // 隊伍空的嗎? console.log(queue.isEmpty()); // ture  // 排隊 queue.enqueue(\u0026#39;A\u0026#39;); queue.enqueue(\u0026#39;B\u0026#39;); queue.enqueue(\u0026#39;C\u0026#39;); // 先出隊的 console.log(queue.dequeue()); // \u0026#39;A\u0026#39;  // 剩幾個? console.log(queue.size()); // 2  // 隊伍最後一個 console.log(queue.rear()); // \u0026#39;C\u0026#39;   3. 優先佇列（Priority Queue） 在一般情況下，從佇列中處理（刪除）的一定是第一個加入的元素，但優先佇列（Priority Queue），不必遵守佇列 FIFO 的特性，每個元素都會設定優先級，優先級最高（數字越小越高）的會優先處理，若相同級別才看排列順序。\n用排隊來比喻就是 VIP 會員等級，等級越高優先服務，或是醫院急診室會評估傷患等級來給予治療順序。\n優先佇列的差異在於 enqueue 方法，在加入元素時，會根據優先級決定插入的位置。\n priority 為優先級，預設值給它無限大。 我們用一個 queueElement 物件來儲存元素和優先級的值。 如果佇列為空直接入列，否則比較優先級。 一個一個比較元素優先級：  優先級較高就用插入在它的前面，並結束函式； 如果都沒有就加到佇列後端。    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Priorityqueue extends Queue { enqueue(element, priority = Infinity) { const queueElement = { element, priority }; if (this.isEmpty()) { this.items.push(queueElement); } else { for (let i = 0; i \u0026lt; this.items.length; i++) { if (priority \u0026lt; this.items[i].priority) { this.items.splice(i, 0, queueElement); return; } } this.items.push(queueElement); } } }   建立實體：\n1 2 3 4 5 6 7 8 9 10 11  const pq = new Priorityqueue(); pq.enqueue(\u0026#39;A\u0026#39;, 1); pq.enqueue(\u0026#39;B\u0026#39;); pq.enqueue(\u0026#39;C\u0026#39;, 1); pq.enqueue(\u0026#39;D\u0026#39;, 2); console.log(pq.dequeue()); // { element: \u0026#39;A\u0026#39;, priority: 1 } console.log(pq.dequeue()); // { element: \u0026#39;C\u0026#39;, priority: 1 } console.log(pq.dequeue()); // { element: \u0026#39;D\u0026#39;, priority: 2 } console.log(pq.dequeue()); // { element: \u0026#39;B\u0026#39;, priority: Infinity }   堆疊的應用 1. 十進制轉二進制 十進制轉二進制轉換過程：\n 10 / 2 = 5 餘 0 5 / 2 = 2 餘 1 2 / 2 = 1 餘 0 1 / 2 = 0 餘 1 10 的二進制結果為 1010  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function divideBy2(decNumber) { const remStack = new Stack(); let number = decNumber; let rem = null; // 餘數  // 將餘數放進堆疊中  while (number \u0026gt; 0) { rem = Math.floor(number % 2); remStack.push(rem); number = Math.floor(number / 2); } // 將結果連成字串  let baseString = \u0026#39;\u0026#39;; while (!remStack.isEmpty()) { baseString += remStack.pop(); } return baseString; }   將上面程式碼稍微修改，可以改成十進制轉 2 ~ 36 進制，10 ~ 35 用英文字母表示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function baseConverter(decNumber, base) { if (!(base \u0026gt;= 2 \u0026amp;\u0026amp; base \u0026lt;= 36)) { return \u0026#39;\u0026#39;; } const remStack = new Stack(); const DIGITS = \u0026#39;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39;; let number = decNumber; let rem = null; while (number \u0026gt; 0) { rem = Math.floor(number % base); remStack.push(rem); number = Math.floor(number / base); } let baseString = \u0026#39;\u0026#39;; while (!remStack.isEmpty()) { baseString += DIGITS[remStack.pop()]; } return baseString; }   2. 驗證括號的問題  Leetcode: 20. Valid Parentheses\n驗證括號（Valid Parentheses）或稱 平衡括號（Balanced Brackets）。\n 給定一個包括 (、{、[、)、}、] 的字串，判斷字串是否有效。\n有效字串需滿足：\n 左括號必須用相同類型的右括號閉合。 左括號必須以正確的順序閉合。  注意空字串可被認為是有效字串。\n範例：\n1 2 3 4 5  \u0026#39;()\u0026#39; // ture \u0026#39;()[]{}\u0026#39; // true \u0026#39;(]\u0026#39; // false \u0026#39;([)]\u0026#39; // false \u0026#39;{[]}\u0026#39; // true   流程：\n 檢查字串，遇到 ( { [ 就放到堆疊中 若遇到 ) ] } 就去找堆疊頂端的資料是否有相對應的 ( { [  沒有就回傳 false 若有就將堆疊頂端對應的 ( { [ 移除   最後檢查堆疊內使否為空  如果是空的回傳 true 不是空的，表示有沒對應到的 ( { [ 回傳 false    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function isValid(s) { const stack = []; const OPENING = { \u0026#39;(\u0026#39;: 0, \u0026#39;[\u0026#39;: 1, \u0026#39;{\u0026#39;: 2 }; const CLOSEING = { \u0026#39;)\u0026#39;: 0, \u0026#39;]\u0026#39;: 1, \u0026#39;}\u0026#39;: 2 }; for (let i = 0; i \u0026lt; s.length; i++) { const character = s[i]; if (OPENING[character] \u0026gt;= 0) { stack.push(character); } else if (CLOSEING[character] \u0026gt;= 0) { const peek = stack[stack.length - 1]; if (OPENING[peek] === CLOSEING[character]) { stack.pop(); } else { return false; } } } return stack.length === 0; }   總結 堆疊和佇列這類最基本的資料結構，它們因為特殊條件限制，只關心頭尾的新增、刪除、獲取的操作，並不關心內部的元素的狀態。\n","description":"這週是六角鼠年鐵人賽第十四週，讓我們來看只關注頭尾的資料結構「堆疊」和「佇列」。","id":7,"section":"posts","tags":["資料結構","堆疊","佇列","w3HexSchool"],"title":"JavaScript 學演算法（六）- 堆疊 ＆ 佇列","uri":"https://chupai.github.io/posts/200504_ds_stack_queue/"},{"content":"這週是 六角鼠年鐵人賽 第十三週，要來簡單說明與陣列類似的資料結構「鏈結串列 Linked list」。\n\r前言 首先來談談陣列的缺點，在大多數的程式語言中，陣列的長度（大小）宣告後就是固定的，也就是說，宣告時已經決定最大空間，如果預設的空間太小容易發生上溢，如果太大容易造成記憶體空間浪費。\n而且從陣列的開頭或中間插入、刪除元素時，往往需要般動其他元素，因此效率不佳。\n鏈結串列是什麼 鏈結串列（Linked list），中國稱「链表」，與陣列一樣都是線性資料結構，但不同於陣列，它為鏈式儲存結構，也就是記憶體位置儲存為不連續性。\n1. 定義 鏈結串列是由一連串 節點（node） 組成，節點之間是透過指標來連接。所以儲存上並不需要連續的空間。\n每個節點包含：\n 資料元素 指標  指標（又稱鏈結、引用），通常為一或兩個，用來指向上／下個的位置，若沒有上／下一個節點，則為空。如果指標斷裂，資料就遺失。\n舉生活上的例子來說，鏈結串列如同火車的車廂一樣，一節拉著一節。\n相較於陣列，鏈結串列的元素並不是連續放置的，插入或移除元素不需要移動其他元素，只需要修改上／下個指標的指向。\n因為鏈結串列沒有索引，若要存取特定特定，需要從頭開始找起，因此相較於陣列，存取資料較費時。\n2. 類型 鏈結串列有很多種不同的類型：\n 單向鏈結串列（Singly Linked List） 雙向鏈結串列（Doubly Linked List） 迴圈鏈結串列（Circularly Linked List）  2.1 單向鏈結串列 單向鏈結串列，又稱單鏈結串列、線性鏈結串列、普通鏈結串列，是最基本的鏈結串列，其特點是鏈結串列的鏈結方向是單向的，對鏈結串列的存取要通過從頭部開始，依序往下讀取。\n2.2 雙向鏈結串列 雙向鏈結串列，又稱為雙鏈結串列，它與單向鏈結串列最大的區別在於，每個結點中都有兩個指標，分別指向上一個和下一個結點。\n所以，從雙向鏈結串列中的任意一個結點開始，都可以很方便地存取它的上一個和下一個結點。\n2.3 迴圈鏈結串列 迴圈鏈結串列，又稱環狀鏈結串列、循環鏈結串列，它與一般的鏈結串列操作基本一致，但串列頭尾的指標會連接再一起，形成一個環。\n3. 時間複雜度 不管是維基百科還是其他鏈結串列相關文章，都只寫鏈結串列的時間複雜度分別為：\n 插入、刪除：$O(1)$ 存取、查詢：$O(n)$  但要注意的是，插入與刪除的 $O(1)$ 指的是，已經獲取節點的前提下所執行的動作。沒有獲取節點，要插入或刪除指定位置的節點，會先經過查詢節點這個動作，所以時間複雜度會變為 $O(n)$。\n但假如節點位置為開頭，時間複雜度也為 $O(1)$。\n4. 優缺點比較 鏈結串列與陣列的優缺點比較。\n陣列的優點：\n 可利用 index 隨機存取（Random Access）只需要 $O(1)$ 的時間。 可靠度高，不會因為鏈結斷裂而遺失資料。  陣列的缺點：\n 在開頭或中間插入、刪除元素，需要花費 $O(n)$ 的時間將元素移動。 連續的記憶體空間，可能會有用不到的空間，而造成浪費。 若陣列已滿，會需要花費 $O(n)$ 的時間搬動資料到新的陣列內。  鏈結串列的優點：\n 資料在記憶體中非連續。 插入、刪除元素只需要修改上／下個指標的指向。  鏈結串列的優點：\n的缺點：\n 只能順序存取，需要花費 $O(n)$ 的時間。 鏈結斷裂就會遺失資料。  JavaScript 實作鏈結串列 JavaScript 沒有內建鏈結串列，我們使用物件來模擬。\n鏈結串列的資料結構：\n1 2 3 4 5 6 7 8 9 10  { data: \u0026#39;data1\u0026#39;, next: { data: \u0026#39;data2\u0026#39;, next: { data: \u0026#39;data3\u0026#39;, next: null } } }   首先會建立兩個類別，分別是 Node 表示節點、LinkedList 提供插入、刪除節點以及其他輔助方法。\n1. Node 節點 Node 包含資料和指標：\n data：資料 next：指向下一個節點。  1 2 3 4 5 6  class Node { constructor(data) { this.data = data; this.next = null; } }   2. LinkedList 基本屬性：\n head：指向串列開頭節點 tail：指向串列結尾節點 length：節點數量  1 2 3 4 5 6 7 8  class LinkedList { constructor() { this.head = null; this.tail = null; this.length = 0; } // methods }   2.1 輔助方法 先建立會用到的輔助方法。\nisEmpty() 檢查串列是否為空：\n1 2 3  isEmpty() { return this.length === 0; }   getNode() 取得指定位置節點：\n1 2 3 4 5 6 7 8 9 10 11 12  getNode(index) { // 判斷指定位置是否在範圍內  if (index \u0026lt; 0 || index \u0026gt;= this.length) return null; // 從頭開始迭代到指定位置訪問  let currNode = this.head; let currIndex = 0; while (currIndex \u0026lt; index) { currIndex += 1; currNode = currNode.next; } return currNode; }   為了方便驗證，建立一個 print() 照順序印出所有節點資料值：\n1 2 3 4 5 6 7 8 9  print() { const temp = []; let currNode = this.head; while (currNode) { temp.push(currNode.data); currNode = currNode.next; } return temp.join(\u0026#39;, \u0026#39;); }   2.2 插入新節點  append(data)：在串列尾部插入一個節點。 insert(index, data)：在指定位置插入一個節點。  在串列尾部插入一個節點可分為兩種情況：\n 串列為空，更新 head 和 tail。 串列不為空，則更新 tail。  需要先將原本的 tail 指向新的節點； 再更新 tail。    1 2 3 4 5 6 7 8 9 10 11  append(data) { const newNode = new Node(data); if (this.isEmpty()) { this.head = newNode; this.tail = newNode; } else { this.tail.next = newNode; this.tail = newNode; } this.length += 1; }   在指定位置插入元素，需要考慮三種情況：\n 插入串列結尾後面，等同使用 append 方法。 插入串列開頭，為取代 head。 在中間位置插入，需要修改上一個節點的指標。  取得指定位置的上一個節點； 再取得指定位置上原本的節點； 重新定義上一個節點指標，指向新插入的節點； 最後將新插入的節點指標，指向原本的節點。    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  insert(index, data) { if (index \u0026gt;= this.length) { this.append(data); return; } const newNode = new Node(data); if (index \u0026lt;= 0) { newNode.next = this.head; this.head = newNode; } else { const prevNode = this.getNode(index - 1); const currNode = prevNode.next; prevNode.next = newNode; newNode.next = currNode; } this.length += 1; }   驗證：\n1 2 3 4 5 6 7 8 9 10 11 12 13  const list = new LinkedList(); list.append(\u0026#39;data1\u0026#39;); list.append(\u0026#39;data2\u0026#39;); list.append(\u0026#39;data3\u0026#39;); console.log(list.print()); // \u0026#39;data1, data2, data3\u0026#39;  list.insert(0, \u0026#39;a\u0026#39;); console.log(list.print()); // \u0026#39;a, data1, data2, data3\u0026#39; list.insert(4, \u0026#39;b\u0026#39;); console.log(list.print()); // \u0026#39;a, data1, data2, data3, b\u0026#39; list.insert(2, \u0026#39;b\u0026#39;); console.log(list.print()); // \u0026#39;a, data1, b, data2, data3, b\u0026#39;   2.3 刪除節點 先判index 有效，刪除指定位置的節點：\n 刪除的節點是開頭，重新指定 head。 其他節點，則找到目標節點，並修改上一個節點的指向，如果目標節點是 tail（指標指向 null）記得要重新指定。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  removeAt(index) { if (index \u0026lt; 0 || index \u0026gt;= this.length) return; if (index === 0) { this.head = this.head.next; } else { const prevNode = this.getNode(index - 1); const delNode = prevNode.next; const nextNode = delNode.next; prevNode.next = nextNode; if (nextNode === null) { this.tail = prevNode; } } this.length -= 1; }   2.4 其他方法 getData() 取得指定位置節點的資料值：\n1 2 3 4  get(index) { const node = this.getNode(index); return node ? node.data : null; }   indexOf() 根據資料的值，回傳索引（第一個符合條件的），沒有則回傳 -1：\n1 2 3 4 5 6 7 8 9 10  indexOf(data) { let currNode = this.head; let currIndex = 0; while (currNode) { if (currNode.data === data) return currIndex; currIndex += 1; currNode = currNode.next; } return -1; }   remove() 根據資料的值，刪除符合的第一個節點：\n1 2 3 4  remove(data) { const index = this.indexOf(data); return this.removeAt(index); }   clear() 清空串列：\n1 2 3 4 5  clear() { this.head = null; this.tail = null; this.length = 0; }   size() 回傳串列的節點個數：\n1 2 3  size() { return this.length; }   3. 最終程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118  class Node { constructor(data) { this.data = data; this.next = null; } } class LinkedList { constructor() { this.head = null; this.tail = null; this.length = 0; } append(data) { const newNode = new Node(data); if (this.isEmpty()) { this.head = newNode; this.tail = newNode; } else { this.tail.next = newNode; this.tail = newNode; } this.length += 1; } insert(index, data) { if (index \u0026gt;= this.length) { this.append(data); return; } const newNode = new Node(data); if (index \u0026lt;= 0) { newNode.next = this.head; this.head = newNode; } else { const prevNode = this.getNode(index - 1); const currNode = prevNode.next; prevNode.next = newNode; newNode.next = currNode; } this.length += 1; } removeAt(index) { if (index \u0026lt; 0 || index \u0026gt;= this.length) return; if (index === 0) { this.head = this.head.next; } else { const prevNode = this.getNode(index - 1); const delNode = prevNode.next; const nextNode = delNode.next; prevNode.next = nextNode; if (nextNode === null) { this.tail = prevNode; } } this.length -= 1; } indexOf(data) { let currNode = this.head; let currIndex = 0; while (currNode) { if (currNode.data === data) return currIndex; currIndex += 1; currNode = currNode.next; } return -1; } remove(data) { const index = this.indexOf(data); return this.removeAt(index); } getNode(index) { if (index \u0026lt; 0 || index \u0026gt;= this.length) return null; let currNode = this.head; let currIndex = 0; while (currIndex \u0026lt; index) { currIndex += 1; currNode = currNode.next; } return currNode; } getData(index) { const node = this.getNode(index); return node ? node.data : null; } isEmpty() { return this.length === 0; } clear() { this.head = null; this.tail = null; this.length = 0; } size() { return this.length; } print() { const temp = []; let currNode = this.head; while (currNode) { temp.push(currNode.data); currNode = currNode.next; } return temp.join(\u0026#39;, \u0026#39;); } }   4. 雙向鏈結串列 接下來我們來實作雙向鏈結串列，它與單向鏈結串列的差異在於，節點會有兩個指標。\n節點上會多一個指向上一個節點的指標：\n1 2 3 4 5 6 7  class DoublyNode { constructor(data) { this.data = data; this.next = null; this.prev = null; } }   除了插入、刪除節點要多加處理 prev 指標，其他方法操作與單向鏈結串列相同，我們這裡直接繼承 LinkedList：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  class DoublyLinkedList extends LinkedList { append(data) { const newNode = new DoublyNode(data); if (this.isEmpty()) { this.head = newNode; this.tail = newNode; } else { newNode.prev = this.tail; // new  this.tail.next = newNode; this.tail = newNode; } this.length += 1; return true; } insert(index, data) { if (index \u0026gt;= this.length) { this.append(data); return; } const newNode = new DoublyNode(data); if (index \u0026lt;= 0) { this.head.prev = newNode; // new  newNode.next = this.head; this.head = newNode; } else { const prevNode = this.getNode(index - 1); const currNode = prevNode.next; prevNode.next = newNode; newNode.next = currNode; } this.length += 1; } removeAt(index) { if (index \u0026lt; 0 || index \u0026gt;= this.length) return; if (index === 0) { this.head = this.head.next; this.head.prev = null; // new  } else { const prevNode = this.getNode(index - 1); const delNode = prevNode.next; const nextNode = delNode.next; prevNode.next = nextNode; if (nextNode === null) { this.tail = prevNode; } else { nextNode.prev = prevNode; // new  } } this.length -= 1; } }   5. 迴圈鏈結串列 迴圈鏈結串列 tail 的 next 指標會指向 head、head 的 prev 指標會指向 tail，而非 null。\nLeetCode 相關題目  707. Design Linked List 設計鏈結串列 141. Linked List Cycle 迴圈鏈結串列 206. Reverse Linked List 反轉鏈結串列  總結 陣列是 JavaScript 最常使用的資料結構，JavaScript 的陣列與其它語言相比很特殊，沒有元素型別與大小限制，但將元素從開頭插入或移除，時間複雜度一樣需要 $O(n)$，而鏈結串列只需要 $O(1)$。\n如果沒有頻繁存取元素的需求，而有需要頻繁將元素插入開頭，可以考慮使用鏈結串列的資料結構邏輯。\n","description":"這週是六角鼠年鐵人賽第十三週，要來簡單說明與陣列類似的資料結構「鏈結串列 Linked list」。","id":8,"section":"posts","tags":["資料結構","鏈結串列","w3HexSchool"],"title":"JavaScript 學演算法（五）- 鏈結串列 Linked list ","uri":"https://chupai.github.io/posts/200427_ds_linkedlist/"},{"content":"這週是 六角鼠年鐵人賽 第十二週，要來簡單說明，最基本的資料結構「陣列 Array」。\n\r陣列是什麼 在計算機科學中，陣列資料結構（array data structure），簡稱 陣列（Array），中國稱「数组」，是最基本的資料結構，屬於線性有序的資料結構。\n大多數的高階程式語言都會內建的陣列資料型別（type），少部分是由雜湊表、連結串列、搜尋樹來實現。\n1. 定義 陣列是由相同類型的元素所組成的有序的資料結構，通常由一塊連續的記憶體位置儲存。\n因為是連續的記憶體位置，所以大部分的高階語言，陣列宣告後的長度（大小）是不能改變的，如果需要調整陣列大小，需要將所有元素搬到新的陣列。\n陣列在插入、刪除元素的效率非常差，因為需要移動（往前或往後）其餘元素。\n元素可以透過索引（index）做隨機存取（Random Access），有時亦稱直接存取。\n陣列特色：\n 線性有序的資料結構 相同類型的元素所組成 由一塊連續的記憶體位置儲存 可以透過索引隨機存取 索引初始位置為 0  JavaScript 的陣列 JavaScript 的陣列與大部分的高階語言的陣列相比，非常不一樣。\n我們上面提到，陣列的定義最主要就是：\n 相同類型的元素所組成 由一塊連續的記憶體位置儲存  但 JavaScript 屬於於動態型別的程式語言，變數單純只是容器，型別是根據賦予的值來決定。因此陣列可以存放不同型別的元素。\nJavaScript 是基於原型模式的物件導向語言，幾乎所有的事物都是物件，或是具有類似物件的行為，陣列也不例外，它本質上屬於一種特殊的物件。\n1 2 3 4  typeof [] // \u0026#34;object\u0026#34;  const array = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; console.log( Object.keys(array) ); // [\u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;]   所以 JavaScript 的陣列與其它程式語言相比，執行速度較慢。\n1. 記憶體儲存 另外，JavaScript 的陣列並不一定是儲存於連續記憶體空間。\n早期的 JavaScript 引擎用為「鏈式儲存結構」，而到了 Chrome 的 V8 才使用「順序儲存結構」與「鏈式儲存結構」混合模式。\n在多數的情況下，V8 引擎的陣列是「順序儲存結構」也就是分配連續記憶體，而以下情況為非連續記憶體：\n 稀疏陣列 元素的非單一型別  非連續記憶體的陣列用的是類似雜湊表（hash table）對映的方式存在。\n陣列的操作 JavaScript 基本操作請參考：\n 陣列 迭代陣列 ","description":"這週是六角鼠年鐵人賽第十二週，最基本的資料結構「陣列 Array」。","id":9,"section":"posts","tags":["資料結構","陣列 Array","w3HexSchool"],"title":"JavaScript 學演算法（四）- 陣列 Array ","uri":"https://chupai.github.io/posts/200426_ds_array/"},{"content":" JavaScript筆記 目錄\n \r對陣列做迭代 對陣列做迭代是最常見的陣列操作，最基本的的迭代方式就是使用 for 迴圈：\n1 2 3 4 5 6 7 8 9  let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; for (let i = 0; i \u0026lt; arr.length; i++) { console.log(arr[i]); } // \u0026#34;a\u0026#34; // \u0026#34;b\u0026#34; // \u0026#34;c\u0026#34;   但如果需要對陣列從頭到尾的迭代，使用 for 迴圈太繁瑣，需要索引值、結束條件。\n因此可以改用 forEach 方法或 ES6 的 for of 迴圈來迭代陣列。\n   類型 效能 說明     for 最高 雖然繁瑣，但自由度高，可使用變數改變索引值，也可以使用 break、return、continue 等語句   for in 最低 可用於物件，但不建議用於陣列   forEach 中間 搭配箭頭函式可使程式碼更簡潔   for of 中間（高於 forEach） 簡潔，而且比起 forEach 可使用 break、return、continue 等語句，但沒有索引    1. forEach 首先我們來看看 forEach 方法，它會將陣列內的每個元素，皆傳入並執行給定的函式一次，不會產生新的陣列。\n語法如下：\n1 2 3  arr.forEach(function callback(currentValue[, index[, array]]) { //your iterator }[, thisArg]);    callback 函式共有三個參數：  currentValue：陣列當前元素 index：陣列當元素的索引值 array：陣列本身   thisArg：執行 callback 回呼函式的 this（即參考之 Object）值 回傳值： undefined  currentValue 為必填參數，而 index 與 array 則選擇性。\n試著改寫開頭的 for 迴圈，達到結果。\n1 2 3 4 5 6 7 8 9 10 11 12  let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; arr.forEach(function(item) { console.log(item); }) // \u0026#34;a\u0026#34; // \u0026#34;b\u0026#34; // \u0026#34;c\u0026#34;  // 使用箭頭函式 arr.forEach((item) =\u0026gt; console.log(item));   當傳入參數 thisArg，callback 函式的 this 就會指向你所傳入的物件。\n1 2 3 4 5 6 7 8 9 10  const arr = [1, 2, 3]; const arr2 = [\u0026#39;一\u0026#39;, \u0026#39;二\u0026#39;, \u0026#39;三\u0026#39;]; arr.forEach(function(item, index) { console.log(item + \u0026#39;：\u0026#39; + this[index]); }, arr2); // \u0026#34;1：一\u0026#34; // \u0026#34;2：二\u0026#34; // \u0026#34;3：三\u0026#34;   2. for of 迴圈 在 ES6 新增了 for of 迴圈，它可以用於可迭代物件（Array、Map、Set、String、TypedArray，arguments）上，也就是只要是實現了 Interable 介面的資料型別都能被遍歷。\n1 2 3 4 5 6 7 8 9  let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; for (let element of arr) { console.log(element); } // \u0026#34;a\u0026#34; // \u0026#34;b\u0026#34; // \u0026#34;c\u0026#34;   使用 for of 遍與 forEach 的最大差異就是可以中斷：\n1 2 3 4 5 6 7 8 9 10 11  let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;]; for (let element of arr) { if (element === \u0026#39;c\u0026#39;) { break; } console.log(element); } // \u0026#34;a\u0026#34; // \u0026#34;b\u0026#34;   操作陣列元素 處理陣列中的元素，並不更動原陣列是常見的操作。\n使用 forEach 方法，須先建立一個新的陣列搭配 push 方法。\n舉例，合併姓名：\n1 2 3 4 5 6 7 8 9 10 11 12  const inventors = [ { first: \u0026#39;Albert\u0026#39;, last: \u0026#39;Einstein\u0026#39; }, { first: \u0026#39;Isaac\u0026#39;, last: \u0026#39;Newton\u0026#39; }, ]; const names = []; inventors.forEach((item) =\u0026gt; { names.push(`${item.first}${item.last}`); }); console.log(names); // [\u0026#34;Albert Einstein\u0026#34;, \u0026#34;Isaac Newton\u0026#34;]   如果改用 map 方法：\n1 2 3 4 5 6  inventors.map(function(item) { return `${item.first}${item.last}`; }); // 箭頭函式 inventors.map(item =\u0026gt; `${item.first}${item.last}`);   map 方法會建立一個新的陣列，其內容為原陣列的每一個元素經由回呼函式運算後所回傳的結果之集合。\n參數基本上與 forEach() 相同，但回呼函式多了一個 return 可以將會將處理結果放到新的陣列中，並回傳新的陣列。\n讓我們來實作一下 map 方法，瞭解其原理：\n1 2 3 4 5 6 7 8 9  function map(arr, callback) { let result = []; for (let i = 0; i \u0026lt; arr.length; i++) { result.push(callback(arr[i])); } return result; } map(inventors, (item) =\u0026gt; `${item.first}${item.last}`);   其他陣列迭代操作方法：\n map() ：執行結果存到新陣列。 filter()：將符合條件的元素存到新陣列。 find()：找到第一個符合條件的元素。 some() ：判斷有元素符合條件。 every()：判斷所有元素都符合條件。 reduce()：根據規則縮減陣列。  1. 過濾陣列 filter 方法會建立一個經指定之函式運算後，由原陣列中通過該函式檢驗之元素所構成的新陣列。 return 是用來判斷條件。如果 return 值為 true 會將該元素放入新陣列。\n通常用來篩選資料：\n1 2 3 4 5 6 7  const numbers = [33, 22, 66, 88, 10, 5, 6, 9]; const bigNum = numbers.filter(function(item) { return item \u0026gt; 30; }); console.log( bigNum ); // [33, 66, 88]   找出大於 30 的數值。\n3. 陣列搜尋 some 方法會測試陣列中是否至少有一個元素通過由給定之函式所實作的測試。return 判斷條件。如果至少 return 一次 true 則回傳 true。\n尋找陣列中使否有元素是奇數值：\n1 2 3 4 5 6 7 8  const array = [1, 2, 3, 4, 5]; const arraySome = array.some(function (even) { return even % 2 === 0; }); console.log( arraySome ); // true   要在一個陣列中搜尋某個值，一般來說會使用 indexOf()，它會回傳第一個符合的值的索引，沒找到回傳 -1。\n1 2 3  const arr = [1, 2, 3, 4, 5]; console.log(arr.indexOf(2)); // 1   但 indexOf() 是使用 === 來進行比較，因此如果傳入字串'2'，就會找不到。\n1 2 3  // 承接上段程式碼  console.log(arr.indexOf(\u0026#39;2\u0026#39;)); // -1   在 ES5 時，會使用 some() 來變通比對邏輯，但也只能判斷該陣列是否擁有該元素，無法實際獲取實際符合條件元素。\n1 2 3 4 5 6 7  // 承接上段程式碼  let result = arr.some(function(even) { return even == \u0026#39;2\u0026#39;; }) console.log(result); // true   而到了 ES6 新增了 find()，解決了這個問題。\nfind 方法會回傳第一個滿足所提供之測試函式的成員值。否則回傳 undefined。與 some() 的差異在於，回傳第一個 return 值為 true 的元素。\n找出第一個符合條件的元素：\n1 2 3 4 5 6 7 8 9 10 11 12  const inventory = [ {name: \u0026#39;apples\u0026#39;, quantity: 2}, {name: \u0026#39;bananas\u0026#39;, quantity: 0}, {name: \u0026#39;cherries\u0026#39;, quantity: 5} ]; const inventoryFind = inventory.find(function(item) { return item.name === \u0026#39;cherries\u0026#39;; }); console.log( inventoryFind ); // { name: \u0026#39;cherries\u0026#39;, quantity: 5 }   findIndex() 也是 ES6 新增的方法，findIndex() 與 find() 差異只在於，其會回傳其索引，如果沒有符合的元素，將返回 -1。\n1 2 3 4 5 6 7 8  // 承接上段程式碼  const inventoryIndexFind = inventory.findIndex(function(item) { return item.name === \u0026#39;cherries\u0026#39;; }); console.log(inventoryIndexFind); // 2   因此 find() 可以應用在更新資料，而 findIndex() 會用來刪除資料。\n1 2 3 4 5 6  const cart = [ {id: 1, count: 0}, {id: 2, count: 0}, {id: 3, count: 0}, {id: 4, count: 0}, ];   找出 id 為 3 並將 count 更新成 5：\n1 2 3 4 5 6 7 8 9 10 11  let item = cart.find((item)=\u0026gt; item.id === 3); item.count = 5; console.log( cart ); // [ // {id: 1, count: 0}, // {id: 2, count: 0}, // {id: 3, count: 5}, // {id: 4, count: 0}, // ]   刪除 id 為 3 的元素：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const cart = [ {id: 1, count: 0}, {id: 2, count: 0}, {id: 3, count: 0}, {id: 4, count: 0}, ]; let index = cart.findIndex((item)=\u0026gt; item.id === 3); cart.splice(index, 1); console.log( cart ); // [ // {id: 1, count: 0}, // {id: 2, count: 0}, // {id: 4, count: 0}, // ]   every 方法會測試陣列中的所有元素是否都通過了由給定之函式所實作的測試。\n與 some() 的差異在於，every() 必須要全部的元素都符合條件才會回傳 true。\n是否全部都是基數：\n1 2 3 4 5 6 7 8  const array = [1, 2, 3, 4, 5]; const arrayEvery = array.every(function (even) { return even % 2 === 0; }); console.log( arrayEvery ); // false   4. reduce reduce 方法將一個累加器及陣列中每項元素（由左至右）傳入回呼函式，將陣列化為單一值。其實就是帶有暫存器的 forEach()。\n語法：\n1  arr.reduce(callback[accumulator, currentValue, currentIndex, array], initialValue)    accumulator：用來累積回呼函式回傳值的累加器，若有提供的話，詳如下敘。累加器是上一次呼叫後，所回傳的累加數值。 initialValue：於第一次呼叫 callback 時要傳入的累加器初始值。若沒有提供初始值，則原陣列的第一個元素將會被當作初始的累加器。假如於一個空陣列呼叫 reduce() 方法且沒有提供累加器初始值，將會發生錯誤。 return：放入累加器中  假設要計算一個數值陣列的總合值為多少，使用 for 迴圈都會額外宣告一個 total 變數來當作累加器。\n1 2 3 4 5 6 7 8 9  const numbers = [1, 2, 3, 4, 5, 6]; let total = 0; for(let i = 0; i \u0026lt; numbers.length; i++) { total += numbers[i]; } console.log( total ); // 21   使用 reduce()：\n1 2 3 4 5 6 7 8  const numbers = [1, 2, 3, 4, 5, 6]; const numTotal = numbers.reduce(function(total, item) { return total + item }, 0); console.log( numTotal ); // 21   而 reduceRight() 基本上與 reduce() 一樣，差異是從右到左進行累加。\n我們用扁平化（flatten）一個元素為陣列的陣列來觀察差異：\n1 2 3 4 5 6 7 8 9 10 11  const arr = [[0, 1], [2, 3], [4, 5]]; function callback(a, b) { return a.concat(b); } let result1 = arr.reduce(callback, []); let result2 = arr.reduceRight(callback, []); console.log(result1); // [0, 1, 2, 3, 4, 5] console.log(result2); // [4, 5, 2, 3, 0, 1]   ","description":"對陣列做迭代是最常見的陣列操作。","id":10,"section":"posts","tags":["JavaScript","陣列 Array"],"title":"迭代陣列","uri":"https://chupai.github.io/posts/200425_js_array_iterate/"},{"content":" JavaScript筆記 目錄\n \r概述 在 JavaScript 中的陣列與其他語言的不同之處在於，JavaScript 的陣列只是容器。任何類型的資料，都可以放入陣列。\n1. 陣列其實就是物件 每個陣列都會有索引值（index），是從 0 開始的順序整數值，但陣列其實就是擁有固定鍵名的物件。\n1 2 3 4 5  typeof [] // \u0026#34;object\u0026#34;`  const array = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; console.log( Object.keys(array) ); // [\u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;]   使用 Object.keys() 傳回陣列的所有 鍵名（key name）。可以看到陣列的鍵名就是整數 0、1、2。\n雖然 typeof 無法判斷陣列與物件，但可以利用 instanceof 運算子區分陣列和物件。\n1 2 3 4 5  const o = {}; const a = []; console.log( o instanceof Array ); // false console.log( a instanceof Array ); // true   或是使用 Array.isArray() 來判斷：\n1 2 3 4  // 承接上方程式碼  console.log( Array.isArray(o) ); // false console.log( Array.isArray(a) ); // true   2. 為何要使用陣列？ 假設需要儲存一年中每個月的平均溫度：\n1 2 3 4 5 6  let averageTep1 = 25; let averageTep2 = 22; let averageTep3 = 24; let averageTep4 = 28; let averageTep5 = 29; ...   使用變數來存放絕對不是一個好辦法。\n因此可以使用陣列來存放資料，能夠一次管理多個變數，\n1 2 3 4 5 6 7 8 9 10  const averageTep = []; averageTep[0] = 25; averageTep[1] = 22; averageTep[2] = 24; averageTep[3] = 28; averageTep[4] = 29; ... console.log( averageTep ); // [25, 22, 24, 28, 29 ...]   還可以搭配物件使用：\n1 2 3 4 5 6 7 8  const person = [ {name: \u0026#39;Peter\u0026#39;, sex: \u0026#39;male\u0026#39;}, {name: \u0026#39;Mike\u0026#39;, sex: \u0026#39;male\u0026#39;}, {name: \u0026#39;Merry\u0026#39;, sex: \u0026#39;female\u0026#39;} ] console.log( person[0].name ); // \u0026#34;Peter\u0026#34; console.log( person[2].sex ); // \u0026#34;female\u0026#34;   基本操作 1. 建立 建立陣列有兩種基本方式：\n 建構函式 Array() 陣列實值 []  1 2 3 4 5  const arr1 = [1, 2, 3]; const arr2 = new Array(1, 2, 3); console.log( arr1 ); // [1, 2, 3] console.log( arr2 ); // [1, 2, 3]   new Arry() 與 Arry() 同義，表示 new 可省略。。\n但是，在 JavaScript 應該優先考慮使用 [] 陣列實值。除了用到字元比較少之外，還有 JavaScript 是自由度高的程式語言，new Array() 有可能會被複寫，創造出不是陣列的東西。\n另外 Array 建構式有一種特殊的使用方式，如果只傳入一個數值引數被傳入，那此建構函式不會把該值當成陣列中內容，而是當作長度 lenght。\nJavaScript 的陣列不需要預設大小，宣告後就可以新增需要的值（大部分高階語言的陣列宣告後大小就固定了）。\n2. 取值 可以透過索引取得元素的指定值：\n1 2 3 4 5 6 7  const array = [1, 2, 3, 4, 5]; console.log( array[0] ); // 1 console.log( array[1] ); // 2 console.log( array[2] ); // 3 console.log( array[3] ); // 4 console.log( array[4] ); // 5   3. 陣列內容操作 除了一開始宣告就有的元素，還可以直接透過賦值方式新增陣列元素：\n1 2 3 4 5 6  const array = []; array[0] = 1; array[1] = 2; console.log( array ); // [1, 2];   如果該索引位置已經有該元素，那將會覆蓋原來的值。\n新增／刪除頭尾的元素可以使用：\n push() 會添加一個或多個元素至陣列的末端，並且回傳陣列的新長度。 unshift() 會添加一個或多個元素至陣列的開頭，並且回傳陣列的新長度。 pop() 會移除並回傳陣列的最後一個元素。此方法會改變陣列的長度。 shift() 會移除並回傳陣列的第一個元素。此方法會改變陣列的長度。  以下兩個陣列方法能新增最後或最前的元素：\n1 2 3 4 5 6 7 8 9 10  // 承接上段程式碼  array.push(3); console.log( array ); // [1, 2, 3]  array.push(4, 5, 6); console.log( array ); // [1, 2, 3, 4, 5, 6]  array.unshift(0, 0); console.log(array); // [0, 0, 1, 2, 3, 4, 5, 6]   以下兩個陣列方法能移除最後或最前的元素：\n1 2 3 4 5 6 7  const array = [1, 2, 3, 4]; array.pop(); console.log( array ); // [1, 2, 3]  array.shift(); console.log( array ); // [2, 3]   如果要刪除特定位置的元素，如果用 deleta 運算子將其移除，會有以下問題：\n1 2 3 4 5 6  const array = [1, 2, 3, 4]; delete array[1]; console.log( array.length ); // 4 console.log( array ); // [1, undefined, 3, 4]   這樣會導致陣列變成稀疏陣列（關於稀疏陣列將在下面說明）。\n3.1 特定位置插入元素、刪除特定位置元素 要在陣列中插入元素、移除特定元素，可以使用 splice()，能通過刪除或替換現有元素或者原地添加新的元素來修改陣列，並以陣列形式回傳被修改的內容。\n此方法會改變原陣列。\n語法：\n1  array.splice(start[, deleteCount[, item1[, item2[, ...]]]])    start：指定修改的起始位置，可以是負數，由末尾計算索引。 deleteCount：表示要移除的數組元素的個數，從起始位置開始刪除。 item1, item2, ...：要插入的元素，由起始位置之後插入，如果不設定將只會刪除元素。  假設我們要在索引位置 2 之後插入一個新的元素：\n1 2 3 4 5  const array = [0, 1, 2, 3, 4, 5]; array.splice(2, 0, \u0026#39;a\u0026#39;); console.log( array ); // [0, 1, \u0026#34;a\u0026#34;, 2, 3, 4, 5]   起始位置設為 2，刪除個數 0。\n如果我們要刪除索引位置 3 的元素：\n1 2 3 4 5  const array = [0, 1, 2, 3, 4, 5]; array.splice(3, 1); console.log( array ); // [0, 1, 2, 4, 5]   起始位置設為 3，刪除個數 1，不設定插入元素。\n3.2 填充陣列 fill() 為 ES6 新增的方法，可以一次設定，起始位置至終止位置的值。不包含終止位置。\n此方法會改變原陣列。\n語法：\n1  array.fill(value[, start[, end]])    value 設定值 start 起始位置 end 終止位置  1 2 3 4 5 6 7  let arr = [0, 1, 2, 3]; console.log(arr.fill(\u0026#39;a\u0026#39;, 1, 3)); // [0, \u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;, 3]  console.log(arr.fill(\u0026#39;b\u0026#39;)); // ) [\u0026#34;b\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;b\u0026#34;]   3.3 複製貼上 copyWithin() 是 ES6 新增的方法，它能夠複製陣列中的某一段，並貼到陣列的其他位置，並取代原本的值。copyWithin() 並不會改變陣列的長度，如果貼上的長度會超過結尾會停止。\n語法：\n1  array.copyWithin(target[, start[, end]])    target：要貼上的起始位置。 start：要複製的起始位置。 end：要複製的結束位置，不包括這個位置元素。 如果是負數由結尾計算。  1 2 3 4 5 6  console.log([1, 2, 3, 4, 5].copyWithin(2)); console.log([1, 2, 3, 4, 5].copyWithin(-2)); console.log([1, 2, 3, 4, 5].copyWithin(0, 2)); console.log([1, 2, 3, 4, 5].copyWithin(0, -2)); console.log([1, 2, 3, 4, 5].copyWithin(0, 3, 4)); console.log([1, 2, 3, 4, 5].copyWithin(-2, -3, -1));   4. 提取陣列中的元素 slice() 會回傳一個新的陣列，這一對是一個由 begin 和 end 決定的原陣列的淺拷貝（包括 begin，不包括end）。\n此方法原陣列不會被改變。\n語法：\n1  array.slice([begin[, end]]);    begin：提取起始處的索引（從 0 開始），從該索引開始提取原陣列元素。 end：提取終止處的索引（從 0 開始），在該索引處結束提取原陣列元素。slice 會提取原陣列中索引從 begin 到 end 的所有元素（包含 begin，但不包含 end）。  begin 和 end 都可以是負數，在這種情況下，從末尾計算索引。\n從陣列中提取索引位置 1 到 2 的元素到新陣列：\n1 2 3 4  const arr = [0, 1, 2, 3, 4]; let newArr = arr.slice(1, 3); console.log( newArr );   如果要提取某位置後的所有元素，可以省略 end：\n1 2 3 4  const arr = [0, 1, 2, 3, 4]; let newArr = arr.slice(2); console.log(newArr); // [2, 3, 4]   因為會建立新的陣列，因此可用來淺拷貝陣列：\n1 2 3 4  const arr = [0, 1, 2, 3, 4]; let newArr = arr.slice(); console.log( newArr ); // [0, 1, 2, 3, 4]   如果搭配展開運算子 ... ，可以建立出一個移除特定位置的新陣列。\n假設要移除索引 3 的元素：\n1 2 3 4 5 6 7  const arr = [0, 1, 2, 3, 4, 5]; let index = 3; let newArr = [...arr.slice(0, index), ...arr.slice(index + 1)]; console.log( newArr ); // [0, 1, 2, 4, 5]   5. 元素數量 陣列的 length 屬性可以查看裡面存放多少資料。\n1 2 3  let array = [1, 2, 3, 4, 5]; console.log( array.length ); // 5   length 屬性可讀可寫，因此也可以將其賦值為0，會等同清空陣列。\n1 2 3  array.length = 0; console.log( array ); // []   如果將 length 屬性賦值的數值小於元素，將會刪除後面的元素。\n但這裡需要注意，如果將 length 給予大於其元素的數值，那會導致陣列變成稀疏陣列。\n5.1 清空 Array 的操作 常見的作法有兩種，兩種看似都是清空陣列，但並不相同：\n Array.length = 0 Array = []  第一種在上面有提到過，就是將陣列元素都移除。\n而第二種要注意的是，陣列跟物件一樣是傳址，每個陣列都會有自己的記憶體位址，而 Array = [ ] 其實是將一個新的空陣列記憶體位置傳給原本存放舊陣列的變數。\n簡單來說，Array.length = 0，是將原本的陣列所有元素移除，而 Array = [] 是重新給一個新陣列。\n舉例說明：\n1 2 3 4 5 6 7 8 9  const myCart = []; myCart.push(\u0026#39;手機\u0026#39;, \u0026#39;電視\u0026#39;); console.log( myCart ); // [\u0026#34;手機\u0026#34;, \u0026#34;電視\u0026#34;]  const MingCart = myCart; MingCart.push(\u0026#39;風扇\u0026#39;); console.log( myCart ); // [\u0026#34;手機\u0026#34;, \u0026#34;電視\u0026#34;, \u0026#34;風扇\u0026#34;]   假設我有一個空購物車，我買了手機、電視，放進購物車。\n小明也有一個購物車，而且跟我共用。\n所以小明加入、刪除商品，我的購物車都會受到影響。\n如果使用 Array.length = 0，因為是共用的購物車，所以小明的購物車也會被清空。\n1 2 3 4  // 承接第一段程式碼  myCart.length = 0; console.log( MingCart ); // []   但如果使用 Array = []，那我會得到一個新的空購物車，而小明還是使用原本的購物車。\n1 2 3 4  // 承接第一段程式碼  myCart = []; console.log( MingCart ); // [\u0026#34;手機\u0026#34;, \u0026#34;電視\u0026#34;, \u0026#34;風扇\u0026#34;]   6. 合併陣列 concat() 用於合併兩個或多個陣列。此方法不會更改現有陣列，而是返回一個新陣列。\n1 2 3 4 5  const arr1 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; const arr2 = [\u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; console.log( arr1.concat(arr2) ); // [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;]   7. 字串相關方法 陣列有自己的 toString 方法，會回傳以逗號分隔的元素列表的字串：\n1 2 3  const arr = [1, 2, 3]; console.log( arr.toString() ); // \u0026#34;1,2,3\u0026#34;   其他轉字串操作的也是一樣結果：\n1 2 3 4  // 承接上方程式碼  console.log( String(arr) ); // \u0026#34;1,2,3\u0026#34; console.log( arr + \u0026#39;\u0026#39; ); // \u0026#34;1,2,3\u0026#34;   因為陣列沒有 Symbol.toPrimitive，也沒有 valueOf()，它們只能執行 toString() 進行轉換。\njoin()  能將一個陣列的所有元素連接成一個字串並回傳這個字符串。如果陣列只有一個項目，那麼將回傳該項目而不使用分隔符號。\n語法：\n1  array.join([separator])   separator 分隔符號，預設為 ,。\n1 2 3 4  let arr = [1, 2, 3]; console.log( arr.join() ); // \u0026#34;1,2,3\u0026#34; console.log( arr.join(\u0026#39;?\u0026#39;) ); // \u0026#34;1?2?3\u0026#34;   9. 排序陣列 reverse() 方法會原地（in place）反轉（reverses）一個陣列。陣列中的第一個元素變為最後一個，而最後一個元素則變成第一個。\n1 2 3 4 5  const arr = [1, 2, 3, 4]; arr.reverse(); console.log(arr); // [4, 3, 2, 1]   sort()方法會原地（in place）對一個陣列的所有元素進行排序，並回傳此陣列。\n語法：\n1  arr.sort([compareFunction])    compareFunction 指定一個函式來定義排序順序。假如省略此參數，陣列將根據各個元素轉為字串後的每一個字元之 Unicode 編碼位置值進行排序。 回傳值：排序後的陣列  如果使用 compareFunction 函式，就要定義這個回呼函式 compareFunction（a, b），讓排序演算法知道兩筆資料項之間的關係，可能的執行結果包括：\n 如果回呼函式回傳值小於 0，則會把 a 排在小於 b 之索引的位置，即 a 排在 b 前面。 如果回呼函式回傳值等於 0，a 與 b 皆不會改變彼此的順序，但會與其他全部的元素比較來排序。 如果回呼函式回傳值大於 0，則會把 b 排在小於 a 之索引的位置，即 b 排在 a 前面。  所以，比較函式會是以下形式：\n1 2 3 4 5 6 7 8 9 10  function compare(a, b) { if (在某排序標準下 a 小於 b) { return -1; } if (在某排序標準下 a 大於 b) { return 1; } // a 必須等於 b  return 0; }   如果比較數值而不是字串，比較函式可以僅僅利用 a 減 b。以下函式將會升冪排序陣列：\n1 2 3  function compareNumbers(a, b) { return a - b; }   如果要降冪排序就改成 b - a。\n範例說明：\n1 2 3 4 5 6 7 8  const inventors = [ { name: \u0026#39;Albert\u0026#39;, year: 1879 }, { name: \u0026#39;Isaac\u0026#39;, year: 1643 }, { name: \u0026#39;Galileo\u0026#39;, year: 1564 }, { name: \u0026#39;Marie\u0026#39;, year: 1867 }, { name: \u0026#39;Johannes\u0026#39;, year: 1571 }, { name: \u0026#39;Nicolaus\u0026#39;, year: 1473 } ];   排序數值大小，將資料依據出生年分排序：\n1 2 3 4 5 6 7 8 9 10 11 12 13  const yearSort = inventors.sort(function(a, b) { return a.year - b.year; }); console.log( yearSort ); // [ // { name: \u0026#39;Nicolaus\u0026#39;, year: 1473 }, // { name: \u0026#39;Galileo\u0026#39;, year: 1564 }, // { name: \u0026#39;Johannes\u0026#39;, year: 1571 }, // { name: \u0026#39;Isaac\u0026#39;, year: 1643 }, // { name: \u0026#39;Marie\u0026#39;, year: 1867 }, // { name: \u0026#39;Albert\u0026#39;, year: 1879 } // ]   排序字串，將資料依據字串第一個字母排序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  inventors.sort(function(a, b) { if(a.name[0] \u0026lt; b.name[0]) { return -1; } if(a.name[0] \u0026gt; b.name[0]) { return 1; } return 0; }); console.log( inventors ); // [ // { name: \u0026#39;Albert\u0026#39;, year: 1879 }, // { name: \u0026#39;Galileo\u0026#39;, year: 1564 }, // { name: \u0026#39;Isaac\u0026#39;, year: 1643 }, // { name: \u0026#39;Johannes\u0026#39;, year: 1571 }, // { name: \u0026#39;Marie\u0026#39;, year: 1867 }, // { name: \u0026#39;Nicolaus\u0026#39;, year: 1473 } // ];   也可以使用 ?: 三元條件運算子簡化：\n1 2 3 4 5 6 7 8 9 10 11 12 13  inventors.sort(function(a, b) { return (a.name[0] \u0026gt; b.name[0]) ? 1 : (a.name[0] \u0026lt; b.name[0]) ? -1 : 0 }); console.log( inventors ); // [ // { name: \u0026#39;Albert\u0026#39;, year: 1879 }, // { name: \u0026#39;Galileo\u0026#39;, year: 1564 }, // { name: \u0026#39;Isaac\u0026#39;, year: 1643 }, // { name: \u0026#39;Johannes\u0026#39;, year: 1571 }, // { name: \u0026#39;Marie\u0026#39;, year: 1867 }, // { name: \u0026#39;Nicolaus\u0026#39;, year: 1473 } // ];   注意事項：\n sort() 不會產生新陣列，會變動原本的陣列。 排序不一定是穩定的，各家瀏覽器都不同，可以參考下面文章。   從 Array 的 sort 方法，聊到各瀏覽器的實作，沒想到 Chrome 和FireFox 的排序如此不同\n 8. 查詢陣列  indexOf(item, from)：從索引 from 的位置往右查詢 item，如果 from 省略則從頭開始。回傳符合的第一個元素的索引，沒有則回傳 -1。 lastIndexOf(item, from)：和上面相同，只是往 from 的左邊查詢，如果省略就是從尾部開始。 includes(item, from)：從索引 from 查詢 item，如果找到則回傳 true。  1 2 3 4 5 6 7 8 9 10  const arr = [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;a\u0026#39;]; console.log(arr.indexOf(\u0026#39;c\u0026#39;)); // 1 console.log(arr.indexOf(\u0026#39;c\u0026#39;, 2)); // 2  console.log(arr.lastIndexOf(\u0026#39;c\u0026#39;)); // 2 console.log(arr.lastIndexOf(\u0026#39;c\u0026#39;, 1)); // 1  console.log(arr.includes(\u0026#39;c\u0026#39;)); // ture console.log(arr.includes(\u0026#39;c\u0026#39;, 2)); // ture   但要注意的是，這些方法是使用 === 嚴格比較。\n如果要處理比較複雜的比較，可以改使用 find() 或 findIndex()。\n陣列兩個容易誤用的重點 陣列兩個容易誤用的重點：\n 稀疏陣列（Sparse Array） 類陣列（Array-Like）  1. 稀疏陣列 稀疏陣列是指陣列中有 插槽（slot） 可能未定義其值或被略過而導致存放 undefined 的狀況，範例如下：\n1 2 3 4 5 6 7  const arr = []; arr[0] = 1; arr[2] = [ 3 ]; console.log( arr[1] ); // undefined console.log( arr.length ); // 3   雖然這樣不會出錯誤，但如果不注意這種小細節，在之後的陣列操作上會出現難以發現的 BUG。\n若使用「很像數字」的字串當成鍵名來存資料，鍵值會被強制轉型為數字。\n1 2 3 4 5  const arr = [ ]; arr[\u0026#39;13\u0026#39;] = 42; console.log( arr.length ); // 14   這樣導致 arr 成了稀疏陣列，其長度就被誤判，因此沒事別對陣列額外新增 鍵值對（key-value）。若索引值非數值還是用乖乖使用物件吧。\n1.1 Array.of() Array() 建構函式建立陣列，有一個常見陷阱，就是當只有一個引數傳入，並不會產生已那個數字為元素的陣列。\n預期建立的陣列為 [3]，但實際結果為一個長度為 3 的稀疏陣列：\n1 2 3 4  const arr = Array(3); console.log( arr[0] ); // undefined console.log( arr.length ); // 3   ES6 新增了 Array.of() 用來取代 Array()，不會發上述的怪異行為：\n1 2 3 4  const arr = Array.of(3); console.log(arr[0]); // 3 console.log(arr.length); // 1   不過一樣很少會用到，使用陣列實值建立陣列優先。\n2. 類陣列（Array-Like） 類陣列（Array-Like）是具有有索引和 length 屬性的物件，可能各種形式的 串列（lists） 或字串，看起來很像陣列，但並非真正的陣列，所以沒有繼承陣列的方法。\n有時候為了使用陣列的方法（例如 map、indexOf 等等方法）來處理類陣列的元素，因此會需要將其轉成真正的陣列。\n舉例來說 DOM 物件操作後所得到的串列：\n1 2 3 4 5  const list = document.getElementsByTagName(\u0026#39;div\u0026#39;); list console.log( list ); // HTMLCollection(3) [div, div, div] console.log( list.length ); // 3   document.getElementsByTagName 會得到一個節點集合，並非真正的陣列，因此沒有繼承陣列的方法，因此需要將它轉成陣列，才能使用陣列的方法。\n轉換串列成陣列的方法\n Array.prototype.slice.call() Array.apply() [...] ES6 新增 Array.from() ES6 新增  1 2 3 4 5 6 7  const link = document.links; Array.isArray( link ); // false Array.isArray( Array.prototype.slice.call(link)); // true Array.isArray( Array.apply(null, link)); // true Array.isArray( [...link]); // true Array.isArray( Array.from(link)); // true   ","description":"幾乎所有程式語言都支援陣列，因為陣列是最簡單的資料結構。","id":11,"section":"posts","tags":["JavaScript","陣列 Array"],"title":"陣列","uri":"https://chupai.github.io/posts/200424_js_array/"},{"content":"這週是 六角鼠年鐵人賽 第十一週，學習基礎演算法之前，先來瞭解基本的資料結構。\n\r為什麼要學習資料結構 因為不同的資料結構，將會影響程式設計（演算法）的方法與效率。\n 程式 = 資料結構 + 演算法\nAlgorithms + Data Structures = Programs\n 選擇正確的資料結構，可以提高演算法的效率。\n什麼是資料結構 在電腦科學中，資料結構（Data Structure）是電腦中儲存、組織資料的方式。簡單來說，當資料存在記憶體中的時候，決定資料的存放順序及存放位置的，就是資料結構。\n舉例來說，假設要儲存考試成績，你不會用變數一個一個去存它，通常會用一個陣列來存放：\n1 2 3 4 5  let score1 = 80; let score2 = 60; let score3 = 70; let scores = [80, 60 , 70];   因為當要儲存的資料變多時，用變數一個一個去存資料，要處理資料時，非常麻煩。\n換句話說，所謂資料結構，就是考慮如何運用變數儲存要處理的資料，而演算法就是要處理這些資料的方法。將資料有組織的存放在程式內，可以提升程式的執行效率。\n常見的資料結構  陣列（Array） 連結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹狀結構（Tree） 圖形結構（Graph） 堆積（Heap） 雜湊表（Hash table）  資料結構的分類 資料結構，根據元素之間的關係，分為兩大類：\n 線性關係的資料結構 非線關係的性結構  1. 線性關係 線性關係的資料結構，其組成資料元素間具有線性關係，簡單來說就是「資料會排成一直線」。\n每個元素只有另外兩個元素相鄰，也就是只有前、後兩個方向：\n 第一個元素沒有前驅者（前面的元素） 最後一個元素沒有後繼者（後面的元素） 其餘的元素都各只有一個前驅者（predecessor）和一個後繼者（successor）  線性關係的資料結構又分為兩種物理結構：\n 順序儲存結構，例：陣列、堆疊、佇列 鏈式儲存結構，例：連結串列  2. 非線性關係 而非線性關係的資料結構，簡單來說就是資料元素間不是只有前後關係。\n非線性關係的資料結構包含：\n 階層關係，例：樹 相鄰關係，例：圖  資料結構操作 常見的資料結構操作的時間複雜度與空間複雜度。\n圖片來源：Know Thy Complexities!\n總結 不過大多數情況下 Javascript 開發關心的是「資料的邏輯結構」而非「資料的儲存結構」。因為 JavaScript 只有物件，陣列實際上也是物件，多數的資料結構都必須使用物件或陣列來模擬實作。\n","description":"這週是六角鼠年鐵人賽第十一週，學習基礎演算法之前，先來瞭解基本的資料結構。","id":12,"section":"posts","tags":["演算法 Algorithm","資料結構","w3HexSchool"],"title":"JavaScript 學演算法（三）- 資料結構概述","uri":"https://chupai.github.io/posts/200419_data_structure/"},{"content":"這週是 六角鼠年鐵人賽 第十週（是不是有銅角獎啦？！），說明如何評估演算法的好壞。\n\r演算法的好壞 一個問題不一定只有一種演算法能解決。那我們怎麼評估演算法的好壞呢？\n最直覺的方式，就是測量程式的執行時間、程式的記憶體使用量。\n但是，即便是相同的演算法，也會因為以下變數而有所不同：\n 不同電腦的處理速度 實作的程式語言 輸入的大小 不同情況的資料  所以需要用一個「不受環境、數據狀況，比較客觀的方式」去分析一個演算法。\n所以我們會用 複雜度 來分析演算法：\n 時間複雜度（Time complexity）\n指演算法所耗費的時間。 空間複雜度（Space Complexity）\n指演算法所需要消耗的儲存記憶體資源。  時間複雜度與空間複雜度是相互影響的，當追求一個較好的時間複雜度時，可能會使空間複雜度的性能變差。舉例來說，Google Chrome 相較於其他瀏覽器，運行速度較快，但它的缺點就是占用很多記憶體。\n根據調查顯示，用戶對於執行效率有極高的要求，對於網頁開啟的忍耐極限是 6 秒甚至更短。在這個大背景下，一個好的演算法，更專注於討論時間複雜度。另外，現在的儲存空間很便宜，而且當 資料量變大 時，空間複雜度的差異通常不大，但 時間複雜度則會有極大的差異。\n不同情況下的分析 每當輸入資料的情況不同時，演算法呈現的效果也不同，舉例來說，在圖書館找一本書，並一本一本找：\n 最佳情況：第一本就是要找的書 最糟情況：最後一本才是要找的書 平均情況：中途就找到要找的書  上述三種情況都可以被用來分析演算法。但最佳情況對演算法沒有多大幫助，通常我們只考慮最糟情況，也就是演算法複雜度的上限值。\n輸入大小與執行時間的關係 我們舉一個非常簡單的例子。\n以 求等差數列的和 來說，假設要求出 1 + 2 + 3 + \u0026hellip; + n 的和，有兩種作法：\n 一個一個加 套用公式計算  用 for 迴圈一個一個的加：\n1 2 3 4 5 6 7  function sum(n) { let sum = 0; for(let i = 0; i \u0026lt;= n; i++) { sum += i; } return sum; }   等差數列的和公式，我們小時候應該都有學過：\n 一個等差數列的和，等於其首項與末項的和，乘以項數除以 2。\n 1 2 3  function sum(n) { return (1 + n) * n / 2; }   兩種作法的時間差異：\n 如果 $1$ 累加到 $n$ 迴圈需要跑 $n$ 次 不論 $n$ 多大，都只需要執行 $1$ 次。  假設執行一次只需要 0.01毫秒，當 $n$ 不大時，一個一個加與套用公式計算的時間差異並不大，但隨著 $n$ 越來越大，你會發現使用一個一個加的時間會變得非常可觀。\n由此可知，當輸入量非常大時，不同演算法執行上效率差異會非常大。\n 演算法效率：執行所需時間與資料量 $n$ 的關係。\n 演算法執行時間的計算方式  執行時間 = 執行次數 * 每次執行所需的時間\n 但是 每次執行所需的時間 會根據機器和語言的的差異而有所不同，因此演算法只考慮執行的次數。\n將演算法中基本操作的執行次數作為演算法時間複雜度的度量，即時間複雜度不是演算法程式的運行時間，而是其中基本操作的總次數。\n舉例來說：\n1 2 3 4 5 6 7  function sum(n) { let sum = 0; for(let i = 0; i \u0026lt; n; i++) { sum += i; } return sum; }   假設每行的執行時間都一樣，記做 $t$。\n line2：需要 $1$ 個 $t$ 的時間 line3：需要 $n$ 個 $t$ 的時間 line4：也是 $n$ 個 $t$ 的時間 line6：需要 $1$ 個 $t$ 的時間 那麼執行時間就是 $(2n + 2) * t$ 執行次數為 $2n + 2$  再考量下面這個例子：\n1 2 3 4 5 6 7 8 9  function sum(n) { let sum = 0; for(let i = 0; i \u0026lt; n; i++) { for(let j = 0; j \u0026lt; n; j++) { sum += i * j; } } return sum; }    line2：需要 $1$ 個 $t$ 的時間 line3：需要 $n$ 個 $t$ 的時間 line4：也是 $n^2$ 個 $t$ 的時間 line5：也是 $n^2$ 個 $t$ 的時間 line8：需要 $1$ 個 $t$ 的時間 執行次數為 $2n^2 + n + 2$  複雜度分析工具 我們在之前已經提過，演算法通常只考慮最糟情況，也就是演算法複雜度的上限值。\n因此我們會用 Big O Notation 來表示演算法的複雜度。\n Big O Notation（$O$），念作 Big Oh 😮，是用於描述函數漸近行為的數學符號，更確切地說，它是用另一個函數來描述一個函數數量級的漸近上界，用 $O(f(n))$ 表示。\n 假設輸入 $n$，而演算法的執行時間為一個函數 $f(n)$，以下五個演算法分別為：\n $1$ $10$ $2n + 1$ $2n^2$ $\\log_2n$  當 $1$ 與 $10$ 比較時，並不會說 $1$ 比 $10$ 有效率，因為當 $n$ 趨近無限大時，$1$ 與 $10$ 兩者差異不大，舉例來說：假如你身上有一千億，當你要花 1元跟 10元時，你會認為 10元的比較貴嗎？不會都是小錢。\n分析演算法是看當資料量「最多」會達到怎麼樣的趨勢，也就是 $n$ 趨近無限大時，並不會在意細節，只看函數的最高次方，會忽略係數、其他次方項與常數。\n用 Big O 表示上述函數之複雜度分析：\n $O(1)$ $O(1)$ $O(n)$ $O(n^2)$ $O(\\log n)$  由此可知，當我們在計算演算法的時間時，只需要大概的算一下迴圈數，大致上判斷一下丟進去的資料量會讓程式執行幾次即可，不需要像之前一樣計算的那麼仔細。\n常見時間複雜度 圖片來源：8 time complexities that every programmer should know\n根據上圖，若同樣處理 $n$ 筆資料，那麼各個時間複雜度成本如下：\n$O(1)\u0026lt;O(\\log n)\u0026lt;O(n)\u0026lt;O(n \\log n)\u0026lt;O(n^2)\u0026lt;O(2^n)\u0026lt;O(n!)$\n成本越高，表示效率越差。\n常見的時間複雜度：\n   執行時間 名稱 演算法舉例     $O(1)$ 常數時間 Constant time 普通數學運算   $O(\\log n)$ 對數時間 Logarithmic time 二分搜尋   $O(n)$ 線性時間 Linear time 簡易搜尋、插入排序法   $O(n \\log n)$ 線性對數時間 Linearithmic Time 比較排序   $O(n^2)$ 平方時間 Quadratic time 選擇排序、泡沫排序   $O(2^n)$ 指數時間 Exponential time 費波那契數列   $O(n!)$ 階乘時間 Factorial time 暴力搜尋解決旅行推銷員問題    輸入 10、100、1000 資料量需花費的時間比較：\n   執行時間 10個資料量 100個資料量 1000個資料量     $O(1)$ 1 1 1   $O(\\log n)$ 3 6 9   $O(n)$ 10 100 1000   $O(n \\log n)$ 30 600 9000   $O(n^2)$ 100 10000 1000000   $O(2^n)$ 1024 1.26e+29 1.07e+301   $O(n!)$ 3628800 9.3e+157 4.02e+2567    當複雜度到達或超過 $O(2^n)$ 時，只要 $n$ 稍大一點，基本上程式就會跑到天荒地老都跑不出來，因此最好避免過高的複雜度。\n空間複雜度 上邊説了那麼一大堆的時間複雜度，相比空間複雜度就是指演算法執行時所花費的記憶體空間的趨勢。\n其計算方式與時間複雜度相似，也使用 Big-O 來表示其複雜度。\n1. 計算演算法使用記憶體量 計算演算法所需的記憶體量，只需要計算使用的變數量。\n舉例來說：\n1 2 3 4 5 6 7  function sum(n) { let sum = 0; for(let i = 0; i \u0026lt; n; i++) { sum += i; } return sum; }   不管程式的執行步驟數是多少，我們的變數始終只有 sum 與 i，也就是變數量只有 2。因此空間複雜度為 $O(1)$。\n再考量下面這個例子：\n1 2 3 4 5 6 7  function show(n) { let arr = []; for (let i = 0; i \u0026lt; n; i++) { arr.push(i); } return arr; }   迴圈每次執行一次 push 方法，就會申請一個空間存儲變量，很明顯的，記憶體的佔用量會隨著輸入量而線性成長，故這個演算法的空間複雜度為 $O(n)$。\n2. 常見的空間複雜度 常見的空間複雜度只有 $O(1)$、$O(n)$、$O(n^2)$，其他的話很少會用到。\n總結 評估演算法的好壞，就是要分析演算法的複雜度，而時間複雜度與空間複雜度式相互影響的，但時間複雜度比空間複雜度重要。\n","description":"這週是 六角鼠年鐵人賽 第十週（是不是有銅角獎啦？！），說明如何評估演算法的好壞。","id":13,"section":"posts","tags":["演算法 Algorithm","w3HexSchool"],"title":"JavaScript 學演算法（二）- 演算法分析","uri":"https://chupai.github.io/posts/200406_analysis_of_algorithms/"},{"content":"這週是 六角鼠年鐵人賽 第九週，接下來幾週大概是我學習演算法筆記，既然是學前端，當然就是使用 JavaScript 來實作。\n\r何謂演算法？ 演算法，英文名稱 Algorithm，中國稱為 算法。\n 演算法，簡單來就是一套解決問題的方法。\n 要簡單明瞭何謂演算法，推薦觀看這個影片：人腦也可以執行演算法 - David J. Malan。\n1. 演算法與程式 演算法通常是電腦所執行的，但演算法在電腦誕生之前就存在，演算法是數學家所提出來的。\n電腦看起來很聰明，但其實電腦只會做 0 跟 1 的運算，而我們就是透過 程式，把現實世界需要解決的問題變成數學問題，丟給電腦來幫我們做運算處理，而這個解題的方法就是演算法。\n所以說，演算法是用以執行計算或完成作業的程序，所有步驟都要能用數學方式表現，而程式是實作演算法的方式。也就是說：\n 演算法相當於「思考程序」 程式相當於為了表現演算法的「語言」  2. 演算法的表示方式  設計程式時，通常會使用 虛擬碼 pseudocode 來表示； 設計電子電路，會使用 流程圖 來表示； 而為了理解演算法，會使用文字與圖片來輔助說明。  演算法的定義 演算法 是對特定問題求解步驟的一種描述，一般演算法嚴謹的條件必須符合五個標準：\n 輸入（Input）：至少有零個或以上的輸入（可以沒輸入或多個輸入）。 輸出（Output）：至少有一個或以上回傳結果（經過演算法計算獲得）。 確定性/明確性（Definiteness）：每一個指令步驟必須明確而不造成混淆。在一定條件下，相同的輸入只能有唯一結果。 有限性（Finiteness）：在有限步驟後一定會結束（完成或終止），確保不會進入無窮迴圈。 可行性/有效性（Effectiveness）：步驟清楚可行，能使用數學運算出結果（表示能夠實現）。  一個好的演算法 一個演算法如果要設計好，必須達到以下目標：\n 正確性（correctness）：不含語法錯誤，對各種需求的輸入數據都能滿足。 可讀性（readability）：簡潔易懂。 健壯性（robustness）：非法數據被輸入時，不會引起演算法崩潰、出錯。 效率與低存儲量需求：即，演算法執行時間短 或 演算法記憶體使用量低。  總結 這週就簡敘述何謂演算法，下週將說明如何分析演算法的好壞。\n目錄 前言：\n 何謂演算法？ 演算法分析  資料結構：\n 資料結構概述 陣列 Array 鏈結串列 Linked list 堆疊 ＆ 佇列 集合 \u0026amp; 映射  排序演算法：\n 排序演算法 ","description":"這週是 六角鼠年鐵人賽 第九週，接下來幾週大概用記錄我學習演算法的筆記，既然是學前端，當然就是使用 JavaScript。","id":14,"section":"posts","tags":["演算法 Algorithm","w3HexSchool"],"title":"JavaScript 學演算法（一）- 何謂演算法？","uri":"https://chupai.github.io/posts/200404_algorithm/"},{"content":"這週是 六角鼠年鐵人賽 第八週，紀錄 Vue 表單驗證套件 - Vee Validate 操作方法。\n前言  VeeValidate 官網\n VeeValidate 是專用於 Vue.js 的表單驗證套件。它有很多預設驗證規則，也支持自定義驗證規則。\n由於 2.x版本 與 3.x版本 的操作非常不同，所以簡單紀錄一下。\nVeeValidate 2 1. 安裝 安裝舊版本：\nnpm install vee-validate@2.2.15 --save 導入：\n1 2 3  // main.js import VeeValidate from \u0026#39;vee-validate\u0026#39;; Vue.use(VeeValidate);   1.1 會遇到的問題 如果 Focus 到 input 標籤再點外面，不會進行驗證，可以修改 events，加上 blur：\n1 2 3 4 5  // main.js  Vue.use(VeeValidate, { events: \u0026#39;input|blur\u0026#39;, });   1.2 中文化 舊方法 2.1.0-beta.24版之前：\n1 2 3 4 5 6 7  // main.js  import VeeValidate from \u0026#39;vee-validate\u0026#39;; import zhTW from \u0026#39;vee-validate/dist/locale/zh_TW\u0026#39;; VeeValidate.Validator.localize(\u0026#39;zhTW\u0026#39;, zhTW); Vue.use(VeeValidate);   新方法，必須先安裝 vue-i18n：\nnpm install vue-i18n --save 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // main.js import VeeValidate from \u0026#39;vee-validate\u0026#39;; import zhTW from \u0026#39;vee-validate/dist/locale/zh_TW\u0026#39;; import VueI18n from \u0026#39;vue-i18n\u0026#39;; Vue.use(VueI18n); const i18n = new VueI18n({ locale: \u0026#39;zhTW\u0026#39;, }); Vue.use(VeeValidate, { events: \u0026#39;input|blur\u0026#39;, i18n, dictionary: { zhTW, }, }); // 記得載入 i18n new Vue({ i18n, router, render: (h) =\u0026gt; h(App), }).$mount(\u0026#39;#app\u0026#39;);   2. 基本用法 1 2 3 4 5 6 7 8  \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34; placeholder=\u0026#34;輸入姓名\u0026#34; v-validate=\u0026#34;\u0026#39;required\u0026#39;\u0026#34; :class=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: errors.has(\u0026#39;name\u0026#39;) }\u0026#34; /\u0026gt; \u0026lt;span v-if=\u0026#34;errors.has(\u0026#39;name\u0026#39;)\u0026#34;\u0026gt;請輸入姓名\u0026lt;/span\u0026gt;    input 標籤內要設定 name 這個特性，特性值的部分則是根據該欄位性質做設定，例：姓名就是 name，地址就是 address。 加上 v-validate=\u0026quot;'required'\u0026quot;，表示這一個欄位是必填的。 errors.has('name') ，填入 name 特性值。初始值為 fasle，當觸發 input 標籤時，就會開始驗證，如果欄位未填寫值為 true。  可以配合 v-if 顯示提式字； 或是搭配 :class 加入提式樣式。    假設要驗證 email 格式，則可以使用 v-validate=\u0026quot;'required|email'\u0026quot;。\n而 errors.first('email') 它會根據 email 驗證的各種狀態來顯示不同的提示文字。\n2.1 獲取錯誤訊息  errors.first('field')：獲取關於當前 field 的第一個錯誤訊息 collect('field')：獲取關於當前 field 的所有錯誤訊息 has('field')：當前 filed 是否有錯誤 all()：當前表單所有錯誤 any()：當前表單是否有任何錯誤  ３. 表單提交前的處理 最後我們還需要設定表單驗證方法，來避免送出錯誤的資料格式：\n1 2 3 4 5 6 7  this.$validator.validate().then((result) =\u0026gt; { if (result) { // 當驗證成功時執行 AJAX 的行為  } else { // 驗證失敗產生的行為  } });   VeeValidate 3 VeeValidate 在 v3.x版本之後的使用方法與之前完全不同。\n1. 安裝 安裝最新版本 vee-validate：\nnpm install vee-validate --save 導入：\n1 2 3 4 5 6 7 8 9 10 11 12 13  // main.js import { ValidationObserver, ValidationProvider, extend, localize} from \u0026#39;vee-validate\u0026#39;; import * as rules from \u0026#39;vee-validate/dist/rules\u0026#39;; import TW from \u0026#39;vee-validate/dist/locale/zh_TW.json\u0026#39;; Object.keys(rules).forEach((rule) =\u0026gt; { extend(rule, rules[rule]); }); localize(\u0026#39;zh_TW\u0026#39;, TW); Vue.component(\u0026#39;ValidationObserver\u0026#39;, ValidationObserver); Vue.component(\u0026#39;ValidationProvider\u0026#39;, ValidationProvider);   安裝內容會在下方依序說明。\n2. 添加規則 預設情況下，VeeValidate 不附帶任何驗證規則，這是為了使檔案輕量。\n首先導入定義規則所需的 extend 函式：\n1 2 3  import { extend } from \u0026#39;vee-validate\u0026#39;; // rules   接下來，就是加入規則。\n2.1 安裝所有規則 安裝所有規則有兩種遍歷作法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  import { extend } from \u0026#39;vee-validate\u0026#39;; import * as rules from \u0026#39;vee-validate/dist/rules\u0026#39;; // 作法一 Object.keys(rules).forEach((rule) =\u0026gt; { extend(rule, rules[rule]); }); // 作法二(with typescript) for (let [rule, validation] of Object.entries(rules)) { extend(rule, { ...validation, }); }   除了上述方法，另一種方法是安裝 vee-validate 的完整捆綁包，而不是預設捆綁包，該捆綁包預裝了所有驗證規則及其英文消息。\n將 'vee-validate' 替換成 'vee-validate/dist/vee-validate.full.esm'，就可以一次安裝所有驗證規則，而不用導入 extend 函式。\n1  import { ValidationObserver, ValidationProvider } from \u0026#39;vee-validate/dist/vee-validate.full.esm\u0026#39;;   但不建議一次安裝全部規則，應該使用下面的方式，按照需求安裝。\r 2.2 導入規則 為了避免一次加載全部規則，我們可以選擇需求來導入規則：\n1 2 3 4 5  import { extend } from \u0026#39;vee-validate\u0026#39;; import { required, email } from \u0026#39;vee-validate/dist/rules\u0026#39;; // 按需求導入規則  extend(\u0026#39;required\u0026#39;, required); extend(\u0026#39;email\u0026#39;, email);   更多可用規則可以參考 官方文件。\n3. 基本用法 導入 ValidationProvider 元件：\n1 2 3 4 5 6 7 8 9 10 11  import { ValidationProvider } from \u0026#39;vee-validate\u0026#39;; // 在 main.js 全域註冊元件 Vue.component(\u0026#39;ValidationProvider\u0026#39;, ValidationProvider); // 區域註冊元件（推薦） export default { components: { ValidationProvider, }, };   2.X 版原本是添加 v-validate，而 3.X版則改用 ValidationProvider 元件進行包裹：\n1 2 3 4 5 6 7 8 9 10  \u0026lt;ValidationProvider v-slot=\u0026#34;{ failed, errors }\u0026#34; name=\u0026#34;name\u0026#34; rules=\u0026#34;required\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34;\u0026gt;*收件人姓名\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34; :class=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: failed }\u0026#34; placeholder=\u0026#34;輸入姓名\u0026#34; /\u0026gt; \u0026lt;span v-if=\u0026#34;failed\u0026#34; class=\u0026#34;text-danger\u0026#34;\u0026gt;{{ errors[0] }}\u0026lt;/span\u0026gt; \u0026lt;/ValidationProvider\u0026gt;    name 為報錯時，顯示的名稱。 在 rules 上，添加要驗證的規則。 插槽範圍內可用的屬性，可以參考 官方文件。  errors：錯誤訊息列表，errors[0] 則代表驗證錯誤規則底下定義的 messages failed：如果經過驗證且無效，則值為 false    預設情況下，ValidationProvider 渲染器為 span 標籤，可以使用套件提供的 prop 來改變呈現標籤：\n1  \u0026lt;ValidationProvider tag=\u0026#34;div\u0026#34;\u0026gt;\u0026lt;/ValidationProvider\u0026gt;   3.3 更詳細 更多可用 prop 可以參考 官方文件。\n另外還提供了許多方法可以使用，可以參考 官方文件。\n4. 表單提交前的處理 1 2 3 4 5 6 7 8 9 10 11  import { ValidationObserver } from \u0026#39;vee-validate\u0026#39;; // 在 main.js 全域註冊元件 Vue.component(\u0026#39;ValidationObserver\u0026#39;, ValidationObserver); // 區域註冊元件（推薦） export default { components: { ValidationObserver, }, };   詳細的處理表單範例，可以參考 官方文件。\n基本範例：\n1 2 3 4 5 6  \u0026lt;ValidationObserver v-slot=\u0026#34;{ invalid }\u0026#34;\u0026gt; \u0026lt;form @submit.prevent=\u0026#34;onSubmit\u0026#34;\u0026gt; \u0026lt;!-- .... --\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; :disabled=\u0026#34;invalid\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/ValidationObserver\u0026gt;   提交按鈕目前為禁用，只有當表單通過驗證才可以送出。\n提交前驗證：\n1 2 3 4 5  \u0026lt;ValidationObserver v-slot=\u0026#34;{ handleSubmit }\u0026#34;\u0026gt; \u0026lt;form @submit.prevent=\u0026#34;handleSubmit(onSubmit)\u0026#34;\u0026gt; \u0026lt;!-- .... --\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/ValidationObserver\u0026gt;   ValidationObserver 提供了一個 handleSubmit 可用於保護表單提交的 handleSubmit 功能。\n重置表單：\n1 2 3 4 5 6  \u0026lt;ValidationObserver v-slot=\u0026#34;{ reset }\u0026#34;\u0026gt; \u0026lt;form @reset.prevent=\u0026#34;reset\u0026#34;\u0026gt; \u0026lt;!-- .... --\u0026gt; \u0026lt;button type=\u0026#34;reset\u0026#34;\u0026gt;Reset\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/ValidationObserver\u0026gt;   4.1 使用 $refs 先通過 $refs 找到 ValidationObserver 元件，呼叫組件中的方法 validate()，如果所有條件都為真（就是說所有的校驗都通過了）回傳 true，否則回傳 false。\n1 2 3 4 5  \u0026lt;ValidationObserver ref=\u0026#34;form\u0026#34;\u0026gt; \u0026lt;form @submit.prevent=\u0026#34;onSubmit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/ValidationObserver\u0026gt;   1 2 3 4 5 6 7 8 9  onSubmit () { this.$refs.form.validate().then((success) =\u0026gt; { if (success) { // 證成功後的行為包含 AJAX傳送、重製表單等等  } else { // 驗證失敗產生的行為  } }); },    官方文件。\n 4.2 顯示初始驗證狀態 使用 immediate顯示　初始驗證狀態：\n1 2 3  \u0026lt;ValidationObserver rules=\u0026#34;required\u0026#34; v-slot=\u0026#34;{ errors }\u0026#34;　immediate\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/ValidationObserver\u0026gt;   詳細的互動和用戶體驗範例，可以參考 官方文件。\n4.3 更詳細 插槽範圍內可用的屬性，可以參考 官方文件。\n更多可用 prop 可以參考 官方文件。\n5. 驗證狀態 驗證狀態\n6. 中文化 vee-validate 附帶了一個很小的 i18n 字典，可滿足基本的 i18n 需求。vee-validate 的預設語言是 en。\n雖然 vee-validate 具有 40 多個可用於互動的驗證的語言環境，但是預設情況下不會安裝它們，因此我們需要導入所需的語言環境。\n導入安裝語言環境所需的 localize 函式：\n1  import { localize } from \u0026#39;vee-validate\u0026#39;;   安裝需要的使用語言環境，並使用 localize() 增加新的語言環境：\n1 2 3  import TW from \u0026#39;vee-validate/dist/locale/zh_TW.json\u0026#39;; localize(\u0026#39;zh_TW\u0026#39;, TW);   ","description":"這週是 六角鼠年鐵人賽 第八週，紀錄 Vue 表單驗證套件 - Vee Validate 操作方法。","id":15,"section":"posts","tags":["VeeValidate","Vue","w3HexSchool"],"title":"Vue筆記 - 表單驗證套件 VeeValidate","uri":"https://chupai.github.io/posts/200328_vee-validate/"},{"content":"這週是 六角鼠年鐵人賽 第七週，挑戰剛開始時，我的文章是放在 Bloggi，而且第一週文章就是 Bloggi 如何使用（明顯混分😂），但後來想想，Bloggi 沒有留言、沒有備份、嵌入 CodePen 會跑版，為了避免之後不必要的麻煩，還是用自己建立一個 Blog 吧。\n\rGitHub Pages 架設部落格最頭痛的問題就是放網站的空間，通常架設網站不是自己用 NAS 來架設，就是花錢租主機空間。\n以上兩種方法都是需要一定的花費，但是透過 GitHub Pages 來架站，則完全免費，但也有一定的 條件：\n 網站大小不能超過 1 GB 網站每月流量不能超過 100 GB 一小時內的網站更新不得超過 10 次  以上限制對一般需求一定夠用，而且 GitHub 是著名的軟體原始碼代管服務，有一定的穩定性。\n要說唯一的缺點，就是 GitHub Pages 只能架設「靜態網站」，因此無法架設 Wordpress 之類的部落格。\n這時候就需要使用到 靜態網頁產生器 來建立 Blog。\n1. 熱門靜態網頁產生器  Top 5 Static Site Generators for 2020 10 best static site generators  Hugo 簡介  Hugo 官網\n Hugo 是一個用 Go 語言編寫的靜態網站生成器，最大的優點就是編譯速度相對於 Jekyll、Hexo 簡直是飛快。\n 基於 go 語言開發，沒有錯綜複雜的依賴關係 社區活躍 功能完善 前端語言支持的種類豐富 整體框架靈活易懂 修改即時預覽  近期有越來越多人因為 Hugo 的編譯速度，將部落格從 Hexo 搬移到 Hugo，不過 Hugo 也有一個很大的缺點，就是相對 Hexo 來說，Blog 的主題太少，也是有人因為 Hexo 有喜歡的主題而捨棄 Hugo。\n搭建 Hugo 1. 前置作業 MacOS 可以直接使用 Homebrew 安裝 Hugo。\nbrew install hugo 在 Windsow 環境必須先下載 hugo_extended_0.67.0_Windows-64bit.zip。\n解壓縮後，會有一個 hugo.exe 檔案。創建一個新資料夾：C:\\hugo，並將 hugo.exe 檔案放到裡面。\n接下來配置環境變數，點選本機（右鍵） \u0026gt; 內容 \u0026gt; 進階系統設定 \u0026gt; 環境變數 \u0026gt; Path \u0026gt; 編輯 \u0026gt; 新增路徑：C:\\hugo。\n2. 建立一個專案 開啟終端機並切換到 hugo/ 資料夾下，執行以下命令：\nhugo new site myBlog myblog 可以替換成任意名稱。\n機器上會產生一個 myBlog 資料夾，結構如下：\nmyBlog/ │ ├── archetypes/ │ │ │ └─ default.md # 預設 markdown ├── content/ # 頁面、文章（markdown） ├── data/ # 資料庫 ├── layouts/ # 自定義的樣板 ├── static/ # 靜態資源 ├── themes/ # 網站的主題 └── config.toml # 網站的配置 3. 加入主題 因為 Hugo 預設沒有任何主題的，因此必須在 Hugo Themes 選擇一個來套用。\n記得先安裝 git 工具，接下來在 myBlog/ 資料夾下加入 git 版控：\ngit init 從 Github 下載主題並將其添加到 theme 目錄中：\ngit submodule add https://github.com/AmazingRise/hugo-theme-diary.git themes/diary 如果沒安裝 git：\n 可以直接下載該主題最新版本，並解壓縮； 將資料夾重新命名 並將其移至 themes 資料夾。  最後開啟跟目錄下的 config.toml 檔案，設定使用主題：\ntheme = \u0026quot;diary\u0026quot; 或是將 theme/ 內的 config.toml 取代根目錄的。\n最基本的主題安裝流程大概是這樣。\n但要注意，因為 config 配置檔，支援 toml、yaml、json 三種格式，也可以放在 config/ 資料夾內，然後拆分不同模組的配置。所以並不是每個主題的安裝方式都相同，因此最好詳細閱讀每個主題下方的說明。\n4. 新增頁面 hugo new 會根據 archetypes/ 資料夾下的 default.md 產生在 content/ 資料夾下。\nhugo new [路徑]頁面名.md 單頁面，一般會放在 content/ 資料夾下，例如：\nhugo new about.md 文章一般會放在 content/posts/ 內，例如：\nhugo new posts/my-first-post.md 不同的主題，會有不同的資料夾結構，單頁面與文章的 Front Matter 設定也都不相同，因此可以查看主題文件說明。\n5. 本地端測試 預覽草稿 Draft：\nhugo server -D 預覽（不包含草稿）：\nhugo server 預覽網址：http://localhost:1313/\n建議在本地測試時，config.toml 設定檔內的 baseURL 先設為空值。\n自定義 1. Front Matter Front-matter 是 md 檔案最上方的分隔區域，用於指定個別檔案的變數。\n預設使用 yaml 格式，使用 --- 分隔：\n1 2 3 4 5  --- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true ---   另外還支持 toml、json 格式，分別使用 +++ 與 {} 分隔。\n預設屬性分別為：\n title：標題名，使用 hugo new 建立會與檔名相同。 date：日期，使用 hugo new 建立為目前時間。 draft：草稿，如果是 true 生成網站時，不包括此頁面。  1.1 常用 Front Matter 屬性 另外，列出其他 Hugo 支持的常用 Front Matter 屬性：\n description：內容描述，主要用於 SEO 優化。 tags：標籤。 categories：分類。 keywords：關鍵字。 url：文章 url 名稱，預設使用檔案名稱。 weight：列表頁的文章排序，越小越靠前，無設定則依照時間排序。  其他屬性，主要看你用的主題所對應到板模上的變數，主題的文件都會詳細說明。\n1.2 Archetypes Archetypes 意思為原型，可以當作是生成 md 檔案的模板。\n當我們使用 hugo new 建立 md 檔案時，會根據 archetypes/ 資料夾下的模板來建立。\n舉例來說，如果 archetypes/ 下有一個 about.md，那麼以下指令就會根據它來產生檔案。\nhugo new about.md 如果沒有相同的檔名，會根據 default.md 來產生檔案。\n2. Config Hugo 將整個網站的設定配置都集中在 config.toml 檔中，預設為 toml 格式，一樣支持另外兩種格式（yaml、json）。\n 完整 Hugo Config 可以詳閱官方文件 Configure Hugo。\n 發佈到 Github Pages 上  Host on GitHub\n 事前準備：\n 安裝 Git 2.8 以上 GitHub 帳號 Hugo 網站  1. 建立 repository 在 GitHub 建立一個 repository，命名為：帳號.github.io。\n2. 設定 baseURL 將 config.toml 配置檔內的 baseURL 設為：\n1  baseURL = \u0026#34;http://帳號.github.io/\u0026#34;   3. 建立 public 資料夾 hugo 執行 hugo 就會產生 public/ 的資料夾。\n4. 上傳 在 public/ 資料夾下執行以下命令：\ngit init git remote add origin https://github.com/帳號/帳號.github.io.git git add . git commit -m \u0026quot;my Blog\u0026quot; git push -u origin master 接下來可能會讓你輸入你的 Github 帳號和密碼，之後就可以去 Github 和 http://帳號.github.io 查看是否成功。\n5. 更新 之後添加文章，只需要重新編譯 Hugo，重新提交到 Github 即可。\ngit add . git commit -m \u0026quot;本次更新的說明\u0026quot; git push origin master 新增留言板 因為是靜態網頁，所以留言板就區要依賴第三方。\nDisqus 是整合性留言管理系統，用來管理各種社群的留言平台。\n1. 註冊帳號 註冊帳號並取得 shortname。\n流程蠻簡單的，如果不清楚，可以自行搜尋一下教學流程，這裡就不多做說明。\nLanguage 如果選擇 Chinese 只有簡體。\n2. 在 Hugo 啟用 假設你的主題已經預設 Disqus 留言板了，那麼只需要在config.toml 配置檔填入 Disqus 的 shortname。\n1  disqusShortname = \u0026#34;yourdiscussshortname\u0026#34;   如果沒有，就需要將官方提供的檔案加到你的網站中。\n在 layouts/partials/ 資料夾下，加入 disqus.html 檔案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026lt;div id=\u0026#34;disqus_thread\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; (function() { // Don\u0026#39;t ever inject Disqus on localhost--it creates unwanted  // discussions from \u0026#39;localhost:1313\u0026#39; on your Disqus account...  if (window.location.hostname == \u0026#34;localhost\u0026#34;) return; var dsq = document.createElement(\u0026#39;script\u0026#39;); dsq.type = \u0026#39;text/javascript\u0026#39;; dsq.async = true; var disqus_shortname = \u0026#39;{{ .Site.DisqusShortname }}\u0026#39;; dsq.src = \u0026#39;//\u0026#39; + disqus_shortname + \u0026#39;.disqus.com/embed.js\u0026#39;; (document.getElementsByTagName(\u0026#39;head\u0026#39;)[0] || document.getElementsByTagName(\u0026#39;body\u0026#39;)[0]).appendChild(dsq); })(); \u0026lt;/script\u0026gt; \u0026lt;noscript\u0026gt;Please enable JavaScript to view the \u0026lt;a href=\u0026#34;https://disqus.com/?ref_noscript\u0026#34;\u0026gt;comments powered by Disqus.\u0026lt;/a\u0026gt;\u0026lt;/noscript\u0026gt; \u0026lt;a href=\u0026#34;https://disqus.com/\u0026#34; class=\u0026#34;dsq-brlink\u0026#34;\u0026gt;comments powered by \u0026lt;span class=\u0026#34;logo-disqus\u0026#34;\u0026gt;Disqus\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;   如果要在本地端測試 Disqus，可以將 if (window.location.hostname == \u0026quot;localhost\u0026quot;) return; 註解掉。\n最後開啟你主題內的 layouts/_default/ 資料夾中的 single.html 在適當位置貼上下面這段：\n1  {{ partial \u0026#34;disqus.html\u0026#34; . }}   這樣就完成了。\nGoogle Analytics 1. 建立帳戶 前往 Google Analytics，可以使用 Google 帳號，直接註冊。\n建立帳戶取得 Tracking ID。\n2. Hugo 設定 在 config.toml 加入 Tracking ID：\ngoogleAnalytics = \u0026quot;UA-XXXXX-Y\u0026quot; 在主題內的 layouts/partials/ 資料夾中的 head.html 在適當位置貼上下面這段：\n1  {{ template \u0026#34;_internal/google_analytics_async.html\u0026#34; . }}   容易遇到的問題 1. Markdown 圖片路徑 在 Markdown 圖片路徑中，是以 static/ 為根目錄寫全路徑。\n圖片位置：/static/imgae/cover/post1.png，那麼在 Markdown 中寫作：\n1  ![圖片說明](/imgae/cover/post1.png)   總結 目前就先記錄到這，之後如果有用到 Hugo 其他功能再補上。\n文章部分，之後會慢慢把 Blogger 的舊文搬過來，還有 Hackmd 的筆記整理後丟過來 🙂\n","description":"這週是 六角鼠年鐵人賽 第七週，Hugo 建立 Blog。","id":16,"section":"posts","tags":["Hugo","w3HexSchool"],"title":"Hugo 建立 Blog","uri":"https://chupai.github.io/posts/200316_hugo/"},{"content":"這週是 六角鼠年鐵人賽 第六週，上週剛好接觸到 Lodash，就簡單紀錄一下。\n\r簡介 你很可能需要經常重複寫一些工具函式，尤其是處理字串與陣列或是物件。為了使開發專案更有效率且好維護，Lodash 可能是你好選擇。\nLodash 是一個一致性、模組化、高性能的 JavaScript 實用工具函式庫，包含對字串、陣列、物件等常見型別的處理函式。\n其中部分是目前 ECMAScript 尚未制訂的規範，但同時被業界所認可的輔助函式。\n Lodash Lodash 中文網  目前在寫這篇文章時，Lodash 在 github 上星數高達 43.8k，版本為 4.17.15。\n另外，在 npm 中依賴 Lodash 的 package 非常多：packages depending on lodash。\nAPI Lodash 提供了非常多的工具方法，包含\n Array：適用於 陣列，例如分割、合併、刪除、查詢、重組等操作。 Collection：適用於 陣列 和 物件，部分可用於字串，例如遍歷、分組、查詢、過濾等操作。 Date：只有一個 now 方法。 Function：函式的操作。 Lang：各種型別的轉換、判斷或是深拷貝。 Math：基本的數學運算，例如數值的四捨五入、數組的最大、最小值等等。 Number：取得隨機數、判斷數值區間、求中間值。 Object：適用於 物件，例如物件的創建、擴展、轉換、搜索、集合等操作。 Seq：常用於創建鏈式呼叫，提高執行性能（惰性計算）。 String：適用於 字串 操作。 Util：實用工具函式。  1. 為什麼不用 ES6 語法就好？ Lodash 有很多方法 ES6 已經封裝好了，而且部分方法也可以使用 ES6 語法替換。加上 ES6 越來越多主流瀏覽器支持，另外還可以使用 Babel 將 ES6 編譯成 ES5。那麼我們還需要使用 Lodash 嗎？\n可以參考以下兩篇文章：\n 在 ES6 大行其道的今天，還有必要使用 lodash 之類的庫嗎？ 為什麼不用 ES6 完全替換 Lodash  2. 惰性求值 Lodash 另一個優勢就是其優異的計算性能。很大部分就來源於其使用的算法「惰性求值」。\n關於 惰性求值 可以參考以下文章：\n 惰性求值——lodash源碼解讀  3. SameValueZero 相等比 部分方法使用 SameValueZero 相等比，關於 SameValueZero 可以看這篇文章： ECMAScript 6相等演算 。\n安裝 1. 瀏覽器 下載檔案，直接引入：\n1  \u0026lt;script src=\u0026#34;lodash.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   或是使用 CDN。\n2. 在專案中使用 lodash 透過 npm 安裝：\nnpm i --save lodash 接著在你的程式碼中 import 即可：\n1  import _ from \u0026#39;lodash\u0026#39;;   但這樣做會將整包 Lodash 打包進去。如果只使用 Lodash 其中一兩個方法，會造成了不必要的資源浪費。\n解決辦法有三種：\n 單獨引入：lodash 每個函式都具有單獨的模組，可以只引入需要的模組。  1 2 3 4 5  import _map from \u0026#39;lodash.map\u0026#39;; import _random from \u0026#39;lodash.random\u0026#39;; // or import _map from \u0026#39;lodash/map\u0026#39;; import _random from \u0026#39;lodash/random\u0026#39;;    使用套件優化：  lodash-webpack-plugin babel-plugin-lodash   使用 lodash-es：  1  import { mapm , random } from \u0026#39;lodash-es\u0026#39;;   不過，是否需要對 Lodash 優化，可以參考這篇文章：lodash 在 webpack 中的各項優化的嘗試。\n2. Vue Cli Vue 除了上述方式，還可以使用 vue-lodash 套件：\n1 2 3 4 5  // main.js import Vue from \u0026#39;vue\u0026#39;; import VueLodash from \u0026#39;vue-lodash\u0026#39;; import lodash from \u0026#39;lodash\u0026#39;; Vue.use(VueLodash, { name: \u0026#39;custom\u0026#39;, lodash: lodash });   1 2 3 4 5 6 7 8 9 10 11 12 13  export default { methods: { test() { console.log( this.lodash.random(20) ); console.log( this._.random(20) ); console.log( this.custom.random(20) ); }, } }; console.log( Vue.lodash.random(20) ); console.log( Vue._.random(20) ); console.log( Vue.custom.random(20) );   常用方法 由於 Lodash 中 API 太多了，這裡只會列幾個會常用到的方法並簡單說明。更詳細的用法、參數可以看官方 API 文件。\n1. Array _.union() 將陣列合併，並去除重複的元素（SameValueZero 相等比較），會回傳一個新陣列。\n1  _.union([arrays])    [arrays] (...Array): 陣列組 回傳值：回傳新的陣列  1 2 3 4 5  let arr1 = [1, 2, 3, 4]; let arr2 = [2, 4, 6, 8]; let arr3 = [3, 5, 7, 9]; console.log( _.union(arr1, arr2, arr3) );   如果元素是物件，可使用 _.unionBy，另外還有 _.unionWith() 可以呼叫一個比較函式。\n_.intersection() 取得陣列組的交集元素（使用 SameValueZero 相等比較）。\n1  _.intersection([arrays])    [arrays] (...Array)：陣列組 回傳值：交集元素陣列  1 2 3 4 5 6 7  let arr1 = [0, 1, 2, 3, 4]; let arr2 = [0, 2, 4, 6, 8]; let arr3 = [0, 2, 3, 5, 7, 9]; console.log( _.intersection(arr1, arr2, arr3) ); // [0, 2]   如果元素是物件，可使用 _.intersectionBy()，另外還有 _.intersectionWith() 可以呼叫一個比較函式。\n_.difference() 檢查一個陣列，並將指定的值排除（SameValueZero 相等比較），會回傳一個新陣列。\n與 _.difference() 類似的方法還有 _.without() 與 _.pull()。\n1  _.difference(array, [values])    array (Array)：需要被檢查的陣列 [values] (...Array)：需要排除的值（放在陣列中） 回傳值：回傳新的陣列  1 2 3  let arr = [0, 1, 2, 3, 4]; console.log( _.difference(arr, [2, 4, 6, 8]) ); // [0, 1, 3]   如果元素是物件，可使用 _.differenceBy()，另外還有 _.differenceWith() 可以呼叫一個比較函式。\n_.uniq() 陣列重組，去除重複的元素（SameValueZero 相等比較），會回傳一個新陣列。\n1  _.uniq(array)    array (Array): 要檢查的陣列 回傳值：回傳新的陣列  1 2  console.log( _.uniq([1, 2, 2, 4, 1, 5]) ); // [1, 2, 4, 5]   如果元素是物件，可使用 _.uniqBy()，另外還有 _.uniqWith() 可以呼叫一個比較函式。\n_.indexOf() 搜尋陣列是否有值為 value 的元素（使用 SameValueZero 等值比較），並回傳第一個符合的索引值。\n1  _.indexOf(array, value, [fromIndex=0])    array (Array)：要查詢的陣列 value (*)：條件值 [fromIndex=0] (number)：初始位置  預設值為 0 也就是開頭 如果 fromIndex 為負值，則從陣列結尾數過來   回傳值：匹配值的索引值，否則回傳 -1  1 2 3 4 5  let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; console.log( _.indexOf(arr, \u0026#39;b\u0026#39;) ); // 1 console.log( _.indexOf(arr, \u0026#39;b\u0026#39;, -1) ); // -1 console.log( _.indexOf(arr, \u0026#39;b\u0026#39;, -2) ); // 4   _.lastIndexOf() 這個方法類似 indexOf ，區別是它是從右到左遍歷陣列的元素，預設起始位置為結尾。\n1  _.lastIndexOf(array, value, [fromIndex=array.length-1])    array (Array)：要查詢的陣列 value (*)：條件值 [fromIndex=array.length-1](number)：初始位置  預設值為 array.length-1 也就是結尾 如果 fromIndex 為負值，則從陣列結尾數過來   回傳值：匹配值的索引值，否則回傳 -1  1 2 3 4 5 6  let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; console.log( _.lastIndexOf(arr, \u0026#39;b\u0026#39;) ); // 4 console.log( _.lastIndexOf(arr, \u0026#39;b\u0026#39;, 0) ); // -1 console.log( _.lastIndexOf(arr, \u0026#39;b\u0026#39;, 2) ); // 1 console.log( _.lastIndexOf(arr, \u0026#39;b\u0026#39;, -2) ); // 4   2. Collection Collection（集合）的方法 陣列 或 物件 都可以使用，部分方法字串也可以。\n其中 map 及 filter 方法最常使用，因為原生 JavaScrtip 中是不支援物件的，因此當需要迭代物件時，會使用 for in 或 Object.keys。\n_.map() 迭代的集合的方法，回傳一個新陣列。\n1  _.map(collection, [iteratee=_.identity])    collection (Array|Object)：用來迭代的集合。 [iteratee=_.identity] (Array|Function|Object|string)：每次迭代呼叫的函式。  參數：(value, index|key, collection)   回傳值：新陣列  Lodash 中有許多方法是防止作為其他方法的迭代函式（註：即不能作為 iteratee 參數傳遞給其他方法），例如： _.every、 _.filter、 _.map、 _.mapValues、 _.reject 和 _.some。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  console.log( _.map([4, 8], (n) =\u0026gt; n * n) ); // [16, 64]  const square = (n) =\u0026gt; n * n; let arr = [2, 4]; let obj = { a: 2, b: 4 }; console.log( _.map(arr, square) ); // [4, 16]  console.log( _.map(obj, square) ); // [4, 16]  let users = [{ user: \u0026#39;barney\u0026#39; }, { user: \u0026#39;fred\u0026#39; }]; console.log( _.map(users, \u0026#39;user\u0026#39;) ); // [\u0026#39;barney\u0026#39;, \u0026#39;fred\u0026#39;]   另外可以參考這篇文章：map () 誰比較快和輕量？ Lodash vs ES6。\n_.filter() 根據條件過濾出符合條件的元素。\n1  _.filter(collection, [predicate=_.identity])    collection (Array|Object)：一個用來迭代的集合。 [predicate=_.identity] (Array|Function|Object|string)：每次迭代呼叫的函式。 回傳值：回傳新的陣列  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  let users = [ { user: \u0026#39;barney\u0026#39;, age: 36, active: true }, { user: \u0026#39;fred\u0026#39;, age: 40, active: false }, ]; _.filter(users, function(o) { return !o.active; }); // =\u0026gt; objects for [\u0026#39;fred\u0026#39;]  // The `_.matches` iteratee shorthand. _.filter(users, { age: 36, active: true }); // =\u0026gt; objects for [\u0026#39;barney\u0026#39;]  // The `_.matchesProperty` iteratee shorthand. _.filter(users, [\u0026#39;active\u0026#39;, false]); // =\u0026gt; objects for [\u0026#39;fred\u0026#39;]  // The `_.property` iteratee shorthand. _.filter(users, \u0026#39;active\u0026#39;); // =\u0026gt; objects for [\u0026#39;barney\u0026#39;]   _.includes() 檢查 value 是否在 collection中。\n1  _.includes(collection, value, [fromIndex=0])   collection (Array|Object|string)：要檢索的集合。\nvalue (*)：要檢索的值。\n[fromIndex=0] (number)：要檢索的索引位置。\n 回傳值：布林值  如果 collection 是一串，value 就是字元，否則使用 SameValueZero 做等值比較。\n1 2 3 4 5 6 7 8 9 10 11  _.includes([1, 2, 3], 1); // =\u0026gt; true  _.includes([1, 2, 3], 1, 2); // =\u0026gt; false  _.includes({ user: \u0026#39;fred\u0026#39;, age: 40 }, \u0026#39;fred\u0026#39;); // =\u0026gt; true  _.includes(\u0026#39;pebbles\u0026#39;, \u0026#39;eb\u0026#39;); // =\u0026gt; true   _.shuffle() 將集合打亂（使用 Fisher-Yates shuffle 洗牌算法）。\n1  _.shuffle(collection)    collection (Array|Object)：要打亂的集合 回傳值：回傳隨機元素的陣列  1 2 3 4 5 6 7 8 9  let arr = [0, 1, 2, 3, 4]; console.log( _.shuffle(arr) ); // [ 3, 4, 1, 0, 2 ] console.log( _.shuffle(arr) ); // [ 3, 0, 2, 4, 1 ]  let obj = { a: 1, b: 2, c: 3 }; console.log( _.shuffle(obj) ); // [ 2, 3, 1 ] console.log( _.shuffle(obj) ); // [ 1, 3, 2 ]   _.sampleSize() 從集合中獲得 n 個隨機元素。\n1  _.sampleSize(collection, [n=1])    collection (Array|Object)：要取樣的集合 [n=1] (number)：取樣的元素個數。 回傳值：回傳隨機元素的陣列  1 2 3 4 5 6  let arr = [0, 1, 2, 3, 4]; console.log( _.sampleSize(arr, 1) ); // [2] console.log( _.sampleSize(arr, 1) ); // [0] console.log( _.sampleSize(arr, 2) ); // [2, 1] console.log( _.sampleSize(arr, 2) ); // [0, 4]   _.sortBy() 創建一個元素陣列。以 iteratee 處理的結果升序排序。這個方法執行穩定排序，也就是說相同元素會保持原始排序\n1  _.sortBy(collection, [iteratees=[_.identity]])    collection (Array|Object)：用來迭代的集合。 [iteratees=[_.identity]] (...* (Array|Array[]|Function|Function[]|Object|Object[]|string|string[]))：這個函式決定排序。 回傳值：排序後的陣列  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  let arr = [1, 65, 44, 2, 3, 55]; console.log( _.sortBy(arr) ); let users = [ { user: \u0026#39;fred\u0026#39;, age: 48 }, { user: \u0026#39;barney\u0026#39;, age: 36 }, { user: \u0026#39;fred\u0026#39;, age: 40 }, { user: \u0026#39;barney\u0026#39;, age: 34 }, ]; console.log(_.sortBy(users, (item) =\u0026gt; item.user)); // [ { user: \u0026#39;barney\u0026#39;, age: 36 }, // { user: \u0026#39;barney\u0026#39;, age: 34 }, // { user: \u0026#39;fred\u0026#39;, age: 48 }, // { user: \u0026#39;fred\u0026#39;, age: 40 } ]  console.log(_.sortBy(users, \u0026#39;age\u0026#39;)); // [ { user: \u0026#39;barney\u0026#39;, age: 34 }, // { user: \u0026#39;barney\u0026#39;, age: 36 }, // { user: \u0026#39;fred\u0026#39;, age: 40 }, // { user: \u0026#39;fred\u0026#39;, age: 48 } ]  console.log(_.sortBy(users, [\u0026#39;user\u0026#39;, \u0026#39;age\u0026#39;])); // [ { user: \u0026#39;barney\u0026#39;, age: 34 }, // { user: \u0026#39;barney\u0026#39;, age: 36 }, // { user: \u0026#39;fred\u0026#39;, age: 40 }, // { user: \u0026#39;fred\u0026#39;, age: 48 } ]   3. Object _.get() 根據物件的路徑取值，沒有則回傳 undefined，可以設定預設值。\n1  _.get(object, path, [defaultValue])    object (Object)：要檢索的物件。 path (Array|string)：要獲取屬性的路徑，可以是字串或陣列。 [defaultValue] (*)：預設值。 回傳值：解析的值  1 2 3 4 5 6 7  let obj = { id: \u0026#39;1234\u0026#39;, list: [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;] }; console.log( _.get(obj, \u0026#39;id\u0026#39;) ); // \u0026#39;1234\u0026#39; console.log( _.get(obj, \u0026#39;list[0]\u0026#39;) ); // \u0026#39;a\u0026#39; console.log( _.get(obj, [\u0026#39;list\u0026#39;, \u0026#39;3\u0026#39;]) ); // \u0026#39;d\u0026#39; console.log( _.get(obj, \u0026#39;name\u0026#39;); // undefined console.log( _.get(obj, \u0026#39;name\u0026#39;, \u0026#39;no-find\u0026#39;) ); // \u0026#39;no-find\u0026#39;   _.pick() 創建一個從 object 中選中的屬性的物件。\n1  _.pick(object, [props])    object (Object)：來源物件。 [props] (...(string|string[]))：選中的屬性。（註：單獨指定或指定在陣列中。） 回傳值：回傳新物件  1 2 3  let object = { a: 1, b: \u0026#39;2\u0026#39;, c: 3 }; console.log( _.pick(object, [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;]) ); // { a:1, c:3 }   _.omit 為反向版的 _.pick。\n_.pickBy() 創建一個物件，這個物件組成為從 object 中經 predicate 判斷為真值的屬性。\n1  _.pickBy(object, [predicate=_.identity])    object (Object)：來源物件。 [predicate=_.identity] (Function)：呼叫每一個屬性的函式。  有 2個參數：(value, key)。   回傳值：回傳新物件  1 2 3 4  let obj = { a: 1, b: \u0026#39;2\u0026#39;, c: 3 }; console.log( _.pickBy(obj, _.isNumber) ); // { \u0026#39;a\u0026#39;: 1, \u0026#39;c\u0026#39;: 3 }   _.omitBy 為反向版的 _.pickBy。\n_.defaults() 安全的合併物件，遇到重複的屬性則忽略。\n1  _.defaults(object, [sources])    object (Object)：目標物件。 [sources] (...Object)：來源物件。 回傳值：這方法會改變目標物件，回傳目標物件  1 2 3 4 5 6 7 8  let obj1 = { foo: 1, boo: 2 }; let obj2 = { foo: 3, zoo: 4 }; let r = _.defaults(obj1, obj2); console.log(r); // { foo: 1, boo: 2, zoo: 4 } console.log(obj1); // { foo: 1, boo: 2, zoo: 4 } console.log(obj1 === r); // true   4. Lang _.cloneDeep() 資料的深拷貝。\n1  _.cloneDeep(value)    value (*)：要拷貝的資料。 回傳值：回傳拷貝的資料。  1 2 3 4  let obj = { a: { b: 1 } }; let newObj = _.cloneDeep(obj); console.log( obj.a === newObj.a ); // false   另外，可以參考以下文章：\n lodash源碼分析——deepclone，基於4.17.10版本\n Lodash 是如何實現深拷貝的  _.isEqual() 執行深比較來確定兩者的值是否相等。\n1  _.isEqual(value, other)    value (*)：用來比較的值。 other (*)：另一個用來比較的值。 回傳值：布林值  如果是物件，則比較自身的屬性，不包括繼承的和可列舉的屬性。不支持函式和DOM 節點比較。\n1 2 3 4 5 6 7  let object = { a: 1 }; let other = { a: 1 }; console.log(object === other); // false console.log(_.isEqual(object, other)); // true   5. Number _.clamp() 設定數值上下限，超出範圍，回傳上限或下限，否則回傳數值本身。\n1  _.clamp(number, [lower], upper)    number (number)：被限制的值。 [lower] (number)：可選，下限值。 upper (number)：上限值。 回傳值：  number 大於 upper 回傳 lower number 小於 lower 回傳 lower 在 upper 之間 lower 回傳 number 本身    1 2 3 4 5 6  console.log( _.clamp(5, 10) ); // 5 console.log( _.clamp(11, 10) ); // 10  console.log( _.clamp(11, -10, 10) ); // 10 console.log( _.clamp(-11, -10, 10) ); // -10 console.log( _.clamp(0, -10, 10) ); // 0   _.random() 隨機產生一個包括 lower 與 upper 之間的數，如果只設置一個參數則回傳 0 到該數之間的數值。\n1  _.random([lower=0], [upper=1], [floating])    [lower=0] (number)：下限。 [upper=1] (number)：上限。 [floating] (boolean)：指定是否回傳浮點數。  lower 與 upper 非浮點數預設為 false    1 2 3 4 5 6 7 8 9 10  _.random(5); // between 0 and 5 _.random(-5); // between -5 and 0 _.random(5, 10); // between 5 and 10 _.random(5, true); // a floating-point number between 0 and 5 _.random(1.2, 5.2); // a floating-point number between 1.2 and 5.2   _.inRange() 檢查 number 是否在 start 與 end 之間（但不包括 end）。\n1  _.inRange(number, [start=0], end)    number (number)：要檢查的值。 [start=0] (number)：開始範圍。  可選，沒設置預設值為 0。   end (number)：結束範圍。  如果第二個參數大於第三個參數，大的為 end。    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  _.inRange(3, 2, 4); // 3 是否在 2~3 之間 =\u0026gt; true _.inRange(4, 8); // 4 是否在 0~7 之間 =\u0026gt; true _.inRange(4, 2); // 4 是否在 0~1 之間 =\u0026gt; false _.inRange(2, 2); // 2 是否在 0~1 之間 =\u0026gt; false _.inRange(1.2, 2); // 1.2 是否在 0~1 之間 =\u0026gt; true _.inRange(3.2, 4); // 3.2 是否在 0~3 之間 =\u0026gt; false _.inRange(0, 4, 0); // 0 是否在 0~3 之間 =\u0026gt; true _.inRange(-3, -2, -6); // -3 是否在 -6~-2 之間 =\u0026gt; true   6. Util _.range() 建立一個指定範圍的數值陣列。\n1  _.range([start=0], end, [step=1])    [start=0] (number：開始的範圍。 end (number)：結束的範圍（不包括自己）。 [step=1] (number)：範圍的增量 或者 減量。  只有一個參數 _.range(n) 等同 _.range(0, n, 1)，如果是負數 _.range(-n) 等同 _.range(0, n, -1)。\nend 小於 start 而且 step 非負數，會創建一個空陣列。\n1 2 3 4 5 6  console.log( _.range(4) ); // [0, 1, 2, 3, 4] console.log( _.range(-4) ); // [0, -1, -2, -3] console.log( _.range(1, 4) ); // [1, 2, 3] console.log( _.range(0, 10, 5) ); // [0, 5, 10] console.log( _.range(0, -4, -1) ); // [0, -1, -2, -3] console.log( _.range(1, 4, 0) ); // [1, 1, 1]   _.times() 呼叫 iteratee 函式 n 次，並將結果存到陣列中，並回傳該陣列。\n1  _.times(n, [iteratee=_.identity])    n (number)：呼叫 iteratee 的次數。 [iteratee=_.identity] (Function)：每次迭代呼叫的函式，參數為 index。  1 2 3 4  console.log(_.times(3, String)); // [\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;] console.log(_.times(3, (index) =\u0026gt; index * index)); // [0, 1, 4]   _.uniqueId() 生成唯一 ID，可以添加前綴。\n1  _.uniqueId([prefix=\u0026#39;\u0026#39;])    [prefix=''] (string)：要添加到 ID 前綴的值。 回傳值：回傳生成的唯一 ID 字串。  1 2 3  console.log( _.uniqueId() ); // \u0026#39;1\u0026#39; console.log( _.uniqueId() ); // \u0026#39;2\u0026#39; console.log( _.uniqueId(\u0026#39;book\u0026#39;) ); // \u0026#39;book3\u0026#39;   7. Math _.sum() 陣列的總和。\n1  _.sum(array)   1 2  _.sum([4, 2, 8, 6]); // =\u0026gt; 20   如果元素是物件，可以使用 _.sumBy()。\n總結 這週先記錄到這邊，有空慢慢補上，下週見。\n","description":"這週是 六角鼠年鐵人賽 第六週，上週剛好接觸到 Lodash，就簡單紀錄一下。","id":17,"section":"posts","tags":["Lodash","w3HexSchool"],"title":"Lodash - JS 實用工具函式庫","uri":"https://chupai.github.io/posts/200315_lodash/"},{"content":"這週是 六角鼠年鐵人賽 第五週，紀錄一下 Vue Transition 用法。\n前言 在日常開發中，網頁動態效果是必不可少的一部分，不僅能讓元素直接的切換顯得更加自然，同時也能極大的增強用戶體驗。\n雖然我們可以使用原生 CSS 或 JS 來實現動態效果，但 Vue 提供了更簡單和高效的方式。\n1. Vue 的轉場工具 Vue 在插入、更新或者移除 DOM 時，提供多種不同方式的應用轉場效果。包括以下工具：\n 在 CSS transition 和 animation 中自動應用 class 名稱； 也可以配合使用第三方 CSS 動畫庫，例如 Animate.css。 在轉場鉤子函式中使用 JavaScript 直接操作 DOM； 也可以配合使用第三方 JavaScript 動畫庫，例如 Velocity.js。  transition 元件 Vue 提供了 transition 的封裝元件，在下列情形中，可以給任何元素和元件添加進入/離開的轉場效果：\n 元素或元件初始渲染時 元素或元件顯示/隱藏時（使用 v-if 或 v-show） 元素或元件切換時  先看一個簡單的基本範例：\n1 2 3 4  \u0026lt;button v-on:click=\u0026#34;show = !show\u0026#34;\u0026gt;Toggle\u0026lt;/button\u0026gt; \u0026lt;transition\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   1 2 3  data: { show: true, },   1 2 3 4 5 6 7 8 9 10 11  .v-enter, .v-leave-to { opacity: 0; } .v-leave, .v-enter-to { opacity: 1; } .v-enter-active, .v-leave-active { transition: opacity 1s; }   當我們使用 transition 元件將元素包住，Vue 會做以下處理：\n 自動偵測目標元素是否應用 CSS transition/animation 如果是，在恰當的時機添加/刪除 CSS 類別名稱。 如果 transition 元件提供了 JavaScript 鉤子函式，這些鉤子函式將在恰當的時機被呼叫。 如果沒有找到 JavaScript 鉤子並且也沒有檢測到 CSS transition/animation，DOM 操作 (插入/刪除) 在下一幀中立即執行。  See the Pen Vue CSS 轉場 基本範例 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  1. CSS 轉場的類別名稱 transition 元件共提供了，六種類別名稱提供切換。\n進場：\n v-enter：定義進場的開始狀態。  在元素被插入之前生效，插入之後的下一幀被移除   v-enter-active：定義進場生效時的狀態，在整個進場的階段中應用。  在元素被插入之前生效，在 transition/animation 完成之後移除 可用來定義進場的過程時間，延遲和曲線函數   v-enter-to：2.1.8版及以上 定義進場的結束狀態。  在元素被插入之後下一幀生效（與此同時 v-enter 被移除），在 transition/animation 完成之後移除    離場：\n v-leave：定義離場的開始狀態。  在離場被觸發時立刻生效，下一幀被移除   v-leave-active：定義離場生效時的狀態，在整個離場的階段中應用。  在離場被觸發時立刻生效，在 transition/animation 完成之後移除 這個類可以被用來定義離場的過程時間，延遲和曲線函數   v-leave-to：2.1.8版及以上 定義離場的結束狀態。  在離開轉場被觸發之後下一幀生效（與此同時 v-leave 被移除），在 transition/animation 完成之後移除    通常會設定 v-enter 與 v-leave-active 相同的效果、v-leave 與 v-enter-to 相同的效果，達到同尾相接形成一個循環，而 v-enter-to 與 v-leave-to 會用來設定轉場時間或動畫。\nenter-to 預設 opacity: 1、transform: none，所以不一定要設定。\r1.1 CSS transition transition 元件預設使用上述 v- 前綴的類別名稱。請參考一開始基本範例。\n因為不可能只用一種動態效果，因此使用自訂義的前綴，需要加上 name 特性，舉例來說，\u0026lt;transition name=\u0026quot;fade\u0026quot;\u0026gt;，套用的那麼類別名稱的前綴就會是 fade-enter。\n1 2 3 4 5 6  \u0026lt;button v-on:click=\u0026#34;show = !show\u0026#34;\u0026gt; Toggle \u0026lt;/button\u0026gt; \u0026lt;transition name=\u0026#34;fade\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   設定一個進場由透明度 0 變 1 並由右測 100px 處滑入，並且進場、離場分別設定不同的曲線函數：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  .fade-enter, .fade-leave-to { opacity: 0; transform: translateX(100px); } .fade-leave, .fade-enter-to { opacity: 1; } .fade-enter-active { transition: all 0.3s ease; } .fade-leave-active { transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1); }   See the Pen Vue CSS 轉場 轉場範例 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  再舉一個例子，由下往上進場，由右出場：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  .fade-enter { opacity: 0; transform: translateY(100%); } .fade-enter-to, .fade-leave { opacity: 1; } .fade-leave-to { opacity: 0; transform: translateX(100%); } .fade-enter-active,.fade-leave-active { transition: all 0.8s ease; }   See the Pen Vue CSS 轉場 轉場範例2 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  1.2 CSS animation CSS animation 用法同 CSS transition，區別是在動畫中 v-enter 類名在節點插入 DOM 後不會立即刪除，而是在 animationend 事件觸發時刪除。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  .bounce-enter-active { animation: bounce-in 0.5s; } .bounce-leave-active { animation: bounce-in 0.5s reverse; } @keyframes bounce-in { 0% { transform: scale(0); } 50% { transform: scale(1.5); } 100% { transform: scale(1); } }   See the Pen Vue CSS 轉場 動畫範例 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 使用自訂義類別名稱 我們可以通過以下 transition 元件特性來使用自訂義類別名稱：\n enter-class enter-active-class enter-to-class 2.1.8+ leave-class leave-active-class leave-to-class 2.1.8+  他們的優先級高於普通的類別名稱。\n舉個簡單得範例，來說明使用方式：\n1 2 3 4 5 6 7  .opacity-0 { opacity: 0; } .trs-time-3 { transition-duration: 3s; }   1 2 3 4 5 6 7 8  \u0026lt;transition enter-class=\u0026#34;opacity-0\u0026#34; leave-to-class=\u0026#34;opacity-0\u0026#34; enter-active-class=\u0026#34;trs-time-3\u0026#34; leave-active-class=\u0026#34;trs-time-3\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   See the Pen Vue CSS 轉場 自訂義 class by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2.1 第三方 CSS 動畫庫 自訂義類別名稱，對於套用第三方 CSS 動畫庫結合非常方便。\n舉例來說，使用 Animate.css 的動畫效果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;button v-on:click=\u0026#34;show = !show\u0026#34;\u0026gt; Toggle \u0026lt;/button\u0026gt; \u0026lt;transition enter-active-class=\u0026#34;animated tada\u0026#34; leave-active-class=\u0026#34;animated bounceOutRight\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;transition enter-active-class=\u0026#34;animated fadeInUp\u0026#34; leave-active-class=\u0026#34;animated flipInY\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   See the Pen Vue CSS 轉場 Animate.css by CHUPAIWANG (@CHUPAIWANG) on CodePen.  或者是 magic.css：\n1 2 3 4 5 6 7 8 9  \u0026lt;button v-on:click=\u0026#34;show = !show\u0026#34;\u0026gt; Toggle \u0026lt;/button\u0026gt; \u0026lt;transition enter-active-class=\u0026#34;magictime foolishIn\u0026#34; leave-active-class=\u0026#34;magictime tinDownOut\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   See the Pen Vue CSS 轉場 magic by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 轉場時間 3.1 同時使用 transition/animation Vue 為了知道轉場的完成，必須設置相應的事件監聽器。它可以是 transitionend 或 animationend，這取決於給元素應用的 CSS 規則。如果你使用其中任何一種，Vue 能自動識別類型並設置監聽。\n但有時候會遇到需要同時設置的情況，但兩邊的完成時間不一致，這時候就需要手動設置 transitionend 或 animationend 來明確告知 Vue 要監聽的類型。\n舉例來說，假設你分別使用自訂義的類別名稱和 Animate.css ：\n1 2 3 4 5 6 7 8 9 10 11  .fade-enter,.fade-leave-to { opacity: 0; } .fade-enter-to, .fade-leave { opacity: 1; } .fade-enter-active,.fade-leave-active { transition: opacity 3s; }   1 2 3 4 5 6 7 8  \u0026lt;transition name=\u0026#34;fade\u0026#34; type=\u0026#34;transition\u0026#34; enter-active-class=\u0026#34;animated swing fade-enter-active\u0026#34; leave-active-class=\u0026#34;animated bounce fade-leave-active\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt;   這裡要注意，使用自訂義類別名稱優先度大於普通的類別名稱，所以fade-enter-active 和 fade-leave-active 記得要補上。\nAnimate.css 預設動畫時間為 1s，而我們設置的 transition 時間為 3s，Animate.css 的動畫很外就觸發完成了，而轉場還沒結束。在很多情況下，Vue 可以自動得出轉場效果的完成時機，但還是有可能出現例外。\n為了避免出現例外，你就需要手動設定 type=\u0026quot;transition\u0026quot; 以 transition 的時間為準。反之動畫時間大於轉場就以動畫時間為準。\nSee the Pen Vue CSS 轉場 同时使用轉場和動畫 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3.2 顯性的轉場持續時間 上面已經提過了，在很多情況下，Vue 可以自動得出轉場效果的完成時機。預設情況下，Vue 會等待其在轉場效果的根元素的第一個 transitionend 或 animationend 事件。\n但在某些情況下，還可以自定義整個動態效果總時間長，使用的是 duration 特性搭配 v-bind。\n舉例來說，總時常為 5s：\n1  \u0026lt;transition :duration=\u0026#34;5000\u0026#34;\u0026gt;...\u0026lt;/transition\u0026gt;   也可以分別設定進入和移除持續時間：\n1  \u0026lt;transition :duration=\u0026#34;{ enter: 500, leave: 800 }\u0026#34;\u0026gt;...\u0026lt;/transition\u0026gt;   這是一個 transition 需要 5秒，但總轉場時間強制設為 1秒的範例：\nSee the Pen Vue CSS 轉場 顯性的轉場持續時間 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  4.初始渲染的轉場 透過設定 appear 特性，設置節點在初始渲染的轉場。\n1 2 3  \u0026lt;transition appear\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/transition\u0026gt;    CodePen，載入畫面時，會有進場效果。\n appear 預設使用進場的類別，如果要與進場套用不同的動畫效果，需要使用自定義的類別名稱：\n1 2 3  \u0026lt;transition appear\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/transition\u0026gt;    CodePen，載入畫面時，會有進場效果。\n appear 預設使用進場的類別，如果要與進場套用不同的動畫效果，需要使用自定義的類別名稱：\n1 2 3 4 5 6 7 8  \u0026lt;transition appear appear-class=\u0026#34;custom-appear-class\u0026#34; appear-to-class=\u0026#34;custom-appear-to-class\u0026#34; (2.1.8+) appear-active-class=\u0026#34;custom-appear-active-class\u0026#34; \u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/transition\u0026gt;   多個元素的轉場 \u0026lt;transition\u0026gt; 也可以用在多個元素的轉場。\n舉例來說：\n1 2 3 4 5 6  \u0026lt;transition\u0026gt; \u0026lt;table v-if=\u0026#34;items.length \u0026gt; 0\u0026#34;\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;p v-else\u0026gt;Sorry, no items found.\u0026lt;/p\u0026gt; \u0026lt;/transition\u0026gt;   但要注意，Vue 在切換畫面時，並不會完全置換元素，會使用一種最大限度減少動態元素並且儘可能的嘗試修復/再利用相同類型元素的算法。\n因此當有相同標籤的元素在做切換時，需要使用 key 特性設置唯一的值來標記以讓 Vue 區分它們。\n1 2 3 4 5 6 7 8  \u0026lt;transition\u0026gt; \u0026lt;button v-if=\u0026#34;isEditing\u0026#34; key=\u0026#34;save\u0026#34;\u0026gt; Save \u0026lt;/button\u0026gt; \u0026lt;button v-else key=\u0026#34;edit\u0026#34;\u0026gt; Edit \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   在一些場景中，也可以通過給同一個元素的 key 特性設置不同的狀態來代替 v-if 和 v-else，上面的範例可以重寫為：\n1 2 3 4 5  \u0026lt;transition\u0026gt; \u0026lt;button v-bind:key=\u0026#34;isEditing\u0026#34;\u0026gt; {{ isEditing ? \u0026#39;Save\u0026#39; : \u0026#39;Edit\u0026#39; }} \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   使用多個 v-if 的多個元素的轉場可以重寫為綁定了動態屬性的單個元素轉場。例如：\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;transition\u0026gt; \u0026lt;button v-if=\u0026#34;docState === \u0026#39;saved\u0026#39;\u0026#34; key=\u0026#34;saved\u0026#34;\u0026gt; Edit \u0026lt;/button\u0026gt; \u0026lt;button v-if=\u0026#34;docState === \u0026#39;edited\u0026#39;\u0026#34; key=\u0026#34;edited\u0026#34;\u0026gt; Save \u0026lt;/button\u0026gt; \u0026lt;button v-if=\u0026#34;docState === \u0026#39;editing\u0026#39;\u0026#34; key=\u0026#34;editing\u0026#34;\u0026gt; Cancel \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   可以重寫為：\n1 2 3 4 5 6  \u0026lt;!-- .html --\u0026gt; \u0026lt;transition\u0026gt; \u0026lt;button :key=\u0026#34;docState\u0026#34;\u0026gt; {{ buttonMessage }} \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   1 2 3 4 5 6 7 8 9 10  // ... computed: { buttonMessage: function () { switch (this.docState) { case \u0026#39;saved\u0026#39;: return \u0026#39;Edit\u0026#39; case \u0026#39;edited\u0026#39;: return \u0026#39;Save\u0026#39; case \u0026#39;editing\u0026#39;: return \u0026#39;Cancel\u0026#39; } } }   1. 轉場模式 請考慮以下程式碼：\n1 2 3 4 5  \u0026lt;transition\u0026gt; \u0026lt;button :key=\u0026#34;isEditing\u0026#34; @click=\u0026#34;isEditing = !isEditing\u0026#34;\u0026gt; {{ isEditing ? \u0026#39;On\u0026#39; : \u0026#39;Off\u0026#39; }} \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   See the Pen Vue CSS 轉場 轉場模式 問題 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  在 on 按鈕和 off 按鈕的轉場中，兩個按鈕都被重繪了，一個離開轉場的時候另一個開始進入轉場。這是 \u0026lt;transition\u0026gt; 的預設行為，進入和離開同時發生。\n你可能會想到，可以加上 position: absolute，因為兩者重疊了，所以不會產生元素位移的情況：\n1 2 3  button { position: absolute; }   See the Pen Vue CSS 轉場 轉場模式 絕對定位 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  但如果加上 translate 讓它們運動像滑動，還是會有兩個元素同時出現的破綻：\n1 2 3 4 5  .v-enter, .v-leave-to { opacity: 0; transform: translateX(100%); }   See the Pen Vue CSS 轉場 轉場模式 絕對定位 + 滑動 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  同時生效的進入和離開的轉場不能滿足所有要求，所以 Vue 提供了轉場模式：\n in-out：新元素先進行轉場，完成之後當前元素轉場離開。 out-in：當前元素先進行轉場，完成之後新元素轉場進入。  加上 mode=\u0026quot;out-in\u0026quot; 的效果：\n1 2 3 4 5  \u0026lt;transition mode=\u0026#34;out-in\u0026#34;\u0026gt; \u0026lt;button :key=\u0026#34;isEditing\u0026#34; @click=\u0026#34;isEditing = !isEditing\u0026#34;\u0026gt; {{ isEditing ? \u0026#39;On\u0026#39; : \u0026#39;Off\u0026#39; }} \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt;   1 2 3  .v-enter-active, .v-leave-active { transition: 1.5s opacity; }   See the Pen Vue CSS 轉場 轉場模式 out-in by CHUPAIWANG (@CHUPAIWANG) on CodePen.  in-out 模式的範例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  button { position: absolute; } .v-enter,.v-leave-to { opacity: 0; } .v-enter { transform: translateX(100%); } .v-leave-to { transform: translateX(-100%); }   See the Pen Vue CSS 轉場 轉場模式 in-out by CHUPAIWANG (@CHUPAIWANG) on CodePen.  多個元件的轉場 多個元件的轉場簡單很多，我們不需要使用 key 特性。只需要使用 動態切換 元件：\n1 2 3 4 5 6 7 8  \u0026lt;!-- .html --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; value=\u0026#34;v-a\u0026#34; v-model=\u0026#34;view\u0026#34; /\u0026gt;A \u0026lt;input type=\u0026#34;radio\u0026#34; value=\u0026#34;v-b\u0026#34; v-model=\u0026#34;view\u0026#34; /\u0026gt;B \u0026lt;transition name=\u0026#34;component-fade\u0026#34; mode=\u0026#34;out-in\u0026#34;\u0026gt; \u0026lt;component v-bind:is=\u0026#34;view\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10  .component-fade-enter, .component-fade-leave-to { opacity: 0; } .component-fade-enter-active, .component-fade-leave-active { transition: opacity 0.3s ease; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14  const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { view: \u0026#39;v-a\u0026#39;, }, components: { \u0026#39;v-a\u0026#39;: { template: \u0026#39;\u0026lt;div\u0026gt;Component A\u0026lt;/div\u0026gt;\u0026#39;, }, \u0026#39;v-b\u0026#39;: { template: \u0026#39;\u0026lt;div\u0026gt;Component B\u0026lt;/div\u0026gt;\u0026#39;, }, }, });   transition-group 元件 1. 大量元素的轉場 目前為止，都是針對單個節點，或是同一時間渲染多個節點中的一個。如果要針對由 v-for 產生的大量元素（例如：列表），就要改為使用 transition-group 元件。\ntransition-group 元件有以下幾個特點：\n 不同於 \u0026lt;transition\u0026gt;，它會以一個真實元素呈現：預設為一個 \u0026lt;span\u0026gt;。可以通過 tag 特性更換為其他元素。 轉場模式（in-out 與 out-in）不可用，因為我們不再相互切換特有的元素。 內部元素 總是需要 提供唯一的 key 屬性值。 CSS 轉場的類將會應用在內部的元素中，而不是這個組/容器本身。  1.1 進入/離開的轉場 首先我們看一段程式碼：\n1 2 3 4 5 6 7  \u0026lt;button v-on:click=\u0026#34;add\u0026#34;\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;button v-on:click=\u0026#34;remove\u0026#34;\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item\u0026#34; class=\u0026#34;list-item\u0026#34;\u0026gt; {{ item }} \u0026lt;/ul\u0026gt;   按下 Add 會隨機插入數字，按下 Remove 會隨機移除數字。\nSee the Pen Vue 大量元素的轉場  by CHUPAIWANG (@CHUPAIWANG) on CodePen.  接下來我們改用 transition-group 元件，增加轉場效果。\ntransition-group 元件預設會有一個 \u0026lt;span\u0026gt; 的根元素，它會包住由 v-for 產生的多個元素當成其子元素。\n我們透過 tag 特性，將其改成 \u0026lt;ul\u0026gt;：\n1 2 3 4 5  \u0026lt;transition-group name=\u0026#34;list\u0026#34; tag=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;item in items\u0026#34; v-bind:key=\u0026#34;item\u0026#34; class=\u0026#34;list-item\u0026#34;\u0026gt; {{ item }} \u0026lt;/li\u0026gt; \u0026lt;/transition-group\u0026gt;   並加上 CSS：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  .list-enter, .list-leave-to { opacity: 0; transform: translateY(100%); } .list-leave, .list-enter-to { opacity: 1; } .list-enter-active, .list-leave-active { transition: all 1s; }   See the Pen Vue 大量元素的轉場 - transition-group by CHUPAIWANG (@CHUPAIWANG) on CodePen.  不過這個範例有一個明顯問題，當新增和移除元素的時候，周圍的元素會瞬間移動到他們的新佈局的位置，這會顯得不自然，我們將會在之後解決這個問題。\n1.2 排序轉場 transition-group 元件還有一個特殊之處。不僅可以進入和離開動畫，還可以改變定位。\nv-move 特性，它會在元素的改變定位的過程中應用。像之前的列別名稱一樣，可以通過 name 屬性來自定義前綴，也可以通過 move-class 屬性手動設置。\nv-move 對於設置轉場的切換時機和轉場曲線非常有用。\n1 2 3 4 5 6 7 8 9  \u0026lt;button v-on:click=\u0026#34;items.reverse()\u0026#34;\u0026gt;Reverses\u0026lt;/button\u0026gt; \u0026lt;transition-group name=\u0026#34;flip-list\u0026#34; tag=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item\u0026#34; class=\u0026#34;list-item\u0026#34;\u0026gt;{{ item }} \u0026lt;/li\u0026gt; \u0026lt;/transition-group\u0026gt;   1 2 3  .flip-list-move { transition: transform 1s; }   1 2 3 4 5 6  const vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { items: [1, 2, 3, 4, 5, 6, 7, 8, 9], }, });   See the Pen Vue 大量元素的轉場 - v-move by CHUPAIWANG (@CHUPAIWANG) on CodePen.  Vue 使用了一個叫 FLIP 簡單的動畫隊列。使用 transforms 將元素從之前的位置平滑轉場新的位置。\n讓我們修正上節不自然的的程式碼：\n1 2 3 4 5 6 7  .list-leave-active { position: absolute; } .list-move { transition: 1s; }   See the Pen Vue 大量元素的轉場 - 進入/離開的轉場 v-move by CHUPAIWANG (@CHUPAIWANG) on CodePen.  另外要注意，FLIP 轉場的元素不能設置為 display: inline。作為替代方案，可以設置為 display: inline-block、display: flex-block 或者放置於 FlexBox 父容器中\rSee the Pen Vue 大量元素的轉場 - 打亂 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  JavaScript 鉤子 transition/animation 的核心概念，就是在對應的時間點新增、移除類別。除了這種在被動的時間點加上類別的方式外，Vue 也提供對應時間的 JavaScript 鉤子讓我們在該時間點使用 JavaScript。\n事件鉤子：\n before-enter：進場前啟動。 enter：進場時啟動。 after-enter：進場結束後啟動。 enter-cancelled：在未完成進場時取消動作。 before-leave：離場前啟動。 leave：離場時啟動。 after-leave：離場結束後啟動。 leave-cancelled：在未完成離場時取消動作。（只用於 v-show 中）  1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;transition v-on:before-enter=\u0026#34;beforeEnter\u0026#34; v-on:enter=\u0026#34;enter\u0026#34; v-on:after-enter=\u0026#34;afterEnter\u0026#34; v-on:enter-cancelled=\u0026#34;enterCancelled\u0026#34; v-on:before-leave=\u0026#34;beforeLeave\u0026#34; v-on:leave=\u0026#34;leave\u0026#34; v-on:after-leave=\u0026#34;afterLeave\u0026#34; v-on:leave-cancelled=\u0026#34;leaveCancelled\u0026#34; \u0026gt; \u0026lt;/transition\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  methods: { beforeEnter: function(el) {}, enter: function(el, done) { done(); }, afterEnter: function(el) {}, enterCancelled: function(el) {}, beforeLeave: function(el) {}, leave: function(el, done) { done(); }, afterLeave: function(el) {}, leaveCancelled: function(el) {}, }    如果只要單獨使用 JS 鉤子轉場，可以設置 v-bind:css=\u0026quot;false\u0026quot;，Vue 會跳過 CSS 的檢測，避免轉場過程受到 CSS 的影響。 enter 和 leave 的回呼函式 done 是可選的：  參數不注入 done 時，預設為同步呼叫，會自動呼叫 done()。 如果有 done 參數，就需要手動呼叫 done()，沒呼叫就不會進入　after-enter／after-leave。 如果想要搭配 CSS 同步自動 call done 的話，就不要帶 done 參數 只使用 JavaScript 鉤子的時候，要記得呼叫 done()。    初始渲染也有事件鉤子：\n before-appear：載入前。 appear：載入時。 after-appear：載入後。 appear-cancelled：載入開始後，執行取消載入。  路由轉場 \u0026lt;router-view\u0026gt; 一樣可以使用 \u0026lt;transition\u0026gt; 元件：\n1 2 3  \u0026lt;transition\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/transition\u0026gt;   1. 單個路由的轉場 如果要讓每個路由元件有各自的轉場效果，可以在元件內使用 \u0026lt;transition\u0026gt; 元件並設置不同的 name。\n1 2 3 4 5 6  \u0026lt;!-- Views1.vue --\u0026gt; \u0026lt;template \u0026gt; \u0026lt;transition name=\u0026#34;slide\u0026#34;\u0026gt; ... \u0026lt;/transition\u0026gt; \u0026lt;/template\u0026gt;   1 2 3 4 5 6  \u0026lt;!-- Views2.vue --\u0026gt; \u0026lt;template \u0026gt; \u0026lt;transition name=\u0026#34;fade\u0026#34;\u0026gt; ... \u0026lt;/transition\u0026gt; \u0026lt;/template\u0026gt;   2. 動態轉場 1 2 3  \u0026lt;transition :name=\u0026#34;transitionName\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/transition\u0026gt;   在接著在父元件內，監聽 $route 決定使用哪種轉場效果：\n1 2 3 4 5 6 7  watch: { \u0026#39;$route\u0026#39; (to, from) { const toDepth = to.path.split(\u0026#39;/\u0026#39;).length const fromDepth = from.path.split(\u0026#39;/\u0026#39;).length this.transitionName = toDepth \u0026lt; fromDepth ? \u0026#39;slide-right\u0026#39; : \u0026#39;slide-left\u0026#39; } }   3. Vueg  Vueg\n為 vue-router 添加轉場效果的開源 Vue 套件。\n 交錯轉場 這裡有一段程式碼：\n1 2 3 4 5 6  \u0026lt;button @click=\u0026#34;show = !show\u0026#34;\u0026gt;show\u0026lt;/button\u0026gt; \u0026lt;ul v-if=\u0026#34;show\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;n in num\u0026#34; :key=\u0026#34;n\u0026#34;\u0026gt; {{ n }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;   1 2 3 4  data: { num: 5, show: false, },   See the Pen 交錯轉場 範例 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  我們要如何將它改成交錯轉場？\n1. transition-delay 最簡單的方式，就是透過 transition-delay 來實現列表的交錯轉場。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  .custom-appear-active-class { transition: opacity 0.3s; } .custom-appear-active-class:nth-child(5n + 2) { transition-delay: 0.3s; } .custom-appear-active-class:nth-child(5n + 3) { transition-delay: 0.5s; } .custom-appear-active-class:nth-child(5n + 4) { transition-delay: 0.7s; } .custom-appear-active-class:nth-child(5n + 5) { transition-delay: 0.9s; }   但缺點也很明顯，要寫大量的 CSS，修改起來也不靈活。\nSee the Pen 交錯轉場 transition-delay by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 透過 data 屬性與 JavaScript 交流 透過 data 屬性取得元素的 index，所以補上 :data-index = index：\n1 2 3 4 5 6 7 8 9  \u0026lt;transition-group tag=\u0026#34;ul\u0026#34; v-if=\u0026#34;show\u0026#34; v-bind:css=\u0026#34;false\u0026#34; @appear=\u0026#34;appear\u0026#34; appear \u0026gt; \u0026lt;li v-for=\u0026#34;(n,index) in num\u0026#34; :key=\u0026#34;n\u0026#34; :data-index = index \u0026gt; {{ n }} \u0026lt;/li\u0026gt; \u0026lt;/transition-group\u0026gt;   利用 el.dataset 取取得元素的 data 屬性。\n1 2 3 4 5 6 7 8 9 10 11 12  methods:{ appear(el, done) { const index = el.dataset.index; // 取得 index  const delay = index * 0.3; gsap.from(el,{ duration: 0.3, opacity: 0, delay: delay, }) done(); }, },   我這裡使用 GSAP3 動畫來設置動畫。\nSee the Pen 交錯轉場 GSAP3 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  或是使用 Velocity.js 搭配 setTimeout：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  methods:{ beforeAppear(el) { el.style.opacity = 0; }, appear(el, done) { const index = el.dataset.index; const delay = index * 300; setTimeout(function () { Velocity( el, { opacity: 1 }, { complete: done } ); }, delay); }, },   See the Pen 交錯轉場 Velocity by CHUPAIWANG (@CHUPAIWANG) on CodePen. ","description":"這週是 六角鼠年鐵人賽 第五週，紀錄一下 Vue Transition 用法。","id":18,"section":"posts","tags":["Vue Transition","Vue","w3HexSchool"],"title":"Vue筆記 - Transition","uri":"https://chupai.github.io/posts/200307_vue-transition/"},{"content":"這週是 六角鼠年鐵人賽 第四週，之前沒碰過 TweenMax，但 GSAP 已經升級 GSAP3，就簡單研究一下 GSAP3。\nGSAP3 GSAP 是 GreenSock Animation Platform 的簡稱，是一套專門處理動畫與特效的 JS 套件。\nGSAP 採用模組化與插件式的結構，保持了核心引擎的輕量。有四個核心 API，TweenLite、TimelinLite、TimelineMax、TweenMax，而 TweenMax 是所有 API 與 Plugin 的集合。\n但 2019年底 GSAP 從 GSAP2 升級到 GSAP3，不再區分 TweenLite、TimelineLite、TimelineMax、TweenMax，全部合並為 gsap 物件。\nGSAP3 的優點：\n 檔案大小為 TweenMax 的一半，但新增了 50多個功能。 全部合並為 gsap 物件，不用在區分 TweenLite 和 TimelineMax 物件。 新版本相容舊版本寫法，所以可以沿用，新寫法提供更好的可讀性。  官網：\n GreenSock 英文官網 TweenMax 中文官網  下載安裝  GSAP Installation\n npm install gsap // or yarn add gsap CDN\nhttps://cdnjs.cloudflare.com/ajax/libs/gsap/3.1.1/gsap.min.js 版本差異 1. gsap 物件 原本須要用 Tweens（補間），就要使用 TweenLite/TweenMax 物件。要用到 Timelines（時間軸），就要使用 TimelineLite/TimelineMax 物件。\nGSAP3 統一使用 gsap 物件。gsap 物件，具有各種方法和屬性，可用來創建 Tweens（補間）和 Timelines（時間軸）。\n舊的 Tween 的創建方式：\n1 2 3  TweenMax.method(\u0026#39;selector\u0026#39;, {}); // or TweenLite.method(\u0026#39;selector\u0026#39;,{});   現在統一使用 gsap 物件：\n1  gsap.method(\u0026#39;selector\u0026#39;, {});   舊的 Timeline 的創建方式：\n1 2 3 4 5 6 7  const tl = new TimelineMax(); tl.method(\u0026#39;selector\u0026#39;, {}); // or const tl = new TimelineLite(); tl.method(\u0026#39;selector\u0026#39;, {});   現在 Timeline 一樣也只需要使用 gsap 物件：\n1 2 3  const tl = gsap.timeline(); tl.method(\u0026#39;selector\u0026#39;, {});   2. duration 參數 原來的寫法 duration 為方法的參數：\n1  TweenMax.to(\u0026#39;.box\u0026#39;, 1, { x: 100 });   新寫法被整合到了 vars 物件中了：\n1 2 3 4  gsap.to(\u0026#39;.box\u0026#39;, { duration: 1, x: 100, });   擁有更佳的可讀性。\n3. Timeline 預設值 原本的 Timeline 寫法：\n1 2 3 4 5 6 7 8 9  const t = new TimelineMax(); t.to(\u0026#39;.box1\u0026#39;, 1, { x: 100, ease: \u0026#39;elastic\u0026#39; }).to(\u0026#39;.box2\u0026#39;, 1, { y: 100, ease: \u0026#39;elastic\u0026#39; });   使用新的寫法，如有有相同的參數，可以設定預設值：\n1 2 3 4 5 6 7 8 9  const t = gsap.timeline({ defaults: { duration: 1, ease: \u0026#39;elastic\u0026#39; } }); t.to(\u0026#39;.box1\u0026#39;, { x: 100 }) .to(\u0026#39;.box2\u0026#39;, { y: 100 });   4. 交錯屬性 原本交錯動畫，要使用到額外的方法創建 Tween 實體，例如staggerTo()、staggerFrom()、staggerFromTo()：\n1  TweenMax.staggerTo(\u0026#39;.box\u0026#39;, 1, {rotation:360, x:100}, 0.5);   現在只需要設置 stagger 屬性即可：\n1 2 3 4 5 6  gsap.to(\u0026#39;.box\u0026#39;, { duration: 1, stagger: 0.5, rotation: 360, x: 100 });   5. 全新的亂數功能 1 ~ 400 之間：\n1 2 3  gsap.to(\u0026#39;.box\u0026#39;, { x: \u0026#39;random(100, 400)\u0026#39;, });   隨機選擇一個數字，可以使用陣列表示：\n1 2 3  gsap.to(\u0026#39;.box\u0026#39;, { x: \u0026#39;random([0，100，400，500])\u0026#39;, });   6. 全新的影格功能 Keyframes 大家一定都知道 CSS 動畫的 keyframes。那 GSAP 中的 keyframes 是什麼？\n原本要建立一連串的動畫（例如，先移動，再下移，最後旋轉），需要為每個動作建立 Tween 或使用 Timeline。而 keyframes 可以在同一個 Tween 內完成。\n1 2 3 4 5 6 7  gsap.to(\u0026#39;.box\u0026#39;, { keyframes: [ { duration: 1, x: 100, }, { duration: 1, y: 100 }, { duration: 1, rotation: 360 }, ] });   7. 全新的 repeatRefresh 開啟 repeatRefresh: true，會在重複執行時（設定 repeat），紀錄當前狀態再執行，而不會回到初始狀態。\n1 2 3 4 5 6  gsap.to(\u0026#39;.box\u0026#39;, { duration: 1, repeat: 5, repeatRefresh: true, x: \u0026#39;random(100, 400)\u0026#39;, });   8. 全新的全域動畫 Global timeline 可以控制全部的動畫實體。\n1 2 3 4  gsap.globalTimeline.timeScale(0.1); // 控制所有動畫的速率 0 ~ 1 gsap.globalTimeline.pause(); // 停止目前所有動畫 gsap.globalTimeline.play(); // 播放目前所有動畫 gsap.globalTimeline.paused(); // 回傳目前動畫狀態 true:暫停 / false:播放   9. 新的動畫輔助工具  Utility Methods\n  gsap.utils.checkPrefix() gsap.utils.clamp() gsap.utils.distribute() gsap.utils.getUnit() gsap.utils.interpolate() gsap.utils.mapRange() gsap.utils.normalize() gsap.utils.pipe() gsap.utils.random() gsap.utils.snap() gsap.utils.splitColor() gsap.utils.toArray() gsap.utils.unitize() gsap.utils.wrap() gsap.utils.wrapYoyo()  10. 相對動畫時間 原本會需要標籤來添加相對動畫時間：\n1 2 3 4 5 6  gsap.timeline() .add(\u0026#39;s\u0026#39;) .to(\u0026#39;.box1\u0026#39;, { ... }, \u0026#39;s\u0026#39;) .to(\u0026#39;.box2\u0026#39;, { ... }, \u0026#39;s\u0026#39;) .to(\u0026#39;.box3\u0026#39;, { ... }, \u0026#39;s+=0.8\u0026#39;) .to(\u0026#39;.box4\u0026#39;, { ... }, \u0026#39;s+=0.8\u0026#39;);   GSAP3 新增了最近的動畫時間：\n \u0026gt;：最近添加的動畫的開始時間 \u0026lt;：最近添加的動畫的結束時間  1 2 3 4 5  gsap.timeline() .to(\u0026#39;.box1\u0026#39;, { ... }) .to(\u0026#39;.box2\u0026#39;, { ... }, \u0026#39;\u0026lt;\u0026#39;) .to(\u0026#39;.box3\u0026#39;, { ... }, \u0026#39;\u0026lt;0.8\u0026#39;) .to(\u0026#39;.box4\u0026#39;, { ... }, \u0026#39;\u0026lt;\u0026#39;);   補間動畫 Tween 補間是 flash 時代的專業詞彙，意思是在起始狀態和終點狀態之間補全中間過程。\n包含四個要素：\n 動畫目標（target） 起始狀態 終點狀態 補間效果  1. 創建 Tween 創建 Tween 的常用方法（所有這些方法都會回傳 Tween 實體）：\n gsap.to(target, vars) gsap.from(target, vars) gsap.fromTo(target, fromVars , toVars )  參數說明：\n target：需要動畫的元素  target 使用 document.querySelectorAll()，所有符合的 CSS 選擇器都會是設置動畫的對象。 如果有多個元素對象，則使用陣列 [element1, element2]   vars：設置補間效果及屬性狀態  Timeline Timeline 就是「時間軸」，可以用來控制、管理一連串的動畫。\n 控制多段動畫 / 序列動畫 自由與重疊排序 添加 Tag 掌握動畫片段  舉例來說，我們要對多個元素作一連串的動畫，需要建立多個 Tween 並用 delay 設置延遲時間，非常麻煩：\n1 2 3  gsap.to(\u0026#39;.box1\u0026#39;, { duration: 1, x: 100, }); gsap.to(\u0026#39;.box2\u0026#39;, { delay: 1, duration: 1, y: 100 }); gsap.to(\u0026#39;.box1\u0026#39;, { delay: 2, duration: 1, rotation: 360 });   而且還無法對這一連串的動畫做控制。點我看範例。\n這時候可以使用 Timeline，建立一個時間軸，來管理這些動畫。\n1 2 3 4 5  const t1 = gsap.timeline(); t1.to(\u0026#39;.box1\u0026#39;, { duration: 1, x: 100, }) .to(\u0026#39;.box2\u0026#39;, { duration: 1, y: 100 }) .to(\u0026#39;.box1\u0026#39;, { duration: 1, rotation: 360 });   點我看範例。\n如果有相同動畫狀態，可以設定預設值，使程式碼更簡潔：\n1 2 3 4 5 6 7 8 9  const t1 = gsap.timeline({ defaults: { duration: 1, }, }); t1.to(\u0026#39;.box1\u0026#39;, { x: 100, }) .to(\u0026#39;.box2\u0026#39;, { y: 100, }) .to(\u0026#39;.box1\u0026#39;, { rotation: 360, });   1. 在時間軸中放置動畫 在時間軸建立動畫：\n to() from fromTo set()  1 2 3  const tl = gsap.timeline(); tl.to(element, {duration: 1, x: 100, opacity: 0.5});   Timeline 可以鏈式呼叫：\n1 2 3 4  const tl = gsap.timeline(); tl.from(element, {duration: 1, x: -100}) .to(element, {duration: 1, y: 50});   在時間軸中，加入一段已建立的動畫，使用 add()：\n1 2 3 4  const tween = tween = gsap.to(element, {duration: 1, x: 100, opacity: 0.5}); const tl = gsap.timeline(); tl.add(tween);   Timeline 許多方法都多 position 參數，可用來控制動畫插入點：\n 無設置：時間軸末尾 1：絕對時間，指定時間處 '+=1'、-=1：相對時間，相對於時間軸的結尾 'someLabel'：指定標籤處（建立標籤使用 addLabel()） ‵someLabel+=1'、‵someLabel-=1'：相對於指定標籤 \u0026lt;：最近動畫的開頭 \u0026gt;：最近動畫的結尾 \u0026lt;1、\u0026lt;-1：相對於最近動畫的開頭 \u0026gt;1、\u0026gt;-1：相對於最近動畫的結尾  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 插入至時間軸末尾 tl.to(element, 1, {}); // 插入至時間軸2秒處 tl.to(element, 1, {}, 2); // 在時間軸結束後2秒鐘插入 tl.to(element, 1, {}, \u0026#39;+=2\u0026#39;); // 在時間軸結束前2秒鐘插入 tl.to(element, 1, {}, \u0026#39;-=2\u0026#39;); // 在3秒處建立spin標籤 t1.addLabel(\u0026#39;spin\u0026#39;, 3); // 在spin標籤處插入動畫 tl.to(element, 1, {}, \u0026#39;spin\u0026#39;); // 在spin標籤處前三秒入動畫 tl.to(element, 1, {}, \u0026#39;spin+=3\u0026#39;); // 在最近一次動畫的開頭插入 tl.to(element, {x: 100}, \u0026#39;\u0026lt;\u0026#39;); // 在最近一次動畫的開始後1秒插入 tl.to(element, {x: 100}, \u0026#39;\u0026lt;1\u0026#39;);   基本用法 1. 數字動畫 0~100 最基本的用法，對物件的屬性去做變化。\nSee the Pen GSAP3 Demo - 基本數字動畫 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. CSS 動畫 See the Pen GSAP3 Demo - CSS 動畫 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 動畫控制  .play()：播放動畫 .pause()：暫停動畫播放 .paused()：獲取或設置動畫暫停狀態  myAnimation.paused(!myAnimation.paused()) 暫停動畫切換   .resume()：繼續動畫播放 .restart()：重新開始動畫 .reverse()：反轉播放動畫 .reversed()：獲取或設置動畫反轉狀態  myAnimation.reversed( !myAnimation.reversed() ) 動畫撥放方向切換。   .seek()：不改變狀態下，跳至動畫某個時間點  See the Pen GSAP3 Demo - 動畫控制 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  4. 重複撥放、來回撥放 1 2 3  repeat: 10, // 設置動畫重複次數 repeatDelay: 0.5, // 設置重複的間隔時間(秒) yoyo: true, // 設為true時，動畫會反轉重複   See the Pen GSAP3 Demo - 重複、來回 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  5. 錯開動畫 1  stagger: 0.5, // 設置錯開時間   See the Pen GSAP3 Demo - 重複、來回 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  6. 週期 GSAP2 的 cycle 屬性，被 GSAP3 的 gsap.utils.wrap() 給取代，而且更加靈活。\nSee the Pen GSAP3 Demo - 週期 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  簡易應用 Mousemove Event 1. Image Trail Effects See the Pen GSAP3 - Image Trail Effects by Chupai@Design (@chupai) on CodePen.  2. Slinky Text See the Pen GSAP3 - Slinky Text by Chupai@Design (@chupai) on CodePen.  Image Block Reveal See the Pen GSAP3 - Image Block Reveal by Chupai@Design (@chupai) on CodePen.  Text Animation  SplitText 商業插件\n 1. 重組文字 See the Pen GSAP3 - 重組文字 by Chupai@Design (@chupai) on CodePen. ","description":"這週是 六角鼠年鐵人賽 第四週，之前沒碰過 TweenMax，但 gsap 已經升級 GSAP3，就簡單研究一下 GSAP3。","id":19,"section":"posts","tags":["GSAP3","TweenMax","w3HexSchool"],"title":"GSAP3 - 專門處理動畫與特效的 JS 套件","uri":"https://chupai.github.io/posts/200229_gsap3/"},{"content":"這週是 六角鼠年鐵人賽 第三週，不知道要寫啥，就重新整理了一下 Flexbox 的筆記。\nFlexbox 概述 Flexbox 全稱為 CSS Flexible Box Layout，也就是 CSS 彈性盒子佈局。是一種新的 CSS3 佈局模式，在彈性盒子佈局中，彈性容器的子項目們可以伸展到任何方向、並讓他們的尺寸更加「彈性」、或者持續增大，以填補未使用的空間，抑或縮小，以避免父元素溢出。子元素的橫向或縱向對齊都很容易操作。\n1. 為何流行？ 為何開始流行了呢？最主要也是因為 CSS3 的規範終於普及，加上行動裝置的發展促成了響應式佈局興起，自適應長寬彈性相當大的 Flexbox 就趁勢而起了。\n 非常適合單向排版，例如導覽列、Gird-Layout 許多 CSS 框架也使用（Bootstrap、Foundation 等）  跟毒品一樣，用過就回不去了。\n2. 瀏覽器的支援 瀏覽器支援高達 97%。\n Can I use CSS Flexible Box Layout Module ?\n 3. Flexbox 規格歷史  2009 年的版本：display: box 現在已經不再跟 Flexbox 有任何關係。 2011 過渡期版本：display: flexbox 只是草稿，只被 IE10 實作, 如果可能的話應該避免使用。 2012 最終版：display: flex  模型概念 來源：CSS彈性盒子用法｜MDN \n容器與項目：\n 彈性容器（Flex container）\n將元素的 display 屬性設為 flex 或 inline-flex，就會變彈性容器。 彈性項目（Flex item）\n所有彈性容器的子元素都會變成彈性項目，包含文字。  彈性容器具有主軸與交錯軸：\n 主軸（main axis） 交錯軸（cross axis）  方向：\n 主軸起點與終點（main start/main end） 交錯軸點與終點（cross start/cross end）  彈性項目具有：\n 水平尺寸與垂直尺寸（main size、cross size）  屬性介紹 Flexbox 可分成外層元素（彈性容器）與內層元素（彈性項目）。\n外容器屬性：\n display：flex、inline-flex，啟用 Flexbox 的必備屬性 flex-flow  flex-direction：決定主軸線的方向 flex-wrap：決定是否換行   justify-content：主軸線的對齊 align-items：交錯軸的對齊 align-content：整體的對齊  內層元素屬性：\n align-self：單一個物件的交錯軸對齊 order：排序 flex  flex-grow：伸展比，其數值與其它物件可分配伸展比有關 flex-shrink：收縮比 flex-basis：絕對值    1. Emmet 速寫格式 Flexbox 相關屬性的 Emmet 速寫格式：\ndisplay\n d:f：display:flex; d:if：display:inline-flex;  flex-direction\n fxd：flex-direction:; fxd:c：flex-direction:column; fxd:cr：flex-direction:column-reverse; fxd:r：flex-direction:row; fxd:rr：flex-direction:row-reverse;  justify-content\n jc：justify-content:; jc:c：justify-content:center; jc:fe：justify-content:flex-end; jc:fs：justify-content:flex-start; jc:sa：justify-content:space-around; jc:sb：justify-content:space-between;  flex-wrap\n fxw：flex-wrap: ; fxw:n：flex-wrap:nowrap; fxw:w：flex-wrap:wrap; fxw:wr：flex-wrap:wrap-reverse;  align-items\n ai：align-items:; ai:b：align-items:baseline; ai:c：align-items:center; ai:fe：align-items:flex-end; ai:fs：align-items:flex-start; ai:s：align-items:stretch;  align-content\n ac：align-content:; ac:c：align-content:center; ac:fe：align-content:flex-end; ac:fs：align-content:flex-start; ac:s：align-content:stretch; ac:sa：align-content:space-around; ac:sb：align-content:space-between;  align-self\n as：align-self:; as:a：align-self:auto; as:b：align-self:baseline; as:c：align-self:center; as:fe：align-self:flex-end; as:fs：align-self:flex-start; as:s：align-self:stretch;  order\n ord：order:;  flex\n fx：flex:; fxb：flex-basis:; fxd：flex-direction:; fxd:c：flex-direction:column; fxd:cr：flex-direction:column-reverse; fxd:r：flex-direction:row; fxd:rr：flex-direction:row-reverse; fxf：flex-flow:; fxg：flex-grow:; fxsh：flex-shrink:; fxw：flex-wrap: ; fxw:n：flex-wrap:nowrap; fxw:w：flex-wrap:wrap; fxw:wr：flex-wrap:wrap-reverse;  外容器屬性 1. 必備屬性 使用 Flexbox 就是要將 display 設為 flex 或 inline-block。\n display: flex 其布局方式與 block 一樣，都會強迫換行； 而 inline-flex 和 inline-block 也 一樣，在後方的元素不會換行。  唯一不同的是，flex 與 inline-flex 的子元素具備了更多彈性的設定。\n1 2 3 4  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;text\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9  .container { display: block; } .box { display: flex; /* or inline-flex */ width: 100px; height: 100px; }   See the Pen Flex - demo1 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 主軸方向 flex-direction 可以決定主軸的方向，主軸的方向將會影響容器內的元素排序順序、方向。\nflex-direction 設定值共有以下四種：\n row：預設值，由左到右，從上到下 row-reverse：與 row 相反 column：從上到下，再由左到右 column-reverse：與 column 相反  1 2 3 4 5  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9  .container { display: flex; flex-direction: row; } .item { width: 50px; height: 50px; }   See the Pen flex-direction demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 主軸對齊 justify-content 決定了內容元素與整個 Flexbox 的「主軸對齊」位置，設定值共有以下五種：\n flex-start：預設值，對齊主軸線最前端 flex-end：對齊主軸線最終端 center：對齊主軸線中央 space-between：平均分配寬度，第一項和最後一項貼齊邊緣 space-around：平均分配寬度、間距  1 2 3 4 5  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9  .container { display: flex; justify-content: flex-start; } .item { width: 50px; height: 50px; }   See the Pen justify-content demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  4. 交錯軸對齊 align-items 剛好和 justify-content 相反，align-items 決定了內容元素與整個 Flexbox 的「交錯軸對齊」位置，設定值總共有下列五個：\n stretch：預設值，如果子元素 height: auto，會將撐開至父元素的高度 flex-start：對齊交錯軸線最前端 flex-end：對齊交錯軸線最末端 center：對齊交錯軸線中央 baseline：對齊子元素的基線  1 2 3 4 5  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item h100\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item h-auto\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  .container { display: flex; justify-content: flex-start; } .item { width: 50px; height: 50px; } .h-100 { height: 100px; } .h-auto { height: auto; }   See the Pen align-items demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  5. 換行 當我們把父容器的 display 設定為 flex 或 inline-flex 的時候，子元素就是以單行的方式排列，因為預設不會行，因此當遇到邊界會彈性調整元素。\nflex-wrap 可以調整元素是否換行，共有三個設定值：\n nowrap：預設值，不斷行 wrap：多行 wrap-reverse：多行，但主軸線起點與終點相反  1 2 3 4 5 6  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9  .container { display: flex; flex-wrap: nowrap; } .item { width: 50px; height: 50px; }   See the Pen flex-wrap by CHUPAIWANG (@CHUPAIWANG) on CodePen.  6. 多行交錯軸對齊 align-items 是針對內容為單行的子元素進行處理，如果遇到多行的子元素（flex-wrap: wrap），就要使用 align-content 這個屬性，這個屬性總共有六個設定值：\n stretch：預設值，會平均分配行距，height: auto 會撐開填滿整行。 flex-start：對齊交錯軸線最前端 flex-end：對齊交錯軸線最末端 center：對齊交錯軸線中央 space-between：第一行與最後一行分別對齊交錯軸線最上方與最下方 space-around：平均分配行距，兩端會有行距一半的間距  1 2 3 4 5 6  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10  .container { display: flex; flex-wrap: wrap; align-content: stretch, } .item { width: 50px; height: 50px; }   See the Pen align-content demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  內層元素屬性 1. 交錯軸位置 align-self 作用於內層容器，也就是子元素本身，會覆蓋外層容器的 align-items。\n設定值與 align-items 相同：\n stretch：預設值，如果子元素 height: auto，會將撐開至父元素的高度 flex-start：對齊交錯軸線最前端 flex-end：對齊交錯軸線最末端 center：對齊交錯軸線中央 baseline：對齊子元素的基線  1 2 3 4 5 6  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt;   1 2 3  .item { align-self: stretch; }   See the Pen align-self demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  2. 排序 order 屬性可以直接指定一個數字，就可以由小到大的排列順序。\n 預設值為 0，只給一個元素設置會跑到最後面 要設置到最前頭，可以設值負值 相同的數字，看元素排序  注意，order 僅僅對元素的視覺順序 (visual order) 產生作用，並不會影響元素的邏輯或順序。\n1 2 3 4 5 6  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item item1\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item2\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item3\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item4\u0026#34;\u0026gt;4\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3  .item1 { order: 2; }   See the Pen align-self demo by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 伸縮比 FlexBox 最重要的屬性「flex」，個別調整子元素長度「伸展」、「壓縮」的比例以及基本大小。\nflex 是簡寫，裡面依序包含三個屬性：\n flex-grow：預設值為 0，負值無效 flex-shrink：預設值為 1，負值無效 flex-basis：預設值為 auto，若值為 0，則必須加上單位，以免被視作伸縮性  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /* 單值語法 無單位數值 unitless number: flex-grow */ flex: 2; /* 單值語法 有效寬高單位 width/height: flex-basis */ flex: 10em; flex: 30px; /* 雙值語法 flex-grow | flex-basis */ flex: 2 2; /* 三值語法 flex-grow | flex-shrink | flex-basis */ flex: 2 2 10%;   三個屬性可以分開設定，也可以合在一起用一個 flex 統一設定。\n3.1 伸展比 flex-grow 元素的伸展性，是一個數值，當子元素的寬度「小」於它自己在父元素分配到的寬度，按照數字做相對應的「伸展」比例分配（剩餘空間）。\n預設值為 0，不會進行彈性變化，不可為負值，設為 1 則會進行彈性變化。\nSee the Pen flex-grow  by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3.2 壓縮比 flex-shrink 元素收縮性，是一個數值，當子元素的寬度「大」於它自己在父元素分配到的寬度時，會進行壓縮。\n預設值為 1，設為 0 的話不會進行彈性變化（全部都 0 可能超出邊界），不可為負值。\nSee the Pen flex-shrink by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3.3 基本大小 flex-basis flex-basis 為子元素的基本大小，作為父容器的大小比較基準，預設值為 auto。\n在分配空間之前，子元素會依 flex-basis 或者 width/height，預約空間，剩餘空間會依 flex-grow 分配。\n主軸方向 flex-direction：\n 水平 row： flex-basis 為 width 的替代 垂直 column：flex-basis 為 height 的替代  優先級：\n 如果同時設置，那麼 width/height 會被覆蓋（flex-basis 的優先級較高）； 其中有一個是 auto，那麼另外一個非 auto 的屬性優先級會更高。  一些常見問題 一些新手使用 FlexBox，沒注意到的問題。\n1. 子元素高度被強制拉伸對齊 常見的情況是，當子元素 col 內，放置不同高度的元素 box，每個子元素 col 都會被強制拉伸對齊。\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box3\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3  .container { display: flex; }   See the Pen 子元素高度被強制拉伸對齊 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  這是因為 align-items 預設 stretch。因此可以透過改變 align-items 的值解決，或是使用 align-self 個別調整。\n2. 元素被壓縮 我們都知道 FlexBox 預設不換行，因此當容器大小不足時，各個子元素會被壓縮。會被壓縮的原因是 flex-shrink 預設為 1。\n所以如果不希望元素被壓縮，可以將 flex-shrink 設為 0。\n1 2 3 4 5 6 7  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col flex-shrink-0\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://picsum.photos/300/300\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   See the Pen 子元素高度被強制拉伸對齊 by CHUPAIWANG (@CHUPAIWANG) on CodePen. ","description":"這週是 六角鼠年鐵人賽 第三週，不知道要寫啥，就重新整理了一下 Flexbox 的筆記。","id":20,"section":"posts","tags":["Flex","CSS排版","w3HexSchool"],"title":"CSS筆記 - Flexbox","uri":"https://chupai.github.io/posts/200220_flex/"},{"content":"這週是 六角鼠年鐵人賽 第二週，就簡單的整理 Swiper 如何使用。\n簡介 Swiper 是一款免費以及輕量級的 JS 框架，常用於移動設備的內容觸摸滑動。\n最重要的是 「不需要使用到 jQuery」。\n更詳細介紹，請見官方：\n Swiper Swiper 中文網  目前 Swiper 版本為 Swiper5，Swiper5 對比 Swiper4 的 API 並無太大變化。Swiper5 增加了 cssMode，並且可以通過 CSS 修改 Swiper 顏色風格。\n 一些基本範例，可以參考 Swiper Demos。\n 安裝 需要用到的檔案有 swiper.min.js 和swiper.min.css 檔案。\n下載：\n Swiper GitHub repository NPM：  $ npm install swiper CDN：\n1 2 3 4 5  \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/swiper/css/swiper.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/swiper/css/swiper.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/swiper/js/swiper.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/swiper/js/swiper.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;    cdnjs - Swiper\n 配置：\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; ... \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/swiper/css/swiper.min.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ... \u0026lt;script src=\u0026#34;https://unpkg.com/swiper/js/swiper.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   初始化 Swiper 1  new Swiper(swiperContainer, parameters);    swiperContainer：要控制的 Swiper 容器，可以是 DOM 元素 或 字串（CSS 選擇器） parameters：一個物件，為 Swiper 的配置參數  1 2 3  var mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { // 配置參數 });    詳細配置參數，可以參考 Swiper API。\n 假設初始化時，沒有定義 Swiper 實體，可以透過 Swiper 的HTML 元素來獲取該實體。\n1 2 3  new Swiper(\u0026#39;.swiper-container\u0026#39;); var mySwiper = document.querySelector(\u0026#39;.swiper-container\u0026#39;).swiper;   Swiper 實體有屬性與方法可以使用，還可以監聽事件。\nLayout 1. Swiper 容器 一個 Swiper 就對應到一個 container。\n1 2  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;/div\u0026gt;   1  var mySwiper = new Swiper (\u0026#39;.swiper-container\u0026#39;);   如果一個頁面有很多個 Swiper，可以給每個容器加上 ID 或 Class 區分。\n1 2 3  \u0026lt;div class=\u0026#34;swiper-container\u0026#34; id=\u0026#34;swiper1\u0026#34;\u0026gt;....\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-container\u0026#34; id=\u0026#34;swiper2\u0026#34;\u0026gt;....\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-container\u0026#34; id=\u0026#34;swiper3\u0026#34;\u0026gt;....\u0026lt;/div\u0026gt;   1 2 3  var swiper1 = new Swiper(\u0026#39;#swiper1\u0026#39;); var swiper2 = new Swiper(\u0026#39;#swiper2\u0026#39;); var swiper3 = new Swiper(\u0026#39;#swiper3\u0026#39;);   我們可以為這個容器設置大小：\n1 2 3 4  .swiper-container { width: 600px; height: 300px; }   2. slide 元件 Swiper 的每個展示區塊為一個 slide，全部的 slide 會放在一個 wrapper 中。\n1 2 3 4 5 6 7  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   See the Pen Swiper - 基本範例 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  3. 控制元件 除了 slide 外，還可以包含其他控制元件，可以自由選擇你需要的。。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;Slide 3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- Pagination --\u0026gt; \u0026lt;div class=\u0026#34;swiper-pagination\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- Navigation --\u0026gt; \u0026lt;div class=\u0026#34;swiper-button-prev\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-button-next\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- Scrollbar --\u0026gt; \u0026lt;div class=\u0026#34;swiper-scrollbar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  var mySwiper = new Swiper (\u0026#39;.swiper-container\u0026#39;, { // Pagination  pagination: { el: \u0026#39;.swiper-pagination\u0026#39;, }, // Navigation  navigation: { nextEl: \u0026#39;.swiper-button-next\u0026#39;, prevEl: \u0026#39;.swiper-button-prev\u0026#39;, }, // Scrollbar  scrollbar: { el: \u0026#39;.swiper-scrollbar\u0026#39;, }, });   See the Pen Swiper - 控制元件 by CHUPAIWANG (@CHUPAIWANG) on CodePen.  控制元件可以放在 container 之外，但需要設置 uniqueNavElements: false。\n3. 對應的 class 名稱 容器、元件、狀態，對應的 class 名稱，都可以透過選項更改。\n舉例來說，將預設的 swiper-wrapper 替換成 my-wrapper：\n1 2 3  var mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;,{ wrapperClass : \u0026#39;my-wrapper\u0026#39;, });   容器：\n swiper-container：Swiper 容器  選項：containerModifierClass   swiper-wrapper：slide 容器  選項：wrapperClass    slide 元件：\n swiper-container：slide 元件  選項：slideClass   swiper-slide-active：active 狀態的 slide 元件  選項：slideActiveClass   swiper-slide-visible：可視區塊的 slide 元件  選項：slideVisibleClass   swiper-slide-next：active slide 的下一個 slide 元件  選項：slideNextClass   swiper-slide-prev：active slide 的上一個 slide 元件  選項：slidePrevClass    基本配置 1. background-img 1 2 3 4 5 6  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34; style=\u0026#34;background-image:url(\u0026#39;\u0026#39;)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10  .swiper-container { width: 600px; height: 300px; } .swiper-slide { background-repeat: no-repeat; background-position: center center; background-size: cover; }   See the Pen Swiper Demos - background-img by Chupai@Design (@chupai) on CodePen.  2. \u0026lt;img\u0026gt; 1 2 3 4 5 6 7 8  \u0026lt;div id=\u0026#34;swiper1\u0026#34; class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11  .swiper-container { width: 600px; height: 300px; } .swiper-slide \u0026gt; img { display: block; width: 100%; height: 100%; object-fit: cover; }   1  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;);   See the Pen Swiper Demos - img by Chupai@Design (@chupai) on CodePen.  3. slidesPerView slidesPerView 能設置同時顯示的 slide 數量，slide 的大小由 container 寬去等分。\n1 2 3  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { slidesPerView: 2, });   See the Pen Swiper Demos - slidesPerView by Chupai@Design (@chupai) on CodePen.  4. 依 slide 大小顯示 如果想要依 slide 大小來顯示，可以將 slidesPerView 設為 'auto'。\n1 2 3 4 5 6 7 8 9 10  .swiper-slide { width: 300px; height: 200px; } .swiper-slide \u0026gt; img { width: 100%; height: 100%; object-fit: cover; }   1 2 3  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { slidesPerView: \u0026#39;auto\u0026#39;, });   See the Pen Swiper Demos - 依 slide 大小顯示 by Chupai@Design (@chupai) on CodePen.  3D Cube Effect 3D Cube Effect：effect: 'cube'。\ncubeEffect 參數：\n slideShadows：slide 陰影。預設為 true。 shadow：投影。預設為 true。 shadowOffset：投影距離（px）。預設為 20。 shadowScale： 投影縮放比例。預設為 0.94。  1 2 3 4 5 6 7 8 9  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;cube\u0026#39;, cubeEffect: { slideShadows: true, // slide 陰影  shadow: true, // 投影  shadowOffset: 20, // 投影距離（px）  shadowScale: 0.94, // 投影縮放比例  }, });   1. 基本 將 container 設為方塊大小。\n1 2 3 4 5 6 7  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34; style=\u0026#34;background-image:url(\u0026#39;\u0026#39;)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34; style=\u0026#34;background-image:url(\u0026#39;\u0026#39;)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10  .swiper-container { width: 300px; height: 300px; } .swiper-slide { background-repeat: no-repeat; background-position: center center; background-size: cover; }   1 2 3  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;cube\u0026#39;, });   See the Pen 3D Cube Effect - Basic by Chupai@Design (@chupai) on CodePen.  2. 卡片 slide 內放置 card 元件，將 container 的寬設為 card 的寬，card 不需設置寬度：。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card__img\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card__body\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;card__title\u0026#34;\u0026gt; Lorem ipsum \u0026lt;span\u0026gt;Web Designer\u0026lt;/span\u0026gt; \u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9  .swiper-container { width: 300px; height: auto; } .card { background-color: white; } .card ...   See the Pen 3D Cube Effect - Card by Chupai@Design (@chupai) on CodePen.  3D Coverflow Effect 3D Coverflow：effect : 'coverflow'。\ncoverflowEffect 參數：\n slideShadows：slide 陰影。預設為 true。 rotate：slide 做 3D 旋轉時 Y 軸的旋轉角度。預設為 50。 stretch：每個 slide 之間的拉伸直，越大 slide 靠得越緊。預設為 0。 depth：slide 的位置深度值，值越大 z 軸距離越遠，看起來越小。預設為 100。 modifier：depth 和 rotate 和 stretch 的倍率。預設為 1。  1 2 3 4 5 6 7 8 9 10 11 12  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;,{ slidesPerView: \u0026#39;auto\u0026#39;, centeredSlides: true, effect : \u0026#39;coverflow\u0026#39;, coverflowEffect: { slideShadows : true, rotate: 50, stretch: 0, depth: 100, modifier: 1, }, });   1. 基本 1 2 3 4 5 6 7  \u0026lt;div class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34; style=\u0026#34;background-image:url(\u0026#39;\u0026#39;)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34; style=\u0026#34;background-image:url(\u0026#39;\u0026#39;)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11  .swiper-container { width: 100%; } .swiper-slide { width: 200px; height: 200px; background-repeat: no-repeat; background-position: center center; background-size: cover; }   1 2 3 4 5  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;coverflow\u0026#39;, slidesPerView: \u0026#39;auto\u0026#39;, centeredSlides: true, });   必設參數：\n slidesPerView: 'auto'，根據 slide 的寬度來設定 slide 可視數量。 centeredSlides，active slide 會置中，而不是預設狀態下的靠左。  See the Pen coverflowEffect - Basic by Chupai@Design (@chupai) on CodePen.  2. Card 將 card 元件加上 swiper-slide，並設置寬度：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;div id=\u0026#34;mySwiper\u0026#34; class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card swiper-slide\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34; class=\u0026#34;card__img\u0026#34;/\u0026gt; \u0026lt;div class=\u0026#34;card__body\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Lorem ipsum0\u0026lt;/h3\u0026gt; \u0026lt;span\u0026gt;Web Designer\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card swiper-slide\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card swiper-slide\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card swiper-slide\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10  .swiper-container { width: 100%; } .card { width: 240px; border-radius: 8px; background: white; overflow: hidden; }   如果 Card 元件要放在 swiper-slide 內有兩種做法：\n 將 slide 的寬設為 card 寬度，card 寬度設為 100%。 將 slide 的寬設為 auto !important，並設置 card 寬度。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;div id=\u0026#34;mySwiper\u0026#34; class=\u0026#34;swiper-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34; class=\u0026#34;card__img\u0026#34;/\u0026gt; \u0026lt;div class=\u0026#34;card__body\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Lorem ipsum0\u0026lt;/h3\u0026gt; \u0026lt;span\u0026gt;Web Designer\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-slide\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /* 作法一 */ .swiper-slide { width: 240px; } .card { width: 100%; /* ... */ } /* 作法二 */ .swiper-slide { width: auto !important; } .card { width: 240px; /* ... */ }   這個範例稍微修改一下 coverflow 參數：\n1 2 3 4 5 6 7 8 9 10 11 12  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;coverflow\u0026#39;, slidesPerView: \u0026#39;auto\u0026#39;, centeredSlides: true, coverflowEffect: { slideShadows: true, rotate: 20, stretch: 0, depth: 350, modifier: 1, }, });   See the Pen coverflowEffect - Card by Chupai@Design (@chupai) on CodePen.  3D Flip Effect 3D Flip Effect：effect: 'cube'。\nflipEffect 參數：\n slideShadows：slide 的陰影。預設為 true。 limitRotation：限制最大旋轉角度為 180 度。預設為 true。  1 2 3 4 5 6 7  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;,{ effect : \u0026#39;flip\u0026#39;, flipEffect: { slideShadows : true, limitRotation : true, } });   1. 基本 配置跟 3D Cube Effect 配置一樣：\n1 2 3  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;,{ effect : \u0026#39;flip\u0026#39;, });   See the Pen 3D Flip Effect - Basic by Chupai@Design (@chupai) on CodePen.  2. 卡片 See the Pen 3D Flip Effect - Card by Chupai@Design (@chupai) on CodePen.  Fade Effect Fade Effect effect: 'fade'。\nfadeEffect 效果參數：\n crossFade：淡出效果，預設為 false。  預設 crossFade 是關閉的，也就是所有 slide 是重疊在一起的。\n1 2 3 4 5 6  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;fade\u0026#39;, fadeEffect: { crossFade: false }, });   1. 基本 配置跟 3D Cube Effect 配置一樣：\n1 2 3  const mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { effect: \u0026#39;fade\u0026#39;, });   See the Pen Fade Effect - Basic by Chupai@Design (@chupai) on CodePen.  Thumbs Thumbs 元件為專門用於製作帶縮略圖的 Swiper，比使用 Controller 更為簡便，且在 loop 狀態下更友好。\n有兩種寫法：\n1 2 3 4 5 6 7 8 9 10  var thumbsSwiper = new Swiper(\u0026#39;.swiper-container-thumbs\u0026#39;, { slidesPerView: 5, }); var mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { ... thumbs: { swiper: thumbsSwiper } });   或是：\n1 2 3 4 5 6 7 8 9 10  var mySwiper = new Swiper(\u0026#39;.swiper-container\u0026#39;, { ... thumbs: { swiper: { el: \u0026#39;.swiper-container-thumbs\u0026#39;, slidesPerView: 5, ... } } });   縮圖的 Swiper active 狀態 slide 會被加上 .swiper-slide-thumb-active 的類名。\n但不知道為什麼，我使用 4.5.1 版本的 CDN，.swiper-slide-thumb-active 不會加上去。\n1. Thumbs Gallery 1 2 3 4 5 6 7 8  \u0026lt;div class=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;swiper-container gallery-top\u0026#34;\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;swiper-container gallery-thumbs\u0026#34;\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  .wrapper { width: 600px; } .swiper-slide { background-repeat: no-repeat; background-size: cover; background-position: center center; } .gallery-top { width: 100%; height: 400px; bottom: 10px; } .gallery-thumbs { width: 100%; height: 100px; } .gallery-thumbs .swiper-slide { opacity: 0.4; } .gallery-thumbs .swiper-slide-thumb-active { opacity: 1; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const mySwiper = new Swiper(\u0026#39;.gallery-top\u0026#39;, { spaceBetween: 10, thumbs: { swiper: { el: \u0026#39;.gallery-thumbs\u0026#39;, spaceBetween: 10, slidesPerView: 4, freeMode: true, }, }, navigation: { nextEl: \u0026#39;.swiper-button-next\u0026#39;, prevEl: \u0026#39;.swiper-button-prev\u0026#39;, }, });   See the Pen Thumbs Gallery by Chupai@Design (@chupai) on CodePen.  總結 這週就先整理到這，有空補上自動撥放、循環模式，我們下週見。\n2020-03-04\n被分享了，有點驚訝，是不是要來加上封面圖了 🤣。\n","description":"這週是 六角鼠年鐵人賽 第二週，就簡單的整理 Swiper 如何使用。","id":21,"section":"posts","tags":["Swiper.js","w3HexSchool"],"title":"Swiper - 不需要使用到 jQuery 的輪播套件","uri":"https://chupai.github.io/posts/200212_swiper/"},{"content":"前言 之前都是使用 Blogger 來放筆記，但 Blogger 沒辦法使用 Markdown 語法，所以筆記幾乎都使用 HackMD 來寫作，有空時才會將文章轉好丟到 Blogger 上，如果文章作修改要同步很麻煩。\n最近六角學院舉辦的 w3HexSchool 鼠年全馬鐵人挑戰 開跑了，有想過使用 Hexo + GitHub pages 建立 Blog，但實在是沒空。\n就在不知道要將文章丟哪時，發現了支援 Markdown 語法的簡易部落格「Bloggi」。\n2020-03-16 第七週已經找時間將全部文章搬到 Hugo 了，可以參考 第七週的文章。\n 原 Blog 新 Blog  有空再把 Blogger 的文章全部搬過來。\n\rBloggi Bloggi 是一個免費的網誌網誌寫作平台，支援 Markdown 語法，介面簡潔、無廣告，只需要簡單的註冊就可以立即使用。\n Bloggi 官網\n 1. 簡單註冊  部落格名稱 電子郵件 密碼  2. 教學手冊 帳號註冊完成後，進到「Posts」，會兩篇預設文章，為教學手冊及 Bloggi 的介紹。看完之後就可以刪除了。\n3. 設定 接下來進到「Settings」，可以編輯部落格名稱、簡介、LOGO、網址名稱等等資訊。\n部分功能則需要付費才使用，例如自訂網域名稱、Favicon、Navigation 等等。\n4. 新增文章 接下來回到「Posts」，如果要新增文章點選「New post」即可。\n編輯器很簡易，只有標題和內文，寫作格式為 Markdown 語法。\n左上分別是：\n Publish 發布文章 Preview 預覽文章 Settimgs 文章設定  5. 預覽  我的 Bloggi\n 總結 優點：\n 支援 Markdown 語法 免費、無廣告 簡單好懂的介面 簡易客製化與設定  缺點：\n 需要第三方圖片空間，管理上略麻煩 匯入匯出功能，期待未來加入  ","description":"這週是 六角鼠年鐵人賽 第一週，支援 Markdown 語法的簡易部落格「Bloggi」。","id":22,"section":"posts","tags":["Bloggi","w3HexSchool"],"title":"Bloggi - 支援 Markdown 語法的簡易部落格","uri":"https://chupai.github.io/posts/200205_bloggi/"},{"content":"JavaScript筆記 目錄\n\r認識 JavaScript：\n基本語法與文法：\n風格：\n物件：\n資料操作：\n 陣列 迭代陣列 展開／其餘運算子 解構指定 物件字面值擴充功能 日期時間  函式：\n物件導向：\n模組 Modules：\nDOM：\n例外與錯誤處理：\n非同步程式設計：\n正規表達式：\n","description":"JavaScript筆記 目錄","id":23,"section":"posts","tags":["JavaScript"],"title":"JavaScript筆記 目錄","uri":"https://chupai.github.io/posts/190620_javascript/"}]